<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.3.6" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Error 404</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Error 404</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どこでもないスペースを見つけました。&lt;br/&gt;
通常のスペースへのパスは、&lt;br/&gt;
ナビゲーションメニューに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A haiku for you.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ポエム
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is a Cloud Native, Container First framework for writing Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、Java アプリケーションを書くためのクラウドネイティブ、コンテナーファーストのフレームワークです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container First</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナー初</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Minimal footprint Java applications optimized for running in containers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーでの実行に最適化されたミニマムフットプリントの Java アプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドネイティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unify imperative and reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令型とリアクティブ型を統一</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Brings under one programming model non blocking and imperative styles of development</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ノンブロッキングと命令型の開発スタイルを 1 つのプログラミングモデルにまとめました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards-based</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準ベース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Based on the standards and the libraries you love and use (RESTEasy, Hibernate, Netty, Eclipse Vert.x, Apache Camel...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準ライブラリーや愛用しているライブラリ－ (RESTEasy、Hibernate、Netty、Eclipse Vert.x、Apache Camel...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microservice First</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイクロサービス初</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extreme productivity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>極限の生産性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instant hot code replacement: don't allow build, deploy, boot delays disrupt your flow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インスタントなホットコードの置き換え: ビルド、デプロイ、ブートの遅延がフローを混乱させないようにします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developer Joy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発者が満足できる要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development-centric experience without compromises to bring your amazing applications to life in no time</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>妥協のない開発中心の体験で、素晴らしいアプリケーションを短時間で実現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All under one framework.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてを一つの枠組みの下で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scratch pad</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スクラッチパッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus believes in developer Joy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、開発者の満足度を重要視しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It unifies imperative and reactive.  It is a Microservice first toolkit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インプライベーティブとリアクティブを統一しています。これは、マイクロサービス初のツールキットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards based Quarkus brings all the standards and frameworks you love and use: RESTEasy, Hibernate, Netty, vert.x, Camel...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準ベースの Quarkus は、お好みで使用されているすべての標準やフレームワークを提供します (RESTEasy、Hibernate、Netty、vert.x、Camelなど)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令型とリアクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Seamlessly build container optimal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シームレスに最適なコンテナーを構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container affinity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーとの親和性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container optimal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーに最適</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unifying Imperative and Reactive under one framework.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令型とリアクティブを 1 つのフレームワークで統一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザービリティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards based</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準ベース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドを完成させるには、以下が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate distributed tracing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、分散トレースを実証するための簡単なRESTアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、すぐに完成した例に飛んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `pom.xml` に以下が追加されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンフィグレーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first approach is by providing the properties within the `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のアプローチは、 `src/main/resources/application.properties` ファイル内でプロパティーを提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. If using `application.properties` to configure the tracer:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでアプリケーションを実行する準備が整いました。トレーサーの設定に `application.properties` を使用している場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then visit the http://localhost:16686[Jaeger UI] to see the tracing information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、 link:http://localhost:16686[Jaeger UI] にアクセスしてトレース情報を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CTRL+C`  を叩いてアプリケーションを停止させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional instrumentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加の計器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instrumentation documented in this section has been tested with Quarkus and works in both standard and native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションで説明されている計器は、Quarkusでテストされており、標準モードとネイティブモードの両方で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Using OpenID Connect to Protect Web Applications using Authorization Code Flow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - 認可コードフローのOpenID Connectを使用してWebアプリケーションを保護</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use Quarkus OpenID Connect Extension to protect your Quarkus HTTP endpoints using OpenId Connect Authorization Code Flow supported by OpenId Connect compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus OpenID Connect Extensionを使用して、 link:https://www.keycloak.org/about.html[Keycloak] などのOpenId Connect準拠の認証サーバーでサポートされているOpenId Connect 認可コードフローを使用してQuarkus HTTPエンドポイントを保護する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension allows to easily authenticate the users of your web application by redirecting them to the OpenID Connect Provider (e.g.: Keycloak) to login and, once the authentication is complete, return them back with the code confirming the successful authentication. The extension will request ID and access tokens from the OpenID Connect Provider using an authorization code grant and verify these tokens in order to authorize an access to the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、OpenID Connect Provider (例: Keycloak) にリダイレクトしてログインさせ、認証が完了したら、認証に成功したことを確認するコードを使って、ウェブアプリケーションのユーザーを簡単に認証することができます。エクステンションは、認可コードグラントを使用して OpenID Connect Provider から ID とアクセストークンを要求し、アプリケーションへのアクセスを承認するためにこれらのトークンを検証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read the link:security-openid-connect[Using OpenID Connect to Protect Service Applications] guide if you need to protect your applications using Bearer Token Authorization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラートークン認証を使用してアプリケーションを保護する必要がある場合は、 link:security-openid-connect[Using OpenID Connect to Protect Service Applications] ガイドをお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read the link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] guide how to support multiple tenants.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチテナントのサポート方法については、 link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] ガイドをお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://stedolan.github.io/jq/[jq tool]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://stedolan.github.io/jq/[jq tool]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple web application with a single page:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、1ページの非常にシンプルなWebアプリケーションを構築しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/index.html`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/index.html`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This page is protected and can only be accessed by authenticated users.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このページは保護されており、認証されたユーザーのみがアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-openid-connect-web-authentication-quickstart` {quickstarts-tree-url}/security-openid-connect-web-authentication-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-openid-connect-web-authentication-quickstart` {quickstarts-tree-url}/security-openid-connect-web-authentication-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `oidc` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `oidc` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple JAX-RS resource which has all the tokens returned in the authorization code grant response injected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認可コードグラントのレスポンスで返されたすべてのトークンが注入されたシンプルなJAX-RSリソースを書いてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint has ID, access and refresh tokens injected. It returns a `preferred_username` claim from the ID token, a `scope` claim from the access token and also a refresh token availability status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエンドポイントには、ID、アクセス、およびリフレッシュ トークンが注入されています。ID トークンから `preferred_username` クレーム、アクセス トークンから `scope` クレーム、およびリフレッシュ トークンの可用性ステータスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you do not have to inject the tokens - it is only required if the endpoint needs to use the ID token to interact with the currently authenticated user or use the access token to access a downstream service on behalf of this user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本的にトークンを注入する必要はありません。エンドポイントが ID トークンを使用して現在認証されているユーザーとやりとりする必要がある場合や、アクセス・トークンを使用してこのユーザーに代わってダウンストリーム・サービスにアクセスする必要がある場合にのみ必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see &lt;&lt;access_id_and_access_tokens,Access ID and Access Tokens&gt;&gt; section below for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳しくは下記の link:#access_id_and_access_tokens[アクセスID・アクセストークン] の項をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenID Connect extension allows you to define the configuration using the `application.properties` file which should be located at the `src/main/resources` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect エクステンションを使用すると、src/main/resources` ディレクトリーにあるはずの `application.properties` ファイルを使用して設定を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring using the application.properties file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.propertiesファイルを使って設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the simplest configuration you can have when enabling authentication to your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、アプリケーションへの認証を有効にする際に最もシンプルな設定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.oidc.client-id` property references the `client_id` issued by the OpenID Connect Provider and, in this case, the application is a public client (no client secret is defined).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.oidc.client-id` プロパティーは OpenID Connect Provider が発行した `client_id` を参照します。この場合、アプリケーションはパブリッククライアントです(クライアントシークレットは定義されていません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.oidc.application-type` property is set to `web-app` in order to tell Quarkus that you want to enable the OpenID Connect Authorization Code Flow, so that your users are redirected to the OpenID Connect Provider to authenticate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect 認可コードフローを有効にしたいことをQuarkusに伝えるために、 `quarkus.oidc.application-type` プロパティーは、 `web-app` に設定します。これにより、ユーザーが認証のためにOpenID Connect Providerにリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to consume this application from another application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the link:http-reference#cors-filter[HTTP CORS documentation] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のドメインで実行されている別のアプリケーションからこのアプリケーションを利用する予定の場合は、CORS (Cross-Origin Resource Sharing) を構成する必要があります。詳細については、 link:http-reference#cors-filter[HTTP CORS のドキュメント] をお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start a Keycloak Server you can use Docker and just run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak Serverを起動するにはDockerを使用し、以下のコマンドを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should be able to access your Keycloak Server at http://localhost:8180/auth[localhost:8180/auth].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloakサーバーには、 link:http://localhost:8180/auth[localhost:8180/auth] でアクセスできるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log in as the `admin` user to access the Keycloak Administration Console. Username should be `admin` and password `admin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak 管理コンソールにアクセスするには、 `admin` ユーザーとしてログインしてください。ユーザー名は `admin` 、パスワードは `admin` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the {quickstarts-tree-url}/security-openid-connect-web-authentication-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm. For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいレルムを作成するには、{quickstarts-tree-url}/security-openid-connect-web-authentication-quickstart/config/quarkus-realm.json[realm構成ファイル]をインポートします。詳細については、 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[新しいレルムの作成] 方法についてのKeycloakのドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running and Using the Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの実行と使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running in Developer Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デベロッパーモードでの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the microservice in dev mode, use `./mvnw clean compile quarkus:dev`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイクロサービスをdevモードで実行するには、 `./mvnw clean compile quarkus:dev` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you're done playing with "dev-mode" you can run it as a standard Java application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>「開発モード」で遊び終わったら、標準のJavaアプリケーションとして実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First compile it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then run it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それから以下で実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running in Native Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードでの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This same demo can be compiled into native code: no modifications required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同じデモをネイティブコードにコンパイルすることができます。修正は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This implies that you no longer need to install a JVM on your production environment, as the runtime technology is included in the produced binary, and optimized to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、生成されたバイナリーにランタイム技術が含まれており、最小限のリソースオーバーヘッドで実行できるように最適化されているため、本番環境にJVMをインストールする必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compilation will take a bit longer, so this step is disabled by default; let's build again by enabling the `native` profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンパイルには少し時間がかかるので、このステップはデフォルトで無効になっています。 `native` プロファイルを有効にして再度ビルドしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw package -Pnative
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw package -Pnative
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After getting a cup of coffee, you'll be able to run this binary directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コーヒーを一杯飲んだら、このバイナリーを直接実行出来るようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test the application, you should open your browser and access the following URL:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストするには、ブラウザを開いて以下のURLにアクセスする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If everything is working as expected, you should be redirected to the Keycloak server to authenticate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてが期待通りに動作している場合は、認証のためにKeycloakサーバーにリダイレクトされるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to authenticate to the application you should type the following credentials when at the Keycloak login page:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを認証するためには、Keycloakのログインページで以下の認証情報を入力する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Username: *alice*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Username: *alice*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Password: *alice*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Password: *alice*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After clicking the `Login` button you should be redirected back to the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Login` ボタンをクリックすると、アプリケーションにリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redirection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with Cookies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クッキーの取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OIDC adapter uses cookies to keep the session, code flow and post logout state.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDCアダプターは、セッション、コードフロー、ログアウト後の状態を保持するためにクッキーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.oidc.authentication.cookie-path` is set to `/` by default but can be narrowed to the more specific root path such as `/web-app`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.oidc.authentication.cookie-path` は、デフォルトでは `/` に設定されていますが、 `/web-app` のように、より具体的なルートパスに絞り込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also set a `quarkus.oidc.authentication.cookie-path-header` property if the cookie path needs to be set dynamically.  For example, setting `quarkus.oidc.authentication.cookie-path-header=X-Forwarded-Prefix` means that the value of HTTP `X-Forwarded-Prefix` header will be used to set a cookie path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クッキーパスを動的に設定する必要がある場合は、 `quarkus.oidc.authentication.cookie-path-header` プロパティを設定することもできます。例えば、 `quarkus.oidc.authentication.cookie-path-header=X-Forwarded-Prefix` を設定すると、HTTP `X-Forwarded-Prefix` ヘッダーの値がクッキーパスを設定するために使用されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://whatever.wherever.company.net/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://whatever.wherever.company.net/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://another.address.company.net/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://another.address.company.net/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログアウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the logout is based on the expiration time of the ID Token issued by the OpenID Connect Provider. When the ID Token expires, the current user session at the Quarkus endpoint is invalidated and the user is redirected to the OpenID Connect Provider again to authenticate. If the session at the OpenID Connect Provider is still active, users are automatically re-authenticated without having to provide their credentials again.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、ログアウトはOpenID Connect Providerが発行したID Tokenの有効期限に基づいて行われます。IDトークンの有効期限が切れると、Quarkusエンドポイントでの現在のユーザーセッションは無効になり、ユーザーは認証のために再度OpenID Connect Providerにリダイレクトされます。OpenID Connect Providerでのセッションがまだアクティブな場合は、ユーザーは再び資格情報を提供することなく自動的に再認証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current user session may be automatically extended by enabling a `quarkus.oidc.token.refresh-expired` property. If it is set to `true` then when the current ID Token expires a Refresh Token Grant will be used to refresh ID Token as well as Access and Refresh Tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のユーザーセッションは、 `quarkus.oidc.token.refresh-expired` プロパティーを有効にすることで自動的に拡張される場合があります。 `true` に設定されている場合、現在の ID トークンの有効期限が切れると、リフレッシュ・トークンの付与が使用され、ID トークンだけでなく、アクセス・トークンやリフレッシュ・トークンもリフレッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User-Initiated Logout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー主導型ログアウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can request a logout by sending a request to the Quarkus endpoint logout path set with a `quarkus.oidc.logout.path` property.  For example, if the endpoint address is `https://application.com/webapp` and the `quarkus.oidc.logout.path` is set to "/logout" then the logout request has to be sent to `https://application.com/webapp/logout`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーは、 `quarkus.oidc.logout.path` プロパティーで設定されたQuarkusエンドポイントのログアウトパスにリクエストを送信することで、ログアウトを要求することができます。たとえば、エンドポイントのアドレスが `https://application.com/webapp` で、 `quarkus.oidc.logout.path` が "/logout" に設定されている場合、ログアウト要求は `https://application.com/webapp/logout` に送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of the `JsonWebToken` and `AccessTokenCredential` is supported in both `@RequestScoped` and `@ApplicationScoped` contexts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonWebToken` と `AccessTokenCredential` のインジェクションは、 `@RequestScoped` と `@ApplicationScoped` の両方のコンテキストでサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RefreshToken is only used to refresh the current ID and access tokens as part of its link:#session_management[session management] process.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RefreshTokenは、その link:#session_management[セッション管理] プロセスの一部として、現在のIDとアクセストークンをリフレッシュするためにのみ使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User Info</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If IdToken does not provide enough information about the currently authenticated user then you can set a `quarkus.oidc.user-info-required=true` property for a https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo] JSON object from the OIDC userinfo endpoint to be requested.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IdTokenが現在認証されているユーザーに関する十分な情報を提供しない場合は、`quarkus.oidc.user-info-required=true` プロパティーを設定することでOIDCのuserinfoエンドポイントから link:https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo] JSONオブジェクトを要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定メタデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Claims And SecurityIdentity Roles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンクレームと SecurityIdentity のロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The way the roles are mapped to the SecurityIdentity roles from the verified tokens is identical to how it is done for the link:security-openid-connect#token-claims-and-securityidentity-roles[bearer tokens] with the only difference being is that https://openid.net/specs/openid-connect-core-1_0.html#IDToken[ID Token] is used as a source of the roles by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証済みトークンからSecurityIdentityのロールにロールをマッピングする方法は、 link:security-openid-connect#token-claims-and-securityidentity-roles[ベアラートークン] の場合と同じですが、唯一の違いは、 link:https://openid.net/specs/openid-connect-core-1_0.html#IDToken[ID] トークンがデフォルトでロールのソースとして使用されるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note if you use Keycloak then you should set a Microprofile JWT client scope for ID token to contain a `groups` claim, please see the https://www.keycloak.org/docs/latest/server_admin/#protocol[Keycloak Server Administration Guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloakを使用する場合は、IDトークン用のMicroprofile JWTクライアントスコープに `groups` クレームを含めるように設定する必要があることに注意してください。詳細については、 link:https://www.keycloak.org/docs/latest/server_admin/#protocol[Keycloakサーバー管理ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If only the access token contains the roles and this access token is not meant to be propagated to the downstream endpoints then set `quarkus.oidc.roles.source=accesstoken`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アクセストークンのみがロールを含み、このアクセストークンが下流のエンドポイントに伝播されることを意図していない場合は、 `quarkus.oidc.roles.source=accesstoken` をセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If UserInfo is the source of the roles then set `quarkus.oidc.authentication.user-info-required=true` and `quarkus.oidc.roles.source=userinfo`, and if needed, `quarkus.oidc.roles.role-claim-path`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UserInfoがロールのソースである場合は、 `quarkus.oidc.authentication.user-info-required=true` と `quarkus.oidc.roles.source=userinfo` をセットし、必要に応じて `quarkus.oidc.roles.role-claim-path` を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally a custom `SecurityIdentityAugmentor` can also be used to add the roles as documented link:security#security-identity-customization[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、カスタム `SecurityIdentityAugmentor` を使用して、 link:security#security-identity-customization[ここ] で文書化されているようにロールを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Session Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セッション管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a link:security-openid-connect#single-page-applications[Single Page Application for Service Applications] where your OpenId Connect Provider script such as `keycloak.js` is managing an authoriization code flow then that script will also control the SPA authentication session lifespan.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`keycloak.js` などの OpenId Connect Provider スクリプトが認可コードフローを管理している link:security-openid-connect#single-page-applications[サービスアプリケーション用のシングルページアプリケーション] の場合、そのスクリプトは SPA 認証セッションの寿命も制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The session age is calculated by adding the lifespan value of the current IDToken and the values of the `quarkus.oidc.authentication.session-age-extension` and `quarkus.oidc.token.lifespan-grace` properties. Of the last two properties only `quarkus.oidc.authentication.session-age-extension` should be used to significantly extend the session lifespan if required since `quarkus.oidc.token.lifespan-grace` is only meant for taking some small clock skews into consideration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セッション年齢は、現在のIDTokenの寿命値と、 `quarkus.oidc.authentication.session-age-extension` と `quarkus.oidc.token.lifespan-grace` プロパティーの値を加算して計算されます。最後の2つのプロパティーのうち、 `quarkus.oidc.authentication.session-age-extension` だけは、必要に応じてセッションの寿命を大幅に延ばすために使用すべきです。 `quarkus.oidc.token.lifespan-grace` は小さなクロックスキューを考慮することだけを目的としている為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TokenStateManager</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TokenStateManager</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening to important authentication events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要な認証イベントのリッスン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single Page Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シングルページアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドサービス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can have Quarkus OIDC `web-app` applications access **Google Cloud services** such as **BigQuery** on behalf of the currently authenticated users who have enabled OpenID Connect (Authorization Code Flow) permissions to such services in their Google Developer Consoles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus OIDC `web-app` アプリケーションは、Google Developer Consolesで *BigQuery* などのサービスに対するOpendId Connect(Authorization Code Flow)パーミッションを有効にしている現在認証されたユーザーに代わって、 *BigQuery* などの *Google Cloudサービスに* アクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is super easy to do with https://github.com/quarkiverse[Quarkiverse] https://github.com/quarkiverse/quarkiverse-google-cloud-services[Google Cloud Services], only add the https://github.com/quarkiverse/quarkiverse-google-cloud-services/releases/latest[latest tag] service dependency, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkiverse[Quarkiverseの] link:https://github.com/quarkiverse/quarkiverse-google-cloud-services[Google Cloud Services] で行うのは超簡単で、 link:https://github.com/quarkiverse/quarkiverse-google-cloud-services/releases/latest[最新のタグ] サービスの依存関係を追加するだけです。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and configure Google OIDC properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そしてGoogle OIDCプロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provider Endpoint configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロバイダーエンドポイントの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default they are discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc.auth-server-url`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、設定された `quarkus.oidc.auth-server-url` に `/.well-known/openid-configuration` パスを追加することで検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, if the discovery endpoint is not available or you would like to save on the discovery endpoint roundtrip, you can disable the discovery and configure them with relative path values, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、ディスカバリーエンドポイントが利用できない場合や、ディスカバリーエンドポイントのラウンドトリップを節約したい場合は、ディスカバリーを無効にして、相対パスの値で設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンの伝播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security-openid-connect-client#token-propagation[Token Propagation] section about the Authorization Code Flow access token propagation to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下流サービスへの認可コードフローアクセストークンの伝播については、 link:security-openid-connect-client#token-propagation[トークン伝播] の項を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wiremock</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Wiremock</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prepare the REST test endpoints, set `application.properties`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTテストエンドポイントを用意し、 `application.properties` を以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and finally write the test code, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして最後にテストコードを例えば以下のように書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to check the errors in the logs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログでエラーを確認する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running behind a reverse proxy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リバースプロキシーの背後での実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OIDC authentication mechanism can be affected if your Quarkus application is running behind a reverse proxy/gateway/firewall when HTTP `Host` header may be reset to the internal IP address, HTTPS connection may be terminated, etc. For example, an authorization code flow `redirect_uri` parameter may be set to the internal host instead of the expected external one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションがリバースプロキシー/ゲートウェイ/ファイアウォールの背後で実行されている場合、HTTP `Host` ヘッダーが内部IPアドレスにリセットされたり、HTTPS接続が終了したりした場合などに、OIDC認証メカニズムが影響を受けることがあります。たとえば、認可コードフロー `redirect_uri` パラメーターが、期待される外部ホストではなく内部ホストに設定されている場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such cases configuring Quarkus to recognize the original headers forwarded by the proxy will be required, see link:vertx#reverse-proxy[Running behind a reverse proxy] Vert.x documentation section for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような場合、プロキシーによって転送された元のヘッダーを認識するようにQuarkusを設定する必要があります。詳細については、 link:vertx#reverse-proxy[リバースプロキシーの背後での実行] Vert.xのドキュメントセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.oidc.authentication.force-redirect-https-scheme` property may also be used when the Quarkus application is running behind a SSL terminating reverse proxy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.oidc.authentication.force-redirect-https-scheme` プロパティーは、QuarkusアプリケーションがSSL終端リバースプロキシーの後ろで実行されている場合にも使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>References</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.keycloak.org/documentation.html[Keycloak Documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.keycloak.org/documentation.html[Keycloak Documentation]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://openid.net/connect/[OpenID Connect]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://openid.net/connect/[OpenID Connect]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tools.ietf.org/html/rfc7519[JSON Web Token]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://tools.ietf.org/html/rfc7519[JSON Web Token]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:security-openid-connect-client[Quarkus - Using OpenID Connect and OAuth2 Client and Filters to manage access tokens]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチテナントへの対応方法については、 link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] ガイドをお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3 is an object storage service. It can be employed to store any type of object which allows for uses like storage for Internet applications, backup and recovery, disaster recovery, data archives, data lakes for analytics, any hybrid cloud storage.  This extension provides functionality that allows the client to communicate with the service when running in Quarkus.  You can find more information about S3 at https://aws.amazon.com/s3/[the Amazon S3 website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon S3はオブジェクトストレージサービスです。インターネットアプリケーションのストレージ、バックアップとリカバリ、災害復旧、データアーカイブ、分析用のデータレイク、あらゆるハイブリッドクラウドストレージなどの用途に使用できるように、あらゆるタイプのオブジェクトを保存するために採用することができます。このエクステンションは、Quarkusで実行しているときにクライアントがサービスと通信できるようにする機能を提供します。S3についての詳細は、 link:https://aws.amazon.com/s3/[Amazon S3のウェブサイト] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The S3 extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>S3 エクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK の `CompletableFuture` オブジェクトと Netty HTTP クライアントをベースにした link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[非同期プログラミング]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use S3 locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、ローカルでAWS上でS3を使用するためのRESTサービスを取得する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An AWS Account to access the S3 service. Before you can use the AWS SDKs with Amazon S3, you must get an AWS access key ID and secret access key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>S3サービスにアクセスするためのAWSアカウント。Amazon S3でAWS SDKを利用する前に、AWSのアクセスキーIDとシークレットアクセスキーを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, Docker for your system to run S3 locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションで、テスト目的でローカルでS3を実行するためのシステムのためのDocker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provision S3 locally</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルでの S3 の準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with S3 is to run a local instance as a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>S3を使い始める最も簡単な方法は、ローカルインスタンスをコンテナーとして実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a S3 instance that is accessible on port `8008`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ポート `8008` でアクセス可能な S3 インスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Versions of localstack newer than v0.11.5 require port `4566` instead of port `4572`. See this https://github.com/localstack/localstack/issues/2983[GitHub issue] for details on this change.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>v0.11.5 より新しいバージョンの localstack では、ポート `4572` の代わりに `4566` を必要とします。この変更の詳細は link:https://github.com/localstack/localstack/issues/2983[GitHub issue] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an AWS profile for your local instance using AWS CLI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS CLIを使ってローカルインスタンスのAWSプロファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built here allows to manage files stored in Amazon S3.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで構築したアプリケーションでは、Amazon S3に保存されているファイルを管理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amazon-s3-quickstart` {quickstarts-tree-url}/amazon-s3-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `amazon-s3-quickstart` {quickstarts-tree-url}/amazon-s3-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and S3 Client extensions.  After this, the `amazon-s3` extension has been added to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RSとS3クライアントエクステンションをインポートするMaven構造を生成します。この後、 `amazon-s3` エクステンションが `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we'll add the following dependency to support `multipart/form-data` requests:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `multipart/form-data` リクエストをサポートするために、以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default setting for `quarkus.http.limits.max-body-size` is 10240K. This may limit your ability to upload multipart files larger than the default. If you want to upload larger files, you will need to set this limit explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.limits.max-body-size` のデフォルト設定は 10240K です。このため、デフォルトよりも大きなマルチパートファイルのアップロードが制限される場合があります。より大きなファイルをアップロードしたい場合は、この制限を明示的に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up the model</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モデルの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of files. The example application will demonstrate the two programming models supported by the extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、ファイルのリストを管理するアプリケーションを作成します。この例のアプリケーションでは、エクステンションでサポートされている2つのプログラミングモデルをデモします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because the primary goal of our application is to upload a file into the S3 bucket, we need to setup the model we will be using to define the `multipart/form-data` payload, in the form of a `MultipartBody` POJO.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのアプリケーションの主な目的はファイルをS3バケットにアップロードすることなので、 `multipart/form-data` ペイロードを定義するために使用するモデルを `MultipartBody` POJO の形で設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.s3.FormData` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のように `org.acme.s3.FormData` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class defines three fields:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスは3つのフィールドを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the second step let's create a bean that will represent a file in a Amazon S3 bucket as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第2ステップでは、以下のようにAmazon S3バケット内のファイルを表すBeanを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer. The static `from` method creates a bean based on the `S3Object` object provided by the S3 client response when listing all the objects in a bucket.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、JSONシリアライゼーションレイヤーによって要求されるということです。static `from` メソッドは、バケット内のすべてのオブジェクトをリストアップする際に、S3 クライアントのレスポンスで提供される `S3Object` オブジェクトに基づいてBeanを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.s3.CommonResource` that will consist of methods to prepare S3 request to get object from a S3 bucket, or to put file into a S3 bucket.  Note a configuration property `bucket.name` is defined here as the request method required name of the S3 bucket.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、S3バケットからオブジェクトを取得したり、S3バケットにファイルを入れたりするためのS3リクエストを準備するためのメソッドからなる `org.acme.s3.CommonResource` を作成します。ここでは、S3バケットのリクエストメソッドの必要な名前として、設定プロパティー `bucket.name` が定義されていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a `org.acme.s3.S3SyncClientResource` that will provides an API to upload/download files as well as to list all the files in a bucket.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、ファイルをアップロード/ダウンロードするためのAPIを提供する `org.acme.s3.S3SyncClientResource` を作成し、バケットのすべてのファイルを一覧表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both S3 clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>S3クライアント(同期と非同期)は、 `src/main/resources` ディレクトリーで提供される `application.properties` ファイルを介して設定可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to add to the classpath a proper implementation of the sync client. By default the extension uses the URL connection HTTP client, so add a URL connection client dependency to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、エクステンションは URL Connection 接続 HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Apache HTTP client instead, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりにApache HTTPクライアントを使用したい場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add following dependency to the application `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、以下の依存関係をアプリケーションの `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For asynchronous client refer to &lt;&lt;Going asynchronous&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期クライアントについては、 link:#Going asynchronous[非同期にする] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're going to use a local S3 instance, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルのS3インスタンスを使う場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.s3.aws.region` - It's required by the client, but since you're using a local S3 instance you can pick any valid AWS region.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.s3.aws.region` - クライアントが必要としていますが、ローカルのS3インスタンスを使用しているので、有効なAWSリージョンを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.s3.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.s3.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-id` と `secret-access-key` の任意の値で設定します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work with an AWS account, you'd need to set it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWSアカウントで作業したい場合は、次のようにして設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`bucket.name` - name of the S3 bucket on your AWS account.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`bucket.name` - AWSアカウント上のS3バケット名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.s3.aws.credentials.type` - use the `default` credentials provider chain that looks for credentials in this order:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.s3.aws.credentials.type` - `default` クレデンシャル・プロバイダ・チェーンを使用して、この順番でクレデンシャルを検索します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a frontend</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フロントエンドの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `S3SyncClientResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `s3.html` file with the content from this {quickstarts-blob-url}/amazon-s3-quickstart/src/main/resources/META-INF/resources/s3.html[s3.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `S3SyncClientResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/amazon-s3-quickstart/src/main/resources/META-INF/resources/s3.html[s3.html] ファイルの内容を含む `s3.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now interact with your REST service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、REST サービスと対話できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with `./mvnw compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw compile quarkus:dev` でQuarkusを起動する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next steps</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging your application is as simple as `./mvnw clean package`.  It can be run with `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのパッケージングは `./mvnw clean package` のように簡単です。 `java -jar target/amazon-s3-quickstart-1.0-SNAPSHOT-runner.jar` で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With GraalVM installed, you can also create a native executable binary: `./mvnw clean package -Dnative`.  Depending on your system, that will take some time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMをインストールした状態で、ネイティブの実行バイナリーを作成することもできます: `./mvnw clean package -Dnative` お使いのシステムにもよりますが、時間がかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going asynchronous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the asynchronous programming model out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのエクステンションで使われているAWS SDK v2.xのおかげで、非同期プログラミングモデルをすぐに使えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.s3.S3AsyncClientResource` that will be similar to our `S3SyncClientResource` but using an asynchronous programming model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`S3SyncClientResource` と同様の `org.acme.s3.S3AsyncClientResource` を作成しますが、非同期プログラミングモデルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need the RESTEasy Mutiny support for asynchronous programming. Add the dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期プログラミングにはRESTEasy Mutinyのサポートが必要です。依存関係を `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or you can alternatively run this command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、プロジェクトのベースディレクトリーでこのコマンドを実行することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add the Netty HTTP client dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `pom.xml` に Netty HTTPクライアントの依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>—
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go to the quark of things.  We don't want you to spend hours learning new technologies.  Instead, {project-name} provides leading frameworks and technologies from open source projects, such as https://vertx.io[Vert.x], https://camel.apache.org[Camel], http://hibernate.org[Hibernate] and https://resteasy.github.io[RESTEasy]. You can also find innovative community projects, such as https://smallrye.io[SmallRye]. If you are looking for standards you can find https://microprofile.io[MicroProfile] and selected specifications from https://jakarta.ee[Jakarta EE].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>物事の核心に迫りましょう。私たちは、新しい技術の習得に何時間も費やしてほしくありません。その代わり、{project-name} では、 link:https://vertx.io[Vert.x]、 link:https://camel.apache.org[Camel]、 link:http://hibernate.org[Hibernate]、 link:https://resteasy.github.io[RESTEasy]などのオープンソースプロジェクトの主要なフレームワークや技術を提供しています。また、 link:https://smallrye.io[SmallRye]のような革新的なコミュニティプロジェクトもあります。標準規格を探している場合は、 link:https://jakarta.ee[Jakarta EE]の link:https://microprofile.io[MicroProfile] や選りすぐりの仕様を見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI with Arc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我々の依存性注入ソリューションは、ArcによるCDIに基づいています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use JAX-RS annotations to define the REST endpoints with https://resteasy.github.io[RESTEasy].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://resteasy.github.io[RESTEasy]では、JAX-RSアノテーションを使ってRESTエンドポイントを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries with http://hibernate.org[Hibernate]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JPAアノテーションを使って永続的なエンティティをマッピングし、JTAアノテーションを使って link:http://hibernate.org[Hibernate]でトランザクション境界を宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use https://smallrye.io[SmallRye] to configure, secure, document and monitor your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://smallrye.io[SmallRye]を使用して、アプリケーションの設定、セキュア化、文書化、監視を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use https://vertx.io[Vert.x] or https://camel.apache.org[Camel], and we support much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io[Vert.x]や link:https://camel.apache.org[Camel]を使用することができ、さらに多くのものをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, {project-name} is not a passive consumer. Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>勿論、我々は標準に限定されない為、あなたの可能性を広げることが可能です。 もちろん、{project-name} は受動的な消費者ではありません。 私たちのゴールは、使用する技術を改善、革新し、私たちが頼りにしているオープンソースプロジェクトと標準に貢献することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/continuum
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: vision
permalink: /vision/continuum
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Imperative and Reactive Continuum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令型とリアクティブ Continuum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For years, the client-server architecture has been the de-facto standard to build applications.  But a major shift happened.  The _one model rules them all_ age is over.  A new range of applications and architecture styles has emerged and impacts how code is written and how applications are deployed and executed.  HTTP microservices, reactive applications, message-driven microservices and serverless are now central players in modern systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何年もの間、このクライアントサーバーアーキテクチャーは、アプリケーションを構築するための事実上の標準でした。しかし、大きな変化が起こったのです。_1 つのモデルがすべてを支配していた_ 時代は終わりました。新しい一連のアプリケーションとアーキテクチャーのスタイルが登場し、これはコードの書き方やアプリケーションの展開と実行の仕方に影響を与えました。HTTP マイクロサービス、リアクティブアプリケーション、メッセージ駆動型マイクロサービス、サーバーレスが、現在のシステムの中心的な役割を果たすようになったのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind, and provides first-class support for these different paradigms.  Quarkus development model morphs to adapt itself to the type of application you are developing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、この新しい世界を念頭に置いて設計されており、これらの異なるパラダイムに対してファーストクラスのサポートを提供しています。Quarkus の開発モデルは、開発中のアプリケーションの種類に合わせて変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s start with the basic: HTTP microservices.  In this context, you need to develop an HTTP endpoint, often called REST or CRUD.  You process incoming HTTP requests, and to do so you often need to rely on others services, such as databases, or another HTTP service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは基本中の基本、HTTP マイクロサービスから始めましょう。これに関しては、HTTP エンドポイントを開発する必要があり、これはしばしば REST や CRUD と呼ばれます。受信した HTTP リクエストを処理しますが、そのためにはデータベースなどの他のサービスや別の HTTP サービスに依存する必要があることが多くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this type of application, Quarkus relies on well-known standards such as JAX-RS, JPA and MicroProfile Rest Client.  Let's take a very simple application handling _fruits_. The code would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このタイプのアプリケーションでは、Quarkus は JAX-RS、JPA、MicroProfile Rest Client などのよく知られた標準に依存しています。_果物_ を扱う非常にシンプルなアプリケーションを見てみましょう。コードは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("fruits")
@Produces("application/json")
@Consumes("application/json")
public class FruitResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("fruits")
@Produces("application/json")
@Consumes("application/json")
public class FruitResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    EntityManager entityManager;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    EntityManager entityManager;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    public List&lt;Fruit&gt; get() {
        return entityManager.createNamedQuery("Fruits.findAll", Fruit.class)
              .getResultList();
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    public List&lt;Fruit&gt; get() {
        return entityManager.createNamedQuery("Fruits.findAll", Fruit.class)
              .getResultList();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("{id}")
    public Fruit getSingle(@PathParam Integer id) {
        Fruit entity = entityManager.find(Fruit.class, id);
        if (entity == null) {
            throw new WebApplicationException("Fruit with id of " + id + " does not exist.", 404);
        }
        return entity;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    @Path("{id}")
    public Fruit getSingle(@PathParam Integer id) {
        Fruit entity = entityManager.find(Fruit.class, id);
        if (entity == null) {
            throw new WebApplicationException("Fruit with id of " + id + " does not exist.", 404);
        }
        return entity;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Transactional
    public Response create(Fruit fruit) {
        if (fruit.getId() != null) {
            throw new WebApplicationException("Id was invalidly set on request.", 422);
        }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @POST
    @Transactional
    public Response create(Fruit fruit) {
        if (fruit.getId() != null) {
            throw new WebApplicationException("Id was invalidly set on request.", 422);
        }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        entityManager.persist(fruit);
        return Response.ok(fruit).status(201).build();
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        entityManager.persist(fruit);
        return Response.ok(fruit).status(201).build();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Java EE or Spring user, this development model should look familiar.  You expose a _resource_ containing methods annotated with `@GET`, `@POST`... to handle the different requests.  The _path_ is specified using the `@Path` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java EE や Spring のユーザーであれば、この開発モデルは見覚えがあるはずです。さまざまなリクエストを処理するために `@GET`、`@POST` ... のアノテーションが付いたメソッドを含む _リソース_ を公開しています。_パスは_ `@Path` アノテーションを使って指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JPA users will recognize the `EntityManager` used to access the database.  Finally, methods requiring a transaction are simply annotated with `@Transactional`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JPA ユーザーは、データベースへのアクセスに使用された `EntityManager` を認識します。最後に、トランザクションを必要とするメソッドには `@Transactional` が付けられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now imagine you need to access another HTTP endpoint.  You can use a HTTP client directly, this is nothing more than repeating boilerplate code.  Quarkus provides a way to call HTTP endpoints that return Rest based results easily using the MicroProfile Rest Client API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、別の HTTP エンドポイントにアクセスする必要があることを想像してみましょう。HTTP クライアントを直接使用できますが、これは定型文のコードを繰り返すだけです。Quarkus には、MicroProfile Rest Client API を使用して HTTP エンドポイントを簡単に呼び出す手段があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First declare your service as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは以下のようにサービスを宣言しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/v2")
@RegisterRestClient
public interface CountriesService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/v2")
@RegisterRestClient
public interface CountriesService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/name/{name}")
    @Produces("application/json")
    Set&lt;Country&gt; getByName(@PathParam("name") String name);
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    @Path("/name/{name}")
    @Produces("application/json")
    Set&lt;Country&gt; getByName(@PathParam("name") String name);
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each call you are intending to do, add a method and use annotations to describe the behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>意図している各呼び出しについて、メソッドを追加し、動作を記述するためにアノテーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, in your resource, just use the `CountriesService`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、リソースの中で `CountriesService` を使いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/country")
public class CountriesResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/country")
public class CountriesResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @RestClient
    CountriesService countriesService;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    @RestClient
    CountriesService countriesService;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/name/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    public Set&lt;Country&gt; name(@PathParam("name") String name) {
        return countriesService.getByName(name);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    @Path("/name/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    public Set&lt;Country&gt; name(@PathParam("name") String name) {
        return countriesService.getByName(name);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you may be wondering where the URL is configured as it's not in the code.  Remember, it must not be hard-coded because the url likely depends on the environment.  The URL is configured in the application configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、URL　がコードの中に出てこないため、URL がどこに設定されているのか気になるかもしれません。URL は環境に依存している可能性が高いので、ハードコード化してはいけないことを覚えておいてください。URL はアプリケーションの設定で設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># the format is interface-name/mp-rest/url=the-service-url
org.acme.restclient.CountriesService/mp-rest/url=https://restcountries.eu/rest
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># the format is interface-name/mp-rest/url=the-service-url
org.acme.restclient.CountriesService/mp-rest/url=https://restcountries.eu/rest
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The url can now be updated during the deployment or at launch time using system properties or environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>システムのプロパティーや環境変数を使用して、デプロイ時や起動時に URL を更新できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブであること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, big data or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの要件は、ここ数年で大きく変化しています。クラウドコンピューティング、ビッグデータ、IoT の時代において成功するためには、リアクティブなアーキテクチャーを採用することがますます重要になってきています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications that have milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput and elasticity.  However, these features are nearly impossible to achieve by using _yesterday’s software architecture_ without a huge investment in resources, infrastructure and tooling.  The world changed and having dozens of servers, long response time (&gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今日のユーザーは、ミリ秒単位の応答時間、100％のアップタイム、低いレイテンシー、プルではなくプッシュデータ、より高いスループットと弾力性を持つアプリケーションを採用しています。しかし、これらの機能は、リソース、インフラストラクチャー、ツールへの莫大な投資なしに、_これまでのソフトウェアアーキテクチャー_ で実現することはほぼ不可能です。世界は変わり、何十台というサーバーの使用、長い応答時間 (500ms 以上)、メンテナンスによるダウンタイム、障害の嵐という状況では、期待されるユーザーエクスペリエンスを満たすことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus stands with you on your path to reactive.  First, you can implement asynchronous HTTP endpoint as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、皆様のリアクティブへの道筋をサポートします。まず、以下のように非同期 HTTP エンドポイントを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@GET
@Path("/greeting/{name}")
public Uni&lt;String&gt; greetings(@PathParam("name") String name) {
    return reactiveService.getAsyncGreetings(name);
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@GET
@Path("/greeting/{name}")
public Uni&lt;String&gt; greetings(@PathParam("name") String name) {
    return reactiveService.getAsyncGreetings(name);
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method actions can compose asynchronous operations and complete the result when everything is done without blocking threads.  This greatly improves resource consumption and elasticity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドアクションは、スレッドをブロックすることなく、すべてが行われたときに非同期操作を構成し、結果を完了させることができます。これにより、リソース消費と弾力性が大幅に向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to a reactive core, an intuitive event-driven development model and a "reactive-first" strategy for all the Quarkus internals, Quarkus applications handles high concurrency, and uses resources efficiently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブコア、直感的なイベント駆動型開発モデル、Quarkus 内部のすべての「リアクティブファースト」戦略により、Quarkus アプリケーションは高度な並列処理を行い、リソースを効率的に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about streams? Generating a _server-sent event_ response with Quarkus is just as simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、ストリームについてはどうでしょうか? Quarkus を使用して _サーバーから送信されたイベント_ レスポンスを生成するのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Produces(MediaType.SERVER_SENT_EVENTS)
@GET
@Path("/neo")
public Multi&lt;String&gt; stream() {
    return service.getStream();
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Produces(MediaType.SERVER_SENT_EVENTS)
@GET
@Path("/neo")
public Multi&lt;String&gt; stream() {
    return service.getStream();
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method returns a `Multi`, but you can use any Reactive Streams `Publisher` implementation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは `Multi` を返しますが、Reactive Streams `Publisher` の実装を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Produces(MediaType.SERVER_SENT_EVENTS)
@GET
@Path("/neo")
public Multi&lt;String&gt; stream() {
    return Multi.createFrom().items("a", "b", "c")
           .onItem().transform(String::toUpperCase);
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Produces(MediaType.SERVER_SENT_EVENTS)
@GET
@Path("/neo")
public Multi&lt;String&gt; stream() {
    return Multi.createFrom().items("a", "b", "c")
           .onItem().transform(String::toUpperCase);
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message-driven microservices</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージ駆動型マイクロサービス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, HTTP characteristics prohibit implementing https://www.reactivemanifesto.org/[reactive systems], where all the components interact using asynchronous messages passing.  But no worries, Quarkus is perfectly suited to implement message-driven microservices and reactive systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、HTTP の特性上、すべてのコンポーネントが非同期メッセージの通過を使用して相互作用する https://www.reactivemanifesto.org/[リアクティブシステム] を実装することはできません。しかし心配はいりません。Quarkus は、メッセージ駆動型のマイクロサービスやリアクティブシステムの実装に完全に適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you can consume messages from various brokers such as AMQP or Kafka, and process these messages smoothly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、AMQP や Kafka などの各種ブローカーからのメッセージを消費し、スムーズに処理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class HealthDataProcessor {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped
public class HealthDataProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Incoming("health")
  @Outgoing("heartbeat")
  public double filtered(Health health) {
    return health.getHeartbeat();
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Incoming("health")
  @Outgoing("heartbeat")
  public double filtered(Health health) {
    return health.getHeartbeat();
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Incoming` and `@Outgoing` annotations are part of https://www.smallrye.io/smallrye-reactive-messaging[Reactive Messaging].  They are used to express from which _stream_ you are consuming and to which stream you are sending.  Thanks to Reactive Messaging you can consume and send messages from and to different brokers and transports such as HTTP, Kafka, or http://camel.apache.org[Apache Camel].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Incoming` および `@Outgoing` アノテーションは、https://www.smallrye.io/smallrye-reactive-messaging[Reactive Messaging] の一部です。これは、消費している _ストリーム_ から、送信しているストリームまでを表現するために使用されます。Reactive Messaging により、HTTP、Kafka、http://camel.apache.org[Apache Camel] などの異なるブローカーやトランスポートとの間でメッセージを消費したり、送信したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you need more than just handling messages one by one.  You can also express your message processing logic using reactive programming as illustrated in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージを 1 つずつ処理するだけでは不十分な場合もあります。次のスニペットに示すように、リアクティブプログラミングを使ってメッセージ処理ロジックを表現することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Incoming("health")
@Outgoing("output")
public Multi&lt;Record&lt;String, JsonObject&gt;&gt; filterState(Multi&lt;JsonObject&gt; input) {
    return input
      .onItem().transform(json -&gt; json.getJsonObject("state"))
      .drop().repetitions()
      .onItem().invoke(json -&gt; LOGGER.info("Forwarding new state '{}' to Kafka", json.encode()))
      .onItem().transform(json -&gt; Record.of("neo", json));
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Incoming("health")
@Outgoing("output")
public Multi&lt;Record&lt;String, JsonObject&gt;&gt; filterState(Multi&lt;JsonObject&gt; input) {
    return input
      .onItem().transform(json -&gt; json.getJsonObject("state"))
      .drop().repetitions()
      .onItem().invoke(json -&gt; LOGGER.info("Forwarding new state '{}' to Kafka", json.encode()))
      .onItem().transform(json -&gt; Record.of("neo", json));
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use _imperative_ logic with Reactive Messaging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messaging で _命令_ 型ロジックを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Incoming("orders")
@Outgoing("queue")
@Blocking
public Beverage process(Order order) {
    return prepare(order); // Block the caller thread.
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Incoming("orders")
@Outgoing("queue")
@Blocking
public Beverage process(Order order) {
    return prepare(order); // Block the caller thread.
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functions as a Service and Serverless</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスとサーバーレスとしての関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments.  If you are using AWS Lambda, your Quarkus function looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>驚異的な起動時間と低いメモリー使用量により、Quarkus を使用して、サーバーレス環境で使用するように関数を実装することができます。AWS Lambda を使用している場合、Quarkus の関数は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class HelloLambda implements RequestHandler&lt;HelloRequest, String&gt; {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class HelloLambda implements RequestHandler&lt;HelloRequest, String&gt; {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    HelloGreeter greeter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    HelloGreeter greeter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public String handleRequest(HelloRequest request, Context context) {
        return greeter.greet(request.firstName, request.lastName);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public String handleRequest(HelloRequest request, Context context) {
        return greeter.greet(request.firstName, request.lastName);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の機能のいずれかは関数で使用することができ、高速な起動と低メモリー使用率の恩恵を受けることができます。Quarkus を使用すると、プログラミング言語を変更することなく、この新しい世界を採用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} - Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} - アーキテクチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image::images/architecture-phases.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image::images/architecture-phases.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} has an architecture that does as much processing as possible at build time. Annotations and other descriptors are processed as early as possible, and then {project-name} will generate bytecode based on this information. This results in lower memory usage and faster startup speeds at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name}は、ビルド時に可能な限り多くの処理を行うアーキテクチャを持っています。アノテーションやその他のディスクリプターはできるだけ早い段階で処理され、{project-name}はこの情報に基づいてバイトコードを生成します。その結果、メモリー使用量が少なくなり、実行時の起動速度が速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションアーキテクチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that a {project-name} based application will go through a few different distinct phases, each of which can potentially be executed in a different JVM. These phases are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、{project-name} ベースのアプリケーションがいくつかの異なるフェーズを経て、それぞれが異なるJVMで実行される可能性があることを意味します。これらのフェーズは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augmentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This involves processing all the metadata that is present in the application and its libraries, such as annotations, descriptors etc, and processing this information to create bytecode that is executable at runtime. This generated bytecode will directly start the runtime services that were represented by the metadata. For example if your application contains a `@WebServlet` annotation this phase will output the bytecode required to start Undertow and register this Servlet.  The end result of this phase is a runnable application that should be equivalent to manually wiring up the runtime services you require, without any of the deployment time code present.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これには、アノテーションやディスクリプタなどのアプリケーションやそのライブラリに存在するすべてのメタデータを処理し、この情報を処理して実行時に実行可能なバイトコードを生成することが含まれます。この生成されたバイトコードは、メタデータによって表現されたランタイムサービスを直接起動します。例えば、アプリケーションに `@WebServlet` アノテーションが含まれている場合、このフェーズは Undertow を起動し、このサーブレットを登録するために必要なバイトコードを出力します。このフェーズの最終的な結果は、デプロイ時のコードを一切使用せずに、必要なランタイムサービスを手動で配線するのと同等の実行可能なアプリケーションとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running as a normal JVM application the bytecode generated in the augmentation phase will be executed to start the runtime services needed by the application. In production mode this will generally be in a different JVM instance, which means that none of the classes needed by the augmentation phase will be loaded at runtime, resulting in a smaller memory footprint and faster startup time. In development mode this will be the same JVM, allowing for the application to be quickly restarted when changes are made.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常のJVMアプリケーションとして実行している場合、拡張フェーズで生成されたバイトコードは、アプリケーションが必要とするランタイムサービスを開始するために実行されます。本番モードでは、これは通常、別のJVMインスタンスで実行されます。これは、拡張フェーズで必要とされるクラスが実行時にロードされないことを意味し、その結果、メモリーフットプリントが小さくなり、起動時間が速くなります。開発モードでは、これは同じJVMになり、変更が加えられたときにアプリケーションを迅速に再起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building a native image with SubstrateVM any code that is part of a static initializer is run as part of the native image build process, and the results are directly stored in memory. {project-name} takes advantage of this by generating some of the startup code in static initializer blocks, so they are run as part of the image build process rather than on image startup. This has multiple advantages, as the image build is a standard JVM it is still possible to use JVM features such as reflection and dynamic proxy generation that do not work out of the box on Substrate. As most of the startup is done in this phase the native image will start even faster, as it effectively contains a serialized image of an already started application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SubstrateVMでネイティブイメージをビルドする際、静的イニシャライザの一部であるコードは、ネイティブイメージのビルドプロセスの一部として実行され、結果は直接メモリーに保存されます。 {project-name} は、スタートアップコードの一部を静的イニシャライザブロックに生成することで、この利点を利用しているため、イメージの起動時ではなく、イメージのビルドプロセスの一部として実行されます。これには複数の利点があります。イメージビルドが標準のJVMであるため、 Substrate上では動作しないリフレクションや動的プロキシー生成などのJVM機能を使用することができます。ほとんどの起動はこのフェーズで行われるので、すでに起動しているアプリケーションのシリアライズされたイメージを効果的に含んでいるため、ネイティブイメージの起動はさらに速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Start</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージの起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As most of the work has been done in the image build the actual native image startup will generally only contain tasks that can't be done in advance, such as opening sockets and connecting to databases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどの作業はイメージのビルドで行われているので、実際のネイティブイメージの起動には、ソケットを開いたりデータベースに接続したりといった、事前にできないタスクしか含まれていないのが一般的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Architecture</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションアーキテクチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a result of this architecture every extension will provide two artifacts, one that handles build time processing (the `-deployment` artifacts), and another `-runtime` artifact that contains the classes needed at runtime. Only the runtime artifact will end up in the final application. The end result of the deployment process is some generated bytecode that can directly start any runtime services required by the application (but don't worry, you don't have to know anything about bytecode to write a {project-name} extension).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1つはビルド時の処理を処理するもの( `-deployment` アーティファクト)で、もう1つは実行時に必要なクラスを含む `-runtime` アーティファクトです。実行時のアーティファクトだけが最終的なアプリケーションになります。デプロイ処理の最終的な結果は、アプリケーションが必要とする任意のランタイムサービスを直接起動することができる、生成されたバイトコードです (ただし、バイトコードについて何も知らなくても {project-name} エクステンションを書くことができますので、ご心配なく)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} uses a novel technique for writing bytecode that we are calling _Bytecode Recording_. Basically at augment time extensions can inject instances of classes that contain the runtime logic to start services, and invoke these instances as if they were directly starting the service. These injected instances are actually proxies, that override all the public methods and record exactly which invocations have been made, what the parameters are, and the order they were made in. They then generate bytecode to perform this exact same sequence of invocations when the application starts up.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} では、バイトコードを書くための _バイトコードレコーディング_ と呼ばれる新しい技術を使用しています。基本的に、拡張フェーズではエクステンションでは、サービスを開始するためのランタイムロジックを含むクラスのインスタンスを注入し、あたかもサービスを直接開始するかのようにインスタンスを呼び出します。これらのインスタンスは実際にはプロキシーで、すべてのパブリックメソッドをオーバーライドして、どの呼び出しが行われたか、パラメーターは何か、どの順番で行われたかを正確に記録します。そして、アプリケーションが起動したときに、全く同じシーケンスの呼び出しを実行するバイトコードを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that from the point of view of an extension developer it looks like they are making invocations that directly start the application, when in fact they are recording bytecode that will be used to start the application later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、エクステンションの開発者の視点から見ると、アプリケーションを直接起動する呼び出しをしているように見えますが、実際には後でアプリケーションを起動するために使用されるバイトコードを記録していることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `-deployment` artifacts work by defining `@BuildStep` methods, that produce and consume `BuildItem` instances, and can also record bytecode if required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-deployment` アーティファクトは `@BuildStep` メソッドを定義することで動作し、 `BuildItem` インスタンスを生成して消費し、必要に応じてバイトコードを記録することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset {project-name} has been designed around a container first philosophy.  What this means in real terms is that {project-name} is optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初から {project-name} はコンテナーファーストの哲学に基づいて設計されています。これが実際に意味することは、{project-name} は以下の方法でメモリー使用量を抑え、起動時間を短縮するように最適化されているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Substrate support has been an important part of the design for {project-name} from the beginning.  When an application is compiled down to a native image it starts much faster and can run with a much smaller heap than a standard JVM. {project-name} are all tested in Substrate, and can run without the `-H:+ReportUnsupportedElementsAtRuntime` flag.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サブストレートのサポートは、最初から {project-name} の設計の重要な部分でした。アプリケーションがネイティブイメージにコンパイルされると、標準的なJVMよりもはるかに高速に起動し、より小さなヒープで実行することができます。project-name} はすべて Substrate でテストされており、 `-H:+ReportUnsupportedElementsAtRuntime` フラグなしで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Metadata Processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時メタデータ処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time, so your application will only contain the classes that are actually needed at runtime. In a traditional model all the classes required to perform the initial application deployment hang around for the life of the application, even though they are only used once. With {project-name} they are not even loaded into the production JVM. This results in less memory usage, and also faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可能な限り多くの処理はビルド時に行われるので、アプリケーションは実行時に実際に必要とされるクラスだけを含みます。従来のモデルでは、最初のアプリケーションのデプロイメントを実行するために必要なすべてのクラスは、一度しか使用されないにもかかわらず、アプリケーションの寿命の間、ぶら下がっています。project-name}では、それらのクラスは本番環境のJVMにロードされません。その結果、メモリー使用量が少なくなり、すべてのメタデータ処理がすでに行われているため、起動時間も速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクション使用量の削減</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible {project-name} tries to avoid reflection, reducing startup time and memory usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name}は可能な限り反射を避け、起動時間とメモリー使用量を減らすようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre Boot</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージのプリブート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in a native image {project-name} pre-boots as much of the framework as possible during the native image build process. This means that the resulting native image has already run most of the startup code and serialized the result into the executable, resulting in even faster startup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージで {project-name}を実行する場合、ネイティブイメージのビルドプロセスの間に、フレームワークの可能な限りの部分をプリブートします。これは、結果として得られるネイティブイメージがすでにほとんどのスタートアップコードを実行し、その結果を実行ファイルにシリアライズしていることを意味し、より高速なスタートアップを実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: publications
permalink: /publications/
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: publications
permalink: /publications/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} - Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} - 出版物</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a list of articles, blogs, podcast and other tidbits published online around {project-name}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、{project-name}関連でオンラインで公開されている記事、ブログ、ポッドキャスト、その他の豆知識のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you believe we are missing an article, blog or video https://github.com/quarkusio/quarkusio.github.io[submit an issue].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>記事、ブログ、ビデオが不足していると思われる場合は、 link:https://github.com/quarkusio/quarkusio.github.io[Issueを登録] してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: community
permalink: /community/
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: community
permalink: /community/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting help</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティからのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation, be sure to check link:{quarkus-site-getting-started}[our getting started] page and all our link:/guides/[guides].  + Also check out our link:/faq[FAQ] section and https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO[Quarkus Tips Playlist].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くのドキュメントがありますので、 link:{quarkus-site-getting-started}[スタート] ページやすべての link:/guides/[ガイド] をご確認ください。+ また、 link:/faq[FAQ] セクションと link:https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO[Quarkus Tipsプレイリスト] もご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスカッション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stack Overflow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stack Overflow</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask your questions on https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow]. + After the documentation, probably the best place to look for answers. We actively monitor the https://stackoverflow.com/questions/tagged/quarkus[quarkus tag].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow] で質問をしてみましょう。+ ドキュメントの後に、おそらく答えを探すのに最適な場所です。 link:https://stackoverflow.com/questions/tagged/quarkus[quarkusタグ] を積極的に監視しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mailing list</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メーリングリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also ask questions on our mailing list. Join the Google group via email {quarkus-mailing-list-subscription-email} or by visiting the Google Groups page {quarkus-mailing-list-index}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、メーリングリストで質問をすることもできます。Google グループに参加するには、電子メール {quarkus-mailing-list-subcription-email} または Google グループページ {quarkus-mailing-list-index} から参加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer live chat with the developers, we have a {quarkus-chat-url}[Zulip chat] where we all hang out.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発者とのライブチャットがお好きな方は、{quarkus-chat-url}[Zulip chat]をご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Publications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出版物</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are actively collection interesting blogs, articles, videos and other interesting publications. You can find those on link:{quarkus-site-publications}[Publications] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは積極的に面白いブログ、記事、ビデオ、その他の興味深い出版物を収集しています。あなたは、 link:{quarkus-site-publications}[出版物] のページでそれらを見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An Open Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オープンプロジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0]. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and welcome contributors. Let's join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} は link:https://www.apache.org/licenses/LICENSE-2.0[Apacheライセンスバージョン2.0] でライセンスされたオープンソースプロジェクトです。まず何よりも、貢献やアイデア、議論がオープンに行われ、貢献者を歓迎するオープンコミュニティです。力を合わせて、Javaアプリケーションの未来を築いていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code and issue tracker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードと課題管理システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code is hosted on {quarkus-base-url}[GitHub]. If you need to report a bug or request a new feature, look for a similar one on our {quarkus-issues-url}[github issues tracker]. If you don’t find any, create a new issue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースコードは{quarkus-base-url}[GitHub]でホストされています。バグの報告や新機能のリクエストが必要な場合は、{quarkus-issues-url}[github issues tracker] で同様のものを探してください。もし見つからなければ、新しい課題を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>貢献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of ways to contribute to {project-name} development:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} の開発に貢献する方法はたくさんあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing documentation and quickstarts,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントやクイックスタートを書いたり、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-issues-url}[Fixing bugs or even just opening an issue],</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quarkus-issues-url}[バグを修正したり、Issueを登録するだけでも構いません]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing new extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are an extension developer or want to contribute to {project-name} development, join our mailing list either:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もしあなたがエクステンションの開発者であったり、{project-name}の開発に貢献したい場合は、私たちのメーリングリストに参加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>by visiting the Google Groups page {quarkus-mailing-list-index}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Googleグループのページ{quarkus-mailing-list-index}にアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you visit our extensive link:{quarkus-writing-extensions-guide}[extension developer guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当社の広範な link:{quarkus-writing-extensions-guide}[エクステンション開発者ガイド] を必ずご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/developer-joy
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: vision
permalink: /vision/developer-joy
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond simply working, we're aiming for Joy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単に働くだけでなく、充実した仕事生活を目指しています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} is not just about being great for writing Web Applications or Micro-Services. We're focusing on more than the feature set: we make sure that every feature works well, simply, with little to no configuration, in the most intuitive way possible. It should be trivial to develop simple things, and easy to develop the more complex ones.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} は、単にWebアプリケーションやマイクロサービスを書くために優れているということだけではありません。私たちが重視しているのは機能セットだけではありません: 私たちは、可能な限り直感的な方法で、ほとんど設定をせずに、シンプルに、すべての機能がうまく動作するようにしています。シンプルなものを開発するのはごく簡単で、複雑なものを開発するのは容易でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We've looked for the most useful extensions, we've made sure they all work together, that every use-case is covered, that out-of-the-box configuration is the most sensible, that every error helps you to resolve it. More than productivity: using {project-name} should be enjoyable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは最も有用なエクステンションを探し、それらがすべて一緒に動作し、すべてのユースケースがカバーされていること、箱から出してすぐに使える設定が最も賢明であること、すべてのエラーが解決に役立つことを確認しました。生産性以上のもの: {project-name} を使うことは楽しいものとなるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統一された設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gone are the days of a thousand configuration files and formats. We're aiming for cohesion, so a single configuration file is all it takes for {project-name} applications to configure every single extension. Not only that, but we've made sure that every configurable option has the most useful and sensible defaults so you can get started with no configuration whatsoever.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何千もの設定ファイルやフォーマットの時代は終わりました。私たちは一貫性を目指しているので、{project-name} アプリケーションがすべてのエクステンションを設定するために必要なのは、単一の設定ファイルだけです。それだけでなく、すべての設定可能なオプションには、最も便利で賢明なデフォルト値が設定されていることを確認していますので、何も設定しなくても始めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライブコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the major productivity problems that face most Java developers is traditional Java development workflow. For most web developers this will generally be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどのJava開発者が直面する主要な生産性の問題の1つは、伝統的なJava開発ワークフローです。ほとんどのウェブ開発者にとって、これは一般的にはこのようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Write Code_ -&gt; _Compile_ -&gt; _Deploy_ -&gt; _Refresh Browser_ -&gt; _Repeat_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_コードを書く_ → _コンパイル_ → _デプロイ_ → _ブラウザを更新_ → _繰り返し_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be a major drain on productivity, as the compile + redeploy cycle can often take up to a minute or more. {project-name} aims to solve this problem with its _Live Coding_ feature. When running in development mode the workflow is simply:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、コンパイルと再デプロイのサイクルが1分以上かかることが多く、生産性を大きく低下させる可能性があります。{project-name} は、 _ライブコーディング_ 機能でこの問題を解決しようとしています。開発モードで実行している場合、ワークフローは単純です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Write Code_ -&gt; _Refresh Browser_ -&gt; _Repeat_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_コードを書く_ → _ブラウザを更新_ → _繰り返し_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will work out of the box, with no special setup required. This works for Java file, application config, and static resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、特別な設定を必要とせず、箱から出してすぐに動作します。これはJavaファイル、アプリケーション設定、静的リソースに対して動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you run `mvn compile quarkus:dev` {project-name} will launch in development mode. When it receives a HTTP request it will hold the request, and check to see if any application source files have been changed. If they have it will transparently compile the changed files, redeploy the application with the changed files, and then the HTTP request will continue to the redeployed application. {project-name} redeploys are much faster than a traditional app server, so for all but the largest applications this should take well under a second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn compile quarkus:dev` {project-name} を実行すると、開発モードで起動します。HTTP リクエストを受信すると、リクエストを保持し、アプリケーションのソースファイルが変更されたかどうかをチェックします。もし変更されていれば、変更されたファイルを透過的にコンパイルし、変更されたファイルでアプリケーションを再デプロイし、再デプロイされたアプリケーションへの HTTP リクエストを続けます。{project-name} の再デプロイは、従来のアプリサーバーよりもはるかに高速なので、大規模なアプリケーションを除くすべてのアプリケーションでは、1秒以下で完了するはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Works on all the things</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのことに取り組んでいます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's nothing worse than getting different results when running your application or tests under Maven, Gradle, or the IDE. Whatever your workflow, {project-name} applications or tests are trivial to run in any environment, so pick your favorite tool and we make sure you get the same results as easily as possible.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven、Gradle、IDEでアプリケーションやテストを実行したときに、異なる結果を得ることほど悪いことはありません。ワークフローがどのようなものであれ、{project-name}アプリケーションやテストはどのような環境でも簡単に実行できます。好みのツールを選んでいただければ、出来る限り簡単に同じ結果が得られることを担保しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Opinionated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定見に基づいた選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We get it: there are a thousand ways to write the same code. Every company has traditions about how a project should be structured, and that can be fine. But it makes it really hard to write simple documentation, to onboard new developers, and to make things simple.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同じコードを書く方法は何千通りもあります。どの会社にもプロジェクトの構造化についての伝統があり、それはそれでいいのです。しかし、そうすると、簡単なドキュメントを書いたり、新しい開発者を迎え入れたり、物事をシンプルにするのは本当に難しいこととなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} will focus on what we feel is the simplest and most useful way to use any given feature. We will work hard to trim that particular feature to its most useful essence, and to document it thoroughly, in an intuitive manner. That's analysing up-front how to best use that feature and helping you avoid that analysis, through our experience, and guiding you in what we think is the best way to do things. That's taking an opinion on how you should do things and voicing it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name} は、与えられた機能を使用するための最もシンプルで最も有用な方法と思われるものに焦点を当てます。私たちは、その特定の機能を最も有用な本質に落とし込み、直観的な方法で徹底的に文書化するように努力します。これは、その機能をどのように使うのが一番良いかを前もって分析し、私たちの経験から、そのような分析を避けるためのお手伝いをし、私たちが考える最善の方法をお客様にご案内することです。これは、物事をどのように行うべきかについて意見を述べ、それを表明することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perhaps you'll disagree with our opinion, or you'll have a much more complex use-case that will not be solved by our recommended way, but that's fine. Don't worry: we will not prevent you from more advanced usage on the features we provide or the frameworks we integrate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おそらくあなたは私たちの意見に同意しないかもしれませんし、私たちの推奨する方法では解決できない複雑なユースケースを抱えているかもしれませんが、それは構いません。ご心配なく、私たちが提供する機能や私たちが統合しているフレームワークのより高度な利用を妨げることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the RESTEasy REST Client in order to interact with REST APIs with very little effort.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、MicroProfile REST Clientを使用して、ほとんど手間をかけずにREST APIとやりとりする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need to write server link:rest-json[JSON REST APIs].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバー link:rest-json[JSON REST API] を書く必要がある場合は、別のガイドがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `rest-client` と `resteasy-jackson` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `resteasy` and `resteasy-jackson` extensions for the REST server support;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST サーバーのサポートのために `resteasy` と `resteasy-jackson` のエクステンションを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `rest-client` and `rest-client-jackson` extensions for the REST client support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST クライアントのサポートのために `rest-client` と `rest-client-jackson` のエクステンションを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `rest-client` and the `rest-client-jackson` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、 `rest-client` と `rest-client-jackson` のエクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will be demonstrating how to consume part of the REST API supplied by the link:https://restcountries.eu[restcountries.eu] service.  Our first order of business is to setup the model we will be using, in the form of a `Country` POJO.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:https://restcountries.eu[restcountries.eu] サービスが提供するREST APIの一部を利用する方法をデモします。まず最初に、 `Country` POJO の形式で使用するモデルをセットアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `src/main/java/org/acme/rest/client/Country.java` file and set the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/java/org/acme/rest/client/Country.java` ファイルを作成し、以下の内容を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The model above is only a subset of the fields provided by the service (thus the `@JsonIgnoreProperties` annotation), but it suffices for the purposes of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のモデルは、サービスによって提供されるフィールドのサブセットに過ぎません(`@JsonIgnoreProperties` アノテーションによる)が、このガイドの目的には十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the interface</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターフェースの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the RESTEasy REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations. In our case the interface should be created at `src/main/java/org/acme/rest/client/CountriesService.java` and have the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile REST Client を使うのは、適切な JAX-RS と MicroProfile アノテーションを使ってインターフェースを作成するのと同じくらい簡単です。私たちの場合、インターフェイスは `src/main/java/org/acme/rest/client/CountriesService.java` で作成され、次のような内容になっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `getByName` method gives our code the ability to query a country by name from the REST Countries API. The client will handle all the networking and marshalling leaving our code clean of such technical details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getByName` メソッドは、私たちのコードに、REST Countries API から名前を指定して国を問い合わせる機能を与えます。クライアントがすべてのネットワーキングとマーシャリングを処理してくれるので、このような技術的な詳細は一切ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of the annotations in the code above is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上のコードのアノテーションの目的は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterRestClient` により、Quarkusは、このインターフェイスがRESTクライアントとしてCDIインジェクションに利用可能であることを知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Path`, `@GET` and `@PathParam` are the standard JAX-RS annotations used to define how to access the service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Path` 、 `@GET` 、 `@PathParam` は、サービスへのアクセス方法を定義するために使用される標準的な JAX-RS アノテーションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Produces` defines the expected content-type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Produces` は、期待されるコンテンツタイプを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-rest-client-jackson` or `quarkus-rest-client-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-rest-client-jackson` や `quarkus-rest-client-jsonb` などの JSON エクステンションがインストールされている場合、メディアタイプが `@Produces` や `@Consumes` アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` メディアタイプをデフォルトで使用します( `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` と `application/octet-stream` がデフォルトとなっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want JSON by default you can set `quarkus.resteasy-json.default-json=false` and the default will change back to being auto-negotiated. If you set this you will need to add `@Produces(MediaType.APPLICATION_JSON)` and `@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to use JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでJSONを使用したくない場合は、 `quarkus.resteasy-json.default-json=false` を設定すると、デフォルトは自動ネゴシエーションに戻ります。これを設定した場合、JSON を使用するためには `@Produces(MediaType.APPLICATION_JSON)` と `@Consumes(MediaType.APPLICATION_JSON)` をエンドポイントに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't rely on the JSON default, it is heavily recommended to annotate your endpoints with the `@Produces` and `@Consumes` annotations to define precisely the expected content-types.  It will allow to narrow down the number of JAX-RS providers (which can be seen as converters) included in the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON のデフォルトに頼らない場合は、エンドポイントに `@Produces` や `@Consumes` のアノテーションを付けて、期待されるコンテンツタイプを正確に定義することを強くお勧めします。これにより、ネイティブ実行ファイルに含まれる JAX-RS プロバイダ (コンバータとみなすことができます) の数を絞り込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query Parameters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリのパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the GET request requires query parameters you can leverage the `@QueryParam("parameter-name")` annotation instead of (or in addition to) the `@PathParam`. Path and query parameters can be combined, as required, as illustrated in a mock example below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GETリクエストにクエリパラメータが必要な場合は、 `@PathParam` の代わりに（または追加で） `@QueryParam("parameter-name")` を利用することができます。パスとクエリパラメータは、必要に応じて組み合わせることができます（以下のモックの例を参照してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to determine the base URL to which REST calls will be made, the REST Client uses configuration from `application.properties`.  The name of the property needs to follow a certain convention which is best displayed in the following code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST 呼び出しが行われるベース URL を決定するために、REST クライアントは `application.properties` からの設定を使用します。プロパティーの名前は、以下のコードで表示される特定の規則に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having this configuration means that all requests performed using `org.acme.rest.client.CountriesService` will use `https://restcountries.eu/rest` as the base URL.  Using the configuration above, calling the `getByName` method of `CountriesService` with a value of `France` would result in an HTTP GET request being made to `https://restcountries.eu/rest/v2/name/France`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定をすると、 `org.acme.rest.client.CountriesService` を使用して実行されるすべてのリクエストが `https://restcountries.eu/rest` をベースURLとして使用します。上記の設定を使用して、 `CountriesService` の `getByName` メソッドを `France` の値で呼び出すと、HTTP GET リクエストが `https://restcountries.eu/rest/v2/name/France` に対して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having this configuration means that the default scope of `org.acme.rest.client.CountriesService` will be `@Singleton`. Supported scope values are `@Singleton`, `@Dependent`, `@ApplicationScoped` and `@RequestScoped`. The default scope is `@Dependent`.  The default scope can also be defined on the interface.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定をすると、 `org.acme.rest.client.CountriesService` のデフォルトのスコープは `@Singleton` になります。サポートされているスコープの値は `@Singleton` , `@Dependent` , `@ApplicationScoped` および `@RequestScoped` です。既定のスコープは `@Dependent` です。デフォルトのスコープはインターフェイス上で定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `org.acme.rest.client.CountriesService` _must_ match the fully qualified name of the `CountriesService` interface we created in the previous section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.rest.client.CountriesService` は、前のセクションで作成した `CountriesService` インターフェイスの完全修飾名と _一致しなければならない_ ことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To facilitate the configuration, you can use the `@RegisterRestClient` `configKey` property that allows to use another configuration root than the fully qualified name of your interface.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>構成を容易にするために、 `@RegisterRestClient` `configKey` プロパティーを使用して、インターフェイスの完全修飾名とは別の構成ルートを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling Hostname Verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ホスト名の検証を無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable the SSL hostname verification for a specific REST client, add the following property to your configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定のRESTクライアントのSSLホスト名検証を無効にするには、次のプロパティーを構成に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable all SSL verifications, add the following property to your configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>全てのSSL検証を無効にするには、次のプロパティーを設定に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/rest/client/CountriesResource.java` file and update it with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/java/org/acme/rest/client/CountriesResource.java` ファイルを開き、以下の内容で更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in addition to the standard CDI `@Inject` annotation, we also need to use the MicroProfile `@RestClient` annotation to inject `CountriesService`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準の CDI `@Inject` アノテーションに加えて、MicroProfile `@RestClient` アノテーションを使用して `CountriesService` を注入する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/rest/client/CountriesResourceTest.java` file and change the content of the `testCountryNameEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/rest/client/CountriesResourceTest.java` ファイルを編集し、 `testCountryNameEndpoint` メソッドの内容を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code above uses link:http://rest-assured.io/[REST Assured]'s link:https://github.com/rest-assured/rest-assured/wiki/GettingStarted#jsonpath[json-path] capabilities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上のコードでは、 link:http://rest-assured.io/[REST Assured] の link:https://github.com/rest-assured/rest-assured/wiki/GettingStarted#jsonpath[json-path] 機能を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Async Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest client supports asynchronous rest calls.  Async support comes in 2 flavors: you can return a `CompletionStage` or a `Uni` (requires the `quarkus-rest-client-mutiny` extension).  Let's see it in action by adding a `getByNameAsync` method in our `CountriesService` REST interface. The code should look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>rest クライアントは非同期の rest 呼び出しをサポートしています。非同期のサポートには、 `CompletionStage` と `Uni` ( `quarkus-rest-client-mutiny` のエクステンションが必要です) の 2 種類があります。 `CountriesService` REST インタフェースに `getByNameAsync` メソッドを追加してみましょう。コードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test asynchronous methods, add the test method below in `CountriesResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期メソッドをテストするには、`CountriesResourceTest` に以下のテストメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Uni` version is very similar:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni` 版は非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CountriesResource` becomes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CountriesResource` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous snippet uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のスニペットでは、Mutinyのリアクティブタイプを使用していますが、もし慣れていない場合は、まず link:getting-started-reactive#mutiny[Getting Started with Reactiveガイド] を読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use a `CompletionStage`, you would need to call the service's method to retry.  This difference comes from the laziness aspect of Mutiny and its subscription protocol.  More details about this can be found in https://smallrye.io/smallrye-mutiny/#_uni_and_multi[the Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CompletionStage` を使用する場合は、サービスのメソッドを呼び出して再試行する必要があります。この違いは、Mutinyとそのサブスクリプションプロトコルの lazy 性の側面から来ています。これについての詳細は Mutiny の link:https://smallrye.io/smallrye-mutiny/#_uni_and_multi[ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom headers support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムヘッダーのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile REST client allows amending request headers by registering a `ClientHeadersFactory` with the `@RegisterClientHeaders` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile REST クライアントでは、 `ClientHeadersFactory` を `@RegisterClientHeaders` アノテーションで登録することで、リクエストヘッダを修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see it in action by adding a `@RegisterClientHeaders` annotation pointing to a `RequestUUIDHeaderFactory` class in our `CountriesService` REST interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CountriesService` REST インタフェースに `@RegisterClientHeaders` アノテーションを追加して、 `RequestUUIDHeaderFactory` クラスを指すようにしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the `RequestUUIDHeaderFactory` would look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `RequestUUIDHeaderFactory` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default header factory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのヘッダーファクトリー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use `@RegisterClientHeaders` annotation without any custom factory specified. In that case the `DefaultClientHeadersFactoryImpl` factory will be used and all headers listed in `org.eclipse.microprofile.rest.client.propagateHeaders` configuration property will be amended. Individual header names are comma-separated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、カスタムファクトリーを指定せずに `@RegisterClientHeaders` アノテーションを使用することもできます。その場合は、 `DefaultClientHeadersFactoryImpl` ファクトリーが使用され、 `org.eclipse.microprofile.rest.client.propagateHeaders` 設定プロパティに記載されているすべてのヘッダーが修正されます。個々のヘッダー名はコンマで区切られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをパッケージ化して実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/country/name/greece.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行します。ブラウザで http://localhost:8080/country/name/greece を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see a JSON object containing some basic information about Greece.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ギリシャに関する基本情報を含む JSON オブジェクトが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file.  You can also generate the native executable with `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative` でネイティブ実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the REST Client extension and link:rest-json[the RESTEasy extension] share the same infrastructure.  One important consequence of this consideration is that they share the same list of providers (in the JAX-RS meaning of the word).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、RESTクライアントエクステンションと link:rest-json[RESTEasyエクステンション] は同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RSの意味での)プロバイダーのリストを共有しているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, if you declare a `WriterInterceptor`, it will by default intercept both the servers calls and the client calls, which might not be the desired behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `WriterInterceptor` を宣言した場合、デフォルトではサーバーの呼び出しとクライアントの呼び出しの両方をインターセプトしますが、これは望ましい動作ではないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can change this default behavior and constrain a provider to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、このデフォルトの動作を変更してプロバイダを制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 *クライアント* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 *サーバー* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a Mock HTTP Server for tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストにモックHTTPサーバーを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up a mock HTTP server, against which tests are run, is a common testing pattern.  Examples of such servers are link:http://wiremock.org/[Wiremock] and link:https://docs.hoverfly.io/projects/hoverfly-java/en/latest/index.html[Hoverfly].  In this section we'll demonstrate how Wiremock can be leveraged for testing the `CountriesService` which was developed above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストを実行するためのモックHTTPサーバーを設定することは、一般的なテストパターンです。そのようなサーバーの例としては、 link:http://wiremock.org/[Wiremock] や link:https://docs.hoverfly.io/projects/hoverfly-java/en/latest/index.html[Hoverfly] があります。このセクションでは、上で開発した `CountriesService` をテストするために Wiremock をどのように活用できるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, Wiremock needs to be added as a test dependency. For a Maven project that would happen like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず第一に、Wiremockをテスト依存関係として追加する必要があります。Mavenプロジェクトの場合は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a proper Wiremock version. All available versions can be found link:https://search.maven.org/artifact/com.github.tomakehurst/wiremock-jre8[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>適切なWiremockのバージョンを使用してください。利用可能なすべてのバージョンは link:https://search.maven.org/artifact/com.github.tomakehurst/wiremock-jre8[ここで]  見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus tests when some service needs to be started before the Quarkus tests are ran, we utilize the `@io.quarkus.test.common.QuarkusTestResource` annotation to specify a `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` which can start the service and supply configuration values that Quarkus will use.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのテストを実行する前にサービスを開始する必要がある場合、Quarkusのテストでは、 `@io.quarkus.test.common.QuarkusTestResource` アノテーションを利用して、サービスを開始できる `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を指定し、Quarkusが使用する設定値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details about `@QuarkusTestResource` refer to link:getting-started-testing#quarkus-test-resource[this part of the documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTestResource` の詳細については、 link:getting-started-testing#quarkus-test-resource[ドキュメントのこの部分] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an implementation of `QuarkusTestResourceLifecycleManager` called `WiremockCountries` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このように `QuarkusTestResourceLifecycleManager` の実装である `WiremockCountries` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Statically importing the methods in the Wiremock package makes it easier to read the test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Wiremockパッケージのメソッドを静的にインポートすると、テストを読みやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `start` method is invoked by Quarkus before any test is run and returns a `Map` of configuration properties that apply during the test execution.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`start` メソッドは、テストを実行する前にQuarkusによって呼び出され、テスト実行中に適用される設定プロパティーの `Map` を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Wiremock.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Wiremockを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Wiremock to stub the calls to `/v2/name/GR` by returning a specific canned response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Wiremockが特定の定型文を返すことで、 `/v2/name/GR` への呼び出しをスタブするように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All HTTP calls that have not been stubbed are handled by calling the real service. This is done for demonstration purposes, as it is not something that would usually happen in a real test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタブ化されていないすべての HTTP 呼び出しは、実際のサービスを呼び出すことで処理されます。これは、実際のテストでは通常発生しないことなので、デモンストレーションのために行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the `start` method returns configuration that applies for tests, we set the rest-client property that controls the base URL which is used by the implementation of `CountriesService` to the base URL where Wiremock is listening for incoming requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`start` メソッドはテストに適用される設定を返すので、 `CountriesService` の実装で使用されるベースURLを制御する rest-client プロパティーを、Wiremock がリクエストの着信をリッスンするベースURLに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When all tests have finished, shutdown Wiremock.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのテストが終了したら、Wiremockをシャットダウンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CountriesResourceTest` test class needs to be annotated like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CountriesResourceTest` テストクラスには、このようなアノテーションが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusTestResource` applies to all tests, not just `CountriesResourceTest`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTestResource` は `CountriesResourceTest` だけでなく、すべてのテストに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further reading</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloud.google.com/[A Google Cloud Account].  Free accounts work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://cloud.google.com/[Googleクラウドのアカウント] 。アカウントの無料枠で試すことが可能です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to follow all these steps, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの手順を順にすべて実行しない場合、完成したサンプルを以下で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven Deployment Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイ用のMavenプロジェクトを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Login to Google Cloud is necessary for deploying the application and it can be done as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのデプロイにはGoogle Cloudへのログインが必要となるため、以下のコマンドでログインします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gcloud auth login
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gcloud auth login
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy to Google Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのビルドとGoogle Cloudへのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first time you launch this command, you can have the following error message:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドを初めて起動したときには、以下のようなエラーメッセージが表示されることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that Cloud Build is not activated yet. To overcome this error, open the URL shown in the error, follow the instructions and then wait a few minutes before retrying the command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Cloud Buildがまだ有効化されていないことを意味します。このエラーを解決するには、エラーに表示されているURLを開き指示に従った後、数分待ってからコマンドを再試行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will give you as output a `httpsTrigger.url` that points to your function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、作成したCloud Functions 関数をトリガーするための `httpsTrigger.url` を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing locally</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to locally test your function is using the Cloud Function invoker JAR.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数をローカルでテストする最も簡単な方法は、Cloud Function invoker JAR を使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can download it via Maven using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコマンドでMaven経由でダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before using the invoker, you first need to build your function via `mvn package`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>invokerを使用する前に、`mvn package` で関数をビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `--classpath` parameter needs to be set to the previously packaged JAR that contains your function class and all Quarkus related classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--classpath` パラメーターには、関数クラスとQuarkus関連のすべてのクラスを含む、先の手順でパッケージ化されたJARを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your endpoints will be available on http://localhost:8080.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントは http://localhost:8080 で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops.  This guide explains how to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、以下の方法を説明します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a Quarkus application with a main method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メインメソッドでQuarkusアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write command mode applications that run a task and then terminate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タスクを実行して終了するコマンドモードのアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application starts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの開始時に通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application stops</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが停止したときに通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `lifecycle-quickstart` {quickstarts-tree-url}/lifecycle-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `lifecycle-quickstart`  {quickstarts-tree-url}/lifecycle-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下が生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mavenの構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page accessible on `http://localhost:8080`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランディングページは次のURLでアクセス可能です: `http://localhost:8080`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`native`  と `jvm`  の両方のモードに対応した `Dockerfile`  ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.lifecycle.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.lifecycle.GreetingResource`  リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メインメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will automatically generate a main method, that will bootstrap Quarkus and then just wait for shutdown to be initiated. Let's provide our own main method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusは自動的にメインメソッドを生成し、Quarkusを起動し、シャットダウンが開始されるのを待つだけです。独自のメインメソッドを追加してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation tells Quarkus to use this as the main method, unless it is overridden in the config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションは、設定でオーバーライドされない限り、これをメインのメソッドとして使用するようQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This launches Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これによりQuarkusが起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This main class will bootstrap Quarkus and run it until it stops. This is no different to the automatically generated main class, but has the advantage that you can just launch it directly from the IDE without needing to run a Maven or Gradle command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメインクラスはQuarkusを起動し、停止するまで実行します。これは自動生成されたメインクラスと変わりませんが、MavenやGradleのコマンドを実行する必要がなく、IDEから直接起動するだけで済むという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not recommenced to do any business logic in this main method, as Quarkus has not been set up yet, and Quarkus may run in a different ClassLoader. If you want to perform logic on startup use an `io.quarkus.runtime.QuarkusApplication` as described below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだQuarkusが設定されておらず、Quarkusは別のClassLoaderで動作する可能性があるため、このメインメソッドでビジネスロジックを行うことは推奨されていません。起動時にロジックを実行したい場合は、以下のように `io.quarkus.runtime.QuarkusApplication`  を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we want to actually perform business logic on startup (or write applications that complete a task and then exit)  we need to supply a `io.quarkus.runtime.QuarkusApplication` class to the run method. After Quarkus has been started the `run` method of the application will be invoked. When this method returns the Quarkus application will exit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動時に実際にビジネスロジックを実行したい場合(またはタスクを完了してから終了するアプリケーションを書きたい場合)、runメソッドに `io.quarkus.runtime.QuarkusApplication`  クラスを指定する必要があります。Quarkusが起動すると、アプリケーションの `run`  メソッドが呼び出されます。このメソッドが返されると、Quarkusアプリケーションは終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to perform logic on startup you should call `Quarkus.waitForExit()`, this method will wait until a shutdown is requested (either from an external signal like when you press `Ctrl+C` or because a thread has called `Quarkus.asyncExit()`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動時にロジックを実行したい場合は、 `Quarkus.waitForExit()`  を呼び出す必要があります。このメソッドは、シャットダウンが要求されるまで待機します( `Ctrl+C`  を押したときのような外部シグナルや、スレッドが `Quarkus.asyncExit()`  を呼び出したときのような外部シグナルのいずれか)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of what this looks like is below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その一例が以下のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting the command line arguments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドライン引数の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to inject the arguments that were passed in on the command line:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドラインで渡された引数を注入することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening for startup and shutdown events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタートアップとシャットダウンのイベントをリッスンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class named `AppLifecycleBean` (or pick another name) in the `org.acme.lifecycle` package, and copy the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.lifecycle`  パッケージ内に `AppLifecycleBean`  という名前の新しいクラスを作成し(または別の名前を選び)、以下の内容をコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is starting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの起動時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is terminating</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの終了時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The events are also called in _dev mode_ between each redeployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、各再配置の間に _devモード_ でイベントが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The methods can access injected beans. Check the {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] class for details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドは注入されたBeanにアクセスすることができます。詳細は {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] クラスを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the difference from `@Initialized(ApplicationScoped.class)` and `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Initialized(ApplicationScoped.class)`  との違いは? `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JVM mode, there is no real difference, except that `StartupEvent` is always fired *after* `@Initialized(ApplicationScoped.class)` and `ShutdownEvent` is fired *before* `@Destroyed(ApplicationScoped.class)`.  For a native executable build, however, `@Initialized(ApplicationScoped.class)` is fired as *part of the native build process*, whereas `StartupEvent` is fired when the native image is executed.  See link:writing-extensions#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMモードでは、 `StartupEvent`  は常に `@Initialized(ApplicationScoped.class)`  の *後に* 実行され、 `ShutdownEvent`  は `@Destroyed(ApplicationScoped.class)`  の *前に* 実行されることを除けば、実質的な違いはありません。しかし、ネイティブの実行可能なビルドでは、 `@Initialized(ApplicationScoped.class)`  はネイティブの *ビルドプロセスの一部* として実行され、 `StartupEvent`  はネイティブイメージが実行されたときに実行されます。詳細については、 link:writing-extensions#bootstrap-three-phases[Bootstrapの3つのフェーズとQuarkusの哲学]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI applications, an event with qualifier `@Initialized(ApplicationScoped.class)` is fired when the application context is initialized. See https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[the spec, window="_blank"] for more info.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI アプリケーションでは、アプリケーションコンテキストが初期化されると、修飾子 `@Initialized(ApplicationScoped.class)`  を持つイベントが発生します。詳細は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[仕様, window=_blank]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@Startup` to initialize a CDI bean at application startup</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Startup`  を使用して、アプリケーション起動時に CDI Bean を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean represented by a class, producer method or field annotated with `@Startup` is initialized at application startup:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Startup`  でアノテーションされたクラス、プロデューサメソッド、フィールドで表現されたBeanは、アプリケーションの起動時に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.enterprise.context.ApplicationScoped;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.enterprise.context.ApplicationScoped;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   private final String name;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>   private final String name;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   EagerAppBean(NameGenerator generator) { // &lt;2&gt;
     this.name = generator.createName();
   }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>   EagerAppBean(NameGenerator generator) { // &lt;2&gt;
     this.name = generator.createName();
   }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Startup`  でアノテーションされた各Beanに対して、 `StartupEvent`  の合成オブザーバが生成されます。デフォルトの優先度が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanのコンストラクタは、アプリケーションの起動時に呼び出され、結果として得られるコンテキストインスタンスがアプリケーションのコンテキストに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Dependent` beans are destroyed immediately afterwards to follow the behavior of observers declared on `@Dependent` beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Dependent` Beanは、 `@Dependent`  Beanに宣言されたオブザーバーの行動に従うために、その後すぐに破壊されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class is annotated with `@Startup` but with no scope annotation then `@ApplicationScoped` is added automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスが `@Startup`  でアノテーションされていて、スコープのアノテーションがない場合は、 `@ApplicationScoped`  が自動的に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`, the logged message is printed.  When the application is stopped, the second log message is printed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw compile quarkus:dev`  でアプリケーションを実行すると、ログメッセージが表示されます。アプリケーションを停止すると、2 番目のログメッセージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file.  You can also generate the native executable using `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、 `./mvnw clean package`  を使ってアプリケーションをパッケージ化し、 `target/quarkus-app/quarkus-run.jar` ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative` を使用してネイティブの実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Modes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has 3 different launch modes, `NORMAL` (i.e. production), `DEVELOPMENT` and `TEST`. If you are running `quarkus:dev` then the mode will be `DEVELOPMENT`, if you are running a JUnit test it will be `TEST`, otherwise it will be `NORMAL`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには3種類の起動モードがあります。 `NORMAL`  (つまりプロダクション)、 `DEVELOPMENT`  、 `TEST`  です。 `quarkus:dev`  を実行している場合は `DEVELOPMENT`  、JUnit テストを実行している場合は `TEST`  、それ以外の場合は `NORMAL`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application can get the launch mode by injecting the `io.quarkus.runtime.LaunchMode` enum into a CDI bean, or by invoking the static method `io.quarkus.runtime.LaunchMode.current()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは、 `io.quarkus.runtime.LaunchMode`  enum を CDI Beanに注入するか、静的メソッド `io.quarkus.runtime.LaunchMode.current()`  を呼び出すことで起動モードを取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Graceful Shutdown</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グレースフルシャットダウン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes support for graceful shutdown, this allows Quarkus to wait for running requests to finish, up till a set timeout. By default this is disabled, however you can configure this by setting the `quarkus.shutdown.timeout` config property. When this is set shutdown will not happen until all running requests have completed, or until this timeout has elapsed. This config property is a duration, and can be set using the standard `java.time.Duration` format, if only a number is specified it is interpreted as seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、Quarkusは、実行中のリクエストが終了するまで、設定されたタイムアウトまで待機することができます。デフォルトでは無効になっていますが、 `quarkus.shutdown.timeout`  configプロパティーを設定することで設定することができます。これが設定されている場合、すべての実行中のリクエストが完了するまで、またはこのタイムアウトが経過するまでシャットダウンは行われません。この設定プロパティーは持続時間であり、標準の `java.time.Duration`  形式で設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions that accept requests need to add support for this on an individual basis. At the moment only the HTTP extension supports this, so shutdown may still happen when messaging requests are active.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストを受け付けるエクステンションは、個別にサポートを追加する必要があります。現時点では HTTP エクステンションだけがこれをサポートしているので、メッセージングリクエストがアクティブなときにシャットダウンが発生する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive SQL Clients have a straightforward API focusing on scalability and low-overhead.  Currently, the following database servers are supported:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive SQL クライアントは、スケーラビリティと低オーバーヘッドに焦点を当てたシンプルな API を持っています。現在、以下のデータベースサーバーがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB/MySQL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MariaDB/MySQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, you will learn how to implement a simple CRUD application exposing data stored in *PostgreSQL* over a RESTful API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 *PostgreSQL* に格納されたデータをRESTful APIで公開するシンプルなCRUDアプリケーションの実装方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension and connection pool class names for each client can be found at the bottom of this document.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各クライアントのエクステンションと接続プールのクラス名は、このドキュメントの下部に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with the Quarkus Vert.x extension, consider reading the link:vertx[Using Eclipse Vert.x] guide first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Vert.xエクステンションに慣れていない場合は、まず link:vertx[Using Eclipse Vert.x] ガイドを読むことを検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application shall manage fruit entities:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは、フルーツのエンティティを管理するものとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class Fruit {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class Fruit {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Fruit() {
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    public Fruit() {
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do you need a ready-to-use PostgreSQL server to try out the examples?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルを試すためにすぐに使えるPostgreSQLサーバーが必要ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, make sure your project has the `quarkus-reactive-pg-client` extension enabled.  If you are creating a new project, set the `extensions` parameter as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、プロジェクトで `quarkus-reactive-pg-client` のエクステンションが有効になっていることを確認します。新しいプロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have an already created project, the `reactive-pg-client` extension can be added to an existing Quarkus project with the `add-extension` command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでに作成済みのプロジェクトがある場合は、`add-extension` コマンドで既存のQuarkusプロジェクトに `reactive-pg-client` エクステンションを追加することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive REST endpoints in your application that return Uni or Multi need `Mutiny support for RESTEasy` extension (`io.quarkus:quarkus-resteasy-mutiny`) to work properly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション内で Uni または Multi を返す Reactive REST エンドポイントが正しく動作するには `Mutiny support for RESTEasy` エクステンション ( `io.quarkus:quarkus-resteasy-mutiny` ) が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will use the Mutiny API of the Reactive PostgreSQL Client.  If you're not familiar with Mutiny reactive types, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Reactive PostgreSQLクライアントのMutiny APIを使用します。Mutinyのリアクティブ型に慣れていない場合は、まず link:getting-started-reactive#mutiny[Getting Started with Reactiveガイド] を読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will expose `Fruit` instances over HTTP in the JSON format.  Consequently, you also need to add the `quarkus-resteasy-jackson` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON 形式で HTTP 経由で `Fruit` インスタンスを公開します。そのため、 `quarkus-resteasy-jackson` のエクステンションも追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer not to use the command line, manually add this to the dependencies section of your `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドラインを使いたくない場合は、 `pom.xml` ファイルの依存関係セクションに以下を手動で追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, this is only a requirement for this guide, not any application using the Reactive PostgreSQL Client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もちろん、これはこのガイドの要件に過ぎず、Reactive PostgreSQLクライアントを使用したアプリケーションではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive PostgreSQL Client can be configured with standard Quarkus datasource properties and a reactive URL:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive PostgreSQLクライアントは、Quarkusの標準的なデータソースプロパティーとReactive URLを使用して設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>src/main/resources/application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/resources/application.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With that you may create your `FruitResource` skeleton and `@Inject` a `io.vertx.mutiny.pgclient.PgPool` instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで `FruitResource` スケルトンと `@Inject` `io.vertx.mutiny.pgclient.PgPool` インスタンスを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>src/main/java/org/acme/vertx/FruitResource.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/java/org/acme/vertx/FruitResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Database schema and seed data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベーススキーマとシードデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before we implement the REST endpoint and data management code, we need to setup the database schema.  It would also be convenient to have some data inserted upfront.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTエンドポイントとデータ管理コードを実装する前に、データベーススキーマを設定する必要があります。また、いくつかのデータを前もって挿入しておくと便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For production we would recommend to use something like the link:flyway[Flyway database migration tool].  But for development we can simply drop and create the tables on startup, and then insert a few fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番環境では、 link:flyway[Flywayデータベースマイグレーションツール] のようなものを使用することをお勧めします。しかし、開発のためには、単に起動時にテーブルをドロップして作成し、いくつかのフルーツを挿入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and send the response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスを構築して送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive SQL clients support defining several datasources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive SQL クライアントは、複数のデータソースの定義をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A typical configuration with several datasources would look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のデータソースを使用した典型的な構成は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:funqy-http[Funqy HTTP] on Azure Functions.  This allows you to invoke on multiple Funqy functions using HTTP deployed as one Azure Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Functions 上で link:funqy-http[Funqy HTTP] を使用することができます。これにより、1つの Azure Functions としてデプロイされた複数の Funqy function をHTTPを使用して呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + Azure Functions binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable cross a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Route link:azure-functions-http[support] instead.  They also work with Quarkus and Azure Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy HTTP + Azure FunctionsバインディングはHTTP上のRESTの代わりではありません。Funqyは多くの異なるプロトコルや関数プロバイダを横断してポータブルである必要があるため、HTTPバインディングは非常にミニマムであり、リンクのようなREST機能やキャッシュコントロールや条件付きGETのようなHTTP機能を活用する機能を失うことになります。代わりに、QuarkusのJAX-RS、Spring MVC、またはVert.x Web Reactive Routeの link:azure-functions-http[サポート] を使用することを検討するとよいでしょう。また、QuarkusやAzure Functionsとも連携しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the link:azure-functions-http[Azure Functions Http Guide].  It walks through using a variety of HTTP frameworks on Azure Functions.  Including Funqy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:azure-functions-http[Azure Functions Http Guide] に従ってください。これは、Azure Functions上で、Funqyを含む様々なHTTPフレームワークを使用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can connect to a Redis server using the Redis Client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがRedisクライアントエクステンションを使用してRedisサーバーに接続する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Redis server, or Docker Compose to start one</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行中のRedisサーバー、または1つ起動するためのDocker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードで動作させたい場合は、GraalVMがインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.  Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:https://redis.io/commands/incrby[`INCRBY`] コマンドを使用して、数値をインクリメントするシンプルな Rest API を公開します。また、 `GET` 、 `SET` 、 `DEL` 、 、 `KEYS` のような他の Redis コマンドの使い方も見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll be using the Quarkus Redis Client extension to connect to our Redis Server. The extension is implemented on top of the https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client], providing an asynchronous and non-blocking way to connect to Redis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回は、Quarkus Redis Clientエクステンションを使用して、Redisサーバーに接続します。このエクステンションは link:https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client] の上に実装されており、非同期かつノンブロッキングでRedisに接続する方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Redis extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RedisエクステンションをインポートしてMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `redis-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `redis-client` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need to start a Redis instance (if you do not have one already) using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、以下のコマンドを使用してRedisインスタンスを起動する必要があります(すでにインスタンスを持っていない場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have the Redis server running, we need to configure the Redis connection properties.  This is done in the `application.properties` configuration file. Edit it to the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis サーバーを起動したら、Redis 接続のプロパティーを設定する必要があります。これは `application.properties` の設定ファイルで行います。以下の内容に編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接続先のRedisホストを設定します。ここでは、前のセクションで開始したRedisサーバーに接続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment POJO</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インクリメントPOJOの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Increment` POJO を使用してインクリメントをモデル化します。 `src/main/java/org/acme/redis/Increment.java` ファイルを作成し、以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インクリメントサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.  With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis クライアントの役割を果たす `IncrementService` クラスを作成します。このクラスで、 `SET` 、 `GET` 、 `DELET` 、 `KEYS` 、 `INCRBY` Redis コマンドを実行できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/java/org/acme/redis/IncrementService.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インクリメントリソースの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/java/org/acme/redis/IncrementResource.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modifying the test class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストクラスの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `src/test/java/org/acme/redis/IncrementResourceTest.java` file to the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/test/java/org/acme/redis/IncrementResourceTest.java` ファイルを以下の内容に編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get it running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>稼動させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指示に従えば、Redisサーバーが起動しているはずです。あとは、アプリケーションを使って実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルを開いて `curl http://localhost:8080/increments` コマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションとの相互作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.  In this section we are going to see how to initialise an increment, see the list of current increments, incrementing a value given its key, retrieving the current value of an increment, and finally deleting a key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上で見たように、APIは5つのRestエンドポイントを公開しています。このセクションでは、インクリメントを初期化する方法、現在のインクリメントのリストを見る方法、キーを指定して値をインクリメントする方法、インクリメントの現在の値を取得する方法、そして最後にキーを削除する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new increment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいインクリメントの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create the first increment, with the key `first` and an initial value of `10`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のインクリメントを作成し、キーは `first` 、初期値は `10` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the above command should return the result below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のコマンドを実行すると、以下のような結果が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See current increments keys</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のインクリメントキーの確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the list of current increments keys, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のインクリメントキーのリストを表示するには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command should return `["first"]` indicating that we have only one increment thus far.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のコマンドは `["first"]` を返し、これまでのところインクリメントが 1 つしかないことを示しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve a new increment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいインクリメントの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To retrieve an increment using its key, we will have to run the below command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーを使ってインクリメントを取得するには、以下のコマンドを実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running this command, should return the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドを実行すると、以下のような結果が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment a value given its key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーが与えられた値をインクリメントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To increment a value, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値をインクリメントするには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment the `first` value by 27.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`first` の値を 27 増やします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments/first` should return the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、コマンドを実行すると `curl http://localhost:8080/increments/first` は次のような結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see that the value of the `first` key is now `37` which is exactly the result of `10 + 27`, quick maths.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`first` キーの値が `37` になっていることがわかりますが、これはまさに簡単な計算である `10 + 27` の結果と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deleting a key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーの削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the command below, to delete an increment given its key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インクリメントのキーを指定して削除するには、以下のコマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`first` のインクリメントを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、コマンドを実行すると `curl http://localhost:8080/increments` は空のリスト `[]` を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application as a conventional jar file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>従来の jar ファイルとしてアプリケーションを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we will need to package it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、パッケージ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will start a Redis instance to execute the tests. Thus your Redis containers need to be stopped.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドはテストを実行するためにRedisインスタンスを起動します。そのため、Redis コンテナーを停止する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create a native executable from this application without making any source code changes. A native executable removes the dependency on the JVM: everything needed to run the application on the target platform is included in the executable, allowing the application to run with minimal resource overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースコードを変更することなく、このアプリケーションからネイティブ実行ファイルを作成することもできます。ネイティブ実行ファイルは、JVMへの依存を取り除きます。ターゲットプラットフォーム上でアプリケーションを実行するために必要なすべてのものが実行ファイルに含まれているため、アプリケーションを最小限のリソースオーバーヘッドで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling a native executable takes a bit longer, as GraalVM performs additional steps to remove unnecessary codepaths. Use the `native` profile to compile a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMは、不要なコードパスを削除するために追加のステップを実行するため、ネイティブ実行ファイルのコンパイルには少し時間がかかります。 `native` プロファイルを使用して、ネイティブ実行ファイルをコンパイルしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the build is finished, you can run the executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドが完了したら、実行ファイルを次のように実行することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connection Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接続のヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-vertx-redis` will automatically add a readiness health check to validate the connection to the Redis server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、 `quarkus-vertx-redis` は、Redis サーバーへの接続を検証するためのreadiness ヘルスチェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、アプリケーションの `/q/health/ready` エンドポイントにアクセスすると、接続の検証状況に関する情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.redis.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、 `application.properties` の `quarkus.redis.health.enabled` プロパティーを `false` に設定することで無効にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のRedisクライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis extension allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis エクステンションを使用すると、複数のクライアントを設定することができます。複数のクライアントを使用しても、単一のクライアントを持つのと同じように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `second` segment).  The syntax is as follows: `quarkus.redis.[optional name.][redis configuration property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キー ( `second` セグメント) に余分なビットがあることに注意してください。構文は次の通りです: `quarkus.redis.[optional name.][redis configuration property]` .名前を省略した場合、デフォルトのクライアントを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Redis client Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前付きRedisクライアントのインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, you can select the client to inject using the `io.quarkus.redis.client.RedisClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のクライアントを使用する場合は、 `io.quarkus.redis.client.RedisClientName` の修飾子を使用して注入するクライアントを選択することができます。上記のプロパティーを使って3つの異なるクライアントを設定すると、以下のようにそれぞれにインジェクションすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the Quarkus Dev UI for link:building-my-first-extension[extension authors].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:building-my-first-extension[エクステンションの作者] のためにQuarkus Dev UIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now ships with a new experimental Dev UI, which is available in dev mode (when you start quarkus with `mvn quarkus:dev`) at http://localhost:8080/q/dev[/q/dev] by default. It will show you something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは現在、新しく実験的なDev UIを搭載しています。このUIは、 devモード( `mvn quarkus:dev` でquarkusを起動)でデフォルトで利用可能で、link:http://localhost:8080/q/dev[/q/dev] に存在し、以下のようなものが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It allows you to quickly visualize all the extensions currently loaded, see their status and go directly to their documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、現在ロードされているすべてのエクステンションを素早く可視化し、そのステータスを確認し、ドキュメントに直接アクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of that, each extension can add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その上で、各エクステンションは以下を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;how-can-i-make-my-extension-support-the-dev-ui,Custom useful bits of runtime information in the overview&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#how-can-i-make-my-extension-support-the-dev-ui[カスタムのランタイム情報の概要]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;adding-full-pages,Full custom pages&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#adding-full-pages[フルカスタムページ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;advanced-usage-adding-actions,Interactive pages with actions&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#advanced-usage-adding-actions[アクション付きのインタラクティブページ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I make my extension support the Dev UI?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをDev UIに対応させるにはどうすればいいですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to make your extension listed in the Dev UI you don't need to do anything!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをDev UIに表示させるためには、何もする必要はありません!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So you can always start with that :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>だから、いつでもそれから始めることができます :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:dev-ui-embedded.png[alt=Dev UI embedded,role="center"]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:dev-ui-embedded.png[alt=Dev UI embedded,role="center"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to add a file named `dev-templates/embedded.html` in your link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] extension module's resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] エクステンションのリソースに `dev-templates/embedded.html` というファイルを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The contents of this file will be included in your extension card, so for example we can place two links with some styling and icons:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このファイルの内容が、エクステンションカードに含まれますので、例えば、次のようにいくつかのスタイリングとアイコンと共に2つのリンクを配置することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the Font Awesome Free icon set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Font Awesome Freeアイコンセットを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Paths are tricky business. Keep the following in mind:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パスというのは厄介なものです。以下の点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template and styling support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートとスタイリングのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both the `embedded.html` files and any full page you add in `/dev-templates` will be interpreted by link:qute[the Qute template engine].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`embedded.html` ファイルと `/dev-templates` に追加したフルページの両方共、 link:qute[Qute テンプレートエンジン] によって処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also means that you can link:qute-reference#user_tags[add custom Qute tags] in `/dev-templates/tags` for your templates to use.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはテンプレートを使用できるようにする為に、 `/dev-templates/tags` に link:qute-reference#user_tags[カスタム Qute タグを追加] 出来ることも意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The style system currently in use is https://getbootstrap.com/docs/4.6/getting-started/introduction/[Bootstrap V4 (4.6.0)] but note that this might change in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在使用されているスタイルシステムは link:https://getbootstrap.com/docs/4.6/getting-started/introduction/[Bootstrap V4(4.6.0)] ですが、将来的に変更される可能性があるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main template also includes https://jquery.com/[jQuery 3.5.1], but here again this might change.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メインテンプレートには link:https://jquery.com/[jQuery 3.5.1] も含まれていますが、こちらも変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing Config Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定プロパティーへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `config:property(name)` expression can be used to output the config value for the given property name.  The property name can be either a string literal or obtained dynamically by another expression.  For example `{config:property('quarkus.lambda.handler')}` and `{config:property(foo.propertyName)}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`config:property(name)` 式を使用して、指定されたプロパティー名の設定値を出力することができます。プロパティー名は、文字列リテラルか、別の式で動的に取得することができます。例えば `{config:property('quarkus.lambda.handler')}` や `{config:property(foo.propertyName)}` が可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding full pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フルページの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add full pages for your Dev UI extension such as this one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のようなDev UIエクステンションにフルページを追加するには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to place them in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] module's `/dev-templates` resource folder, like this page for the link:cache[`quarkus-cache` extension]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それらをlink:cache[`quarkus-cache`] エクステンションのこのページのように、
エクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] モジュールの `/dev-templates` リソースフォルダーに配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to benefit from the same style as other Dev UI pages, extend the `main` template</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他の Dev UI ページと同じスタイルを利用するには、 `main` テンプレートを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can pass extra CSS for your page in the `style` template parameter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`style` テンプレートパラメーターで、ページに追加の CSS を渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to set your page title in the `title` template parameter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`title` テンプレートパラメーターにページタイトルを設定することを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `body` template parameter will contain your content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`body` テンプレートパラメーターには、コンテンツが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order for your template to read custom information from your Quarkus extension, you can use the `info` link:qute-reference#namespace_extension_methods[namespace].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートがQuarkusエクステンションからカスタム情報を読み取るためには、 `info` link:qute-reference#namespace_extension_methods[名前空間] を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows an &lt;&lt;advanced-usage-adding-actions,interactive page&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、 link:#advanced-usage-adding-actions[インタラクティブページ] を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Linking to your full-page templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フルページテンプレートへのリンク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing information to your templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートに情報を渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In `embedded.html` or in full-page templates, you will likely want to display information that is available from your extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`embedded.html` やフルページのテンプレートでは、エクステンションから得られる情報を表示したい場合が多いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to make that information available, depending on whether it is available at build time or at run time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その情報を利用可能にするには、ビルド時に利用可能か、実行時に利用可能かによって、2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both cases we advise that you add support for the Dev UI in your `{pkg}.deployment.devconsole` package in a `DevConsoleProcessor` class (in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] module).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらの場合も、 `{pkg}.deployment.devconsole` パッケージの `DevConsoleProcessor` クラス (エクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] モジュール)でDev UIのサポートを追加することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing run-time information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時情報を渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to make this link:building-my-first-extension#deploying-the-greeting-feature[build step] conditional on being in dev mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この link:building-my-first-extension#deploying-the-greeting-feature[ビルドステップ]は 、開発者モードであることを条件にすることを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a run-time dev `info:cacheInfos` template value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時 dev `info:cacheInfos` テンプレート値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will map the `info:cacheInfos` value to this supplier in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `info:cacheInfos` の値がエクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`] にマップされます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing build-time information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時情報を渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you only need build-time information to be passed to your template, so you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時の情報だけをテンプレートに渡す必要がある場合もあります。その場合、このようにすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use whatever dependencies you need as input</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要な依存関係を入力として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a build-time `info:devQuteInfos` DEV template value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時 `info:devQuteInfos` DEVテンプレート値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced usage: adding actions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高度な使用法:アクションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also add actions to your Dev UI templates:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev UI テンプレートにアクションを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done by adding another link:building-my-first-extension#deploying-the-greeting-feature[build step] to declare the action in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] module:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、別の link:building-my-first-extension#deploying-the-greeting-feature[ビルドステップ] を追加してエクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] モジュールでアクションを宣言することで実現可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark the recorder as optional, so it will only be invoked when in dev mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコーダーをオプションとしてマークし、開発モードの時にのみ起動されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a `POST {urlbase}/caches` route handled by the given handler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与えられたハンドラーによって処理される `POST {urlbase}/caches` ルートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: you can see &lt;&lt;action-example,how to invoke this action from your full page&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>NOTE: link:#action-example[アクションを呼び出す方法は、ページ全体から見る] ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now all you have to do is implement the recorder in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あとは、エクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`] でrecorderを実装するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you can use https://vertx.io/docs/vertx-web/java/#_routing_by_http_method[any Vert.x handler], the `DevConsolePostHandler` superclass will handle your POST actions nicely, and auto-redirect to the `GET` URI right after your `POST` for optimal behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-web/java/#_routing_by_http_method[どのVert.x ハンドラーでも] 使用することができますが、 `DevConsolePostHandler` スーパークラスは POST アクションをうまく処理し、最適な動作を実現するために `POST` の直後に `GET` URI に自動リダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the Vert.x `RoutingContext` as well as the `form` contents</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x `RoutingContext` の他、 `form` のコンテンツも入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to add a message for the user to let them know everything went fine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてがうまくいったことを知らせるために、ユーザーにメッセージを追加することを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also add error messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エラーメッセージを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flash messages are handled by the `main` DEV template and will result in nice notifications for your users:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フラッシュメッセージは `main` DEV テンプレートで処理され、ユーザーへの素敵な通知になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがOAuth2トークンを利用して、JAX-RSエンドポイントへのセキュアなアクセスを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth2 is an authorization framework that enables applications to obtain access to an HTTP resource on behalf of a user.  It can be used to implement an application authentication mechanism based on tokens by delegating to an external server (the authentication server) the user authentication and providing a token for the authentication context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2は、アプリケーションがユーザーに代わってHTTPリソースへのアクセスを取得することを可能にする認可フレームワークです。ユーザー認証を外部サーバー(認証サーバー)に委譲し、認証コンテキストにトークンを提供することで、トークンに基づくアプリケーション認証の仕組みを実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension provides a light-weight support for using the opaque Bearer Tokens and validating them by calling an introspection endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、不透明なベアラートークンを使用してイントロスペクションエンドポイントを呼び出して検証するための軽量なサポートを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the OAuth2 Authentication server provides JWT Bearer Tokens then you should consider using either link:security-openid-connect[OpenId Connect] or link:security-jwt[SmallRye JWT] extensions instead.  OpenId Connect extension has to be used if the Quarkus application needs to authenticate the users using OIDC Authorization Code Flow, please read link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Applications] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2認証サーバーがJWT Bearer Tokensを提供している場合は、 link:security-openid-connect[OpenId Connect] または link:security-jwt[MicroProfile JWT RBAC] エクステンションの使用を検討する必要があります。OpenId Connectエクステンションは、QuarkusアプリケーションがOIDC Authorization Code Flowを使用してユーザーを認証する必要がある場合に使用する必要があります。詳しくは link:security-openid-connect-web-authentication[OpenID Connectを利用したウェブアプリケーションの保護]ガイドをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: git clone https://github.com/quarkusio/quarkus-quickstarts.git, or download an archive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Git リポジトリのクローン: git clone https://github.com/quarkusio/quarkus-quickstarts.git 、またはアーカイブをダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-oauth2-quickstart` {quickstarts-tree-url}/security-oauth2-quickstart[directory].  It contains a very simple UI to use the JAX-RS resources created here, too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-oauth2-quickstart` {quickstarts-tree-url}/security-oauth2-quickstart[ディレクトリ] にあります。ここで作成したJAX-RSリソースを利用するための非常にシンプルなUIも含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `elytron-security-oauth2` extension, which includes the OAuth2 opaque token support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、OAuth2不透明トークンのサポートを含む `elytron-security-oauth2` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to use the Maven plugin, you can just include the dependency in your pom.xml:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mavenプラグインを使用したくない場合は、pom.xmlに依存関係を含めるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/security/oauth2/TokenSecuredResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/java/org/acme/security/oauth2/TokenSecuredResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a basic REST endpoint that does not have any of the {extension-name} specific features, so let's add some.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは{extension-name}特有の機能を持たない基本的なRESTエンドポイントなので、いくつか追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will use the JSR 250 common security annotations, they are described in the link:security[Using Security] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSR 250の共通セキュリティーアノテーションを使用します。 link:security[Securityの使用] ガイドで説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@PermitAll` indicates that the given endpoint is accessible by any caller, authenticated or not.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@PermitAll` は、認証されているかどうかに関わらず、どのような呼出元からでもアクセス可能であることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we inject the JAX-RS `SecurityContext` to inspect the security state of the call.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、JAX-RS `SecurityContext` を注入して、呼出のセキュリティー状態を検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we obtain the current request user/caller `Principal`. For an unsecured call this will be null, so we build the user name by checking `caller` against null.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、現在のリクエストの ユーザー/呼出元 `Principal` を取得します。セキュリティー保護されていない呼出の場合、これはnullになりますので、 `caller` をnullかチェックしてユーザー名を構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reply we build up makes use of the caller name, the `isSecure()` and `getAuthenticationScheme()` states of the request `SecurityContext`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちが構築した応答では 呼出元の名前、リクエストの `SecurityContext` の `isSecure()` と `getAuthenticationScheme()` の状態を利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.propertiesの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to configure your application with the following minimal properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の最小限のプロパティーでアプリケーションを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to specify the introspection URL of your authentication server and the `client-id` / `client-secret` that your application will use to authenticate itself to the authentication server. + The extension will then use this information to validate the token and recover the information associate with it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証サーバーのイントロスペクション URL と、アプリケーションが認証サーバーへの認証に使用する `client-id` / `client-secret` を指定する必要があります。+ エクステンションはこの情報を使ってトークンを検証し、関連する情報を復元します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For all configuration properties, see the link:#config-reference[Configuration reference] section at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての設定プロパティーについては、このガイドの最後にある link:#config-reference[設定リファレンス] のセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. Use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、アプリケーションを実行する準備が整いました。次を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the REST endpoint is running, we can access it using a command line tool like curl:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使ってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have not provided any token in our request, so we would not expect that there is any security state seen by the endpoint, and the response is consistent with that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストにトークンを提供していないので、エンドポイントが見ているセキュリティー状態があるとは期待できず、レスポンスもそれと一致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>user name is anonymous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー名は anonymous (匿名) です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`isSecure` is false as https is not used</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`isSecure` は https が使用されていないため false です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`authScheme` is null</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`authScheme` はnullです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Securing the endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントのセキュア化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So now let's actually secure something. Take a look at the new endpoint method `helloRolesAllowed` in the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では実際に何かをセキュア化してみましょう。下記の新しいエンドポイントメソッド `helloRolesAllowed` を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This new endpoint will be located at `/secured/roles-allowed`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この新しいエンドポイントは `/secured/roles-allowed` に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@RolesAllowed` indicates that the given endpoint is accessible by a caller if they have either a "Echoer" or "Subscriber" role assigned.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RolesAllowed` は、呼出側に "Echoer" または "Subscriber" ロールが割り当てられている場合、指定されたエンドポイントにアクセスできることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you make this addition to your `TokenSecuredResource`, try `curl -v http://127.0.0.1:8080/secured/roles-allowed; echo` to attempt to access the new endpoint. Your output should be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたの `TokenSecuredResource` に追加した後、 `curl -v http://127.0.0.1:8080/secured/roles-allowed; echo` を試行し、新しいエンドポイントへのアクセスを試みて下さい。出力は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excellent, we have not provided any OAuth2 token in the request, so we should not be able to access the endpoint, and we were not. Instead we received an HTTP 401 Unauthorized error. We need to obtain and pass in a valid OAuth2 token to access that endpoint. There are two steps to this, 1) configuring our {extension-name} extension with information on how to validate the token, and 2) generating a matching token with the appropriate claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>素晴らしい、リクエストにOAuth2トークンを提供していないので、エンドポイントにアクセスできないはずであり、アクセス出来ませんでした。代わりにHTTP 401 Unauthorizedエラーを受け取りました。エンドポイントにアクセスするためには、有効な OAuth2 トークンを取得して渡す必要があります。これには 2 つのステップがあります。1) {extension-name} エクステンションにトークンの検証方法に関する情報を設定すること、そして 2) 適切なクレームを持つ適合するトークンを生成することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating a token</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to obtain the token from a standard OAuth2 authentication server (https://www.keycloak.org/[Keycloak] for example) using the token endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンエンドポイントを使用して、標準的なOAuth2認証サーバー link:https://www.keycloak.org/[(Keycloak] など)からトークンを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find below a curl example of such call for a `client_credential` flow:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたは、 `client_credential` フローのためのそのような呼び出しのcurlの例を以下に見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should respond something like that...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは以下のような反応をする筈です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, make a secured request to /secured/roles-allowed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、/secured/roles-allowed へのセキュアなリクエストを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's use this to make a secured request to the `/secured/roles-allowed` endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを使って `/secured/roles-allowed` エンドポイントに安全なリクエストをしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Success! We now have:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>成功! これで、以下が得られます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an authentication scheme of OAuth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2 の認証方式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roles mapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロールマッピング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roles are mapped from one of the claims of the introspection endpoint response. By default, it's the `scope` claim. Roles are obtained by splitting the claim with a space separator. If the claim is an array, no splitting is done, the roles are obtained from the array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロールは、イントロスペクションのエンドポイントレスポンスのクレームの1つからマッピングされます。デフォルトでは、 `scope` クレームです。ロールはクレームをスペース区切りで分割することで得られます。クレームが配列の場合、分割は行われず、ロールは配列から取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can customize the name of the claim to use for the roles with the `quarkus.oauth2.role-claim` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.oauth2.role-claim` プロパティーを使用して、ロールに使用するクレームの名前をカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、 `./mvnw clean package` を使ってパッケージ化し、 `target/quarkus-app/quarkus-run.jar` ファイルを使ってアプリケーションを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also generate the native executable with `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw clean package -Pnative` でネイティブの実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to use a real OAuth2 authorization server for your integration tests, you can use the link:security-properties[Properties based security] extension for your test, or mock an authorization server using Wiremock.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合テストに本物の OAuth2 認証サーバーを使用したくない場合は、 link:security-properties[Properties ベースのセキュリティー] エクステンションをテストに使用するか、Wiremock を使用して認証サーバーをモックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an implementation of `QuarkusTestResourceLifecycleManager` called `MockAuthorizationServerTestResource` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このように `QuarkusTestResourceLifecycleManager` の実装である `MockAuthorizationServerTestResource` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Wiremock to stub the calls to `/introspect` by returning an OAuth2 introspect response. You need to customize this line to return what's needed for your application (at least the scope property as roles are derived from the scope).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2のイントロスペクトレスポンスを返すことで、 `/introspect` への呼び出しをスタブ化するように Wiremock を設定します。この行をカスタマイズして、アプリケーションに必要なものを返すようにする必要があります (ロールはスコープから派生しているので、少なくともスコープのプロパティーを)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the `start` method returns configuration that applies for tests, we set the `quarkus.oauth2.introspection-url` property that controls the URL of the introspect endpoint used by the OAuth2 extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`start` メソッドはテストに適用する設定を返すので、OAuth2 エクステンションで使用する introspect エンドポイントの URL を制御する `quarkus.oauth2.introspection-url` プロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your test class needs to be annotated like with `@QuarkusTestResource(MockAuthorizationServerTestResource.class)` to use this `QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この `QuarkusTestResourceLifecycleManager` を使用するためには、テストクラスに `@QuarkusTestResource(MockAuthorizationServerTestResource.class)` のようなアノテーションを付ける必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is an example of a test that uses the `MockAuthorizationServerTestResource`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、 `MockAuthorizationServerTestResource` を使用したテストの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the previously created `MockAuthorizationServerTestResource` as a Quarkus test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以前に作成した `MockAuthorizationServerTestResource` をQuarkusのテストリソースとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define whatever token you want, it will not be validated by the OAuth2 mock authorization server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任意のトークンを定義してください。OAuth2のモック認可サーバーでは検証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this token inside the `Authorization` header to trigger OAuth2 authentication.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このトークンを `Authorization` ヘッダ内で使用して、OAuth2 認証を開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusTestResource` applies to all tests, not just `TokenSecuredResourceTest`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTestResource` は `TokenSecuredResourceTest` だけでなく、すべてのテストに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tools.ietf.org/html/rfc6749[OAuth2]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://tools.ietf.org/html/rfc6749[OAuth2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-google-cloud-functions` extension allows you to use Quarkus to build your Google Cloud Functions.  Your functions can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-google-cloud-functions` エクステンションを使用すると、Quarkusを使用してGoogle Cloud Functionsを構築することができます。関数では、CDIやSpringからのインジェクションアノテーションや、必要に応じて他のQuarkusの機能を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating a sample project followed by creating multiple functions showing how to implement `HttpFunction`, `BackgroundFunction` and `RawBackgroundFunction` in Quarkus.  Once built, you will be able to deploy the project to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、サンプルプロジェクトを生成し、Quarkusで `HttpFunction` 、 `BackgroundFunction` 、 `RawBackgroundFunction` を実装する方法を説明します。ビルド後は、プロジェクトをGoogle Cloudにデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `google-cloud-functions-quickstart` {quickstarts-tree-url}/google-cloud-functions-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでのソリューションは `google-cloud-functions-quickstart` {quickstarts-tree-url}/google-cloud-functions-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an application with the `quarkus-google-cloud-functions` extension.  You can use the following Maven command to create it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-google-cloud-functions` のエクステンションを持つアプリケーションを作成します。以下のMavenコマンドを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's remove what's not needed inside the generated application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、生成されたアプリケーションから不要なものを削除します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the dependency `io.quarkus:quarkus-resteasy` from your `pom.xml` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-resteasy` を、`pom.xml` の依存関係から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the generated `org.acme.quickstart.GreetingResource` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `org.acme.quickstart.GreetingResource` クラスを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the `index.html` from `resources/META-INF/resources` or it will be picked up instead of your Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`resources/META-INF/resources` から `index.html` を削除します。このファイルを削除しない場合Cloud Functions の関数として扱われてしまいます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the existing tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のテストを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud Functions の関数を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this example project, we will create three functions, one `HttpFunction`, one `BackgroundFunction` (Storage event) and one `RawBackgroundFunction` (PubSub event).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロジェクトの例では、 `HttpFunction` 、 `BackgroundFunction` (ストレージイベント)、 `RawBackgroundFunction` (PubSubイベント)の3つの関数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choose Your Function</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>functionの選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-google-cloud-functions` extension scans your project for a class that directly implements the Google Cloud `HttpFunction`, `BackgroundFunction` or `RawBackgroundFunction` interface.  It must find a class in your project that implements one of these interfaces or it will throw a build time failure.  If it finds more than one function classes, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-google-cloud-functions` エクステンションは、プロジェクト内からGoogle Cloud `HttpFunction` 、 `BackgroundFunction` 、または `RawBackgroundFunction` インターフェイスを直接実装しているクラスをプロジェクト内でスキャンします。これらのインターフェイスを実装しているクラスがプロジェクト内で見つからない場合やインターフェイスを実装しているクラスが複数見つかった場合は、ビルド時に例外がスローされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related functions that share code and creating multiple maven modules is just an overhead you don't want to do.  The extension allows you to bundle multiple functions in one project and use configuration or an environment variable to pick the function you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、同じコードを利用するCloud Functionの関数クラスが複数あるような場合に、個別maven モジュールを作成することは手間となります。このQuarkusエクステンションを使うと、複数のCloud Function関数を一つのプロジェクトにバンドルし、設定や環境変数を使ってデプロイしたい関数を選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the name of the function, you can use the following configuration property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud Functions の関数に名前を設定するには、以下の設定プロパティーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.google-cloud-functions.function` property tells Quarkus which function to deploy. This can be overridden with an environment variable too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.google-cloud-functions.function` プロパティーは、デプロイする関数をQuarkusに伝えます。これは環境変数でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the function class must match the value specified within the `quarkus.google-cloud-functions.function` property.  This must be done using the `@Named` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud Functions の関数となるクラスの CDI 名は、 `quarkus.google-cloud-functions.function` プロパティー内で指定された値と一致している必要があります。これは `@Named` アノテーションを使用して行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Named` annotation allows to name the CDI bean to be used by the `quarkus.google-cloud-functions.function` property, this is optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Named` アノテーションでは、 `quarkus.google-cloud-functions.function` プロパティーで使用する CDI Beanに名前を付けることができますが、これはオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function must be a CDI bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数はCDI Beanでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a regular Google Cloud Function implementation, so it needs to implement `com.google.cloud.functions.HttpFunction`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functionで実行するためには、実行する対象のクラスは`com.google.cloud.functions.HttpFunction`インターフェースをImplementsする必要があります .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection works inside your function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションはCloud Function関数クラスの中で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is standard Google Cloud Function implementation, nothing fancy here.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは標準的な Google Cloud Function の実装であり、ここでは何も派手なことはしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `BackgroundFunction` is triggered by a Storage event, you can use any events supported by Google Cloud instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この `BackgroundFunction` はストレージイベントによってトリガーされる以外にも、Google Cloud でサポートされているトリガーイベントを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a regular Google Cloud Function implementation, so it needs to implement `com.google.cloud.functions.BackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functionで実行するためには、実行する対象のクラスは `com.google.cloud.functions.BackgroundFunction` インターフェースをImplementsする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the class the event will be deserialized to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはトリガーのイベントデータがデシリアライズされるクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `RawBackgroundFunction` is triggered by a PubSub event, you can use any events supported by Google Cloud instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この `RawBackgroundFunction` は PubSub イベントでトリガーされる以外にも、Google Cloud でサポートされているトリガーイベントを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a regular Google Cloud Function implementation, so it needs to implement `com.google.cloud.functions.RawBackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functionで実行するためには、実行する対象のクラスは  `com.google.cloud.functions.RawBackgroundFunction` インターフェースをImplementsする必要があります。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build your application, you can package it using the standard `mvn clean package` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをビルドするには、標準の `mvn clean package` コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result of the previous command is a single JAR file inside the `target/deployment` repository that contains classes and dependencies of the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のコマンドの結果、 `target/deployment` リポジトリ内に単一の JAR ファイルが生成されます。このJARファイルにはプロジェクト内のクラスと、依存関係のクラスが含まれています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example command to deploy your `HttpFunction` to Google Cloud:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `HttpFunction` を Google Cloud にデプロイするためのコマンドの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry point must always be set to `io.quarkus.gcp.functions.QuarkusHttpFunction` as this is the class that integrates Cloud Functions with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エントリーポイントは常に `io.quarkus.gcp.functions.QuarkusHttpFunction` に設定する必要があります。このクラスはQuarkusとCloud Functionsを統合するクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before deploying your function, you need to create a bucket.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数をデプロイする前に、バケットを作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gsutil mb gs://quarkus-hello
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gsutil mb gs://quarkus-hello
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example command to deploy your `BackgroundFunction` to Google Cloud, as the function is triggered by a Storage event, it needs to use `--trigger-event google.storage.object.finalize` and the `--trigger-resource` parameter with the name of a previously created bucket:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `BackgroundFunction` を Google Cloud にデプロイするためのコマンドの例です。この関数は Storage イベントによってトリガーされるため、 `--trigger-event google.storage.object.finalize` と `--trigger-resource` パラメーターに先の手順で作成したバケットの名前を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry point must always be set to `io.quarkus.gcp.functions.QuarkusBackgroundFunction` as this is the class that integrates Cloud Functions with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エントリーポイントは常に `io.quarkus.gcp.functions.QuarkusBackgroundFunction` に設定する必要があります。このクラスはQuarkusとCloud Functionsを統合するクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger the event, you can send a file to the GCS `quarkus-hello` bucket or you can use gcloud to simulate one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントをトリガーするには、GCS `quarkus-hello` バケットにファイルを送るか、gcloudコマンドを使ってシミュレーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`--data` contains the GCS event, it is a JSON document with the name of the file added to the bucket.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--data` には GCS イベントを指定します。これは、バケットに追加されたファイル名を含む JSON形式のフォーマットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example command to deploy your `RawBackgroundFunction` to Google Cloud, as the function is triggered by a PubSub event, it needs to use `--trigger-event google.pubsub.topic.publish` and the `--trigger-resource` parameter with the name of a previously created topic:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `RawBackgroundFunction` を Google Cloud にデプロイするコマンドの例です。この関数は PubSub イベントによってトリガーされるので、 `--trigger-event google.pubsub.topic.publish` と `--trigger-resource` パラメーターに、先の手順で作成したトピックの名前を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger the event, you can send a file to the `hello_topic` topic or you can use gcloud to simulate one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントをトリガーするには、 `hello_topic` トピックにファイルを送信するか、gcloudコマンドを使用してシミュレーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test an `HttpFunction`, you can use this command to launch your function locally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`HttpFunction` をテストするために、以下のコマンドを使用しローカルで関数を起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For background functions, you launch the invoker with a target class of `io.quarkus.gcp.functions.BackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BackgroundFunction関数の場合は、 `io.quarkus.gcp.functions.BackgroundFunction` のターゲットクラスでinvokerを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can call your background function via an HTTP call with a payload containing the event:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動後、HTTP 呼び出しにイベントを含むペイロードを付与することでバックグラウンド関数を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will call your Storage background function with an event `{"name":"hello.txt"}`, so an event on the `hello.txt` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドにより、イベント `{"name":"hello.txt"}` でBackgroundFunctionを呼び出します。これは、`hello.txt`をCloud Storageに保存した際のイベントをテストするのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will call your PubSub background function with a PubSubMessage `{"greeting":"world"}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、PubSubのBackgroundFunctionを次のPubSubMessageで呼び出します `{"greeting":"world"}` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://flywaydb.org/[Flyway] is a popular database migration tool that is commonly used in JVM environments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://flywaydb.org/[Flyway] は、JVM環境でよく使われているデータベースマイグレーションツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Flyway as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、このガイドで説明するように、Flywayを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start using Flyway with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトで Flyway を使い始めるには、以下のことを行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your migrations to the `{migrations-path}` folder as you usually do with Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway で通常行うように、マイグレーションを `{migrations-path}` フォルダーに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Flyway` object and run your migration as you normally do</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`migrate-at-start` オプションを有効にしてスキーマを自動的に移行するか、 `Flyway` オブジェクトを注入して通常のように移行を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `pom.xml`, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` で、以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Flyway extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway エクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お使いの JDBC ドライバーのエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;!-- JDBC driver dependencies --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;!-- JDBC driver dependencies --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Flyway to manage the schema.  Also, you can customize the Flyway behaviour by using the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway のサポートは、Quarkus のデータソース設定に依存しています。この設定は、デフォルトのデータソースだけでなく、 すべての link:#multiple-datasources[名前の付いたデータソース] に対してカスタマイズすることができます。まず、Flyway によるスキーマ管理を可能にするために、データソース設定を `{config-file}` ファイルに追加する必要があります。また、以下のプロパティーを使用して、Flyway の動作をカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example for the `{config-file}` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{config-file}` ファイルの例は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration to the default folder following the Flyway naming conventions: `{migrations-path}/V1.0.0__Quarkus.sql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{migrations-path}/V1.0.0__Quarkus.sql` のように Flyway の命名規則に従って、デフォルトフォルダーに SQL マイグレーションを追加します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Flyway's migrate method according to your config:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでアプリケーションを起動でき、Quarkus は設定に従って Flyway のマイグレーションメソッドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Flyway object if you want to use it directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway オブジェクトを直接使用する場合はインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway can be configured for multiple datasources.  The Flyway properties are prefixed exactly the same way as the named datasources, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway は、複数のデータソースに対して設定可能です。Flyway のプロパティーには、例えば、名前の付いたデータソースと全く同じように接頭辞が付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:default
quarkus.datasource.jdbc.max-size=13
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:default
quarkus.datasource.jdbc.max-size=13
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:tcp://localhost/mem:users
quarkus.datasource.users.jdbc.max-size=11
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:tcp://localhost/mem:users
quarkus.datasource.users.jdbc.max-size=11
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:tcp://localhost/mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:tcp://localhost/mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.flyway.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーに余分なビットがあることに注意してください。構文は次の通りです。`quarkus.flyway.[optional name.][datasource property]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Flyway is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定なしの場合、Flyway はデフォルト設定を使用して各データソースに対して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Flyway` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Flyway` オブジェクトを直接使いたい場合は、以下のように注入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enabled the `quarkus.flyway.migrate-at-start` property, by the time you use the Flyway instance, Quarkus will already have run the migrate operation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.flyway.migrate-at-start` プロパティーを有効にした場合、Flyway インスタンスを使用する時点で、Quarkus はすでにマイグレーション操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources using the Quarkus `FlywayDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus `FlywayDataSource` 修飾子を使用して、指定されたデータソースに Flyway を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前の付いたデータソースへの Flyway の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.inject.Inject;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document explains how the dev-mode in Quarkus differs from a production application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、Quarkusのdev-modeが本番アプリケーションとどのように異なるかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Intro</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イントロ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a dev-mode (explained in more detail link:maven-tooling.adoc#dev-mode[here] and link:gradle-tooling.adoc#dev-mode[here]) which greatly aids during development but should *NEVER* be used in production.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには開発モード（詳細は link:maven-tooling.adoc#dev-mode[こちら]と link:gradle-tooling.adoc#dev-mode[こちら]）があり、開発に大いに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architectural differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アーキテクチャの差異</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feature sets aside, the Quarkus application that is run under dev-mode differs architecturally from the production application (i.e. the one that is run using `java -jar ...`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>機能セットはさておき、dev-modeで実行されるQuarkusアプリケーションは、プロダクションアプリケーション（すなわち、 `java -jar …​` を使用して実行されるもの）とはアーキテクチャ的に異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev-mode, Quarkus uses a ClassLoader hierarchy (explained in detail link:class-loading-reference.adoc[here]) that enables the live reload of user code without requiring a rebuild and restart of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでは、QuarkusはClassLoader階層（詳細は link:class-loading-reference.adoc[こちら]）を使用し、アプリケーションの再構築や再起動を必要とせずにユーザーコードのライブリロードを可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a production application, the aforementioned class loading infrastructure is entirely absent - there is a single, purpose built ClassLoader that loads (almost) all classes and dependencies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番アプリケーションでは、前述のクラスローディングのインフラは全く存在しません。目的に応じて構築された単一のClassLoaderがあり、（ほぼ）すべてのクラスと依存関係をロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev-mode features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードの機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In keeping with the mantra of providing developer joy, Quarkus provides a host of features when dev-mode is enabled. The most important features are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発者満足を提供するという信条のもと、Quarkusはdev-modeを有効にすると多くの機能を提供します。最も重要な機能は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライブ・リロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mightily important feature needs no introduction and has already been mentioned in the &lt;&lt;architectural-differences, architectural differences&gt;&gt; section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この非常に重要な機能については紹介するまでもなく、 link:#architectural-differences[アーキテクチャの差異]の項ですでに触れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a very useful link:dev-ui.adoc[UI] accessible from the browser at `/q/dev`. This UI allows a developer to see the state of the application, but also provides access to various actions that can change that state (depending on the extensions that are present).  Examples of such operations are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、ブラウザからアクセスできる非常に便利な link:dev-ui.adoc[UI]を提供しています。 `/q/dev` 。このUIにより、開発者はアプリケーションの状態を確認できるだけでなく、（存在するエクステンションに応じて）その状態を変更できる様々な操作にアクセスできます。そのような操作の例は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing configuration values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定値の変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Database migration scripts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベース移行スクリプトの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clearing of caches</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュの消去</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running scheduled operations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジュールされたオペレーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エラーページ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In an effort to make development errors very easy to diagnose, Quarkus provides various detailed error pages when running in dev-mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発エラーの診断を非常に簡単にするために、Quarkusは開発モードでの実行時に様々な詳細なエラーページを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Database import scripts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースインポートスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-hibernate-orm` extension will run the `import.sql` script in `src/main/resources` when Quarkus is running in dev-mode. More details can be found link:hibernate-orm.adoc#dev-mode[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-hibernate-orm` エクステンションは、Quarkusがdev-modeで動作しているときに、 `src/main/resources` の `import.sql` スクリプトを実行します。詳細は link:hibernate-orm.adoc#dev-mode[こちら]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev Services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When testing or running in dev-mode Quarkus can even provide you with a zero config database out of the box, a feature we refer to as DevServices.  More information can be found link:datasource.adoc#dev-services[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、テストや開発モードで実行する際に、ゼロコンフィグのデータベースをすぐに提供することができますが、これはDevServicesと呼ばれる機能です。詳細については link:datasource.adoc#dev-services[こちら]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Swagger UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Swagger UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-smallrye-openapi` extension will expose the Swagger UI when Quarkus is running in dev-mode. Additional information can be found link:openapi-swaggerui.adoc#dev-mode[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-openapi` エクステンションは、Quarkusがdev-modeで動作しているときに、Swagger UIを公開します。追加情報は link:openapi-swaggerui.adoc#dev-mode[こちら]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphQL UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQL UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-smallrye-graphql` extension will expose the GraphiQL UI when Quarkus is running in dev-mode. More details can be found link:smallrye-graphql.adoc#ui[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-graphql` エクステンションは、Quarkusがdev-modeで動作しているときにGraphiQL UIを公開します。詳細は link:smallrye-graphql.adoc#ui[こちら]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Health UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-smallrye-health` extension will expose the Health UI when Quarkus is running in dev-mode. link:smallrye-health.adoc#ui[This] section provides additional information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` エクステンションは、Quarkusがdev-modeで動作しているときにHealth UIを公開します。 link:smallrye-health.adoc#ui[この]セクションでは、追加情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mock mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-mailer` extension will enable an in-memory mock mail server when Quarkus is running in dev-mode. See link:mailer.adoc#testing[this] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-mailer` エクステンションは、Quarkusがdev-modeで動作しているときに、インメモリのモックメールサーバを有効にします。詳しくは link:mailer.adoc#testing[こちら]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gRPC Reflection Service is enabled in dev mode by default. That lets you use tools such as `grpcurl`. In production mode, the reflection service is disabled. You can enable it explicitly using `quarkus.grpc-server.enable-reflection-service=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC Reflection Serviceは、devモードではデフォルトで有効になっています。これにより、 `grpcurl` のようなツールを使用することができます。本番モードでは、リフレクションサービスは無効になっています。 `quarkus.grpc-server.enable-reflection-service=true` を使って明示的に有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev-mode, `quarkus.grpc.server.instances` has no effect.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>dev-modeでは、 `quarkus.grpc.server.instances` は効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Others</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There might be other configuration properties (depending on the extensions added to the application) that have no effect in dev-mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（アプリケーションに追加されたエクステンションに応じて）他の設定プロパティがあるかもしれませんが、dev-modeでは影響がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Performance implications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パフォーマンスへの影響</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev-mode minimizing the runtime footprint of the application is not the primary objective (although Quarkus still starts plenty fast and consumes little memory even in dev-mode) - the primary objective is enabling developer joy.  Therefore, many more classes are loaded and build time operations also take place every time a live-reload is performed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでは、アプリケーションの実行時フットプリントを最小化することは主な目的ではありません（ただし、Quarkusは開発モードでも高速に起動し、メモリをほとんど消費しません） - 主な目的は、開発者満足を実現することです。そのため、ライブリロードが実行されるたびに、より多くのクラスがロードされ、ビルド時の操作も行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In contrast, in a production application the main objective for Quarkus is to consume the least amount of memory and startup in the smallest amount of time.  Thus, when running the production application, build time operations are not performed (by definition) and various infrastructure classes needed at build time are not present at all at runtime.  Furthermore, the purpose built ClassLoader that comes with the link:maven-tooling.adoc#fast-jar[fast-jar] package type ensures that class lookup is done as fast as possible while also keeping the minimum amount of jars in memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>対照的に、プロダクションアプリケーションでは、Quarkusの主な目的は、最小限のメモリを消費し、最小限の時間で起動することです。したがって、本番アプリケーションを実行する際には、ビルド時の操作は（定義上）実行されず、ビルド時に必要なさまざまなインフラストラクチャクラスは、実行時にはまったく存在しません。さらに、 link:maven-tooling.adoc#fast-jar[fast-jar]パッケージタイプに付属する目的に応じて構築されたClassLoaderにより、クラスの検索が可能な限り高速に行われると同時に、メモリ内のjarの量も最小限に抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security implications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティへの影響</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perhaps the most important reason why dev-mode applications should not be run in production is that the dev-mode allows reading information that could be confidential (via the Dev-UI)  while also giving access to operations that could be destructive (either by exposing endpoints that should not be available in production application or via the Dev-UI).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>dev-modeアプリケーションを本番環境で実行してはいけない最も重要な理由は、dev-modeでは（Dev-UIを介して）機密性のある情報を読み取ることができる一方で、（本番環境のアプリケーションでは利用できないはずのエンドポイントを公開したり、Dev-UIを介して）破壊的な操作にアクセスすることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native binary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブバイナリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a native binary is created (explained in detail link:building-native-image[here]), it is *always* built from a production application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ・バイナリを作成する場合（詳細は link:building-native-image[こちら]）、 *常に* 本番アプリケーションからビルドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many projects that use data require connections to a relational database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データを使用する多くのプロジェクトでは、リレーショナルデータベースへの接続が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual way of obtaining connections to a database is to use a datasource and configure a JDBC driver.  But you might also prefer using a reactive driver to connect to your database in a reactive way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースへの接続を取得する一般的な方法は、データソースを使用して JDBC ドライバーを設定することです。しかし、リアクティブな方法でデータベースに接続するために、リアクティブなドライバーを使用することが好まれる場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has you covered either way:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、どちらにも対応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For JDBC, the preferred datasource and connection pooling implementation is https://agroal.github.io/[Agroal].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC の場合、データソースと接続プーリングの実装は https://agroal.github.io/[Agroal] が好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For reactive, we use the https://vertx.io/[Vert.x] reactive drivers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブには、https://vertx.io/[Vert.x] リアクティブドライバーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both are configured via unified and flexible configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらも統一された柔軟な構成で構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Agroal is a modern, light weight connection pool implementation designed for very high performance and scalability, and features first class integration with the other components in Quarkus, such as security, transaction management components, health, and metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Agroal は、非常に高いパフォーマンスとスケーラビリティ－を実現するように設計されたモダンで軽量な接続プールの実装です。また、セキュリティー、トランザクション管理コンポーネント、ヘルス、メトリクスなど、Quarkus における他のコンポーネントとのファーストクラスの統合を特徴としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will explain how to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、以下の方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is mainly about datasource configuration.  If you want more details about how to consume and make use of a reactive datasource, please refer to the link:reactive-sql-clients[Reactive SQL clients guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、主にデータソースの設定について説明します。反応性のあるデータソースを消費して利用する方法の詳細については、リアクティブデータソースの利用方法についての詳細は、link:reactive-sql-clients[リアクティブ SQL クライアントガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TL;DR</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細な説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a quick introduction to datasource configuration.  If you want a better understanding of how all this works, this guide has a lot more information in the subsequent paragraphs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはデータソースの設定についての簡単な紹介です。すべての動作について理解を深める場合は、このガイドの後の段落でさらに多くの情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero Config Setup (DevServices)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ゼロコンフィグ設定（DevServices）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When testing or running in dev mode Quarkus can even provide you with a zero config database out of the box, a feature we refer to as DevServices. Depending on your database type you may need docker installed in order to use this feature. DevServices is supported for the following open source databases:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、テストや開発モードで実行する際に、ゼロコンフィグでデータベースをすぐに提供することができます。これは、私たちがDevServicesと呼ぶ機能です。データベースの種類によっては、この機能を使用するためにdockerをインストールする必要があります。DevServicesは以下のオープンソースデータベースでサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2 (container) (requires license acceptance)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2 (コンテナ)(要ライセンス承諾)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MSSQL (container) (requires license acceptance)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MSSQL (コンテナ)(要ライセンス承諾)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use DevServices then all you need to do is include the relevant extension for the type of database you want (either reactive or JDBC, or both), and don't configure a database URL, username and password, Quarkus will provide the database and you can just start coding without worrying about config.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DevServicesを使用する場合、必要なのは使用するデータベースの種類（リアクティブまたはJDBC、またはその両方）に応じた関連するエクステンションを含めることだけで、データベースのURLやユーザー名、パスワードを設定する必要はありません。Quarkusがデータベースを提供するので、ユーザーは設定に煩わされることなく、ただコーディングを開始することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a proprietary database such as DB2 or MSSQL you will need to accept the license agreement. To do this create a `src/main/resources/container-license-acceptance.txt` files in your project and add a line with the image name and tag of the database. By default Quarkus uses the default image for the current version of Testcontainers, if you attempt to start Quarkus the resulting failure will tell you the exact image name in use for you to add to the file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2やMSSQLなどのプロプライエタリなデータベースを使用している場合は、使用許諾契約書に同意する必要があります。これを行うには、プロジェクト内に `src/main/resources/container-license-acceptance.txt` ファイルを作成し、データベースのイメージ名とタグを記載した行を追加します。デフォルトでは、Quarkusは現在のバージョンのTestcontainersのデフォルトイメージを使用しますが、Quarkusを起動しようとすると、失敗したときに使用されている正確なイメージ名が表示されるので、ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example file is shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ファイルの例を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>src/main/resources/container-license-acceptance.txt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/resources/container-license-acceptance.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then configure your datasource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、データソースを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=postgresql &lt;1&gt;
quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=postgresql &lt;1&gt;
quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you only have a single JDBC extension, or you are running tests and only have a single test scoped JDBC extension installed then this is optional. If there is only one possible extension we assume this is the correct one, and if a driver has been added with test scope then we assume that this should be used in testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBCエクステンションが1つしかない場合や、テストを実行していてテストスコープ付きのJDBCエクステンションが1つしかインストールされていない場合は、これはオプションです。利用可能なエクステンションがひとつしかない場合は、それが正しいものであると仮定します。また、テストスコープでドライバが追加されている場合は、それをテストで使用すべきであると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the correct reactive extension for the database you are using: `reactive-pg-client`, `reactive-mysql-client`, or `reactive-db2-client`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用しているデータベースに適切なリアクティブ拡張を追加します。`reactive-pg-client` , `reactive-mysql-client`、または `reactive-db2-client`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then configure your reactive datasource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、リアクティブデータソースを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.reactive.url=postgresql:///your_database
quarkus.datasource.reactive.max-size=20
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.reactive.url=postgresql:///your_database
quarkus.datasource.reactive.max-size=20
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As specified above this is optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上述の通り、これはオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A datasource can be either a JDBC datasource, a reactive one or both.  It all depends on how you configure it and which extensions you added to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースは、JDBC データソースまたはリアクティブデータソースのいずれか 1 つでも、その両方でも構いません。データソースの設定方法と、プロジェクトに追加したエクステンションによって異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a datasource, start with the following (note that this is only required if you have more than one database type installed):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースを定義するには、まず以下のようにします（複数のデータベースタイプがインストールされている場合にのみ必要となりますのでご注意ください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=h2
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=h2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The database kind defines which type of database you will connect to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースの種類は、接続するデータベースの種類を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We currently include these built-in database kinds:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のところ、これらの組込データベースの種類が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2: `db2`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2: `db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby: `derby`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Derby: `derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>H2: `h2`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>H2: `h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB: `mariadb`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MariaDB: `mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server: `mssql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microsoft SQL Server: `mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL: `mysql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MySQL: `mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL: `postgresql`, `pgsql` or `pg`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL: `postgresql`、`pgsql`、または `pg`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Giving Quarkus the database kind you are targeting will facilitate configuration.  By using a JDBC driver extension and setting the kind in the configuration, Quarkus resolves the JDBC driver automatically, so you don't need to configure it yourself.  If you want to use a database kind that is not part of the built-in ones, use `other` and define the JDBC driver explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>対象とするデータベースの種類を Quarkus に指定することで、設定が容易になります。JDBC ドライバーの拡張を使用して、設定でタイプを指定することで、Quarkus は自動的に JDBC ドライバーを解決します。そのため、自分で設定する必要はありません。組み込みのものに含まれていないデータベースの種類を使用したい場合は、`other` を使用して、JDBCドライバーを明示的に定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any JDBC driver in a Quarkus app in JVM mode (see &lt;&lt;other-databases,Using other databases&gt;&gt;).  It is unlikely that it will work when compiling your application to a native executable though.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVM モードの Quarkus アプリでは、任意のJDBCドライバーを使用することができます (&lt;&lt;other-databases,Using other databases&gt;&gt; を参照)。しかし、アプリケーションをネイティブの実行ファイルにコンパイルした場合には動作しない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to make a native executable, we recommend you use the existing JDBC Quarkus extensions (or contribute one for your driver).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルを作成する場合は、既存の JDBC Quarkus エクステンションを使用するこが推奨されます (または、ドライバーに貢献することをお勧めします)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a good chance you will need to define some credentials to access your database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースにアクセスするために、いくつかの認証情報を定義する必要がある可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done by configuring the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、以下のプロパティーを設定することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also retrieve the password from Vault by link:vault-datasource[using a credential provider] for your datasource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、データソースの link:vault-datasource[認証情報プロバイダを使用] 、Vault からパスワードを取得することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have defined the database kind and the credentials, you are ready to configure either a JDBC datasource, a reactive one, or both.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースの種類と認証情報を定義したら、JDBC データソースまたはリアクティブデータソースのいずれか 1 つ、あるいはその両方を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDBC is the most common database connection pattern.  You typically need a JDBC datasource when using Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC は最も一般的なデータベース接続パターンです。通常、Hibernate ORM を使用する場合は JDBC データソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Maven dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven の依存関係をインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you will need to add the `quarkus-agroal` dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、`quarkus-agroal` 依存関係をプロジェクトに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add it using a simple Maven command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルな Maven コマンドを使って追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="agroal"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="agroal"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Agroal comes as a transitive dependency of the Hibernate ORM extension so if you are using Hibernate ORM, you don't need to add the Agroal extension dependency explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Agroal は Hibernate ORM 拡張の遷移依存関係として提供されるので、Hibernate ORM を使用している場合は、Agroal エクステンションの依存関係を明示的に追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will also need to choose, and add, the Quarkus extension for your relational database driver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、リレーショナルデータベースドライバー用の Quarkus エクステンションを選択して追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides driver extensions for:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、以下のためのドライバーエクステンションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2 - `jdbc-db2`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2 - `jdbc-db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby - `jdbc-derby`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Derby - `jdbc-derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>H2 - `jdbc-h2`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>H2 - `jdbc-h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB - `jdbc-mariadb`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MariaDB - `jdbc-mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server - `jdbc-mssql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microsoft SQL Server - `jdbc-mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL - `jdbc-mysql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MySQL - `jdbc-mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL - `jdbc-postgresql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL - `jdbc-postgresql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See &lt;&lt;other-databases&gt;&gt; if you want to use a JDBC driver for another database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のデータベースに JDBC ドライバーを使用する場合は、&lt;&lt;other-databases&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The H2 and Derby databases can normally be configured to run in "embedded mode"; the extension does not support compiling the embedded database engine into native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>H2 データベースと Derby データベースは通常、「埋め込みモード」で実行するように設定することができます。また、この拡張は、組み込みデータベースエンジンのネイティブ実行ファイルへのコンパイルに対応していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read &lt;&lt;in-memory-databases,Testing with in-memory databases&gt;&gt; (below) for suggestions regarding integration testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合テストに関する提案については、&lt;&lt;in-memory-databases,Testing with in-memory databases&gt;&gt; (下) をお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, you can install the extension using `add-extension`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常通り、`add-extension` を使ってエクステンションをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To install the PostgreSQL driver dependency for instance, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL ドライバーの依存関係をインスタンスにインストールするには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your JDBC connection is easy, the only mandatory property is the JDBC URL.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC 接続の設定は簡単で、必須のプロパティーは JDBC URL のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the `jdbc` prefix in the property name.  All the configuration properties specific to JDBC have this prefix.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティー名の接頭辞 `jdbc` に注意してください。JDBC に固有のすべての構成プロパティーには、この接頭辞があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about the JDBC URL format, please refer to the &lt;&lt;jdbc-url,JDBC url reference section&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC URL 形式の詳細については、&lt;&lt;jdbc-url,JDBC url reference section&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using one of the built-in datasource kinds, the JDBC driver is resolved automatically to the following values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルトインデータソースのいずれかの種類を使用している場合、JDBC ドライバーは以下の値に自動的に解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Database kind</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースの種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`db2`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.ibm.db2.jcc.DBDriver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.ibm.db2.jcc.DBDriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.ibm.db2.jcc.DB2XADataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.ibm.db2.jcc.DB2XADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`derby`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.derby.jdbc.ClientDriver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.derby.jdbc.ClientDriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.derby.jdbc.ClientXADataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.derby.jdbc.ClientXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`h2`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.h2.Driver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.h2.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.h2.jdbcx.JdbcDataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.h2.jdbcx.JdbcDataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mariadb`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.mariadb.jdbc.Driver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.mariadb.jdbc.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.mariadb.jdbc.MySQLDataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.mariadb.jdbc.MySQLDataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mssql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerDriver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerDriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerXADataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mysql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.mysql.cj.jdbc.Driver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.mysql.cj.jdbc.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.mysql.cj.jdbc.MysqlXADataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.mysql.cj.jdbc.MysqlXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`postgresql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`postgresql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.postgresql.Driver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.postgresql.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.postgresql.xa.PGXADataSource`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.postgresql.xa.PGXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As previously stated, most of the time, this automatic resolution will suit you and you won't need to configure the driver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述したように、多くの場合、この自動解像度が適切で、ドライバーを設定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a database with no built-in extension or with a different driver</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルトインエクステンションのないデータベースを使用するか、別のドライバーのあるデータベースを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a specific driver if you need to (for instance for using the OpenTracing driver)  or if you want to use a database for which Quarkus does not have a built-in JDBC driver extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要に応じて (例えば OpenTracing ドライバーを使用する場合)、あるいはビルトイン JDBC ドライバー拡張のない Quarkus のデータベースを使用する必要がある場合は、特定のドライバーを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without an extension, the driver will work fine in any Quarkus app running in JVM mode.  It is unlikely that it will work when compiling your application to a native executable though.  If you plan to make a native executable, we recommend you use the existing JDBC Quarkus extensions (or contribute one for your driver).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張がない場合でも、JVM モードで実行されている Quarkus アプリであれば、ドライバーは問題なく動作します。しかし、アプリケーションをネイティブ実行ファイルにコンパイルした場合には動作しません。ネイティブ実行ファイルを作成する予定がある場合は、既存の JDBC Quarkus エクステンションを使用することをお勧めします (または、ドライバー用のエクステンションを提供することをお勧めします)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how you would use the OpenTracing driver:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、OpenTracing ドライバーをどのように使用するかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.driver=io.opentracing.contrib.jdbc.TracingDriver
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.jdbc.driver=io.opentracing.contrib.jdbc.TracingDriver
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how you would define access to a database with no built-in support (in JVM mode):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、組み込みサポートのないデータベースへのアクセスを定義する方法を説明します (JVMモードで)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=other
quarkus.datasource.jdbc.driver=oracle.jdbc.driver.OracleDriver
quarkus.datasource.jdbc.url=jdbc:oracle:thin:@192.168.1.12:1521/ORCL_SVC
quarkus.datasource.username=scott
quarkus.datasource.password=tiger
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=other
quarkus.datasource.jdbc.driver=oracle.jdbc.driver.OracleDriver
quarkus.datasource.jdbc.url=jdbc:oracle:thin:@192.168.1.12:1521/ORCL_SVC
quarkus.datasource.username=scott
quarkus.datasource.password=tiger
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure a lot more things, for instance the size of the connection pool.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接続プールのサイズなど、より多くのことを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the &lt;&lt;jdbc-configuration,JDBC configuration reference&gt;&gt; for all the details about the JDBC configuration knobs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC 構成ノブの詳細については、&lt;&lt;jdbc-configuration,JDBC configuration reference&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming the datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースの消費</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Hibernate ORM, the datasource will be consumed automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM を使用している場合、データソースは自動的に消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for whatever reason, access to the datasource is needed in code, it can be obtained as any other bean in the following manner:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何らかの理由でコード内でデータソースへのアクセスが必要な場合は、以下の方法で他の Bean と同じようにデータソースを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
AgroalDataSource defaultDataSource;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Inject
AgroalDataSource defaultDataSource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above example, the type is `AgroalDataSource` which is a subtype of `javax.sql.DataSource`.  Because of this, you can also use `javax.sql.DataSource` as the injected type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の例では、型は `AgroalDataSource` であり、 `javax.sql.DataSource` のサブタイプです。このため、`javax.sql.DataSource` を注入された型として使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer using a reactive datasource, Quarkus offers DB2, MySQL/MariaDB, and PostgreSQL reactive clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータソースを使用したい場合は、Quarkus では、DB2、MySQL/MariaDB、PostgreSQL リアクティブクライアントを利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on which database you want to use, add the corresponding extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用したいデータベースに応じて、対応するエクステンションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2: `quarkus-reactive-db2-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2: `quarkus-reactive-db2-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL/MariaDB: `quarkus-reactive-mysql-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MySQL/MariaDB: `quarkus-reactive-mysql-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL: `quarkus-reactive-pg-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL: `quarkus-reactive-pg-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installed extension must be consistent with the `quarkus.datasource.db-kind` you define in your datasource configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インストールされているエクステンションは、データソースの設定で定義する `quarkus.datasource.db-kind` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the reactive datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータソースの構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the driver is there, you just need to configure the connection URL.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドライバーあれば、あとは接続 URL を設定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, but highly recommended, you should define a proper size for your connection pool.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任意ですが、接続プールの適切なサイズを定義することを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDBC and reactive datasources simultaneously</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC とリアクティブデータソースの同時利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, if you include both a JDBC extension (+ Agroal) and a reactive datasource extension handling the given database kind, both will be created.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、JDBC 拡張 (+ Agroal) と、指定したデータベースの種類を扱うリアクティブデータソース拡張の両方を含めると、これらのファイル両方が作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable the JDBC datasource explicitly, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC データソースを明示的に無効にしたい場合は、以下を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc=false
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.jdbc=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable the reactive datasource explicitly, use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータソースを明示的に無効にしたい場合は、以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.reactive=false
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.reactive=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time, the configuration above won't be necessary as either a JDBC driver or a reactive datasource extension will be present and not both.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くの場合、存在するのはJDBC ドライバーまたはリアクティブデータソース拡張のどちらかで、両方存在するわけではありません。そのため、上記の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Multiple Datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のデータソースの構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, multiple datasources are only supported for JDBC and the Agroal extension.  So it is not currently possible to create multiple reactive datasources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のところ、複数のデータソースは JDBC と Agroal 拡張でのみサポートされています。そのため、現在、複数の反応性データソースを作成することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate ORM extension link:hibernate-orm#multiple-persistence-units[supports defining several persistence units using configuration properties].  For each persistence unit, you can point to the datasource of your choice.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM エクステンションは、link:hibernate-orm#multiple-persistence-units[設定プロパティーを使用して複数の永続ユニットの定義に対応]しています。それぞれの永続化ユニットでは、任意のデータソースを参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining multiple datasources works exactly the same way as defining a single datasource, with one important change: you define a name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のデータソースの定義は、単一のデータソースの定義と全く同じです。ただし、1 つだけ重要な変更点があります。それは、名前を定義することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following example, you have 3 different datasources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例では、3 つの異なるデータソースがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default one,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A datasource named `users`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`users` という名前のデータソース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A datasource named `inventory`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`inventory` という名前のデータソース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>each with its own configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それぞれが独自の設定を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there is an extra bit in the key.  The syntax is as follows: `quarkus.datasource.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーに余分なビットがあることに注意してください。構文は以下の通りです。`quarkus.datasource.[optional name.][datasource property]` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Even when only one database extension is installed, named databases need to specify at least one build time property so that Quarkus knows they exist. Generally this will be the `db-kind` property, although you can also specify DevServices properties to create named datasources (covered later in this guide).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースエクステンションが1つしかインストールされていない場合でも、名前付きデータベースは、Quarkusがその存在を認識できるように、少なくとも1つのビルド時プロパティを指定する必要があります。通常、これは `db-kind` プロパティになりますが、名前付きデータソースを作成するためにDevServicesプロパティを指定することもできます（このガイドで後述します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Datasource Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前付きデータソースインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple datasources, each `DataSource` also has the `io.quarkus.agroal.DataSource` qualifier with the name of the datasource as the value.  Using the above properties to configure three different datasources, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のデータソースを使用する場合、それぞれの `DataSource` にも、値としてデータソース名のある `io.quarkus.agroal.DataSource` の修飾子が付けられています。上記のプロパティーを使って 3 つの異なるデータソースを設定すると、以下のようにそれぞれのデータソースを注入することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
@DataSource("users")
AgroalDataSource usersDataSource;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Inject
@DataSource("users")
AgroalDataSource usersDataSource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
@DataSource("inventory")
AgroalDataSource inventoryDataSource;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Inject
@DataSource("inventory")
AgroalDataSource inventoryDataSource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datasource Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, the `quarkus-agroal` and reactive client extensions will automatically add a readiness health check to validate the datasource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` 拡張を使用している場合、`quarkus-agroal` とリアクティブクライアント拡張は、データソースを検証するための準備の健全性チェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you access the `/q/health/ready` endpoint of your application you will have information about the datasource validation status.  If you have multiple datasources, all datasources will be checked and the status will be `DOWN` as soon as there is one datasource validation failure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの `/q/health/ready` エンドポイントにアクセスすると、データソースの検証ステータスに関する情報が表示されます。複数のデータソースがある場合は、すべてのデータソースがチェックされ、1 つのデータソースの検証に失敗するとすぐにステータスが `DOWN` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled via the property `quarkus.datasource.health.enabled`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、プロパティー `quarkus.datasource.health.enabled` で無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datasource Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースメトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-agroal` can expose some data source metrics on the `/q/metrics` endpoint. This can be turned on by setting the property `quarkus.datasource.metrics.enabled` to true.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-micrometer` または `quarkus-smallrye-metrics` エクステンションを使用している場合、`quarkus-agroal` は `/q/metrics` エンドポイントでいくつかのデータソースメトリクスを公開できます。これは、プロパティー `quarkus.datasource.metrics.enabled` を true に設定することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the exposed metrics to contain any actual values, it is necessary that metric collection is enabled internally by Agroal mechanisms. By default, this metric collection mechanism gets turned on for all data sources if a metrics extension is present and metrics for the Agroal extension are enabled. If you want to disable metrics for a particular data source, this can be done by setting `quarkus.datasource.jdbc.enable-metrics` to `false` (or `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics` for a named datasource).  This disables collecting the metrics as well as exposing them in the `/q/metrics` endpoint, because it does not make sense to expose metrics if the mechanism to collect them is disabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>公開されたメトリクスに実際の値が含まれるようにするには、メトリクス収集が Agroal メカニズムによって内部的に有効化されている必要があります。デフォルトでは、メトリクス拡張が存在し、Agroal 拡張のメトリクスが有効になっている場合に、このメトリック収集メカニズムはすべてのデータソースに対してオンになります。特定のデータソースのメトリクスを無効にしたい場合は、`quarkus.datasource.jdbc.enable-metrics` を `false` (名前付きデータソースの場合は `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics`) に設定することで行うことができます。これは、メトリクスを収集するメカニズムが無効化されている場合は、メトリクスの公開は意味がありません。そのため、`/q/metrics` エンドポイントでの公開と同様に、メトリクスの収集を無効化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversely, setting `quarkus.datasource.jdbc.enable-metrics` to `true` (or `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics` for a named datasource) explicitly can be used to enable collection of metrics even if a metrics extension is not in use.  This can be useful if you need to access the collected metrics programmatically.  They are available after calling `dataSource.getMetrics()` on an injected `AgroalDataSource` instance. If collection of metrics is disabled for this data source, all values will be zero.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>逆に、明示的に `quarkus.datasource.jdbc.enable-metrics` を `true` (名前付きデータソースの場合は `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics`) に設定することで、メトリクス拡張が使用されていなくても、メトリクスの収集を有効にすることができます。これは、収集したメトリクスにプログラムでアクセスする必要がある場合に便利です。インジェクト下 `AgroalDataSource` インスタンスで `dataSource.getMetrics()` を呼び出した後に利用できます。このデータソースでメトリクスの収集が無効になっている場合、すべての値はゼロになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Narayana JTA extension is also available, integration is automatic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Narayana JTA エクステンションも利用できる場合、統合は自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override this by setting the `transactions` configuration property - see the &lt;&lt;configuration-reference, Configuration Reference&gt;&gt; below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを上書きするには、`transactions` 構成プロパティーを設定します。以下の &lt;&lt;configuration-reference, Configuration Reference&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus supports a feature called DevServices that allows you to create datasources without any config. If you have a database extension that supports it and no config is provided, Quarkus will automatically start a database (either using Testcontainers, or by starting a Java DB in process), and automatically configure a connection to this database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述の通り、QuarkusはDevServicesと呼ばれる機能をサポートしており、設定なしでデータソースを作成することができます。サポートしているデータベースエクステンションがあり、設定が提供されていない場合、Quarkusは自動的にデータベースを起動し（Testcontainersを使用するか、インプロセスのJava DBを起動する）、このデータベースへの接続を自動的に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Production databases need to be configured as normal, so if you want to include a production database config in your application.properties and continue to use DevServices we recommend that you use the `%prod.` profile to define your database settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番環境のデータベースは通常通り構成する必要があります。そのため、本番環境のデータベースの構成をapplication.propertiesに含めてDevServicesを継続して使用したい場合は、 `%prod.` プロファイルを使用してデータベースの設定を定義することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DevServices supports the following config options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DevServicesは、以下の構成オプションをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前付きデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using DevServices the default datasource will always be created, but to specify a named datasource you need to have at least one build time property so Quarkus knows to create the datasource. In general you will usually either specify the `db-kind` property, or explicitly enable DevDb: `quarkus.datasource."named".devservices=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DevServicesを使用する場合、デフォルトのデータソースは常に作成されますが、名前付きのデータソースを指定するには、Quarkusがデータソースの作成を認識できるように、少なくとも1つのビルド時プロパティが必要です。一般的には、 `db-kind` プロパティを指定するか、明示的にDevDb: `quarkus.datasource."named".devservices=true` を有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing with in-memory databases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インメモリーデータベースを使用したテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some databases like H2 and Derby are commonly used in "embedded mode" as a facility to run quick integration tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>H2 や Derby のようなデータベースの中には、迅速な統合テストを実行するためのファシリティして "embedded mode" で一般的に使用されているものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our suggestion is to use the real database you intend to use in production; container technologies made this simple enough so you no longer have an excuse. Still, there are sometimes good reasons to also want the ability to run quick integration tests using the JVM powered databases, so this is possible as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番で使用する予定の実際のデータベースを使用することを提案します。コンテナーテクノロジーによりこれが容易になりました。依然として、JVM を搭載したデータベースを使用して迅速な統合テストを実行する機能が必要な場合もあります。そのような場合でも、これが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to remember that when configuring H2 (or Derby) to use the embedded engine, this will work as usual in JVM mode but such an application will not compile into a native executable, as the Quarkus extensions only cover for making the JDBC client code compatible with the native compilation step: embedding the whole database engine into a native executable is currently not implemented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>埋め込みエンジンを使用するように H2 (または Derby) を設定する場合、JVM モードでは通常通り動作しますが、そのようなアプリケーションはネイティブの実行ファイルにはコンパイルされません。これは、Quarkus 拡張が、JDBC クライアントコードをネイティブコンパイルステップに対応させることのみを対象としているためです。データベースエンジン全体のネイティブ実行可能ファイルへの組み込みは現在実装されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to run such integration tests in the JVM exclusively, it will of course work as usual.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような統合テストを JVM で排他的に実行する予定であれば、もちろん通常通りに動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want the ability to run such integration test in both JVM and/or native executables, we have some cool helpers for you: just add either `@QuarkusTestResource(H2DatabaseTestResource.class)` or `@QuarkusTestResource(DerbyDatabaseTestResource.class)` on any class in your integration tests, this will make sure the test suite starts (and stops) the embedded database into a separate process as necessary to run your tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような統合テストを JVM やネイティブ実行ファイルの両方で実行できるようにしたい場合は、いくつかの便利なヘルパーを利用できます。統合テストの任意のクラスに `@QuarkusTestResource(H2DatabaseTestResource.class)` または `@QuarkusTestResource(DerbyDatabaseTestResource.class)` を追加するだけで、テストスイートがテストを実行するために必要なデータベースを別のプロセスに組み込んで起動 (および停止) するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These additional helpers are provided by the artifacts having Maven coordinates `io.quarkus:quarkus-test-h2` and `io.quarkus:quarkus-test-derby`, respectively for H2 and Derby.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの追加のヘルパーは、H2 と Derby 用にそれぞれ Maven 座標 `io.quarkus:quarkus-test-h2` と `io.quarkus:quarkus-test-derby` を持アーティファクトによって提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follows an example for H2:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、H2 の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package my.app.integrationtests.db;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package my.app.integrationtests.db;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@QuarkusTestResource(H2DatabaseTestResource.class)
public class TestResources {
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@QuarkusTestResource(H2DatabaseTestResource.class)
public class TestResources {
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will allow you to test your application even when it's compiled into a native executable, while the database will run in the JVM as usual.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、ネイティブ実行ファイルにコンパイルされている場合でもアプリケーションをテストすることができ、データベースは通常通り JVM で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connect to it using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下を使用して接続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:test
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:test
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common Datasource Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>共通データソース構成リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each of the supported databases contains different JDBC URL configuration options.  Going into each of those options is beyond the scope of this document, but the following section gives an overview of each database URL and a link to the official documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているデータベースにはそれぞれ異なる JDBC URL 設定オプションがあります。それぞれのオプションについては、本ドキュメントの説明範囲を超えていますが、以下のセクションでは各データベースの URL の概要と公式ドキュメントへのリンクを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:h2:{ {.|mem:}[name] | [file:]fileName | {tcp|ssl}:[//]server[:port][,server2[:port]]/name }[;key=value...]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:h2:{ {.|mem:}[name] | [file:]fileName | {tcp|ssl}:[//]server[:port][,server2[:port]]/name }[;key=value...]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:h2:tcp://localhost/~/test`, `jdbc:h2:mem:myDB`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:h2:tcp://localhost/~/test`, `jdbc:h2:mem:myDB`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>H2 is an embedded database.  It can run as a server, based on a file, or live completely in memory.  All of these options are available as listed above.  You can find more information at the https://h2database.com/html/features.html?highlight=url&amp;search=url#database_url[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>H2 は組み込みデータベースです。サーバーとして、ファイルに基づいて、あるいは、メモリー内で完全にライブで実行できます。これらすべてのオプションは上記のように利用可能です。詳細は、link:https://h2database.com/html/features.html?highlight=url&amp;search=url#database_url[公式ドキュメント] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL only runs as a server, as do the rest of the databases below.  As such, you must specify connection details, or use the defaults.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL は、以下の他のデータベースと同様に、サーバーとしてのみ動作します。そのため、接続の詳細を指定するか、デフォルトを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:postgresql:[//][host][:port][/database][?key=value...]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:postgresql:[//][host][:port][/database][?key=value...]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:postgresql://localhost/test`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:postgresql://localhost/test`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defaults for the different parts are as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各部のデフォルトは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`host`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`host`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>localhost</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>localhost</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`port`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`port`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`database`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`database`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://jdbc.postgresql.org/documentation/head/connect.html[official documentation] go into more detail and list optional parameters as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://jdbc.postgresql.org/documentation/head/connect.html[公式ドキュメント] では、より詳細な情報を紹介しており、同様にオプションのパラメーターをリストアップしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:db2://&lt;serverName&gt;[:&lt;portNumber&gt;]/&lt;databaseName&gt;[:&lt;key1&gt;=&lt;value&gt;;[&lt;key2&gt;=&lt;value2&gt;;]]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:db2://&lt;serverName&gt;[:&lt;portNumber&gt;]/&lt;databaseName&gt;[:&lt;key1&gt;=&lt;value&gt;;[&lt;key2&gt;=&lt;value2&gt;;]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:db2://localhost:50000/MYDB:user=dbadm;password=dbadm;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:db2://localhost:50000/MYDB:user=dbadm;password=dbadm;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.apdv.java.doc/src/tpc/imjcc_r0052342.html[official documentation] for more detail on URL syntax and additional supported options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>URL の構文やサポートされているオプションの詳細は、 link:https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.apdv.java.doc/src/tpc/imjcc_r0052342.html[公式ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MariaDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mariadb:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:mariadb:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hostDescription</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>hostDescription</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mariadb://localhost:3306/test`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:mariadb://localhost:3306/test`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this feature and others detailed in the https://mariadb.com/kb/en/library/about-mariadb-connector-j/[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能の詳細は、link:https://mariadb.com/kb/en/library/about-mariadb-connector-j/[公式ドキュメント] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MySQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mysql:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:mysql:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mysql://localhost:3306/test`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:mysql://localhost:3306/test`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this feature and others detailed in the https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference.html[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能は、link:https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference.html[公式ドキュメント] に詳しい情報が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microsoft SQL Server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server takes a connection URL in the following form:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microsoft SQL Server は、以下の形式で接続 URL を処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:sqlserver://localhost:1433;databaseName=AdventureWorks`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:sqlserver://localhost:1433;databaseName=AdventureWorks`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft SQL Server JDBC driver works essentially the same as the others.  More details can be found in the https://docs.microsoft.com/en-us/sql/connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver?view=sql-server-2017[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microsoft SQL Server JDBC ドライバーは基本的に他のものと同じように動作します。詳細は link:https://docs.microsoft.com/en-us/sql/connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver?view=sql-server-2017[公式ドキュメント] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Derby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:derby:[//serverName[:portNumber]/][memory:]databaseName[;property=value[;property=value]]`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:derby:[//serverName[:portNumber]/][memory:]databaseName[;property=value[;property=value]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:derby://localhost:1527/myDB`, `jdbc:derby:memory:myDB;create=true`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jdbc:derby://localhost:1527/myDB`, `jdbc:derby:memory:myDB;create=true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby is an embedded database.  It can run as a server, based on a file, or live completely in memory.  All of these options are available as listed above.  You can find more information at the https://db.apache.org/derby/docs/10.8/devguide/cdevdvlp17453.html#cdevdvlp17453[official documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Derby は組み込みデータベースです。サーバーとして、ファイルを元にして、あるいは完全にメモリー内でライブで実行するこもできます。これらすべてのオプションは上記のように利用可能です。詳細は link:https://db.apache.org/derby/docs/10.8/devguide/cdevdvlp17453.html#cdevdvlp17453[公式ドキュメント] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Datasource Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータソース構成リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive DB2 Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな DB2 の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive MariaDB/MySQL Specific Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな MariaDB/MySQL 固有の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive PostgreSQL Specific Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな PostgreSQL 固有の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは以下をカバーしています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this guide you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは以下が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly 1 hour for all modalities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての手順を試すのに約1時間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will take as input an application developed in the link:getting-started[Getting Started guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:getting-started[入門ガイド] で開発されたアプリケーションを入力として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have the getting-started application at hand, or clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]. The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手元に get-started アプリケーションがあることを確認するか、Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、もしくは {quickstarts-archive-url}[archive] をダウンロードしてください。ソリューションは `getting-started` ディレクトリーにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the _lingua franca_ between microservices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON は今やマイクロサービス間の _共通言語_ となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、REST サービスが JSON ペイロードを消費および生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need a link:rest-client[REST client] (including support for JSON).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:rest-client[REST クライアント] が必要な場合は、別のガイドがあります (JSON のサポートを含む)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで開発するアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、リストが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server are formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザとサーバー間の情報はすべて JSON 形式になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and https://github.com/FasterXML/jackson[Jackson] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RSと link:https://github.com/FasterXML/jackson[Jackson] エクステンションをインポートするMaven構造を生成し、特に以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To improve user experience, Quarkus registers the three Jackson https://github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need to do it manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーエクスペリエンスを向上させるために、Quarkusは3つのJackson link:https://github.com/FasterXML/jackson-modules-java8[Java 8モジュール] を登録しているので、手動で登録する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports http://json-b.net/[JSON-B] so, if you prefer JSON-B over Jackson, you can create a project relying on the RESTEasy JSON-B extension instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは link:http://json-b.net/[JSON-B] もサポートしているので、JacksonよりもJSON-Bが好きな場合は、代わりにRESTEasy JSON-B エクステンションに依存したプロジェクトを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and http://json-b.net/[JSON-B] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RSと link:http://json-b.net/[JSON-B] 拡張をインポートするMaven構造を生成し、特に以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating your first JSON REST service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初めてのJSON RESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、果物のリストを管理するアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create the `Fruit` bean as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、以下のように `Fruit` Bean を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことはJSONシリアライズレイヤーで必須であるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.rest.json.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `org.acme.rest.json.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/fruits")
public class FruitResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/fruits")
public class FruitResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装は非常に簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Fruit` objects will be automatically serialized/deserialized by http://json-b.net/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], depending on the extension you chose when initializing the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Fruit` オブジェクトは、プロジェクトの初期化時に選択したエクステンションに応じて、 link:http://json-b.net/[JSON-B] または link:https://github.com/FasterXML/jackson[Jackson] によって自動的にシリアライズ/デシリアライズされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-resteasy-jackson` or `quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy-jackson` や `quarkus-resteasy-jsonb` などの JSON エクステンションがインストールされている場合、メディアタイプが `@Produces` や `@Consumes` アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` メディアタイプをデフォルトで使用します( `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` と `application/octet-stream` がデフォルトとなっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jackson</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and consumed by the Quarkus extensions) is configured to ignore unknown properties (by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、CDI経由で取得した(そしてQuarkusのエクステンションによって消費される)デフォルトのJackson `ObjectMapper` は、未知のプロパティーを無視するように設定されています( `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 機能を無効にすることで)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the default behavior of Jackson by setting `quarkus.jackson.fail-on-unknown-properties=true` in your `application.properties` or on a per class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` で `quarkus.jackson.fail-on-unknown-properties=true` を設定するか、 `@JsonIgnoreProperties(ignoreUnknown = false)` を経由してクラスごとに設定することで、Jackson のデフォルトの動作を復元することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the `ObjectMapper` is configured to format dates and time in ISO-8601 (by disabling the `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` feature).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、 `ObjectMapper` 、日付と時刻をISO-8601でフォーマットするように設定されています（ `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` の機能を無効にすることで）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behaviour of Jackson can be restored by setting `quarkus.jackson.write-dates-as-timestamps=true` in your `application.properties`. If you want to change the format for a single field, you can use the `@JsonFormat` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` で `quarkus.jackson.fail-on-unknown-properties=true` を設定するか、 `@JsonIgnoreProperties(ignoreUnknown = false)` を経由してクラスごとに設定することで、Jackson のデフォルトの動作を復元することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, Quarkus makes it very easy to configure various Jackson settings via CDI beans.  The simplest (and suggested) approach is to define a CDI bean of type `io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson configuration can be applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Quarkusは、CDI Bean を介して、様々なJackson設定を非常に簡単に設定することができます。最も単純な(そして推奨される)アプローチは、 `io.quarkus.jackson.ObjectMapperCustomizer` 型の CDI Bean を定義し、その中で、Jackson の設定を適用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example where a custom module needs to be registered would look like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムモジュールを登録する必要がある場合の例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can even provide their own `ObjectMapper` bean if they so choose.  If this is done, it is very important to manually inject and apply all `io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that produces `ObjectMapper`.  Failure to do so will prevent Jackson specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーは、選択すれば自分の `ObjectMapper` Beanを提供することもできます。この場合、 `ObjectMapper` を生成する CDI プロデューサの中で、すべての `io.quarkus.jackson.ObjectMapperCustomizer` Bean を手動で注入して適用することが非常に重要です。これを怠ると、様々なエクステンションによって提供される Jackson 固有のカスタマイズが適用されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class CustomObjectMapper {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class CustomObjectMapper {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As stated above, Quarkus provides the option of using JSON-B instead of Jackson via the use of the `quarkus-resteasy-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のように、Quarkusでは、 `quarkus-resteasy-jsonb` エクステンションを使用することで、Jacksonの代わりにJSON-Bを使用するオプションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same approach as described in the previous section, JSON-B can be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前項と同様のアプローチで、 `io.quarkus.jsonb.JsonbConfigCustomizer` beanを使用してJSON-Bを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example a custom serializer named `FooSerializer` for type `com.example.Foo` needs to be registered with JSON-B, the addition of a bean like the following would suffice:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `FooSerializer` という名前のカスタムシリアライザを `com.example.Foo` タイプで JSON-B で登録する必要がある場合、以下のような Bean を追加すれば十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more advanced option would be to directly provide a bean of `javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  If the latter approach is leveraged it is very important to manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI producer that produces `javax.json.bind.Jsonb`.  Failure to do so will prevent JSON-B specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より高度なオプションとしては、 `javax.json.bind.JsonbConfig` ( `Dependent` スコープ付き)の Bean を直接提供するか、極端な場合には `javax.json.bind.Jsonb` ( `Singleton` スコープ付き)のタイプの Bean を提供することが考えられます。後者のアプローチを利用する場合は、 `javax.json.bind.Jsonb` を生成する CDI プロデューサに `io.quarkus.jsonb.JsonbConfigCustomizer` Bean をすべて手動で注入して適用することが非常に重要です。これを怠ると、様々なエクステンションによって提供される JSON-B 固有のカスタマイズが適用されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class CustomJsonbConfig {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class CustomJsonbConfig {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `FruitResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser to `http://localhost:8080/fruits.html`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザで `http://localhost:8080/fruits.html` を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルは、通常のコマンド `./mvnw package -Pnative` でビルドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行は簡単で、 `./target/rest-json-quickstart-1.0-SNAPSHOT-runner` を実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then point your browser to `http://localhost:8080/fruits.html` and use your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、ブラウザで `http://localhost:8080/fruits.html` を開いてアプリケーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シリアライゼーションについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON serialization libraries use Java reflection to get the properties of an object and serialize them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSONシリアライズライブラリは、Javaのリフレクションを使用してオブジェクトのプロパティーを取得してシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native executables with GraalVM, all classes that will be used with reflection need to be registered.  The good news is that Quarkus does that work for you most of the time.  So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMでネイティブ実行ファイルを使用する場合、リフレクションで使用されるすべてのクラスを登録する必要があります。良いニュースは、Quarkusがほとんどの場合、その作業を代行してくれるということです。これまでのところ、 `Fruit` でさえ、リフレクトを使用するためのクラスを登録しておらず、すべてが正常に動作しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.  When you have the following REST method, Quarkus determines that `Fruit` will be serialized:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、RESTメソッドからシリアライズされた型を推論することができる場合に、何らかのマジックを実行します。以下のようなRESTメソッドがある場合、Quarkusは、 `Fruit` がシリアライズされると判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does that for you automatically by analyzing the REST methods at build time and that's why we didn't need any reflection registration in the first part of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、ビルド時にRESTメソッドを分析することで、自動的にそのような処理を行ってくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another common pattern in the JAX-RS world is to use the `Response` object.  `Response` comes with some nice perks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSの世界では、 `Response` オブジェクトを使用するのがもう一つの一般的なパターンです。 `Response` にはいくつかの素晴らしい特典があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can return different entity types depending on what happens in your method (a `Legume` or an `Error` for instance);</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドで何が起こるかによって異なるエンティティータイプを返すことができます (例えば `Legume` や `Error` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can set the attributes of the `Response` (the status comes to mind in the case of an error).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Response` の属性を設定することができます (エラーが発生した時にステータスを知ることができます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your REST method then looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTメソッドは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.  In this case, Quarkus won't be able to automatically register for reflection the required classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Response` に含まれるタイプは情報がないため、Quarkusがビルド時に判断することはできません。この場合、Quarkusは必要なクラスを自動的に反映登録することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This leads us to our next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これが次のセクションにつながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create the `Legume` class which will be serialized as JSON, following the same model as for our `Fruit` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Fruit` クラスと同じモデルに従って、JSON としてシリアライズされる `Legume` クラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's create a `LegumeResource` REST service with only one method which returns the list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、マメ科植物のリストを返すメソッドを一つだけ持つ `LegumeResource` REST サービスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method returns a `Response` and not a list of `Legume`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは `Response` を返し、 `Legume` のリストではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to display our list of legumes.  In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、マメ科植物のリストを表示するための簡単なウェブページを追加してみましょう。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] ファイルの内容を含む `legumes.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a browser to http://localhost:8080/legumes.html and you will see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザを開いて http://localhost:8080/legumes.html にアクセスすると、マメ科植物のリストが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part starts when running the application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>興味深い部分は、アプリケーションをネイティブ実行ファイルとして実行するときに始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the native executable with `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw package -Pnative` でネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>execute it with `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./target/rest-json-quickstart-1.0-SNAPSHOT-runner` で実行します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No legumes there.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこには豆類はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.  The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のように、Quarkusが `Legume` クラスを判断できなかったことが問題となっており、REST エンドポイントを解析して何らかの反映が必要となります。JSONシリアライズライブラリは、 `Legume` のフィールドのリストを取得しようとすると空のリストを取得するので、フィールドのデータをシリアライズしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.  GraalVM will simply return an empty list of fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現時点では、JSON-BやJacksonがクラスのフィールドのリストを取得しようとしたときに、そのクラスがリフレクションに登録されていない場合、例外はスローされません。GraalVMは単に空のフィールドのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully, this will change in the future and make the error more obvious.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>うまくいけば、将来的にはこれが変化して、エラーがより明白になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can register `Legume` for reflection manually by adding the `@RegisterForReflection` annotation on our `Legume` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Legume` クラスに `@RegisterForReflection` アノテーションを追加することで、手動で `Legume` を リフレクション用に登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's do that and follow the same steps as before:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それを実行して、今までと同じ手順を踏んでみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hit `Ctrl+C` to stop the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Ctrl+C` を叩いてアプリケーションを停止させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, you can see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回はマメ科の一覧が表示されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return _reactive types_ to handle asynchronous processing.  Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write reactive and asynchronous code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期処理を処理するために _リアクティブ型_ を返すことができます。Quarkusでは、リアクティブで非同期なコードを書くために link:https://smallrye.io/smallrye-mutiny[Mutiny] の使用を推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To integrate Mutiny and RESTEasy, you need to add the `quarkus-resteasy-mutiny` dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny と RESTEasy を統合するには、 `quarkus-resteasy-mutiny` 依存関係をプロジェクトに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, your endpoint can return `Uni` or `Multi` instances:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、エンドポイントは `Uni` や `Multi` のインスタンスを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `Uni` when you have a single result.  Use `Multi` when you have multiple items that may be emitted asynchronously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単一の結果がある場合は `Uni` を使用します。 `Multi` は、非同期的に放出される可能性のある複数の項目がある場合に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Uni` and `Response` to return asynchronous HTTP responses: `Uni&lt;Response&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni` と `Response` を使用して、非同期 HTTP レスポンスを返すことができます: `Uni&lt;Response&gt;` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about Mutiny can be found in the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyについての詳細は、 link:getting-started-reactive#mutiny[Reactiveの入門ガイド] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both HTTP request and response can be intercepted by providing `ContainerRequestFilter` or `ContainerResponseFilter` implementations respectively. These filters are suitable for processing the metadata associated with a message: HTTP headers, query parameters, media type, and other metadata. They also have the capability to abort the request processing, for instance when the user does not have the permissions to access the endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP リクエストとレスポンスの両方とも、それぞれ `ContainerRequestFilter` または `ContainerResponseFilter` の実装を提供することで、 インターセプトすることができます。これらのフィルタは、メッセージに関連付けられたメタデータを処理するのに適しています。HTTP ヘッダ、クエリパラメーター、メディアタイプ、その他のメタデータです。また、ユーザーがエンドポイントにアクセスする権限を持っていない場合など、リクエスト処理を中止する機能も持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's use `ContainerRequestFilter` to add logging capability to our service. We can do that by implementing `ContainerRequestFilter` and annotating it with the `@Provider` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ContainerRequestFilter` を使用して、サービスにロギング機能を追加してみましょう。 `ContainerRequestFilter` を実装して、 `@Provider` アノテーションをつけることで実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, whenever a REST method is invoked, the request will be logged into the console:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、RESTメソッドが呼び出されるたびに、リクエストがコンソールにログとして記録されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[クロスオリジンリソース共有] (CORS)は、ウェブページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a CORS filter. Read the link:http-reference#cors-filter[HTTP Reference Documentation] to learn how to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusにはCORSフィルターが付属しています。使用方法については、 link:http-reference#cors-filter[HTTPリファレンスドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with GZip support (even though it is not enabled by default). The following configuration knobs allow to configure GZip support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusにはGZipサポートが搭載されています(デフォルトでは有効になっていませんが)。以下の設定ノブを使用して、GZipサポートを設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable Gzip support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gzipサポートを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the upper limit on deflated request body. This is useful to mitigate potential attacks by limiting their reach. The default value is `10M`.  This configuration option would recognize strings in this format (shown as a regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix is given, assume bytes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフレーションされたリクエストボディの上限を設定します。これは、リーチを制限することで潜在的な攻撃を緩和するのに便利です。既定値は `10M` です。この設定オプションは、以下の形式の文字列を認識します(正規表現で表示されます): `[0-9]+[KkMmGgTtPpEeZzYy]?` .サフィックスが指定されていない場合は、バイトとみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once GZip support has been enabled you can use it on an endpoint by adding the `@org.jboss.resteasy.annotations.GZIP` annotation to your endpoint method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GZip サポートが有効になったら、エンドポイントメソッドに `@org.jboss.resteasy.annotations.GZIP` アノテーションを追加することで、エンドポイントで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to compress everything then we recommended that you use the `quarkus.http.enable-compression=true` setting instead to globally enable compression support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてを圧縮したい場合は、代わりに `quarkus.http.enable-compression=true` の設定を使用してグローバルに圧縮サポートを有効にすることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multipart Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチパートサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy supports multipart via the https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasyは link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider] を介してマルチパートをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides an extension called `quarkus-resteasy-multipart` to make things easier for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `quarkus-resteasy-multipart` というエクステンションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension slightly differs from the RESTEasy default behavior as the default charset (if none is specified in your request) is UTF-8 rather than US-ASCII.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、デフォルトの文字セットが US-ASCII ではなく UTF-8 であるため、RESTEasy のデフォルトの動作とは若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior with the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、以下の構成プロパティーで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Servlet compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーブレットとの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP server, or on top of Undertow if you have any servlet dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、RESTEasyはVert.x HTTPサーバーの上で直接実行するか、サーブレットに依存している場合はUndertowの上で実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a result, certain classes, such as `HttpServletRequest` are not always available for injection. Most use-cases for this particular class are covered by JAX-RS equivalents, except for getting the remote client's IP. RESTEasy comes with a replacement API which you can inject: https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`], which has the methods https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] and https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] to solve this problem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その結果、 `HttpServletRequest` のような特定のクラスが常にインジェクションに利用できるわけではありません。この特定のクラスのほとんどのユースケースは、リモートクライアントの IP を取得することを除いて、JAX-RS と同等のものでカバーされています。RESTEasy には、インジェクション可能な代替 API が付属しています。 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`] これは以下のメソッドを持っています。 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] そして link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] を解決するために、この問題を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the RESTEasy extension and link:rest-client[the REST Client extension] share the same infrastructure.  One important consequence of this consideration is that they share the same list of providers (in the JAX-RS meaning of the word).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、RESTEasyエクステンションと link:rest-client[RESTクライアントエクステンションは] 同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RSの意味での)プロバイダーのリストを共有しているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 *サーバー* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 *クライアント* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No Need for `Application` Class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Application` クラスは不要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration via an application-supplied subclass of `Application` is supported, but not required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Application` のアプリケーションが提供するサブクラスによる設定もサポートされていますが、必須ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only a single JAX-RS application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単一のJAX-RSアプリケーションのみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In contrast to JAX-RS (and RESTeasy) running in a standard servlet-container, Quarkus only supports the deployment of a single JAX-RS application.  If multiple JAX-RS `Application` classes are defined, the build will fail with the message `Multiple classes have been annotated with @ApplicationPath which is currently not supported`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS(およびRESTeasy)が標準のサーブレットコンテナーで実行されているのとは対照的に、Quarkusは単一のJAX-RSアプリケーションのデプロイのみをサポートしています。複数のJAX-RS `Application` クラスが定義されている場合、ビルドは `Multiple classes have been annotated with @ApplicationPath which is currently not supported` というメッセージとともに失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If multiple JAX-RS applications are defined, the property `quarkus.resteasy.ignoreApplicationClasses=true` can be used to ignore all explicit `Application` classes. This makes all resource-classes available via the application-path as defined by `quarkus.resteasy.path` (default: `/`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の JAX-RS アプリケーションが定義されている場合、プロパティー `quarkus.resteasy.ignoreApplicationClasses=true` を使用して、すべての明示的な `Application` クラスを無視することができます。これにより、すべてのリソースクラスが `quarkus.resteasy.path` で定義されたアプリケーションパスを介して利用できるようになります(デフォルトは `/` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The RESTEasy extension doesn't support the method `getProperties()` of the class `javax.ws.rs.core.Application`. Moreover, it only relies on the methods `getClasses()` and `getSingletons()` to filter out the annotated resource, provider and feature classes.  It doesn't filter out the built-in resource, provider and feature classes and also the resource, provider and feature classes registered by the other extensions.  Finally the objects returned by the method `getSingletons()` are ignored, only the classes are took into account to filter out the resource, provider and feature classes, in other words the method `getSingletons()` is actually managed the same way as `getClasses()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasyエクステンションは、クラス `javax.ws.rs.core.Application` のメソッド `getProperties()` をサポートしていません。さらに、アノテーションされたリソース、プロバイダ、フィーチャークラスをフィルタリングするために、 `getClasses()` と `getSingletons()` のメソッドにのみ依存しています。組み込みのリソース、プロバイダ、機能クラスや、他の拡張機能で登録されたリソース、プロバイダ、機能クラスは除外されません。最後に、メソッド `getSingletons()` が返すオブジェクトは無視され、リソース、プロバイダ、機能クラスをフィルタリングするためにクラスのみが考慮されます。言い換えれば、メソッド `getSingletons()` は実際には `getClasses()` と同じように管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle of Resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus all JAX-RS resources are treated as CDI beans.  It's possible to inject other beans via `@Inject`, bind interceptors using bindings such as `@Transactional`, define `@PostConstruct` callbacks, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、すべてのJAX-RSリソースはCDI Bean として扱われます。 `@Inject` を介して他の Bean を注入したり、 `@Transactional` のようなバインディングを使用してインターセプターをバインドしたり、 `@PostConstruct` コールバックを定義したりすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no scope annotation declared on the resource class then the scope is defaulted.  The default scope can be controlled through the `quarkus.resteasy.singleton-resources` property.  If set to `true` (default) then a *single instance* of a resource class is created to service all requests (as defined by `@javax.inject.Singleton`).  If set to `false` then a *new instance* of the resource class is created per each request.  An explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, etc.) always overrides the default behavior and specifies the lifecycle of resource instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースクラスでスコープ注釈が宣言されていない場合は、スコープはデフォルトになります。デフォルトのスコープは `quarkus.resteasy.singleton-resources` プロパティーで制御できます。 `true` (デフォルト) に設定すると、( `@javax.inject.Singleton` で定義されているように) すべてのリクエストにサービスを提供するためのリソースクラスの *単一のインスタンス* が作成されます。 `false` に設定すると、各リクエストごとにリソースクラスの *新しい インスタンス* が作成されます。明示的な CDI スコープ注釈 ( `@RequestScoped` , `@ApplicationScoped` , など) は常にデフォルトの動作を上書きし、リソースインスタンスのライフサイクルを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Include/Exclude JAX-RS classes with build time conditions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時条件でJAX-RSクラスを含める/除外する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus enables the inclusion or exclusion of JAX-RS Resources, Providers and Features directly thanks to build time conditions in the same that it does for CDI beans.  Thus, the various JAX-RS classes can be annotated with profile conditions (`@io.quarkus.arc.profile.IfBuildProfile` or `@io.quarkus.arc.profile.UnlessBuildProfile`) and/or with property conditions (`io.quarkus.arc.properties.IfBuildProperty` or `io.quarkus.arc.properties.UnlessBuildProperty`) to indicate to Quarkus at build time under which conditions these JAX-RS classes should be included.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、CDI Beanの場合と同様に、ビルド時の条件に応じて、JAX-RSリソース、プロバイダー、および機能を直接包含または除外することができます。したがって、さまざまなJAX-RSクラスは、プロファイル条件（ `@io.quarkus.arc.profile.IfBuildProfile` または `@io.quarkus.arc.profile.UnlessBuildProfile` ）および／またはプロパティ条件（ `io.quarkus.arc.properties.IfBuildProperty` または `io.quarkus.arc.properties.UnlessBuildProperty` ）でアノテーションすることができ、構築時にどの条件でこれらのJAX-RSクラスが含まれるべきかをQuarkusに示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following example, Quarkus includes the endpoint `sayHello` if and only if the build profile `app1` has been enabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の例では、Quarkusは、ビルドプロファイル `app1` が有効になっている場合に限り、エンドポイント `sayHello` を含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that if a JAX-RS Application has been detected and the method `getClasses()` and/or `getSingletons()` has/have been overridden, Quarkus will ignore the build time conditions and consider only what has been defined in the JAX-RS Application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSアプリケーションが検出され、メソッド `getClasses()` および／または `getSingletons()` がオーバーライドされている／されている場合、Quarkusはビルド時の条件を無視し、JAX-RSアプリケーションで定義されているもののみを考慮することに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conclusion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating JSON REST services with Quarkus is easy as it relies on proven and well known technologies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusを使用したJSON RESTサービスの作成は、実績のあるよく知られたテクノロジーに依存しているため、簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, Quarkus further simplifies things under the hood when running your application as a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、Quarkusは、アプリケーションをネイティブ実行ファイルとして実行する際に、水面下の作業をさらに簡略化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is only one thing to remember: if you use `Response` and Quarkus can't determine the beans that are serialized, you need to annotate them with `@RegisterForReflection`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>覚えておくべきことは一つだけあります。 `Response` を使用していて、Quarkus がシリアライズされているBeanを特定できない場合は、 `@RegisterForReflection` を使って注釈を付ける必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which additional flags will Quarkus apply to native-image by default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusがデフォルトでネイティブイメージに適用する追加フラグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All of our tests are run on the same hardware for a given batch.  It goes without saying but it's better when you say it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのテストはすべて、与えられたバッチに対して同じハードウェアで実行されます。言うまでもないことですが、言うべきことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do we measure memory usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メモリー使用量の測定方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When measuring the footprint of a Quarkus application, we measure https://en.wikipedia.org/wiki/Resident_set_size[Resident Set Size (RSS)] and not the JVM heap size which is only a small part of the overall problem.  The JVM not only allocates native memory for heap (`-Xms`, `-Xmx`) but also structures required by the jvm to run your application. Depending on the JVM implementation, the total memory allocated for an application will include, but not limited to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションのフットプリントを測定する際には、 link:https://en.wikipedia.org/wiki/Resident_set_size[Resident Set Size(RSS)] を測定します。JVMのヒープサイズではありません。JVMヒープサイズは全体的な問題のほんの一部です。JVMは、ヒープ用のネイティブメモリー( `-Xms` , `-Xmx` )を割り当てるだけでなく、アプリケーションを実行するためにjvmが必要とする構造体も割り当てます。JVMの実装に応じて、アプリケーションに割り当てられる総メモリーは、以下のものを含みますが、これに限りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Heap space</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヒープ空間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスメタデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread stacks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スレッドスタック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiled code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンパイルされたコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Garbage collection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ガベージコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Memory Tracking</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブメモリーのトラッキング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to view the native memory used by the JVM, you can enable the https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html[Native Memory Tracking] (NMT) feature in hotspot;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMで使用されているネイティブメモリーを表示するには、hotspotでNMT( link:https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html[Native Memory Tracking] )機能を有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable NMT on the command line;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドラインでNMTを有効に設定;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> -XX:NativeMemoryTracking=[off | summary | detail] &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> -XX:NativeMemoryTracking=[off | summary | detail] &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE: this feature will add cause an approximately 5-10% performance overhead</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>留意事項: この機能は、約 5-10% のパフォーマンスオーバーヘッドを発生させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is then possible to use jcmd to dump a report of the native memory usage of the Hotspot JVM running your application;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、jcmdを使ってアプリケーションを実行しているHotspot JVMのネイティブメモリー使用量のレポートをダンプすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB] [scale= KB | MB | GB
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Native Memory Limits</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドネイティブのメモリー制限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to measure the whole memory to see the impact of a Cloud Native application.  It is particularly true of container environments which will kill a process based on its full RSS memory usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud Nativeアプリケーションの影響を見るためには、メモリー全体を測定することが重要です。特にRSSメモリーの全使用量に基づいてプロセスを強制終了させてしまうことがあるコンテナー環境では特にそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Likewise, don't fall into the trap of only measuring private memory which is what the process uses that is not shareable with other processes.  While private memory might be useful in a environment deploying many different applications (and thus sharing memory a lot), it is very misleading in environments like Kubernetes/OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、プロセスが使用している、他のプロセスと共有されないプライベートメモリーだけを測定するという罠にはまらないようにしましょう。プライベートメモリーは、多くの異なるアプリケーションをデプロイする環境(したがってメモリーを多く共有する)では有用かもしれませんが、Kubernetes/OpenShiftのような環境では非常に誤解を招く可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Platform Specific Memory Reporting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラットフォーム固有のメモリーレポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to not incur the performance overhead of running with NVM enabled, we measure the total RSS of an JVM application using tools specific to each platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>NVMを有効にして実行することによるパフォーマンスオーバーヘッドを発生させないために、各プラットフォームに特化したツールを使用して、JVMアプリケーションの総RSSを測定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Linux</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Linux</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The linux https://linux.die.net/man/1/pmap[pmap] and https://linux.die.net/man/1/ps[ps] tools provide a report on the native memory map for a process</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Linux の link:https://linux.die.net/man/1/pmap[pmap] と link:https://linux.die.net/man/1/ps[ps] ツールはプロセスのネイティブメモリーマップのレポートを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Memory region that has been allocated for the process is listed;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロセスに割り当てられた各メモリー領域が一覧表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kbytes: Size (kilobytes) of virtual address space reserved for region</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kbytes(キロバイト): リージョン用に予約された仮想アドレス空間のサイズ (キロバイト)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RSS:     Resident set size (kilobytes).  This is the measure of how much memory space is actually being used
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RSS: 常駐セットサイズ(キロバイト)。これは、実際に使用されているメモリー領域の量を示す指標です。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dirty:   dirty pages (both shared and private) in kilobytes
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dirty: ダーティなページ (共有およびプライベートの両方) をキロバイト単位で表示します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mode:    Access mode for memory region
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モード: メモリー領域のアクセスモード
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping: Includes application regions and Shared Object (.so) mappings for process
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マッピング: プロセス用のアプリケーション領域と共有オブジェクト(.so)のマッピングを含む
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Total RSS (kB) line reports the total native memory the process is using.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Total RSS (kB)行は、プロセスが使用しているネイティブメモリーの合計を報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>macOS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>macOS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, you can use `ps x -o pid,rss,command -p &lt;PID&gt;` which list the RSS for a given process in KB (1024 bytes).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>macOSでは、特定のプロセスのRSSをKB(1024バイト)単位で一覧表示する `ps x -o pid,rss,command -p &lt;PID&gt;` を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which means IntelliJ IDEA consumes 281,8 MB of resident memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>つまり、IntelliJ IDEAは281,8MBのRSSを消費していることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do we measure startup time</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動時間の測定方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some frameworks use aggressive lazy initialization techniques.  It is important to measure the startup time to first request to most accurately reflect how long a framework needs to start.  Otherwise, you will miss the time the framework _actually_ takes to initialize.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フレームワークの中には、アグレッシブな遅延初期化技術を使用しているものがあります。フレームワークを開始するために必要な時間を最も正確に反映させるために、最初のリクエストまでの起動時間を測定することが重要です。そうしないと、フレームワークが _実際に_ 初期化にかかる時間を見逃してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how we measure startup time in our tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、テストでの起動時間の測定方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create a sample application that logs timestamps for certain points in the application lifecycle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのライフサイクルの特定のポイントのタイムスタンプをログに記録するサンプルアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We start looping in a shell, sending requests to the rest endpoint of the sample application we are testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちはシェル内でループを開始し、テストしているサンプルアプリケーションのRESTエンドポイントにリクエストを送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separate terminal, we start the timing application that we are testing, printing the time the application starts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルで、テストしているタイミングアプリケーションを起動し、アプリケーションが起動した時刻を印刷します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The difference between the final timestamp and the first timestamp is the total startup time for the application to serve the first request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最終タイムスタンプと最初のタイムスタンプの差は、アプリケーションが最初のリクエストにサービスを提供するまでの総起動時間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus invokes GraalVM `native-image` it will apply some additional flags by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusがGraalVM `native-image` を起動すると、 デフォルトでいくつかの追加フラグが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to know about the following ones in case you're comparing performance properties with other builds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のビルドと性能特性を比較する場合には、以下のようなものを知っておいた方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable fallback images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールバックイメージの無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fallback native images are a feature of GraalVM to "fall back" to run your application in the normal JVM, should the compilation to native code fail for some reason.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールバックネイティブイメージは、何らかの理由でネイティブコードへのコンパイルに失敗した場合に、アプリケーションを通常のJVMで実行するために「フォールバック」するためのGraalVMの機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus disables this feature by setting `-H:FallbackThreshold=0`: this will ensure you get a compilation failure rather risking to not notice that the application is unable to really run in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `-H:FallbackThreshold=0` を設定することでこの機能を無効にします。これにより、アプリケーションが本当にネイティブモードで実行できないことに気づかないリスクの代わりに、コンパイルに失敗するように出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you instead want to just run in Java mode, that's totally possible: just skip the native-image build and run it as a jar.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりに Java モードで実行したい場合は、ネイティブイメージのビルドをスキップして jar として実行することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable Isolates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離の無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Isolates are a neat feature of GraalVM, but Quarkus isn't using them at this stage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離はGraalVMの優れた機能ですが、Quarkusは現段階では使用していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable via `-H:-SpawnIsolates`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-H:-SpawnIsolates` で無効化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable auto-registration of all Service Loader implementations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのサービスローダー実装の自動登録の無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions can automatically pick the right services they need, while GraalVM's native-image defaults to include all services it's able to find on the classpath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのエクステンションでは、必要なサービスを自動的に選択することができますが、GraalVMのネイティブイメージのデフォルトでは、クラスパス上で見つけることができるすべてのサービスが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We prefer listing services explicitly as it produces better optimised binaries. Disable it as well by setting `-H:-UseServiceLoaderFeature`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスを明示的にリストアップした方が最適化されたバイナリーが生成されるので好ましいです。 `-H:-UseServiceLoaderFeature` により、無効化することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Better default for Garbage Collection implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ガベージコレクション実装のためのより良いデフォルト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default in GraalVM seems meant to optimise for short lived processes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMのデフォルト値は、短命なプロセスに最適化することを意図しているようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus defaults to server applications, so we switch to a better default by setting
 `-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime`.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのデフォルトはサーバーアプリケーションになっているので、 `-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime` によってより良いデフォルト値に切り替えています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Others ...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section is provided as high level guidance, but can't presume to be comprehensive as some flags are controlled
 dynamically by the extensions, the platform you're building on, configuration details, your code and possibly
 a combination of any of these.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションは高レベルのガイダンスとして提供されていますが、フラグのいくつかはエクステンションや構築しているプラットフォーム、設定の詳細、あなたのコード、そしておそらくこれらの組み合わせによって動的に制御されるため、包括的なものとは考えられません。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally speaking the ones listed here are those most likely to affect performance metrics, but in the right circumstances one could observe non negligible impact from the other flags too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的に言えば、ここに挙げたものはパフォーマンス・メトリクスに影響を与える可能性が高いものですが、適切な状況下では、他のフラグからも無視できないほどの影響を受ける可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're to investigate some differences in detail make sure to check what Quarkus is invoking exactly: when the build plugin is producing a native image, the full command lines are logged.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの差異を詳細に調査する場合は、Quarkusが呼び出しているものを正確にチェックしてください。ビルドプラグインがネイティブイメージを生成しているときには、コマンドライン全体がログに記録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-azure-functions-http` extension allows you to write microservices with RESTEasy (JAX-RS), Undertow (servlet), Vert.x Web, or link:funqy-http[Funqy HTTP] and make these microservices deployable to the Azure Functions runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-azure-functions-http` エクステンションを使うと、RESTEasy (JAX-RS)、Undertow (サーブレット)、Vert.x Web、または link:funqy-http[Funqy HTTP] を使ってマイクロサービスを書き、これらのマイクロサービスをAzure Functionsランタイムにデプロイできるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One azure function deployment can represent any number of JAX-RS, servlet, Vert.x Web, or link:funqy-http[Funqy HTTP] endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1 つの Azure Functions デプロイメントでは、JAX-RS、サーブレット、Vert.x Web、または link:funqy-http[Funqy HTTP] エンドポイントを任意の数だけ代表できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only text based media types are supported at the moment as Azure Functions HTTP Trigger for Java does not support a binary format</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Functions HTTP Trigger for Javaがバイナリ形式をサポートしていないため、現時点ではテキストベースのメディアタイプのみがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://azure.microsoft.com[An Azure Account].  Free accounts work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://azure.microsoft.com[Azureのアカウント]  。無料アカウントでも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through running a Maven Archetype to generate a sample project that contains three http endpoints written with JAX-RS APIs, Servlet APIs, Vert.x Web, or link:funqy-http[Funqy HTTP] APIs.  After building, you will then be able to deploy to Azure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、JAX-RS API、Servlet API、Vert.x Web、または link:funqy-http[Funqy HTTP] APIで記述された3つのHTTPエンドポイントを含むサンプルプロジェクトを生成するために、Maven Archetype のウォークスルーを行います。ビルド後、Azureにデプロイできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the azure maven project for your Quarkus application using our Maven Archetype.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven Archetypeを使用して、Quarkusアプリケーション用の Azure mavenプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running this command will run maven in interactive mode and it will ask you to fill in some build properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドを実行すると、インタラクティブモードでmavenが実行され、いくつかのビルドプロパティーの入力を求められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`groupId` - The maven groupId of this generated project.  Type in `org.acme`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`groupId` - この生成されたプロジェクトの maven グループ ID。 `org.acme` と入力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`artifactId` - The maven artifactId of this generated project. Type in `quarkus-demo`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`artifactId` - この生成されたプロジェクトの maven artifactId。を入力します。 `quarkus-demo` と入力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`version` - Version of this generated project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`version` - この生成されたプロジェクトのバージョン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appName` - Use the default value.  This is the application name in Azure.  It must be a unique subdomain name under `*.azurewebsites.net`. Otherwise deploying to Azure will fail.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`appName` - 既定値を使用します。これは、Azure でのアプリケーション名です。 `*.azurewebsites.net` 以下の一意のサブドメイン名である必要があります。そうしないと、Azure へのデプロイに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appRegion` - Defaults to `westus`.  Dependent on your azure region.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`appRegion` - デフォルトは `westus` です。お使いの azure リージョンに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function` - Use the default which is `quarkus`.  Name of your azure function. Can be anything you want.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`function` - デフォルトの `quarkus` を使用してください。あなたの azure 関数の名前。何でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resourceGroup` - Use the default value.  Any value is fine though.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`resourceGroup` - デフォルト値を使用してください。どんな値でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values above are defined as properties in the generated `pom.xml` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の値は、生成された `pom.xml` ファイルのプロパティーとして定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't login to Azure you won't be able to deploy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azureにログインしないとデプロイできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy to Azure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドと Azure へのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `pom.xml` you generated in the previous step pulls in the `azure-functions-maven-plugin`.  Running maven install generates config files and a staging directory required by the `azure-functions-maven-plugin`.  Here's how to execute it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のステップで生成した `pom.xml` は、 `azure-functions-maven-plugin` .maven install を実行すると、設定ファイルと `azure-functions-maven-plugin` によって必要とされるステージングディレクトリーが生成されます。実行方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you haven't already created your function up at azure, the will build an uber-jar, package it, create the function at Azure, and deploy it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたがまだ Azure で Function を作成していない場合は、uber-jar をビルドしてパッケージ化し、Azure で Function を作成してデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If deployment is a success, the azure plugin will tell you the base URL to access your function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイが成功した場合、azure プラグインは Function にアクセスするためのベース URL を教えてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i.e.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL to access the service would be</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスにアクセスするためのURLは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://{appName}.azurewebsites.net/api/ https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello hello https://{appName}.azurewebsites.net/api/ https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension maven dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのmaven依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The sample project includes the RESTEasy, Undertow, Vert.x Web, link:funqy-http[Funqy HTTP] extensions.  If you are only using one of those APIs (i.e. jax-rs only), respectively remove the maven dependency `quarkus-resteasy`, `quarkus-undertow`, `quarkus-funqy-http`, and/or `quarkus-vertx-web`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルプロジェクトには、RESTEasy、Undertow、Vert.x Web、 link:funqy-http[Funqy HTTP] エクステンションが含まれています。これらのAPIの1つだけを使用している場合(つまりjax-rsのみ)は、`quarkus-resteasy` , `quarkus-undertow` , `quarkus-funqy-http` , , および/または `quarkus-vertx-web` などのそれぞれmavenの依存関係を削除してください </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must include the `quarkus-azure-functions-http` extension as this is a generic bridge between the Azure Functions runtime and the HTTP framework you are writing your microservices in.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-azure-functions-http` エクステンションを含める必要があります。これは、Azure Functions ランタイムとマイクロサービスを書いている HTTP フレームワークの間の一般的なブリッジです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates for Azure Functions deployment descriptors (`host.json`, `function.json`) are within the `azure-config` directory.  Edit them as you need to.  Rerun the build when you are ready.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Functions デプロイメントディスクリプタのテンプレート ( `host.json` , `function.json` ) は、 `azure-config` ディレクトリー内にあります。必要に応じて編集してください。準備ができたらビルドを再実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*NOTE*: If you change the `function.json` `path` attribute or if you add a `routePrefix`,
your jax-rs endpoints won't route correctly.  See &lt;&lt;config-azure-paths&gt;&gt; for more information.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*注* : `function.json` `path` 属性を変更したり、 `routePrefix` を追加したりすると、jax-rs エンドポイントは正しくルーティングされません。詳細は link:#config-azure-paths[[config-azure-paths] ] を参照してください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Root Paths</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルートパスの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default route prefix for an Azure Function is `/api`.  All of your JAX-RS, Servlet, Vert.x Web, and link:funqy-http[Funqy HTTP] endpoints must explicitly take this into account.  In the generated project this is handled by the `quarkus.http.root-path` switch in `application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Function のデフォルトのルートプレフィックスは `/api` です。すべてのJAX-RS、サーブレット、Vert.x Web、および link:funqy-http[Funqy HTTP] エンドポイントは、これを明示的に考慮しなければなりません。生成されたプロジェクトでは、これは `application.properties` の `quarkus.http.root-path` スイッチで制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you modify the `path` or add a `routePrefix` within the `azure-config/function.json` deployment descriptor, your code or configuration must also reflect any prefixes you specify for your path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`path` を変更したり、 `azure-config/function.json` デプロイメントディスクリプタ内に `routePrefix` を追加したりする場合、コードや設定にはパスに指定した接頭辞も反映させる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto standard JPA implementation and offers you the full breadth of an Object Relational Mapper.  It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMは、デファクトスタンダートなJPA実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。これはQuarkusで美しく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Hibernate ORM in Quarkus, you don't need to have a `persistence.xml` resource to configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusでHibernate ORMを使用する場合は、 設定の為に `persistence.xml` リソースは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a classic configuration file is an option, but unnecessary unless you have specific advanced needs; so we'll see first how Hibernate ORM can be configured without a `persistence.xml` resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような古典的な設定ファイルを使用することは選択肢として存在しますが、特定の高度なニーズがない限り不要です。そのため、まずはHibernate ORMを `persistence.xml` リソース無しで設定できることをみていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your configuration settings in `{config-file}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{config-file}` に設定を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>annotate your entities with `@Entity` and any other mapping annotation as usual</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティーに `@Entity` やその他のマッピングアノテーションを通常通りにアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other configuration needs have been automated: Quarkus will make some opinionated choices and educated guesses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の設定の必要性は自動化されています。Quarkusは、いくつかの定見に基づいた選択と経験に基づいた推測を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependencies to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の依存関係をプロジェクトに追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Hibernate ORM extension: `io.quarkus:quarkus-hibernate-orm`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM エクステンション: `io.quarkus:quarkus-hibernate-orm`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension; the following options are available:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC ドライバーエクステンション。以下のオプションを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-db2` for link:https://www.ibm.com/products/db2-database[IBM DB2]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.ibm.com/products/db2-database[IBM DB2の] ための `quarkus-jdbc-db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-derby` for link:https://db.apache.org/derby/[Apache Derby]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://db.apache.org/derby/[アパッチダービー] のための `quarkus-jdbc-derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-h2` for link:https://www.h2database.com/html/main.html[H2]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.h2database.com/html/main.html[H2] のための `quarkus-jdbc-h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-mariadb` for link:https://mariadb.com/[MariaDB]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://mariadb.com/[MariaDB] のための `quarkus-jdbc-mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-mssql` for link:https://www.microsoft.com/en-gb/sql-server/[Microsoft SQL Server]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.microsoft.com/en-gb/sql-server/[Microsoft SQL Server] のための `quarkus-jdbc-mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-mysql` for link:https://www.mysql.com/[MySQL]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.mysql.com/[MySQL] のための `quarkus-jdbc-mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-oracle` for link:https://www.oracle.com/database/[Oracle Database]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.oracle.com/database/[Oracle Database] のための `quarkus-jdbc-oracle`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-postgresql` for link:https://www.postgresql.org/[PostgreSQL]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.postgresql.org/[PostgreSQL] のための `quarkus-jdbc-postgresql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotate your persistent objects with `@Entity`, then add the relevant configuration properties in `{config-file}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>persistent オブジェクトに`@Entity` アノテーションを付けてから、 `{config-file}` で関連する設定プロパティーを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example `{config-file}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例 `{config-file}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject your entity manager and have fun</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティーマネージャーを注入して楽しむ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To load SQL statements when Hibernate ORM starts, add an `import.sql` file to the root of your resources directory.  This script can contain any SQL DML statements.  Make sure to terminate each statement with a semicolon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMの起動時にSQL文をロードするには、 `import.sql` ファイルをresourcesディレクトリーのルートに追加します。このスクリプトには、任意のSQL DML文を含めることができます。各ステートメントは必ずセミコロンで終了させてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to have a data set ready for your tests or demos.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストやデモ用のデータセットを用意しておくと便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction. Marking a CDI bean method `@Transactional` will do that for you and make that method a transaction boundary. We recommend doing so at your application entry point boundaries like your REST endpoint controllers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースを変更するメソッド (例: `entity.persist()` ) をトランザクション内でラップするようにしてください。CDI Beanメソッド `@Transactional` をマークすることで、それを実現出来、そのメソッドをトランザクションの境界に出来ます。REST エンドポイントコントローラーのように、アプリケーションのエントリーポイントの境界でこれを行うことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration properties listed here allow you to override such defaults, and customize and tune various aspects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここに記載されている設定プロパティーでは、このようなデフォルトを上書きしたり、様々な面をカスタマイズしたり調整したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start a non-durable empty database: ideal for a quick experiment!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、永続化されない空のデータベースを起動します。簡単な実験に最適です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple persistence units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の永続性ユニット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up multiple persistence units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の永続化ユニットの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to define multiple persistence units using the Quarkus configuration properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの設定プロパティーを使用して、複数の永続化ユニットを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a datasource named `users`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`users` という名前のデータソースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a datasource named `inventory`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`inventory` という名前のデータソースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a persistence unit called `users`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`users` という永続化ユニットを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the datasource used by the persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>永続性ユニットが使用するデータソースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration property is important but we will discuss it a bit later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定プロパティーは重要ですが、後ほど少し説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attaching model classes to persistence units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モデルクラスを永続化ユニットにアタッチする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to attach model classes to persistence units, and they should not be mixed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モデルクラスを永続化ユニットにアタッチする方法は2つあり、混在してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Via the `packages` configuration property;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`packages` 設定プロパティーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration snippet will create two persistence units:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定スニペットは、2つの永続化ユニットを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Panache entities can be attached to only one persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panacheエンティティーは、1つの永続化ユニットにのみアタッチできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will inject the `EntityManager` of the default persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、デフォルトの永続化ユニットの `EntityManager` を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining entities in external projects or jars</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>外部プロジェクトや jar でエンティティーを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM in Quarkus relies on compile-time bytecode enhancements to your entities. If you define your entities in the same project where you build your Quarkus application, everything will work fine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのHibernate ORMは、エンティティーに対するコンパイル時のバイトコード強化に依存しています。Quarkusアプリケーションを構築するのと同じプロジェクトでエンティティーを定義すれば、すべてがうまく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the entities come from external projects or jars, you can make sure that your jar is treated like a Quarkus application library by adding an empty `META-INF/beans.xml` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティーが外部のプロジェクトやジャーから来ている場合は、空の `META-INF/beans.xml` ファイルを追加することで、jarがQuarkusアプリケーションライブラリのように扱われるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will allow Quarkus to index and enhance your entities as if they were inside the current project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、Quarkusは、エンティティーが現在のプロジェクトの内部にあるかのようにインデックスを作成し、強化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM in development mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでのHibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM in production mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番モードでのHibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with default profiles (`dev`, `test` and `prod`).  And you can add your own custom profiles to describe various environments (`staging`, `prod-us`, etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusにはデフォルトのプロファイルが付属しています ( `dev` , `test` と `prod` )。また、様々な環境を記述するために独自のカスタムプロファイルを追加することができます ( `staging` , `prod-us` , など )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate ORM Quarkus extension sets some default configurations differently in dev and test modes than in other environments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM Quarkusエクステンションでは、いくつかのデフォルト設定が、開発モードとテストモードで他の環境とは異なるように設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.sql-load-script` is set to `no-file` for all profiles except the `dev` and `test` ones.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`dev` と `test` 以外のプロフィールは `quarkus.hibernate-orm.sql-load-script` が `no-file` に設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override it in your `application.properties` explicitly (e.g. `%prod.quarkus.hibernate-orm.sql-load-script = import.sql`)  but we wanted you to avoid overriding your database by accident in prod :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーが `application.properties` で明示的にオーバーライドすることもできますが (例: `%prod.quarkus.hibernate-orm.sql-load-script = import.sql` )、prod で誤ってデータベースをオーバーライドしないようにしたいと思いました :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Speaking of, make sure to not drop your database schema in production! Add the following in your properties file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そういえば、本番ではデータベーススキーマを落とさないようにしましょう!プロパティーファイルに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching of entities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティーのキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable second-level cache, mark the entities that you want cached with `@javax.persistence.Cacheable`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第 2 レベルのキャッシュを有効にするには、キャッシュしたいエンティティーを `@javax.persistence.Cacheable` でマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an entity is annotated with `@Cacheable`, all its field values are cached except for collections and relations to other entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティーが `@Cacheable` でアノテーションされているときは、コレクションと他のエンティティーとの関係を除いて、そのすべてのフィールド値がキャッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching of collections and relations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コレクションとリレーションのキャッシング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching of queries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリのキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Queries can also benefit from second-level caching. Cached query results can be returned immediately to the caller, avoiding to run the query on the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリは、第二レベルのキャッシュの恩恵を受けることもできます。キャッシュされたクエリの結果は即座に呼び出し元に返すことができるので、データベース上でクエリを実行する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful as this implies the results might not reflect recent changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最近の変化を反映していない可能性があることを含意しているので注意が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To cache a query, mark it as cacheable on the `Query` instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリをキャッシュするには、 `Query` インスタンス上でキャッシュ可能なものとしてマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tuning of Cache Regions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュ領域の調整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limitations of Caching</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシングの制限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The caching technology provided within Quarkus is currently quite rudimentary and limited.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusで提供されているキャッシング技術は、現在のところ非常に初歩的で限られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Envers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Envers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Envers extension to Hibernate ORM aims to provide an easy auditing / versioning solution for entity classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMのEnversエクステンションは、エンティティークラスのための簡単な監査/バージョン管理ソリューションを提供することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, Envers has a dedicated Quarkus Extension `io.quarkus:quarkus-hibernate-envers`; you just need to add this to your project to start using it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、Enversには専用のQuarkus Extensionがあります。 `io.quarkus:quarkus-hibernate-envers` ; これをプロジェクトに追加して使用を開始する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either link:micrometer[Micrometer] or link:microprofile-metrics[SmallRye Metrics] are capable of exposing metrics that Hibernate ORM collects at runtime. To enable exposure of Hibernate metrics on the `/q/metrics` endpoint, make sure your project depends on a metrics extension and set the configuration property `quarkus.hibernate-orm.metrics.enabled` to `true`.  When using link:microprofile-metrics[SmallRye Metrics], metrics will be available under the `vendor` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:micrometer[Micrometer] または link:microprofile-metrics[SmallRye Metrics] は、Hibernate ORM が実行時に収集するメトリクスを公開することができます。 `/q/metrics` エンドポイントで Hibernate メトリクスを公開できるようにするには、プロジェクトがメトリクスエクステンションに依存していることを確認し、設定プロパティー `quarkus.hibernate-orm.metrics.enabled` を `true` に設定します。 link:microprofile-metrics[SmallRye Metrics] を使用すると、メトリクスは `vendor` スコープの下で利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limitations and other things you should know</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制限事項など知っておくべきこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does not modify the libraries it uses; this rule applies to Hibernate ORM as well: when using this extension you will mostly have the same experience as using the original library.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは使用するライブラリを変更しません。このルールはHibernate ORMにも適用されます。このエクステンションを使用すると、元のライブラリを使用した場合とほとんど同じエクスペリエンスが得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic build time enhancement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自動ビルド時間の強化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This limitation might be removed in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この制限は将来的に削除される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自動統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction Manager integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクション・マネージャーの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connection pool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>接続プール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second Level Cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セカンドレベルキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limitations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制約事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Binding the Session to ThreadLocal context</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セッションをThreadLocalコンテキストにバインドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other notable differences</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の特記すべき相違点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Format of `import.sql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`import.sql` のフォーマット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure your datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datasource configuration is extremely simple, but is covered in a different guide as technically it's implemented by the Agroal connection pool extension for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースの設定は非常にシンプルですが、技術的にはQuarkus用のAgroal接続プールエクステンションによって実装されているため、別のガイドで説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jump over to link:datasource[Quarkus - Datasources] for all details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての詳細については、 link:datasource[Quarkus - データソース] にジャンプしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multitenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチテナンシー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"マルチテナンシーという用語は、一般的にソフトウェア開発に適用され、アプリケーションの単一の実行中のインスタンスが同時に複数のクライアント(テナント)にサービスを提供するアーキテクチャを示しています。これはSaaSソリューションでは非常に一般的です。様々なテナントに関連する情報(データ、カスタマイズなど)を分離することは、これらのシステムでは特別な課題です。これには、データベースに格納されている各テナントが所有するデータも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは現在、 link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[分離型データベース] と link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[分離型スキーマ] アプローチをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは `/{tenant}` エンドポイントを実装してみましょう。下のソースコードを見るとわかるように、これは通常の JAX-RS リソースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the Flyway SQL (`V1.0.0__create_fruits.sql`) to be created in the configured folder `src/main/resources/schema`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、設定されたフォルダー `src/main/resources/schema` に作成される Flyway SQL ( `V1.0.0__create_fruits.sql` ) の例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DATABASE approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースアプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every tenant you need to create a named data source with the same identifier that is returned by the `TenantResolver`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのテナントに対して、 `TenantResolver` が返すのと同じ識別子を持つ名前付きデータソースを作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following are examples of the Flyway SQL files to be created in the configured folder `src/main/resources/database`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、設定されたフォルダー `src/main/resources/database` に作成する Flyway SQL ファイルの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default schema (`src/main/resources/database/default/V1.0.0__create_fruits.sql`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトスキーマ ( `src/main/resources/database/default/V1.0.0__create_fruits.sql` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mycompany schema (`src/main/resources/database/mycompany/V1.0.0__create_fruits.sql`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mycompany schema (`src/main/resources/database/mycompany/V1.0.0__create_fruits.sql`):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically Resolving Tenants Connections</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テナント接続をプログラムで解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `kubernetes-client` extension which enables the use of the https://github.com/fabric8io/kubernetes-client[Fabric8 Kubernetes Client] in native mode while also making it easier to work with.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、 link:https://github.com/fabric8io/kubernetes-client[Fabric8 Kubernetesクライアント] をネイティブモードで使用できるようにする `kubernetes-client` エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having a Kubernetes Client extension in Quarkus is very useful in order to unlock the power of Kubernetes Operators.  Kubernetes Operators are quickly emerging as a new class of Cloud Native applications.  These applications essentially watch the Kubernetes API and react to changes on various resources and can be used to manage the lifecycle of all kinds of complex systems like databases, messaging systems and much much more.  Being able to write such operators in Java with the very low footprint that native images provide is a great match.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes Operatorsのパワーを引き出すためには、QuarkusにKubernetesクライアントエクステンションがあると非常に便利です。Kubernetes Operatorsは、クラウドネイティブアプリケーションの新しい種類として急速に台頭してきています。これらのアプリケーションは、基本的にKubernetes APIを監視し、様々なリソースの変更に反応し、データベースやメッセージングシステムなど、あらゆる種類の複雑なシステムのライフサイクルを管理するために使用することができます。ネイティブイメージが提供する非常に低いフットプリントで、このようなOperatorをJavaで書くことができるということは、非常にマッチしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `kubernetes-client` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで次のコマンドを実行して、 `kubernetes-client` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus configures a Bean of type `KubernetesClient` which can be injected into application code using the well known CDI methods.  This client can be configured using various properties as can be seen in the following example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、よく知られたCDIメソッドを使用してアプリケーションコードに注入できる `KubernetesClient` タイプのBeanを設定します。このクライアントは、以下の例にあるように、さまざまなプロパティーを使用して設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the full list of properties is available in the https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーの完全なリストは、 link:https://github.com/quarkusio/quarkus/blob/master/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] クラスで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overriding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension also allows application code to override either of `io.fabric8.kubernetes.client.Config` or `io.fabric8.kubernetes.client.KubernetesClient` which are normally provided by the extension by simply declaring custom versions of those beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、このエクステンションでは、アプリケーションコードは、単にそれらのBeanのカスタムバージョンを宣言することで、通常はエクステンションによって提供される `io.fabric8.kubernetes.client.Config` や `io.fabric8.kubernetes.client.KubernetesClient` のいずれかをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of this can be seen in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例は、次のスニペットの通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make testing against a mock Kubernetes API extremely simple, Quarkus provides the `WithKubernetesTestServer` annotation which automatically launches a mock of the Kubernetes API server and sets the proper environment variables needed so that the Kubernetes Client configures itself to use said mock.  Tests can inject the mock server and set it up in any way necessary for the particular testing using the `@KubernetesTestServer` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モックのKubernetes APIに対するテストを非常に簡単にするために、Quarkusでは、Kubernetes APIサーバーのモックを自動的に起動し、Kubernetesクライアントがそのモックを使用するように設定するために必要な適切な環境変数を設定する `KubernetesMockServerTestResource` を提供しています。テストは、 `@MockServer` アノテーションを使用して、特定のテストに必要な方法でモックを注入し、設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's assume we have a REST endpoint defined like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようにRESTエンドポイントが定義されているとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We could write a test for this endpoint very easily like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエンドポイントのテストは次のように簡単に書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that to take advantage of these features, the `quarkus-test-kubernetes-client` dependency needs to be added, for example like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの機能を利用するには、例えば次のように `quarkus-test-kubernetes-client` 依存関係を追加する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternately, you can create a `CustomKubernetesMockServerTestResource.java` to ensure all your `@QuarkusTest` enabled test classes share the same mock server setup:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CustomKubernetesMockServerTestResource.java` を作成して、 `@QuarkusTest` を有効にしたすべてのテストクラスが同じモックサーバー設定を共有できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and use this in your other test classes as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、これを次のように他のテストクラスで使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, to get a mock server that replies with empty lists by default (instead of getting 404 responses from the Kubernetes API), you can use the `EmptyDefaultKubernetesMockServerTestResource.class` instead of `KubernetesMockServerTestResource.class`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、デフォルトで空のリストで応答するモックサーバーを取得するには(Kubernetes APIから404の応答を取得するのではなく)、 `KubernetesMockServerTestResource.class` の代わりに `EmptyDefaultKubernetesMockServerTestResource.class` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that defining the generic type via a class hierarchy similar to the following example will also work correctly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例のようにクラス階層を介してジェネリック型を定義した場合も、正しく動作することに注目してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example will **not** work in native mode because the generic type of watcher cannot be determined by looking at the class and method definitions thus making Quarkus unable to properly determine the Kubernetes model class for which reflection registration is needed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例では、クラスやメソッドの定義を見てウォッチャーのジェネリック型を判断できないため、Quarkusはリフレクション登録が必要なKubernetesモデルクラスを適切に判断できないため、ネイティブモードでは動作 *しません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In many cases in order to access the Kubernetes API server a `ServiceAccount`, `Role` and `RoleBinding` will be necessary.  An example that allows listing all pods could look something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くの場合、Kubernetes API サーバーにアクセスするには `ServiceAccount` 、 `Role` 、 `RoleBinding` が必要になります。すべてのPodをリスト可能な例は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace `&lt;applicationName&gt;` and `&lt;namespace&gt;` with your values.  Have a look at https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[Configure Service Accounts for Pods] to get further information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;applicationName&gt;` と `&lt;namespace&gt;` は値に置き換えてください。 link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[PodのService Accountの設定] を参照して、詳細な情報を入手してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the targeted Kubernetes cluster is an OpenShift cluster, it is possible to access it through the `openshift-client` extension, in a similar way. This leverages the dedicated fabric8 openshift client, and provides access to `OpenShift` proprietary objects (e.g. `Route`, `ProjectRequest`, `BuildConfig` ...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>対象となるKubernetesクラスターがOpenShiftクラスターであれば、同様の方法で、 `openshift-client` エクステンションを利用してアクセスすることが可能です。これは専用の fabric8 openshift クライアントを利用し、 `OpenShift` 固有のオブジェクト(例: `Route` , `ProjectRequest` , `BuildConfig` ...)へのアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the configuration properties are shared with the `kubernetes-client` extension. In particular they have the same `quarkus.kubernetes-client` prefix.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定プロパティーは `kubernetes-client` エクステンションと共有されていることに注意してください。特に、これらは同じ `quarkus.kubernetes-client` プレフィックスを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the extension with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコマンドでエクステンションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `openshift-client` extension has a dependency on the `kubernetes-client` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`openshift-client` エクステンションは `kubernetes-client` エクステンションに依存していることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the client, inject an `OpenShiftClient` instead of the `KubernetesClient`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントを使用するには、 `KubernetesClient` の代わりに `OpenShiftClient` を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to override the default `OpenShiftClient`, provide a producer such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの `OpenShiftClient` を上書きする必要がある場合は、次のようなプロデューサーを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock support is also provided in a similar fashion:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モックサポートも同様の方法で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, you have to add a dependency on `quarkus-test-openshift-client`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能を使用するには、 `quarkus-test-openshift-client` に依存関係を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCを始める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This page explains how to start using gRPC in your Quarkus application.  While this page describes how to configure it with Maven, it is also possible to use Gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このページでは、QuarkusアプリケーションでgRPCを使い始める方法を説明します。このページではMavenでの設定方法を説明していますが、Gradleを使用することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].  The default configuration is enough, but you can also select some extensions if you want.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、 link:https://code.quarkus.io[Quarkusプロジェクトジェネレータ] から生成された通常のQuarkusプロジェクトを想像してみましょう。デフォルトの設定で十分ですが、必要に応じていくつかのエクステンションを選択することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `pom.xml` file to add the Quarkus gRPC extension dependency (just under `&lt;dependencies&gt;`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` ファイルを編集して、Quarkus gRPCエクステンションの依存関係を追加します( `&lt;dependencies&gt;` のすぐ下)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have `generate-code` goal of `quarkus-maven-plugin` enabled in your `pom.xml`.  If you wish to generate code from different `proto` files for tests, also add the `generate-code-tests` goal.  Please note that no additional task/goal is required for the Gradle plugin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` で `generate-code` ゴールの `quarkus-maven-plugin` が有効になっていることを確認してください。テスト用に異なる `proto` ファイルからコードを生成したい場合は、 `generate-code-tests` ゴールも追加してください。Gradleプラグインに追加のタスク/ ゴールは必要ないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this configuration, you can put your service and message definitions in the `src/main/proto` directory.  `quarkus-maven-plugin` will generate Java files from your `proto` files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定では、サービスとメッセージの定義を `src/main/proto` ディレクトリーに置くことができます。 `quarkus-maven-plugin` は、 `proto` ファイルから Java ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-maven-plugin` retrieves a version of `protoc` (the protobuf compiler) from Maven repositories. The retrieved version matches your operating system and CPU architecture.  If this retrieved version does not work in your context, you can download the suitable binary and specify the location via `-Dquarkus.grpc.protoc-path=/path/to/protoc`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-maven-plugin` は、Maven リポジトリから `protoc` (protobuf コンパイラ)のバージョンを取得します。取得されたバージョンは、お使いのオペレーティングシステムとCPUアーキテクチャに適合します。この取得したバージョンがあなたのコンテキストで動作しない場合は、適切なバイナリをダウンロードして、 `-Dquarkus.grpc.protoc-path=/path/to/protoc` でその場所を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively to using the `generate-code` goal of the `quarkus-maven-plugin`, you can use `protobuf-maven-plugin` to generate these files, more in &lt;&lt;Generating Java files from proto with protobuf-maven-plugin&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-maven-plugin` の `generate-code` ゴールを使用する代わりに、 `protobuf-maven-plugin` を使用してこれらのファイルを生成することができます。詳細は &lt;&lt;protoファイルからprotobuf-maven-pluginでJavaファイルを生成する&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with a simple _Hello_ service.  Create the `src/main/proto/helloworld.proto` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは簡単な _Hello_ サービスから始めてみましょう。 `src/main/proto/helloworld.proto` ファイルを以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `proto` file defines a simple service interface with a single method (`SayHello`), and the exchanged messages (`HelloRequest` containing the name and `HelloReply` containing the greeting message).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この `proto` ファイルは、単一のメソッド ( `SayHello` ) と交換されたメッセージ (名前を含む `HelloRequest` と挨拶メッセージを含む `HelloReply` ) を持つシンプルなサービスインターフェースを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before coding, we need to generate the classes used to implement and consume gRPC services.  In a terminal, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コーディングの前に、gRPCサービスを実装して消費するためのクラスを生成する必要があります。ターミナルで以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, you can look at the `target/generated-sources/grpc` directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたら、 `target/generated-sources/grpc` ディレクトリーを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the classes we are going to use.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらは、これから使うクラスファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Protocol Buffers specification provides a way to import `proto` files.  The Quarkus code generation mechanism lets you control the scope of dependencies to scan for possible imports by setting the `quarkus.generate-code.grpc.scan-for-imports` property to one of the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Protocol Buffers仕様では、 `proto` ファイルをインポートする方法を提供しています。Quarkusのコード生成メカニズムでは、 `quarkus.generate-code.grpc.scan-for-imports` プロパティーを以下のいずれかに設定することで、インポートの可能性をスキャンするための依存関係の範囲を制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`groupId1:artifactId1,groupId2:artifactId2` - scan only the dependencies with group id and artifact id in the list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`groupId1:artifactId1,groupId2:artifactId2` - リスト内のグループIDとアーティファクトIDを持つ依存関係のみをスキャンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not specified, the property is set to `com.google.protobuf:protobuf-java`.  To override it, set the `quarkus.generate-code.grpc.scan-for-imports` property in your pom.xml (or gradle.properties) to the desired value, e.g.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指定されていない場合、このプロパティーは `com.google.protobuf:protobuf-java` に設定されます。これを上書きするには、pom.xml (または gradle.properties) の `quarkus.generate-code.grpc.scan-for-imports` プロパティーを希望の値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a gRPC service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we have the generated classes let's implement our _hello_ service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたクラスができたので、 _hello_ サービスを実装してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/HelloService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/java/org/acme/HelloService.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the methods defined in the service definition (here we have a single method).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービス定義で定義されたメソッドを実装します(ここでは1つのメソッドを使用しています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extends the `ImplBase` class. This is a generated class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ImplBase` クラスを拡張します。生成されたクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスを閉じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your service implementation logic is blocking (use blocking I/O for example), annotate your method with `@Blocking`.  The `io.smallrye.common.annotation.Blocking` annotation instructs the framework to invoke the annotated method on a worker thread instead of the I/O thread (event-loop).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスの実装ロジックがブロッキングである (例えば、ブロッキング I/O を使用する) 場合には、メソッドに `@Blocking` をアノテーションします。 `io.smallrye.common.annotation.Blocking` アノテーションは、I/O スレッド (イベントループ) の代わりにワーカースレッドでアノテーションされたメソッドを呼び出すようにフレームワークに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gRPC server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The services are _served_ by a _server_.  Available services (_CDI beans_) are automatically registered and exposed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスは _サーバー_ によって _提供されます_ 。利用可能なサービス( _CDIBean_ )は自動的に登録され、公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using: `mvn quarkus:dev`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn quarkus:dev` を使用してアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming a gRPC service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we are going to consume the service we expose.  To simplify, we are going to consume the service from the same application, which in the real world, does not make sense.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、公開しているサービスを消費することにします。簡単に言うと、同じアプリケーションからサービスを消費することになりますが、これは現実の世界では意味がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the existing `org.acme.ExampleResource` class, and edit the content to become:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存の `org.acme.ExampleResource` クラスを開き、内容を編集してこのようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoke the service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the application to indicate where the `hello` service is found.  In the `src/main/resources/application.properties` file, add the following property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`hello` サービスがどこにあるかを示すようにアプリケーションを構成する必要があります。 `src/main/resources/application.properties` ファイルで、以下のプロパティーを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`host` configures the service host (here it's localhost).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`host` はサービスホストを設定します (ここでは localhost)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open http://localhost:8080/hello/quarkus in a browser, and you should get `Hello quarkus`!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、ブラウザで http://localhost:8080/hello/quarkus を開くと、 `Hello quarkus` と表示されるはずです!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like any other Quarkus applications, you can package it with: `mvn package`.  You can also package the application into a native executable with: `mvn package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のQuarkusアプリケーションと同様に、 `mvn package` でパッケージングすることができます。また、 `mvn package -Pnative` でアプリケーションをネイティブの実行ファイルにパッケージングすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating Java files from proto with protobuf-maven-plugin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>protoファイルからprotobuf-maven-pluginでJavaファイルを生成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively to using Quarkus code generation to generate stubs for `proto` files, you can also use `protobuf-maven-plugin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのコード生成を使用して `proto` ファイルのスタブを生成する代わりに、 `protobuf-maven-plugin` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do it, first define the 2 following properties in the `&lt;properties&gt;` section:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのためには、まず `&lt;properties&gt;` セクションで以下の 2 つのプロパティーを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They configure the gRPC version and the `protoc` version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらは gRPC のバージョンと `protoc` のバージョンを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `build` セクションに `os-maven-plugin` のエクステンションと `protobuf-maven-plugin` の設定を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービス定義( `proto` ファイル)からスタブクラスを生成する `protobuf-maven-plugin`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class generation uses a tool named `protoc`, which is OS-specific.  That's why we use the `os-maven-plugin` to target the executable compatible with the operating system.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラス生成には、OS固有の `protoc` というツールを使用しています。そのため、OSと互換性のある実行ファイルを対象に `os-maven-plugin` を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration instructs the `protobuf-maven-plugin` to generate the default gRPC classes and classes using Mutiny to fit with the Quarkus development experience.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定は、Quarkusの開発経験に合わせてMutinyを使用してデフォルトのgRPCクラスとクラスを生成するように、 `protobuf-maven-plugin` に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `protobuf-maven-plugin`, instead of the `quarkus-maven-plugin`, every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-maven-plugin` の代わりに `protobuf-maven-plugin` を利用する場合、 `proto` ファイルを更新するたびに、( `mvn compile` を使用して) クラスを再生成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Spring Boot `@ConfigurationProperties` annotated class to access application properties instead of a Quarkus native `@ConfigProperties` or a MicroProfile `@ConfigProperty` approach, you can do that with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusネイティブの `@ConfigProperties` や MicroProfile `@ConfigProperty` のアプローチではなく、Spring Boot `@ConfigurationProperties` アノテーションクラスを使用してアプリケーションのプロパティーにアクセスしたい場合は、このエクステンションを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GreetingController</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GreetingController</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Maven plugin automatically generated a `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Mavenプラグインは、 `src/main/java/org/acme/spring/boot/properties/GreetingResource.java` ファイルに以下のような `GreetingResource` JAX-RSリソースを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify that application still functions correctly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストを実行して、アプリケーションがまだ正常に機能していることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを実行するには、次の手順を実行します: `./mvnw compile quarkus:dev` 。ブラウザで http://localhost:8080/greeting を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定ファイルの変更はすぐに反映されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default values</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go ahead and add the new field to the `GreetingProperties` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingProperties` クラスに新しいフィールドを追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And update the `GreetingResource` and its test `GreetingResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `GreetingResource` とそのテスト `GreetingResourceTest` を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the tests to verify the change.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストを実行して変更を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grouping properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーのグループ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のSpringガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、より多くのSpring互換機能があります。詳細については、以下のガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Micrometer metrics library for runtime and application metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがランタイムメトリクスとアプリケーションメトリクスのためにMicrometerメトリクスライブラリを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports built-in metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで説明されているアプリケーション固有のメトリクスとは別に、Quarkusのさまざまなエクステンションによって公開されているビルトインメトリクスを利用することもできます。これらについては、ビルトインメトリクスをサポートしている各エクステンションのガイドで説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer is the recommended approach to metrics for Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometerは、Quarkusのメトリクスとして推奨されるアプローチです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the git repository: `git clone {quickstarts-clone-url}`, or</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-archive-url}[アーカイブ] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micrometer extensions are structured similarly to Micrometer itself: `quarkus-micrometer` provides core micrometer support and runtime integration and other Quarkus and Quarkiverse extensions bring in additional dependencies and requirements to support specific monitoring systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus MicrometerエクステンションはMicrometer 自身と同様に構成されています。`quarkus-micrometer` はコア micrometer サポートとランタイム統合を提供し、その他のQuarkus、Quarkiverse エクステンションは特定のモニタリングシステムをサポートするための追加の依存関係や要件を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this example, we'll use the Prometheus registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、Prometheus のレジストリを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.  This extension will load the core `micrometer` extension as well as additional library dependencies required to support prometheus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、 `micrometer-registry-prometheus` エクステンションを依存関係としてインポートする Maven プロジェクトを生成します。このエクステンションは、 `micrometer` エクステンションだけでなく、 Prometheus をサポートするために必要な追加のライブラリ依存関係もロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `micrometer-registry-prometheus` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `micrometer-registry-prometheus` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gauges</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ゲージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gauges measure a value that can increase or decrease over time, like the speedometer on a car. Gauges can be useful when monitoring the statistics for a cache or collection. Consider the following simple example that observes the size of a list:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ゲージは、車のスピードメーターのように、時間の経過とともに増えたり減ったりする値を測定するものです。ゲージは、キャッシュやコレクションの統計情報を監視する際に便利です。次の簡単な例では、リストのサイズを監視しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Compile and run the app in dev mode:
./mvnw compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Compile and run the app in dev mode:
./mvnw compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カウンター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># If you did not leave quarkus running in dev mode, start it again:
./mvnw compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># If you did not leave quarkus running in dev mode, start it again:
./mvnw compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summaries and Timers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サマリーとタイマー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To view metrics, execute `curl localhost:8080/q/metrics/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メトリクスを表示するには、 `curl localhost:8080/q/metrics/` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that metrics appear lazily, you often won't see any data for your endpoint until something tries to access it, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メトリクスは遅延的に表示され、何かがアクセスしようとするまでエンドポイントのデータが表示されないことが多いことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignoring endpoints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントの無視</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.  The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry` instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometerは `MeterFilter` インスタンスを使って、 `MeterRegistry` インスタンスが出力するメトリクスをカスタマイズします。 Micrometer エクステンションは、 `MeterFilter` のCDI Beanを検出して、 `MeterRegistry` インスタンスを初期化するときにそれを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does Micrometer support annotations?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometerはアノテーションをサポートしていますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using other Registry implementations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のレジストリ実装の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you aren't using Prometheus, you have a few options. Some Micrometer registry implementations have been wrapped in https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse extensions].  To use the Micrometer StackDriver MeterRegistry, for example, you would use the `quarkus-micrometer-registry-stackdriver` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Prometheusを使用していない場合は、いくつかの選択肢があります。いくつかのMicrometerのレジストリーの実装は、 link:https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverseのエクステンション] でラップされています。たとえば、Micrometer StackDriver MeterRegistryを使用するには、 `quarkiverse-micrometer-registry-stackdriver` エクステンションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Micrometer registry you would like to use does not yet have an associated extension, use the `quarkus-micrometer` extension and bring in the packaged MeterRegistry dependency directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用したい Micrometer レジストリに関連する拡張機能がまだない場合は、 `quarkus-micrometer` エクステンションを使用して、パッケージ化された MeterRegistry の依存関係を直接取り込んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will then need to specify your own provider to configure and initialize the MeterRegistry, as discussed in the next section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、次のセクションで説明するように、MeterRegistry を設定して初期化するために、独自のプロバイダを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a customized MeterRegistry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタマイズされたMeterRegistryの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a custom `@Produces` method to create and configure a customized `MeterRegistry` if you need to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要に応じて、カスタム `@Produces` メソッドを使用して、カスタマイズされた `MeterRegistry` を作成して設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example customizes the line format used for StatsD:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例では、StatsDで使用される行フォーマットをカスタマイズしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example corresponds to the following instructions in the Micrometer documentation: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例は、Micrometerのドキュメントにある以下の指示に対応しています: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the method returns the specific type of `MeterRegistry` as a `@Singleton`. Use MicroProfile Config to inject any configuration attributes you need to configure the registry. Most Micrometer registry extensions, like `quarkus-micrometer-registry-statsd`, define a producer for registry-specific configuration objects that are integrated with the Quarkus configuration model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、 `MeterRegistry` の特定の型を `@Singleton` として返すことに注意してください。レジストリーを設定するために必要な設定属性を注入するには、MicroProfile Configを使用します。 `quarkiverse-micrometer-registry-statsd` のようなほとんどのMicrometerのレジストリーエクステンションでは、Quarkusの設定モデルと統合されたレジストリー固有の設定オブジェクトのプロデューサを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry. Note that naming conventions between the two systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change.  You can use a `MeterFilter` to remap names or tags according to your conventions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションで MicroProfile Metrics API を使用している場合、Micrometer エクステンションは、これらのメトリクスを Micrometer レジストリにマッピングするための適応レイヤーを作成します。2 つのシステム間の命名規則は異なるので、MP MetricsをMicrometerと一緒に使用した場合に出力されるメトリクスは変化します。MeterFilters を使用して名前やタグをダッシュボードが必要とするものに再マッピングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure the following dependency is present in your `pom.xml` file if you require the Microprofile Metrics API:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microprofile Metrics APIを必要とする場合は、 `pom.xml` ファイルに以下の依存関係があることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MP Metrics API compatibility layer will be moved to a different extension in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MP Metrics API互換性レイヤは、将来的には別のエクステンションに移される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kotlinlang.org/[Kotlin] は、JVMをターゲットにした(他の環境を含めても)非常に人気のあるプログラミング言語です。Kotlinはここ数年で人気が急上昇し、Javaを除いて最も人気のあるJVM言語となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Kotlin as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで説明するように、QuarkusはKotlinを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NB: For Gradle project setup please see below, and for further reference consult the guide in the link:gradle-tooling[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注: link:gradle-tooling[Gradle] プロジェクトのセットアップについては以下を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new Kotlin project. This can be done using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、新しいKotlinプロジェクトが必要です。これは以下のコマンドで行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding `kotlin` to the extensions list, the Maven plugin will generate a project that is properly configured to work with Kotlin. Furthermore the `org.acme.rest.GreetingResource` class is implemented as Kotlin source code (as is the case with the generated tests).  The addition of `resteasy-jackson` in the extension list results in importing the RESTEasy/JAX-RS and Jackson extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin` をエクステンションリストに追加すると、Maven プラグインは Kotlin で動作するように適切に設定されたプロジェクトを生成します。さらに、 `org.acme.rest.GreetingResource` クラスは Kotlin ソースコードとして実装されます (生成されたテストも同様です)。エクステンションリストに `resteasy-jackson` を追加すると、RESTEasy/JAX-RS と Jackson エクステンションがインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`GreetingResource.kt` looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingResource.kt` はこのようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to show a more practical example of Kotlin usage we will add a simple link:https://kotlinlang.org/docs/reference/data-classes.html[data class] called `Greeting.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin のより実用的な使用例を示すために、 `Greeting.kt` というシンプルな link:https://kotlinlang.org/docs/reference/data-classes.html[データクラス] を追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also update the `GreetingResource.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingResource.kt` もこのように更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With these changes in place the `/greeting` endpoint will reply with a JSON object instead of a simple String.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの変更により、 `/greeting` エンドポイントは単純な String の代わりに JSON オブジェクトを応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the test pass, we also need to update `GreetingResourceTest.kt` like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストをパスさせるためには、 `GreetingResourceTest.kt` に以下のような更新も必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Important Maven configuration points</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要なMavenの設定ポイント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated `pom.xml` contains the following modifications compared to its counterpart when Kotlin is not selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `pom.xml` には、Kotlin が選択されていない場合と比較して、以下の修正が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-kotlin` artifact is added to the dependencies. This artifact provides support for Kotlin in the live reload mode (more about this later on)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-kotlin` アーティファクトが依存関係に追加されています。このアーティファクトはライブリロードモードでの Kotlin のサポートを提供します (これについては後ほど説明します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-stdlib-jdk8` is also added as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-stdlib-jdk8` も依存関係として追加されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven's `sourceDirectory` and `testSourceDirectory` build properties are configured to point to Kotlin sources (`src/main/kotlin` and `src/test/kotlin` respectively)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven の `sourceDirectory` と `testSourceDirectory` ビルドプロパティーは、Kotlin ソースを指すように設定されています (それぞれ `src/main/kotlin` と `src/test/kotlin` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `kotlin-maven-plugin` is configured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kotlin-maven-plugin` は以下のように設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important thing to note is the use of the https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] Kotlin compiler plugin.  In order to understand why this plugin is needed, first we need to note that by default all the classes generated from the Kotlin compiler are marked as `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意すべき重要なこととして、 link:https://kotlinlang.org/docs/reference/compiler-plugins.html#all-open-compiler-plugin[all-open] Kotlinコンパイラーのプラグインを使用していることです。なぜこのプラグインが必要なのかを理解するためには、まず、Kotlin コンパイラから生成されるクラスはデフォルトで `final` でマークされていることに注目してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having `final` classes however does not work well with various frameworks that need to create https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[Dynamic Proxies].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、 `final` クラスであることは、 link:https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[ダイナミックプロキシー] を作成する必要がある様々なフレームワークではうまく機能しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the `all-open` Kotlin compiler plugin allows us to configure the compiler to *not* mark as `final` classes that have certain annotations. In the snippet above, we have specified that classes annotated with `javax.ws.rs.Path` should not be `final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このように、 `all-open` Kotlin コンパイラプラグインを使うと、特定のアノテーションを持つクラスを `final` としてマークし *ない* ようにコンパイラを設定することができます。上のスニペットでは、 `javax.ws.rs.Path` でアノテーションされたクラスを `final` ではないようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application contains classes annotated with `javax.enterprise.context.ApplicationScoped` for example, then `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` needs to be added as well. Same goes for any class that needs to have a dynamic proxy created at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、アプリケーションに `javax.enterprise.context.ApplicationScoped` のアノテーションが付いたクラスがある場合、 `&lt;option&gt;all-open:annotation=javax.enterprise.context.ApplicationScoped&lt;/option&gt;` も追加する必要があります。実行時にダイナミックプロキシーを作成する必要があるクラスについても同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Future versions of Quarkus will configure the Kotlin compiler plugin in a way that will make it unnecessary to alter this configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの将来のバージョンでは、この設定を変更する必要がないようにKotlinコンパイラプラグインを設定するようになる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Important Gradle configuration points</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要なGradle設定ポイント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the Maven configuration, when using Gradle, the following modifications are required when Kotlin is selected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mavenの設定と同様、Gradleを使用する場合、Kotlinを選択すると以下のような修正が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kotlin plugin is activated, which implicitly adds `sourceDirectory` and `testSourceDirectory` build properties to point to Kotlin sources (`src/main/kotlin` and `src/test/kotlin` respectively)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin プラグインが有効になり、暗黙のうちに `sourceDirectory` と `testSourceDirectory` のビルドプロパティーが追加され、Kotlin ソース (それぞれ `src/main/kotlin` と `src/test/kotlin` ) を指すようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open Kotlin plugin tells the compiler not to mark as final, those classes with the annotations highlighted (customize as required)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>all-open Kotlinプラグインは、アノテーションがハイライトされているクラスを最終的なものとしてマークしないようにコンパイラに指示します (必要に応じてカスタマイズしてください)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native-image, the use of http (or https) protocol(s) must be declared</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージを使用する場合は、http (または https) プロトコルの使用を宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example configuration follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下に設定例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kotlin plugin version needs to be specified.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlinプラグインのバージョンを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The all-open configuration required, as per Maven guide above</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のMavenガイドにあるように、all-open設定が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for live reloading changes made to source code. This support is also available to Kotlin, meaning that developers can update their Kotlin source code and immediately see their changes reflected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、ソースコードに加えられた変更をライブでリロードする機能をサポートしています。このサポートはKotlinでも利用できます。つまり、開発者はKotlinのソースコードを更新して、変更が反映されたことをすぐに確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see this feature in action, first execute: `./mvnw compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能の動作を確認するには、まず次を実行します: `./mvnw compile quarkus:dev`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When executing an HTTP GET request against `http://localhost:8080/greeting`, you see a JSON message with the value `hello` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/greeting` に対して HTTP GET リクエストを実行すると、 `hello` という値を `message` フィールドに持つ JSON メッセージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now using your favorite editor or IDE, update `GreetingResource.kt` and change the `hello` method to the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>好きなエディタやIDEを使って、 `GreetingResource.kt` を更新し、 `hello` の方法を以下のように変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now execute an HTTP GET request against `http://localhost:8080/greeting`, you should see a JSON message with the value `hi` as its `message` field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/greeting` に対して HTTP GET リクエストを実行すると、 `hi` という値を `message` フィールドに持つ JSON メッセージが表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note is that the live reload feature is not available when making changes to both Java and Kotlin source that have dependencies on each other. We hope to alleviate this limitation in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意点としては、お互いに依存関係にあるJavaとKotlinの両方のソースに変更を加えた場合、ライブリロード機能が利用できないということです。将来的にはこの制限を緩和したいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file. You can also build the native executable using `./mvnw package -Pnative`, or `./gradlew buildNative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常通り、 `./mvnw clean package` を使用してアプリケーションをパッケージ化し、 `target/quarkus-app/quarkus-run.jar` ファイルを使用して実行することができます。また、 `./mvnw package -Pnative` 、または `./gradlew buildNative` を使用してネイティブの実行ファイルをビルドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `com.fasterxml.jackson.module:jackson-module-kotlin` dependency and the `quarkus-jackson` extension (or the `quarkus-resteasy-jackson` extension) have been added to the project, then Quarkus automatically registers the `KotlinModule` to the `ObjectMapper` bean (see link:rest-json#jackson[this] guide for more details).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`com.fasterxml.jackson.module:jackson-module-kotlin` 依存関係と `quarkus-jackson` エクステンション(または `quarkus-resteasy-extension` )がプロジェクトに追加されている場合、Quarkus は自動的に `KotlinModule` を `ObjectMapper` Beanに登録します(詳細は link:rest-json#jackson[この] ガイドを参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Kotlin data classes with `native-image` you may experience serialization errors that do not occur with the `JVM` version, despite the Kotlin Jackson Module being registered. This is especially so if you have a more complex JSON hierarchy, where an issue on a lower node causes a serialization failure. The error message displayed is a catch-all and typically displays an issue with the root object, which may not necessarily be the case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin のデータクラスを `native-image` で使用すると、Kotlin Jackson Module が登録されているにもかかわらず、 `JVM` バージョンでは発生しないシリアライズエラーが発生することがあります。これは、より複雑なJSON階層を持っている場合に特に見られる現象で、下位のノードで問題が発生するとシリアライズに失敗します。表示されるエラーメッセージはキャッチオールで、通常はルートオブジェクトの問題を表示しますが、必ずしもそうではない場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ensure full-compability with `native-image`, it is recommended to apply the Jackson `@field:JsonProperty("fieldName")` annotation, and set a nullable default, as illustrated below. You can automate the generation of Kotlin data classes for your sample JSON using Intellij plugins (such as JSON to Kotlin Class), and easily enable the Jackson annotation and select nullable parameters as part of the auto-code generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`native-image` との完全な互換性を確保するためには、Jackson `@field:JsonProperty("fieldName")` アノテーションを適用し、以下の図のように nullable のデフォルトを設定することをお勧めします。Intellijのプラグイン（JSON to Kotlin Classなど）を使用して、サンプルのJSONに対するKotlinデータクラスの生成を自動化し、Jacksonアノテーションを有効にして、自動コード生成の一部としてnullableパラメータを選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin coroutines provide a imperative programming model that actually gets executed in an asynchronous, reactive manner.  To simplify the interoperation between Mutiny and Kotlin there is the module `io.smallrye.reactive:mutiny-kotlin`, described link:https://smallrye.io/smallrye-mutiny/guides/kotlin[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlinのコルーチンは、非同期でリアクティブな方法で実際に実行される命令型プログラミングモデルを提供します。MutinyとKotlinの相互運用を簡単にするために、モジュール `io.smallrye.reactive:mutiny-kotlin` が存在し、 link:https://smallrye.io/smallrye-mutiny/guides/kotlin[ここ] で解説されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin reflection annotation processing differs from Java.  You may experience an error when using CDI @Inject such as: "kotlin.UninitializedPropertyAccessException: lateinit property xxx has not been initialized"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlinのリフレクションアノテーション処理はJavaとは異なります。CDIの@Injectを使用していると、以下のようなエラーが発生することがあります。"kotlin.UninitializedPropertyAccessException: lateinitプロパティーxxxが初期化されていません"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the example below, this can be easily solved by adapting the annotation, adding @field: Default, to handle the lack of a @Target on the Kotlin reflection annotation definition.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例では、アノテーションに @field を追加することで、Kotlin のリフレクションアノテーション定義に @Target がない場合に対応し、問題を簡単に解決できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, prefer the use of constructor injection which works without modification of the Java examples.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、Javaの例を変更せずに動作するコンストラクタ注入の使用も良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kotlin requires a @field: xxx qualifier as it has no @Target on the annotation definition. Add @field: xxx in this example. @Default is used as the qualifier, explicitly specifying the use of the default bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlinでは、アノテーション定義に@Targetがないため、@field: xxx修飾子が必要です。この例では @field: xxx を追加します。@Defaultが修飾子として使用され、デフォルトBeanの使用を明示的に指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to test your Quarkus Application.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションのテスト方法について説明します。このガイドでは、以下の内容について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing in native mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of resources into tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストへのリソースの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The completed greeter application from the link:getting-started[Getting Started Guide]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:getting-started[入門ガイド]の完成済のgreeterアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、入門ガイドの一部として作成された最初のテストを拡張します。テストへのインジェクションと、ネイティブの実行ファイルをテストする方法もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `getting-started-testing`  {quickstarts-tree-url}/getting-started-testing[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide assumes you already have the completed application from the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 `getting-started`  ディレクトリーの完成したアプリケーションをすでに持っていることを前提としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have started from the Getting Started example you should already have a completed test, including the correct `pom.xml` setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はじめにのサンプルから始めた場合は、正しい `pom.xml`  の設定を含めて、すでにテストが完了しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file you should see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml`  ファイルには、2つのテスト依存関係があるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-junit5`  は、テストフレームワークを制御する `@QuarkusTest`  アノテーションを提供するため、テストには必須です。 `rest-assured`  は必須ではありませんが、HTTP エンドポイントをテストするのに便利な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JUnit 5を使用しているので、 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]のバージョンを設定する必要があります。デフォルトのバージョンはJUnit 5をサポートしていない為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `java.util.logging.manager`  システムプロパティーを設定して、テストが正しい logmanager と `maven.home`  を使用して、 `${maven.home}/conf/settings.xml` からのカスタム設定が適用されるようにしています (存在する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project should also contain a simple test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトには簡単なテストも含まれているはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このテストはHTTPを使用して、RESTエンドポイントを直接テストします。テストが実行されると、テストが実行される前にアプリケーションが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controlling the test port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストポートの制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusはデフォルトではポート `8080`  をリッスンしますが、テストを実行する場合はデフォルトで `8081`  をリッスンします。これにより、アプリケーションを並行して実行しながらテストを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the test port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストポートの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `application.properties` の `quarkus.http.test-port` を設定することで、を HTTP 用にテストで使われるポートを設定出来、 `quarkus.http.test-ssl-port` を設定することで HTTPS 用にテストで使用するポートを設定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`0` will result in the use of a random port (assigned by the operating system).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`0` を使用すると、(オペレーティングシステムによって割り当てられた)ランダムなポートが使用されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusはまた、テストを実行する前にRestAssuredによって使用されるデフォルトのポートを更新するRestAssuredインテグレーションも提供しているため、追加の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストで REST Assured を使用する場合、接続と応答のタイムアウトは 30 秒に設定されます。この設定は `quarkus.http.test-timeout`  プロパティーでオーバーライドできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>URLをテストに直接注入することも可能で、別のクライアントを使用するのが簡単になります。これは `@TestHTTPResource`  アノテーションで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>静的なリソースをロードするための簡単なテストを書いてみましょう。まず、シンプルなHTMLファイルを `src/main/resources/META-INF/resources/index.html` に作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create a simple test to ensure that this is being served correctly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これが正しく提供されているかどうかを確認するための簡単なテストを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションを使用すると、QuarkusインスタンスのURLを直接注入することができます。アノテーションの値は、URLのパス部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところ `@TestHTTPResource`  では、URL の `URI` , `URL` , `String`  表現を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a specific endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定のエンドポイントのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTassured と `@TestHTTPResource`  の両方で、パスをハードコーディングするのではなく、テストするエンドポイントクラスを指定することができます。これは現在、JAX-RS エンドポイント、サーブレット、リアクティブルートの両方をサポートしています。これにより、特定のテストがどのエンドポイントをテストしているかを正確に確認することが非常に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of these examples I am going to assume we have an endpoint that looks like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの例では、以下のようなエンドポイントを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは現在、JAX-RS のコンテキストパスを設定するための `@ApplicationPath()`  アノテーションをサポートしていません。カスタムのコンテキストパスを設定したい場合は、代わりに `quarkus.resteasy.path`  の設定値を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TestHTTPResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストHTTPリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用してエンドポイントのパスを指定することが出来、指定されたエンドポイントからパスが抽出されます。 `TestHTTPResource`  エンドポイントにも値を指定すると、エンドポイントパスの最後に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because `GreetingResource` is annotated with `@Path("/hello")` the injected URL will end with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingResource`  は `@Path("/hello")`  とアノテーションされているので、注入された URL は `/hello`  で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTassured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTassured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTassured ベースパス (すなわち、すべてのリクエストのルートとなるデフォルトパス) を制御するには、 `io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用できます。これはクラスやメソッドレベルで適用できます。グリーティングリソースをテストするには、以下のようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells RESTAssured to prefix all requests with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、RESTAssured はすべてのリクエストの前に `/hello` を付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note we don't need to specify a path here, as `/hello` is the default for this test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このテストでは `/hello`  がデフォルトなので、ここでパスを指定する必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection into tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストへの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、HTTP エンドポイントを介してアプリをテストする統合スタイルのテストしか取り上げてきませんでしたが、ユニットテストを行い、Beanを直接テストしたい場合はどうでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `@Inject`  アノテーションを介してテストにCDI Beanを注入できるようにすることで、これをサポートしています(実際、Quarkusのテストは完全なCDI Beanなので、すべてのCDI機能を使用することができます)。HTTPを使用せずにグリーティングサービスを直接テストするシンプルなテストを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GreetingService` bean will be injected into the test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingService`  Beanがテストに注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applying Interceptors to Tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストへのインターセプターの適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述したように、Quarkusのテストは実際には完全なCDI Beanであり、通常のようにCDIインターセプターを適用することができます。例えば、トランザクションのコンテキスト内でテストメソッドを実行したい場合、 `@Transactional`  アノテーションをメソッドに適用するだけで、トランザクションインターセプターがそれを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this you can also create your own test stereotypes. For example we could create a `@TransactionalQuarkusTest` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これに加えて、独自のテスト・ステレオタイプを作成することもできます。例えば、次のように `@TransactionalQuarkusTest`  を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションをテストクラスに適用すると、 `@QuarkusTest`  と `@Transactional`  の両方のアノテーションを適用したかのように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tests and Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストとトランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストでは標準のQuarkus `@Transactional`  アノテーションを使用することができますが、これは、テストでデータベースに加えた変更が永続化されることを意味します。テストの終了時に変更をロールバックしたい場合は、 `io.quarkus.test.TestTransaction`  アノテーションを使用することができます。これは、トランザクション内でテストメソッドを実行しますが、テストメソッドが完了したらロールバックして、データベースの変更を元に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターの代わりに、あるいはインターセプターに加えて、以下のコールバックインターフェースを実装することで、 *すべての* `@QuarkusTest` クラスを充実させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a callback implementation has to be registered as a "service provider" as defined by `java.util.ServiceLoader`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなコールバックの実装は、 `java.util.ServiceLoader`  で定義されている「サービスプロバイダ」として登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the following sample callback:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、以下のようなサンプルコールバックです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to read annotations from the test class or method to control what the callback shall be doing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストクラスやメソッドからアノテーションを読み込んで、コールバックが何をするかを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has
         to run tests in a custom classloader which JUnit is not aware of.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`BeforeEachCallback` のような JUnit Jupiter コールバックインターフェイスを使うことも可能ですが、QuarkusはJUnitが把握しないカスタムクラスローダーでテストを実行する必要がある為、クラスローディングの問題にぶつかるかもしれません。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Different Profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>異なるプロファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shutdown at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでのところ、すべての例では、すべてのテストに対して一度だけQuarkusを起動しています。最初のテストが実行される前にQuarkusが起動し、次にすべてのテストが実行され、最後にQuarkusがシャットダウンします。これにより、非常に高速なテストが可能になりますが、異なる設定をテストすることができないため、少し制限があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この問題を回避するために、Quarkusはテストプロファイルの考え方をサポートしています。以前に実行したテストとは異なるプロファイルを持つテストがある場合、Quarkusはテストを実行する前にシャットダウンされ、新しいプロファイルで開始されます。これは、テスト時間にシャットダウン/起動サイクルが追加されるため、明らかに少し遅くなりますが、非常に大きな柔軟性が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to reduce the amount of times Quarkus needs to restart it is recommended that you place all tests that need a specific profile into their own package, and then run tests alphabetically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの再起動の回数を減らすために、特定のプロファイルを必要とするすべてのテストを独自のパッケージに入れ、アルファベット順にテストを実行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Profile</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロフィールの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストプロファイルを実装するには、 `io.quarkus.test.junit.QuarkusTestProfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to override configuration properties. Here we are changing the JAX-RS root path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この方法では、設定プロパティーをオーバーライドすることができます。ここでは、JAX-RSのルートパスを変更しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to enable CDI `@Alternative` beans. This makes it easy to mock out certain beans functionality.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを使うことで、CDI `@Alternative`  Beanを有効にすることができます。これにより、特定のBeanの機能を簡単にモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to change the config profile. As this default is `test` this does nothing, but is included for completeness.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは設定プロファイルを変更するために使用できます。このデフォルトは `test`  なので、これは何もしませんが、完全性を保つために含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to apply **additional** `QuarkusTestResourceLifecycleManager` classes, specific for this profile only. If this method is not overridden, then only the `QuarkusTestResourceLifecycleManager` classes enabled via the `@QuarkusTestResource` class annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを使用すると、このプロファイル専用の `QuarkusTestResourceLifecycleManager`  クラスを *追加で* 適用することができます。このメソッドがオーバーライドされていない場合は、 `@QuarkusTestResource`  クラスアノテーションを介して有効化された `QuarkusTestResourceLifecycleManager`  クラスのみが、このプロファイルを使用するテストに使用されます (これは、プロファイルを全く使用しないテストと同じ動作です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have defined our profile we need to include it on our test class. We do this with `@TestProfile(MockGreetingProfile.class)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロファイルを定義したので、それをテストクラスに含める必要があります。 `@TestProfile(MockGreetingProfile.class)` で、これを行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the test profile config is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストプロファイルの設定はすべて単一のクラスに保存されているので、前回のテストが同じ設定で実行されたかどうかが簡単にわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モックサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、2つの異なるアプローチを使用したモックオブジェクトの使用をサポートしています。CDIの代替品を使用してすべてのテストクラスのBeanをモックアウトするか、 `QuarkusMock`  を使用してテストごとにBeanをモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI `@Alternative` mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI `@Alternative`  メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを使用するには、 `src/test/java`  ディレクトリーのクラスでモックしたいBeanをオーバーライドし、 `@Alternative`  と `@Priority(1)`  アノテーションをBeanに配置するだけです。あるいは、便利な `io.quarkus.test.Mock`  ステレオタイプアノテーションを使用することもできます。この組み込みステレオタイプは、 `@Alternative`  、 `@Priority(1)`  、 `@Dependent`  を宣言します。例えば、以下のようなサービスがあるとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I could mock it with the following class in `src/test/java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/test/java`  で以下のクラスでモックできました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overrides the `@Dependent` scope declared on the `@Mock` stereotype.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Mock`  ステレオタイプで宣言された `@Dependent`  スコープをオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代替品が `src/main/java`  ではなく `src/test/java`  ディレクトリーに存在することが重要です。そうでなければ、テスト以外も常に有効になってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that at present this approach does not work with native image testing, as this would required the test alternatives to be baked into the native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のところ、このアプローチはネイティブイメージテストでは機能しないことに注意してください。テスト代替品がネイティブイメージに焼き込まれる必要がある為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.test.junit.QuarkusMock`  クラスは、通常のスコープ付きBeanを一時的にモックアウトするために使用することができます。 `@BeforeAll`  メソッドでこのメソッドを使用した場合、モックは現在のクラスのすべてのテストに対して有効になりますが、test メソッドでこれを使用した場合、モックは現在のテストの間のみ有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この方法は、通常のスコープ付き CDI Bean(例: `@ApplicationScoped` , `@RequestScoped`  など、 `@Singleton`  と `@Dependent`  以外の基本的にすべてのスコープ)に対して使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage could look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用例は次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションされたインスタンスはここでは利用できないので、 `installMockForType` を使用します。このモックは両方のテストメソッドに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは `installMockForInstance`  を使用して注入されたBeanを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mockitoには依存しないことに注意してください。好きなモッキングライブラリを使うことができますし、必要な動作を提供するためにオブジェクトを手動でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further simplification with `@InjectMock`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectMock` での更なる単純化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusMock`  で提供されている機能をベースに、Quarkusでは、 `QuarkusMock`  でサポートされているBeanをモックするために link:https://site.mockito.org/[Mockito を]簡単に利用できるようにしています。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectMock`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectMock`  を使用すると、先ほどの例は次のように書くことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectMock` により、モックがテストクラスのテストメソッドに存在することになり、利用可能になります (他のテストクラスはこの影響を受け *ません* )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mockableBean1` is configured here for every test method of the class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスのすべてのテストメソッドに対して `mockableBean1`  が設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the `mockableBean2` mock has not been configured, it will return the default Mockito response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mockableBean2`  のモックが設定されていないので、デフォルトの Mockito レスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this test the `mockableBean2` is configured, so it returns the configured response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このテストでは、 `mockableBean2`  が設定されているので、設定されたレスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上のテストは `@InjectMock`  の機能を示すのには良いですが、実際のテストを上手く表してはいません。実際のテストでは、ほとんどの場合、モックを設定し、モックされたBeanを使用するBeanをテストします。以下に例を示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`greetingService`  をモックとして設定したので、 `GreetingService`  Beanを使用する `GreetingResource`  は、通常の `GreetingService` Beanのレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spies instead of Mocks with `@InjectSpy`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `@InjectSpy` で、モックの代わりにスパイを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`InjectMock`  で提供されている機能をベースに、 `QuarkusMock`  でサポートされているBeanをスパイするために link:https://site.mockito.org/[Mockito ]を簡単に利用できるようにしました。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectSpy`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストを行う際に、特定の論理パスが取られたかどうかを確認するだけで済む場合もありますし、Spied クローン上で残りのメソッドを実行している間に、1つのメソッドのレスポンスをスタブアウトするだけで済む場合もあります。Spy パーシャル モックの詳細については link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito のドキュメント]を参照してください。いずれの場合も、オブジェクトの Spy が望ましいでしょう。 `@InjectSpy`  を使用して、先ほどの例は次のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値をオーバーライドするのではなく、 `GreetingService`  の greet メソッドがこのテストで呼び出されたことを確認したいだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we are telling the Spy to return "hi" instead of "hello". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、"hello"の代わりに"hi"を返すようにSpyに指示しています。 `GreetingResource`  が `GreetingService`  から挨拶を要求するとき、通常の `GreetingService`  Bean のレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are verifying that we get the mocked response from the Spy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは、スパイからのモックされた応答を得ることを検証しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock` with `@RestClient`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@InjectMock`  との併用 `@RestClient`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RegisterRestClient`  は、実行時に rest-client の実装を登録しています。Beanは通常のスコープである必要があるため、インターフェイスに `@ApplicationScoped` を付与する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the test class here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストクラスの例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that this injection point is meant to use an instance of `RestClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この注入ポイントが `RestClient`  のインスタンスを使用することを意味していることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the link:hibernate-orm-panache#mocking[Hibernate ORM with Panache Mocking] and link:mongodb-panache#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-hibernate-orm-panache`  や `quarkus-mongodb-panache` のエクステンションを使っている場合は、 link:hibernate-orm-panache#mocking[Hibernate ORM とPanache Mocking]や link:mongodb-panache#mocking[MongoDB とPanache Mocking]のドキュメントをチェックして、データアクセスをモックする最も簡単な方法を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティーのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus Security, check out the link:security-testing[Testing Security] section for information on how to easily test security features of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Securityを使用している場合、アプリケーションのセキュリティー機能を簡単にテストする方法については、「 link:security-testing[セキュリティーのテスト]」のセクションをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非常に一般的なニーズは、Quarkusアプリケーションがテストを開始する前に、Quarkusアプリケーションに依存するいくつかのサービスを開始することです。このニーズに対応するために、Quarkusでは、 `@io.quarkus.test.common.QuarkusTestResource`  と `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行可能ファイルテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to test native executables using `@NativeImageTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@NativeImageTest` を使用してネイティブ実行ファイルをテストすることも可能です。これは、テストに注入すること(そして、ネイティブ実行可能ファイルは別の非JVMプロセスで実行されることーこれは実際には可能ではありません)を除いて、このガイドで述べたすべての機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is covered in the link:building-native-image[Native Executable Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは link:building-native-image[ネイティブ実行可能ファイルガイド] で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `@QuarkusTest` from an IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDE から `@QuarkusTest`  を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most IDEs offer the possibility to run a selected class as JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどの IDE では、選択したクラスを JUnit テストとして直接実行できるようになっています。そのためには、選択した IDE の設定でいくつかのプロパティーを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.logging.manager` (see link:logging[Logging Guide])</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.logging.manager`  (ロ link:logging[ギングガイド]を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`maven.settings`  (カスタム版の `settings.xml`  ファイルをテストに使用する場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy your current "Installed JRE" definition into a new one, where you will add the properties as a new VM arguments:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在の"Installed JRE"定義を新しい定義にコピーし、新しいVMの引数としてプロパティーを追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Dmaven.home=&lt;path-to-your-maven-installation&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-Dmaven.home=&amp;amp;lt;path-to-your-maven-installation&amp;amp;gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any "Run as JUnit" configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このJRE定義をQuarkusプロジェクトのターゲットランタイムとして使用すると、「Run as JUnit」設定に回避策が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode "run with" configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>VSCode "run with" 設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `settings.json` placed in the root of your project directory or in the workspace will need the workaround in your test configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトディレクトリーやワークスペースのルートにある `settings.json`  は、テスト設定で回避策が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing needed in IntelliJ because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IntelliJでは何も必要ありません。なぜなら、IDEは `systemPropertyVariables` を `pom.xml`のsurefireプラグイン設定から取得するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional blocking code uses link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`]
 variables to store contextual objects in order to avoid
passing them as parameters everywhere. Many Quarkus extensions require those contextual objects to operate
properly: link:rest-json[RESTEasy], link:cdi-reference[ArC] and link:transaction[Transaction]
for example.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>従来のブロッキングコードでは  link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`] 変数を使用してコンテキストオブジェクトを格納します。多くのQuarkusエクステンションは、適切に動作するためにこれらのコンテキストオブジェクトを必要とします。例えば、 link:rest-json[RESTEasy]、 link:cdi-reference[ArC]、 link:transaction[Transaction]などです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you write reactive/async code, you have to cut your work into a pipeline of code blocks that get executed "later", and in practice after the method you defined them in have returned. As such, `try/finally` blocks as well as `ThreadLocal` variables stop working, because your reactive code gets executed in another thread, after the caller ran its `finally` block.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ/非同期コードを書く場合、「後で」実行されるコードブロックのパイプラインに作業を切り 込まなければならず、実際には、定義したメソッドがreturnされた後に実行されます。そのため、 `try/finally` ブロックや `ThreadLocal` 変数は動作しなくなります。なぜならば、呼び出し元が `finally` ブロックを実行した後に、 リアクティブコードは別のスレッドで実行されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/smallrye/smallrye-context-propagation[SmallRye Context Propagation] an implementation of link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] was made to make those Quarkus extensions work properly in reactive/async settings. It works by capturing those contextual values that used to be in thread-locals, and restoring them when your code is called.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] の実装である link:https://github.com/smallrye/smallrye-context-propagation[SmallRye Context Propagation] は、リアクティブ/非同期設定でQuarkusエクステンションが正しく動作するようにするために作られました。これは、スレッドローカルにあったコンテキスト値を取得し、コードが呼び出されたときにそれらを復元することで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting it up</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:http://smallrye.io/smallrye-mutiny[Mutiny] (the `quarkus-mutiny` extension), you just need to add the the `quarkus-smallrye-context-propagation` extension to enable context propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://smallrye.io/smallrye-mutiny[Mutiny] ( `quarkus-mutiny` のエクステンション) を使用している場合は、コンテキストの伝播を有効にするために `quarkus-smallrye-context-propagation` のエクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, add the following dependencies to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>つまり、以下の依存関係を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, you will get context propagation for ArC, RESTEasy and transactions, if you are using them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、ArC、RESTEasy、トランザクションを使用している場合は、コンテキストの伝播を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、Mutinyのリアクティブタイプ を使用しています。慣れていない場合は、 link:getting-started-reactive#mutiny[Getting Started with Reactive guide] を先にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a REST endpoint that reads the next 3 items from a link:kafka[Kafka topic], stores them in a database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client, you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:kafka[Kafkaトピック] から次の3つのアイテムを読み込んで、 link:hibernate-orm-panache[Hibernate ORM with Panache] を使ってデータベースに保存してからクライアントに返すRESTエンドポイントを書いてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that thanks to Mutiny support for context propagation, this works out of the box.  The 3 items are persisted using the same transaction and this transaction is committed when the stream completes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキストの伝播のための Mutiny サポートのおかげで、これは、そのまま直ぐに動作することに注目してください。3つのアイテムは同じトランザクションを使用して保持され、このトランザクションはストリームが完了するとコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage example for `CompletionStage`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CompletionStage` の使用例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`] you need manual context propagation. You can do that by injecting a `ThreadContext` or `ManagedExecutor` that will propagate every context. For example, here we use the link:vertx[Vert.x Web Client] to get the list of Star Wars people, then store them in the database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client as JSON using link:rest-json[Jackson or JSON-B]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`]を使用する場合、手動でコンテキストを伝播させる必要があります。 `ThreadContext` や `ManagedExecutor` を注入することで、すべてのコンテキストを伝播させることができます。例えば、ここでは link:vertx[Vert.x Web Client] を使用してスターウォーズの登場人物のリストを取得し、 link:hibernate-orm-panache[Hibernate ORM with Panache を]使用して(全て同じトランザクション内で) データベースに保存します。その後、 link:rest-json[Jackson または JSON-B] を使用して JSON としてクライアントに返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `ThreadContext` or `ManagedExecutor` you can wrap most useful functional types and `CompletionStage` in order to get context propagated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ThreadContext` または `ManagedExecutor` を使用することで、ほとんどの有用な関数型と `CompletionStage` をラップしてコンテキストを伝播させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected `ManagedExecutor` uses the Quarkus thread pool.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入された `ManagedExecutor` は、Quarkus のスレッドプールを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In terms of CDI, `@RequestScoped`, `@ApplicationScoped` and `@Singleton` beans get propagated and are available in other threads.  `@Dependent` beans as well as any custom scoped beans cannot be automatically propagated via CDI Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI の観点からは、 `@RequestScoped`, `@ApplicationScoped`, `@Singleton` Beanは伝播され、他のスレッドで利用可能です。 `@Dependent` BeanやカスタムスコープされたBeanは、CDI コンテキスト伝播を介して自動的に伝播されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` and `@Singleton` beans are always active scopes and as such are easy to deal with - context propagation tasks can work with those beans so long as the CDI container is running.  However, `@RequestScoped` beans are a different story. They are only active for a short period of time which can be bound either to HTTP request or some other request/task when manually activated/deactivated.  In this case user must be aware that once the original thread gets to an end of a request, it will terminate the context, calling `@PreDestroy` on those beans and then clearing them from the context.  Subsequent attempts to access those beans from other threads can result in unexpected behaviour.  It is therefore recommended to make sure all tasks using request scoped beans via context propagation are performed in such a manner that they don't outlive the original request duration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ApplicationScoped` と `@Singleton` のBeanは常にアクティブなスコープであり、そのため対処が簡単です - コンテキスト伝播タスクは、CDI コンテナーが動作している限り、これらのBeanで動作します。しかし、 `@RequestScoped` Beanは話が違います。手動で有効化/無効化すると、HTTP リクエストや他のリクエスト/タスクにバインドされます。この場合、元のスレッドがリクエストの終了に到達すると、コンテキストを終了し、それらのBeanで `@PreDestroy` を呼び出し、コンテキストからクリアされることに注意しなければなりません。その後、他のスレッドからこれらのBeanにアクセスしようとすると、予期せぬ動作をすることがあります。したがって、コンテキストの伝播を介してリクエストスコープされたBeanを使用するすべてのタスクは、元のリクエストの持続時間を超えないような方法で実行されることを確認することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the above described behavior, it is recommended to avoid using `@PreDestroy` on `@RequestScoped` beans when working with Context Propagation in CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記で説明した動作のため、CDI で Context Propagation を使用する際には `@PreDestroy` を `@RequestScoped` Beanで使用しないことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to log to Sentry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusがSentryにログ送信するように設定する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry is a really easy way to be notified of errors happening in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Sentryは、Quarkusアプリケーションで発生したエラーを通知する本当に簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a self-hosted and cloud-based error monitoring that helps software teams discover, triage, and prioritize errors in real-time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セルフホスト型か、クラウドベースのエラーモニターリングで、ソフトウェアチームがリアルタイムでエラーを発見し、トリアージし、優先順位をつけるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They offer a free starter price for cloud-based or you can self host it for free.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドベースの場合は無料のスターター価格を提供してくれますし、セルフホストでも無料で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry's Java SDK is open source, but recently sentry.io https://blog.sentry.io/2019/11/06/relicensing-sentry[changed the license] for their backend to the non-open source https://github.com/getsentry/sentry/blob/master/LICENSE[BSL license]. This might or might not be an issue for your project and product.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Sentry の Java SDK はオープンソースですが、最近 sentry.io はバックエンドの link:https://blog.sentry.io/2019/11/06/relicensing-sentry[ライセンス] を非オープンソースの link:https://github.com/getsentry/sentry/blob/master/LICENSE[BSL ライセンス]に link:https://blog.sentry.io/2019/11/06/relicensing-sentry[変更しました]。これはあなたのプロジェクトや製品にとって問題になるかもしれませんし、ならないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start with, you need to get a Sentry DSN either by https://sentry.io/signup/[creating a Sentry account] or https://docs.sentry.io/server/[installing your own self-hosted Sentry].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手始めに、Sentry link:https://sentry.io/signup/[アカウントを作成する]か、自前のSentry link:https://docs.sentry.io/server/[をインストール] してSentry DSNを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“In Application” Stack Frames</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"in Application" スタックフレーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry differentiates stack frames that are directly related to your application (“in application”) from stack frames that come from other packages such as the standard library, frameworks, or other dependencies. The difference is visible in the Sentry web interface where only the “in application” frames are displayed by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Sentry は、アプリケーションに直接関連するスタックフレーム("in application")と、標準ライブラリやフレームワーク、その他の依存関係のあるパッケージから来るスタックフレームを区別します。この違いは、SentryのWebインタフェースでは、デフォルトでは "in application" フレームのみが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure which package prefixes your application uses with the `in-app-packages` option, which takes a comma separated list of packages:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`in-app-packages` オプションで、アプリケーションが使用するパッケージの接頭辞を設定できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don’t want to use this feature but want to disable the warning, simply set it to `*`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能を使用したくないが警告を無効にしたい場合は、 `*` をセットしてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors and warnings occurring in any of the packages will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いずれかのパッケージで発生したすべてのエラーや警告は、DSNと共にSentryに送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors occurring in the package `org.example` will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パッケージ `org.example` で発生したすべてのエラーは、DSN と共にSentry に送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is configured through the standard `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、標準の `application.properties` ファイルを介して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.  Each extension dealing with persistence will integrate with it for you.  And you will explicitly interact with transactions via CDI.  This guide will walk you through all that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusにはTransaction Managerが付属しており、これを使用してトランザクションを調整してアプリケーションに公開します。永続性を扱う各エクステンションは、これと統合されます。そして、CDIを介して明示的にトランザクションと対話することになります。このガイドでは、これらすべてについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.  Hibernate ORM for example will include the transaction manager and set it up properly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを必要とするエクステンションは単に依存関係として追加するだけなので、ほとんどの場合、設定について心配する必要はありません。例えばHibernate ORMはトランザクションマネージャーを含んでおり、適切に設定してくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.  Add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、Hibernate ORMを使用せずに直接トランザクションを使用している場合は、明示的に依存関係として追加する必要があるかもしれません。以下を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting and stopping transactions: defining your boundaries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションの開始と停止:境界線の定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your transaction boundaries the easy way, or the less easy way :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションの境界を定義するには、簡単な方法と比較的簡単ではない方法があります :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declarative approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>宣言的アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`javax.transaction.Transactional`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションの境界を定義する最も簡単な方法は、エントリーメソッド ( `javax.transaction.Transactional` ) で `@Transactional` アノテーションを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation defines your transaction boundaries and will wrap this call within a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションは、トランザクションの境界を定義し、トランザクション内でこの呼び出しをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `RuntimeException` crossing the transaction boundaries will rollback the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RuntimeException` がトランザクションの境界を越えると、トランザクションがロールバックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional` は、メソッドレベルまたはクラスレベルで、すべてのメソッドがトランザクションであることを保証するために、任意の CDI Bean のトランザクション境界を制御するために使用することができます。これにはRESTエンドポイントも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can control whether and how the transaction is started with parameters on `@Transactional`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional` のパラメーターを使用して、トランザクションを開始するかどうか、どのように開始するかを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(REQUIRED)` (デフォルト): 何も開始されていない場合はトランザクションを開始し、そうでない場合は既存のトランザクションを維持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(REQUIRES_NEW)` : 何も開始されていない場合はトランザクションを開始し、既存のトランザクションが開始されている場合はそれを一時停止し、そのメソッドの境界で新しいトランザクションを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(MANDATORY)` : トランザクションが開始されていない場合は失敗し、そうでない場合は既存のトランザクション内で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(SUPPORTS)` : トランザクションが開始されている場合、それに参加します。開始されていない場合はトランザクションなしで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(NOT_SUPPORTED)` : トランザクションが開始されている場合、それを一時停止し、メソッドの境界ではトランザクションなしで動作します。開始されていない場合は、トランザクションなしで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional(NEVER)` : トランザクションが開始されている場合は例外を発生させます。開始されていない場合はトランザクションなしで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクション設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the transaction timeout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションタイムアウトの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the default transaction timeout, the timeout that applies to all transactions managed by the transaction manager, via the property `quarkus.transaction-manager.default-transaction-timeout`, specified as a duration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのトランザクション・タイムアウト、つまりトランザクション・マネージャーによって管理されるすべてのトランザクションに適用されるタイムアウトを、プロパティー `quarkus.transaction-manager.default-transaction-timeout` を使用して、期間として指定して構成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is 60 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト値は60秒です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring transaction node name identifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションノード名識別子の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Narayana, as the underlying transaction manager, has a concept of a unique node identifier.  This is important if you consider using XA transactions that involve multiple resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Narayanaは、基礎となるトランザクションマネージャーであり、一意のノード識別子の概念を持っています。これは、複数のリソースを含む XA トランザクションの使用を検討している場合に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier plays a crucial part in the identification of a transaction.  The node name identifier is forged into the transaction id when the transaction is created.  Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction counterparts created in database or JMS broker. The identifier makes possible for the transaction manager to roll back the transaction counterparts during recovery.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ノード名識別子はトランザクションの識別において重要な役割を果たします。ノード名識別子は、トランザクションが作成されるときに、トランザクションIDの作成に使用されます。ノード名識別子に基づいて、トランザクションマネージャーはデータベースまたはJMSブローカに作成されたXAトランザクションのカウンターパートを認識することができます。この識別子により、トランザクションマネージャーはリカバリ中にトランザクションのカウンターパートをロールバックすることが可能になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier needs to be unique per transaction manager deployment.  And the node identifier needs to be stable over the transaction manager restarts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ノード名識別子は、トランザクションマネージャーのデプロイメントごとに一意である必要があります。また、ノード識別子はトランザクションマネージャーの再起動時に変化しない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier may be configured via the property `quarkus.transaction-manager.node-name`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ノード名識別子は、プロパティー `quarkus.transaction-manager.node-name` を通じて設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why always having a transaction manager?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜ常にトランザクションマネージャーを持っているのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does it work everywhere I want to?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使いたいところなら、どこでも使えるのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.  JTA has some bad press for some people.  I don't know why.  Let's just say that this is not your grandpa's JTA implementation.  What we have is perfectly embeddable and lean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、Quarkusアプリケーションでも、IDEでも、テストでも動作します。JTAは一部の人に悪評があります。なぜかはわかりません。これはあなたのおじいちゃんのJTA実装ではないとは言っておきましょう。私たちが持っているものは、完全に埋め込み可能で無駄がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does it do 2 Phase Commit and slow down my app?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それは2フェーズコミットを行い、私のアプリの速度を遅くしますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No, this is an old folk tale.  Let's assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いや、これは昔話です。基本的にはフリーで提供され、必要に応じて複数のデータソースを含むより複雑なケースにも対応できると考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I don't need transaction when I do read only operations, it's faster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>読み込み専用の操作をするときにはトランザクションはいらないので、その方が早いですね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrong. + First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). + Second, it's again fairy tale that not using transaction is faster.  The answer is, it depends on your DB and how many SQL SELECTs you are making.  No transaction means the DB does have a single operation transaction context anyways. + Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.  Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.  By reading it in one transaction, they will be consistent.  If you read one and the other from two different transactions, then they can be inconsistent.  It can be more dramatic if you read data related to rights and access management for example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>誤りです。+ まず第一に、トランザクションの境界を `@Transactional(NOT_SUPPORTED)` (または `NEVER` または `SUPPORTS` ) でマークすることで、トランザクションを無効にしてください。+ 第二に、トランザクションを使用しない方が速いというのは、またしてもおとぎ話です。答えは、それはあなたのDBと、あなたが行っているSQL SELECTの数に依存します。トランザクションを使用しないということは、DBはいずれにしても単一操作のトランザクションコンテキストを持っていることを意味します。+ 第三に、複数のSELECTを実行する場合は、それらを一つのトランザクションにまとめる方が良いでしょう。あなたのDBがあなたの車のダッシュボードを表しているとしましょう、あなたは残りのキロ数と燃料計のレベルを見ることができます。それを1つのトランザクションで読み取ることで、それらは一貫したものになります。一方ともう一方を2つの異なるトランザクションから読み取った場合、それらは一貫性のないものになる可能性があります。例えば、権限やアクセス管理に関連するデータを読むと、より劇的になることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.  Transactions are also about JMS and other database access, so one API makes more sense.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`entityManager.getTransaction().begin()` やその類似を経由して手動でトランザクションを管理すると、最終的に人々が間違えるような試行回数の多い醜いコードになってしまいます。トランザクションはまた、JMSと他のデータベースアクセスについてですので、1つのAPIはより多くの理にかなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a mess because I don't know if my JPA persistence unit is using `JTA` or `Resource-level` Transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私のJPA永続化ユニットが `JTA` を使っているのか `Resource-level` トランザクションを使っているのかわからないので、めちゃくちゃです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not a mess in Quarkus :)  Resource-level was introduced to support JPA in a non managed environment.  But Quarkus is both lean and a managed environment so we can safely always assume we are in JTA mode.  The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusではごちゃごちゃしていません :)リソースレベルは、管理されていない環境でJPAをサポートするために導入されました。しかし、Quarkusはリーン環境であると同時にマネージド環境でもあるので、常にJTAモードになっていると思っておけば安心です。結局、Java SEモードでHibernate ORM + CDI + トランザクションマネージャーを実行することの難しさはQuarkusで解決されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy Funqy as a standalone service and invoke on Funqy functions using HTTP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Funqyをスタンドアロンサービスとしてデプロイし、HTTPを使ってFunqy関数を呼び出す方法をクイックスタートコードで説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Routes support instead, although Funqy will have less overhead than these alternatives (except Vert.x which is still super fast).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>FunqyのHTTPバインディングはHTTP上のRESTの代わりではありません。Funqyは多くの異なるプロトコルや Function プロバイダに対してポータブルである必要があるので、HTTPバインディングは非常にミニマムで、リンクのようなREST機能やキャッシュコントロールや条件付きGETのようなHTTPを利用する機能を失うことになります。代わりにQuarkusのJAX-RS、Spring MVC、またはVert.x Web Reactive Routesのサポートを使用することを検討すると良いでしょう。しかしながら、Funqy はこれらの選択肢と比べてオーバーヘッドが小さいでしょう(例外として Vert.x はそれでもすごく早いですが)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about link:funqy[Funqy Basics].  This is a short read!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:funqy[Funqy の基礎] を読む。短時間で読めます!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quickstart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クイックスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the Java code, you'll see that there is no HTTP specific API.  Its just simple Java methods annotated with `@Funq`.  Simple, easy, straightforward.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javaコードを見ると、HTTP固有のAPIがないことがわかります。単純な Java メソッドに `@Funq` と注釈が付けられているだけです。シンプルで、簡単で、わかりやすいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write Funqy HTTP functions, simply include the `quarkus-funqy-http` dependency into your Quarkus `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy HTTP Function を書くには、 `quarkus-funqy-http` 依存関係をQuarkus `pom.xml` ファイルにインクルードするだけでよいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts your functions in Quarkus dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、Quarkus devモードで Function が起動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL path to execute a function is the function name.  For example if your function name is `foo` then the URL path to execute the function would be `/foo`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Function を実行するための URL パスは、Function 名です。例えば、Function 名が `foo` の場合、Function を実行する URL パスは `/foo` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP POST or GET methods can be used to invoke on a function.  The return value of the function is marshalled to JSON using the Jackson JSON library.  Jackson annotations can be used.  If your function has an input parameter, a POST invocation must use JSON as the input type.  Jackson is also used here for unmarshalling.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP POST または GET メソッドを使用して Function を呼び出すことができます。Function の戻り値は、Jackson JSON ライブラリを使用して JSON にマーシャルされます。Jackson アノテーションを使用することができます。Function に入力パラメーターがある場合、POST 呼び出しは入力タイプとして JSON を使用しなければなりません。ここでもJackson はアンマーシャリングに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can invoke the `hello` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] by pointing your browser to http://localhost:8080/hello</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザを http://localhost:8080/hello に向けると、 {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `hello` Function を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoking the other functions in the quickstart requires an HTTP POST.  To execute the `greet` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/GreetingFunction.java[GreetingFunction.java] invoke this curl script.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クイックスタートの他の Function を呼び出すには、HTTP POST が必要です。 {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/GreetingFunction.java[GreetingFunction.java] で定義されている `greet` 関数を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primitive types can also be passed as input using the standard JSON mapping for them.  To execute the `toLowerCase` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プリミティブ型は、標準の JSON マッピングを使用して入力として渡すこともできます。`toLowerCase` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `toLowerCase` 関数を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To execute the `double` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `double` Function を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For GET requests, the Funqy HTTP Binding also has a query parameter mapping for function input parameters.  Only bean style classes and `java.util.Map` can be used for your input parameter.  For bean style classes, query parameter names are mapped to properties on the bean class.  Here's an example of a simple `Map`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GETリクエストのために、Funqy HTTPバインディングは、Function の入力パラメーターのためのクエリパラメーターマッピングも提供しています。Bean スタイル・クラスと `java.util.Map` だけが入力パラメーターに使用できます。Bean スタイル・クラスでは、クエリ・パラメーター名は Bean クラスのプロパティーにマッピングされます。以下は、単純な `Map` の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Key values must be a primitive type (except char) or `String`.  Values can be primitives (except char), `String`, `OffsetDateTime` or a complex bean style class.  For the above example, here's the corresponding curl request:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キー値は、プリミティブ型(char を除く)か `String` でなければなりません。値は、プリミティブ型 (char を除く)、 `String` 、 `OffsetDateTime` 、または複雑な Bean スタイルのクラスを使用できます。上記の例に対して、対応する curl リクエストを以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `map` input parameter of the `hello` function would have the key value pairs: `a`-&gt;1, `b`-&gt;2.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`hello` Function の `map` 入力パラメーターは、 `a` →1, `b` →2 というキーバリューペアを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean style classes can also be use as the input parameter type.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean スタイルクラスを入力パラメーター型として使用することもできます。以下に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property values can be any primitive type except `char`. It can also be `String`, and `OffsetDateTime`.  `OffsetDateTime` query param values must be in ISO-8601 format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーの値は、 `char` 以外の任意のプリミティブ型にすることができます。また、 `String` や `OffsetDateTime` も可能です。 `OffsetDateTime` クエリのパラメーター値は ISO-8601 形式でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can invoke on this using an HTTP GET and query parameters:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP GET とクエリパラメーターを使用して呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above request, the query parameter names are mapped to corresponding properties in the input class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のリクエストでは、クエリパラメーター名が入力クラスの対応するプロパティーにマッピングされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input class can also have nested bean classes.  Expanding on the previous example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入力クラスは、入れ子になった Bean クラスを持つこともできます。前の例を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, query parameters for nested values use the `.` notation.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、入れ子になった値のクエリパラメーターは `.` 表記法を使用します。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.List` and `Set` are also supported as property values.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.List` と `Set` もプロパティー値としてサポートされています。例えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To invoke a GET request, just list the `pets` query parameter multiple times.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GETリクエストを実行するためには、 `pets` クエリパラメーターを複数回リストアップするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more complex types, `List` and `Set` members must have an identifier in the query parameter.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より複雑な型の場合、 `List` および `Set` のメンバーは、クエリパラメーターに識別子を持つ必要があります。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `kids` query parameter must identify the kid they are referencing so that the runtime can figure out which property values go to which members in the list.  Here's the curl request:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それぞれの `kids` クエリーパラメーターは、参照している kid を識別する必要があります。これにより、ランタイムはどのプロパティー値がリストのどのメンバーに属するかを把握することができます。これが curl リクエストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above URL uses the value `1` and `2` to identity the target member of the list, but any unique string can be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のURLでは、リストの対象メンバーを識別するために `1` と `2` という値を使用していますが、任意の一意の文字列を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A property can also be a `java.util.Map`.  The key of the map can be any primitive type and `String`.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーは `java.util.Map` でもよいです。 マップのキーは、任意のプリミティブ型と `String` が利用できます。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding call would look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>対応する呼び出しは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your `Map` value is a complex type, then just continue the notation by adding the property to set at the end.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Map` の値が複雑な型であれば、最後に set するプロパティーを追加して表記を続けるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse https://vertx.io[Vert.x] is a toolkit for building reactive applications.  It is designed to be lightweight and embeddable.  Vert.x defines a reactive execution model and provides a large ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse link:https://vertx.io[Vert.x] は、リアクティブなアプリケーションを構築するためのツールキットです。軽量で埋め込み可能なように設計されています。Vert.xはリアクティブ実行モデルを定義し、大規模なエコシステムを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is based on Vert.x, and almost all network-related features rely on Vert.x.  While lots of reactive features from Quarkus don't _show_ Vert.x, it's used underneath.  Quarkus also integrates smoothly with the Vert.x event bus (to enable asynchronous messaging passing between application components) and some reactive clients.  You can also use various Vert.x APIs in your Quarkus application, such as deploying _verticles_, instantiating clients...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはVert.xをベースにしており、ほとんどすべてのネットワーク関連機能はVert.xに依存しています。Quarkusのリアクティブ機能の多くはVert.xを _表に出して_ いませんが、その下で使用されています。また、Quarkusは、Vert.xイベントバス(アプリケーションコンポーネント間の非同期メッセージングの受け渡しを可能にするため)やいくつかのリアクティブクライアントとスムーズに統合されています。また、Quarkusアプリケーションでは、さまざまなVert.x APIを使用することができます(例えば、 _バーティクル_ のデプロイ、クライアントのインスタンス化など)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access Vert.x, well, you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter are follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.xにアクセスするに、この機能を利用するには、 `vertx` エクステンションを有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでに作成済みのプロジェクトがある場合は、 `vertx` エクステンションを既存のQuarkusプロジェクトに `add-extension` コマンドで追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブトランスポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If all is well quarkus will log:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてがうまくいけば、クァーカス以下のログ出力を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Linux Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブLinuxトランスポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux you can enable the following socket options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Linuxでは、以下のソケットオプションを有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SO_REUSEPORT</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SOREUSEPORT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native MacOS Transport</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブMacOSトランスポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MacOS Sierra and above you can enable the following socket options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MacOS Sierra以上では、以下のソケットオプションを有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides 2 Vert.x APIs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは2つのVert.x APIを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_bare_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_bare_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Inject io.vertx.core.Vertx vertx`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Inject io.vertx.core.Vertx vertx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://smallrye.io/smallrye-mutiny/[Mutiny]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://smallrye.io/smallrye-mutiny/[Mutiny]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Inject io.vertx.mutiny.core.Vertx vertx`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Inject io.vertx.mutiny.core.Vertx vertx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host. This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>unix ドメインソケットをリスンすることで、同じホストから quarkus サービスへの接続が確立されている場合、TCP のオーバーヘッドを省くことができます。これはサービスへのアクセスがプロキシーを経由している場合に起こる可能性があり、Envoyのようなプロキシーでサービスメッシュを設定している場合によく起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work on platforms that support &lt;&lt;native-transport&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、 link:#native-transport[[native-transport]] をサポートするプラットフォームでのみ動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To setup please enable the appropriate &lt;&lt;native-transport&gt;&gt; and set the following environment property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定するには、適切な link:#native-transport[native-transport] を有効にし、以下の環境プロパティーを設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported forwarding address headers are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされている転送アドレスヘッダは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Forwarded`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Forwarded`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`X-Forwarded-Proto`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`X-Forwarded-Proto`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`X-Forwarded-Host`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`X-Forwarded-Host`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`X-Forwarded-Port`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`X-Forwarded-Port`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`X-Forwarded-Ssl`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`X-Forwarded-Ssl`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`X-Forwarded-Prefix`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`X-Forwarded-Prefix`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Software Transactional Memory (STM) has been around in research environments since the late 1990's and has relatively recently started to appear in products and various programming languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].  However, suffice it to say that STM offers an approach to developing transactional applications in a highly concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations, or at least made optional. This is not the situation with JTA, where state changes are made durable to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA standard].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソフトウェアトランザクションメモリー (STM) は、1990 年代後半から研究されており、最近になって製品やさまざまなプログラミング言語に登場し始めました。STM の背後にあるすべての詳細については触れませんが、興味のある方は https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[この記事] を参照してください。しかし、STM は、JTA を通じて既に使用されている ACID トランザクションと同じ特性を持つ、高度な同時実行環境でトランザクションアプリケーションを開発するためのアプローチを提供していることは言うまでもありません。しかし、STM では、ACID トランザクションと同じ特性を持つ、高度な同時実行環境のトランザクションアプリケーションを開発するためのアプローチを利用できます。重要なのは、STM の実装では、Durability プロパティーが緩和 （削除） されているか、少なくともオプションになっていることです。これは、link:https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[X/Open XA 標準] をサポートするリレーショナルデータベースに対して状態の変更を耐久性のあるものにするという JTA の状況とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities into Quarkus when developing Kubernetes native applications and microservices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus が提供する STM の実装は、link:https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] の実装に基づいています。このドキュメントは、そのプロジェクトのドキュメントに代わるものではありません。そのため、その詳細についてはそちらを参照してください。しかし、Kubernetes ネイティブアプリケーションやマイクロサービスを開発する際に、主要な機能のいくつかを Quarkus にどのように組み合わせることができるかについて、より焦点を当ててみたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why use STM with Quarkus?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜ Quarkus で STM を使うのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you may still be asking yourself "Why STM instead of JTA?" or "What are the benefits to STM that I don't get from JTA?" Let's try to answer those or similar questions, with a particular focus on why we think they're great for Quarkus, microservices and Kubernetes native applications. So in no specific order ...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>「なぜ JTA ではなく STM なのか?」あるいは「JTA では得られない STM のメリットとは?」と自問自答しているかもしれません。ここでは、STM が Quarkus、マイクロサービス、Kubernetes ネイティブアプリケーションに最適である理由を中心に、これらの質問や似たような質問に答えていきます。順序にはこだわりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The goal of STM is to simplify object reads and writes from multiple threads/protect state from concurrent updates. The Quarkus STM implementation will safely manage any conflicts between these threads using whatever isolation model has been chosen to protect that specific state instance (object in the case of Quarkus). In Quarkus STM, there are two isolation implementations, pessimistic (the default), which would cause conflicting threads to be blocked until the original has completed its updates (committed or aborted the transaction); then there's the optimistic approach which allows all of the threads to proceed and checks for conflicts at commit time, where one or more of the threads may be forced to abort if there have been conflicting updates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>STM の目的は、オブジェクト読み込みを簡素化し、複数のスレッドから書き込みを行い、同時更新からの状態を保護することです。Quarkus の STM 実装では、特定のステートインスタンス (Quarkus の場合はオブジェクト) を保護するために選択された分離モデルを使用して、これらのスレッド間の競合を安全に管理します。Quarkus STM で は、2つの分離実装があります。ペシミスティックアプローチ (デフォルト) では、元のスレッドが更新を完了する (コミットまたはトランザクションを中止する) まで競合するスレッドがブロックされます。一方、オプティミスティックアプローチでは、すべてのスレッドの続行を許可し、同時に競合をチェックします。ここでは、競合更新がある場合は、1 つ以上のスレッドが強制的に中止されることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another benefit of STM is composability and modularity. You can write concurrent Quarkus objects/services that can be easily composed with any other services built using STM, without exposing the details of how the objects/services are implemented. As we discussed earlier, this ability to compose objects you wrote with those other teams may have written weeks, months or years earlier, and have A, C and I properties can be hugely beneficial. Furthermore, some STM implementations, including the one Quarkus uses, support nested transactions and these allow changes made within the context of a nested (sub) transaction to later be rolled back by the parent transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>STM のもう 1 つの利点は、構成可能性とモジュール性です。オブジェクト/サービスの実装詳細を公開することなく、STM を使用して構築された他の任意のサービスと簡単に構成することができる Quarkus オブジェクト/サービスを並行して書くことができます。先ほど説明したように、他のチームと一緒に書いたオブジェクトを、数週間、数ヶ月、数年前に書いたかもしれない、A、C、I のプロパティーのあるオブジェクトをコンパイルできるこの機能は、非常に有益です。さらに、Quarkus が使用しているものを含むいくつかの STM 実装では、入れ子になったトランザクションをサポートしており、入れ子になった (サブ) トランザクションのコンテキスト内で行われた変更を、後で親トランザクションによってロールバックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the default for STM object state is volatile, it is possible to configure the STM implementation such that an object's state is durable. Although it's possible to configure Narayana such that different backend datastores can be used, including relational databases, the default is the local operating system file system, which means you don't need to configure anything else with Quarkus such as a database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>STMオ ブジェクトステートのデフォルトは揮発性ですが、オブジェクトの状態が耐久性を持つように STM の実装を構成することができます。リレーショナルデータベースなど、さまざまなバックエンドのデータストアを使用できるように Narayana を設定することは可能です。ただし、デフォルトはローカルのオペレーティングシステムのファイルシステムであり、データベースのように、Quarkus で他の何かを設定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many STM implementations allow "plain old language objects" to be made STM-aware with little or no changes to the application code. You can build, test and deploy applications without wanting them to be STM-aware and then later add those capabilities if they become necessary and without much development overhead at all.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くの STM 実装では、アプリケーションコードをほとんど変更することなく、「古い言語オブジェクト」を STM 対応させることができます。アプリケーションを STM に対応させずに、アプリケーションの構築、テスト、デプロイし、必要になっときに、開発のオーバーヘッドがほとんどない状態で、これらの機能を後で追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also a fully worked example in the quickstarts which you may access by cloning the Git repository: `git clone {quickstarts-clone-url}`, or by downloading an {quickstarts-archive-url}[archive].  Look for the `software-transactional-memory-quickstart` example. This will help to understand how you can build STM-aware applications with Quarkus. However, before we do so there are a few basic concepts which we need to cover.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quickstarts には完全に動作する例もあり、Git リポジトリーを複製してアクセスすることができます。`git clone {quickstarts-clone-url}` あるいは {quickstarts-archive-url}[archive] をダウンロードしてください。`software-transactional-memory-quickstart` の例を見てください。これで、Quarkus を使って STM を意識したアプリケーションを構築する方法を説明しています。しかし、その前に、いくつかの基本的な概念を知っておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, as you will see, STM in Quarkus relies on a number of annotations to define behaviours. The lack of these annotations causes sensible defaults to be assumed but it is important for the developer to understand what these may be. Please refer to the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM manual] and the https://narayana.io//docs/project/index.html#d0e16133[STM annotations guide] for more details on all of the annotations Narayana STM provides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご覧のように、Quarkus の STM は、動作を定義するために多くのアノテーションに依存しています。これらのアノテーションがないために、適切なデフォルトが仮定されますが、開発者はこれらのアノテーションが何であるかを理解することが重要です。Narayana STM が提供するすべてのアノテーションの詳細については、https://narayana.io/docs/project/index.html#d0e16066[Narayana STM manual] と https://narayana.io//docs/project/index.html#d0e16133[STM アノテーションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the extension include it as a dependency in your application pom:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションを使用するには、アプリケーションの依存関係として以下を pom にインクルードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependencies&gt;
    &lt;!-- STM extension --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-narayana-stm&lt;/artifactId&gt;
      &lt;version&gt;${quarkus.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependencies&gt;
    &lt;!-- STM extension --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-narayana-stm&lt;/artifactId&gt;
      &lt;version&gt;${quarkus.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order for the STM subsystem to have knowledge about which classes are to be managed within the context of transactional memory it is necessary to provide a minimal level of instrumentation. This occurs by categorising STM-aware and STM-unaware classes through an interface boundary; specifically all STM-aware objects must be instances of classes which inherit from interfaces that themselves have been annotated to identify them as STM-aware. Any other objects (and their classes) which do not follow this rule will not be managed by the STM subsystem and hence any of their state changes will not be rolled back, for example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>STM サブシステムが、トランザクションメモリーのコンテキスト内でどのクラスが管理されるべきかを認識するには最低限の手段を提供する必要があります。これは、STM を意識したクラス STM を意識しないクラスをインターフェース境界で分類することで行います。特に、すべての STM 対応オブジェクトは、STM 対応として識別するためのアノテーションが付けられているインターフェースから継承するクラスのインストタンスである必要があります。このルールに従わない他のオブジェクト (およびそのクラス) は、STM サブシステムによって管理されません。そのため、それらの状態の変更はロールバックされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The specific annotation that STM-aware application interfaces must use is `org.jboss.stm.annotations.Transactional`.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>STM を意識したアプリケーションインターフェースが使用しなければならない特定のアノテーションは、`org.jboss.stm.annotations.Transactional` です。例を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Transactional
public interface FlightService {
    int getNumberOfBookings();
    void makeBooking(String details);
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Transactional
public interface FlightService {
    int getNumberOfBookings();
    void makeBooking(String details);
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes which implement this interface are able to use additional annotations from Narayana to tell the STM subsystem about things such as whether a method will modify the state of the object, or what state variables within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back if a transaction aborts. As mentioned earlier, if those annotations are not present then defaults are chosen to guarantee safety, such as assuming all methods will modify state.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このインターフェースを実装したクラスは、Narayana からの追加のアノテーションを使用して、メソッドがオブジェクトの状態を変更するかどうかや、クラス内のどの状態変数をトランザクション的に管理すべきか (例えば、トランザクションが中断した場合にロールバックする必要のないインスタンス変数があるなど) を STM サブシステムに伝えることができます。前述のように、これらのアノテーションが存在しない場合は、すべてのメソッドが状態を変更すると仮定するなど、安全性を保証するためにデフォルトが選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FlightServiceImpl implements FlightService {
    @ReadLock
    public int getNumberOfBookings() { ... }
    public void makeBooking(String details) {...}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class FlightServiceImpl implements FlightService {
    @ReadLock
    public int getNumberOfBookings() { ... }
    public void makeBooking(String details) {...}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @NotState
    private int timesCalled;
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @NotState
    private int timesCalled;
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, by using the `@ReadLock` annotation on the `getNumberOfBookings` method, we are able to tell the STM subsystem that no state modifications will occur in this object when it is used in the transactional memory. Also, the `@NotState` annotation tells the system to ignore `timesCalled` when transactions commit or abort, so this value only changes due to application code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、`getNumberOfBookings` メソッドに `@ReadLock` アノテーションを使用することで、このオブジェクトがトランザクションメモリーで使用されているときに、状態の変更がこのオブジェクトでは発生しないことを STM サブシステムに伝えることができます。また、`@NotState` アノテーションは、トランザクションがコミットまたは中止されたときに `timesCalled` を無視するようにシステムに指示するので、この値はアプリケーションコードによってのみ変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement interfaces marked with the `@Transactional` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Transactional` アノテーションでマークされたインターフェースを実装したオブジェクトのトランザクション動作をより細かく制御する方法の詳細は、Narayana を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The STM subsystem needs to be told about which objects it should be managing. The Quarkus (aka Narayana) STM implementation does this by providing containers of transactional memory within which these object instances reside. Until an object is placed within one of these STM containers it cannot be managed within transactions and any state changes will not possess the A, C, I (or even D) properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>STM サブシステムは、どのオブジェクトを管理すべきかを伝える必要があります。Quarkus (別名 Narayana) の STM 実装は、これらのオブジェクトインスタンスが存在するトランザクションメモリーのコンテナーを提供することでこれを行います。オブジェクトがこれらの STM コンテナー内に置かれるまでは、トランザクション内で管理することはできず、状態の変更は A、C、I (あるいは D) のプロパティーを持たないことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, the term "container" was defined within the STM implementation years before Linux containers came along. It may be confusing to use especially in a Kubernetes native environment such as Quarkus, but hopefully the reader can do the mental mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意: "コンテナー" という用語は、Linux コンテナーが登場する何年も前に STM の実装で定義されていました。特に Quarkus のような Kubernetes ネイティブ環境で使用すると混乱するかもしれませんが、読者の方には柔軟に理解していただければと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default STM container (`org.jboss.stm.Container`) provides support for volatile objects that can only be shared between threads in the same microservice/JVM instance. When a STM-aware object is placed into the container it returns a handle through which that object should then be used in the future. It is important to use this handle as continuing to access the object through the original reference will not allow the STM subsystem to track access and manage state and concurrency control.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの STM コンテナー (`org.jboss.stm.Container`) は、同じマイクロサービス/JVM インスタンス内のスレッド間でのみ共有可能な揮発性オブジェクトをサポートしています。STM を意識したオブジェクトがコンテナーに置かれると、そのオブジェクトが将来的に使用されるべきハンドルを返します。元の参照を介してオブジェクトにアクセスし続けると、STM サブシステムがアクセスを追跡したり、状態や同時実行制御を管理したりすることができなくなるため、このハンドルを使用することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    import org.jboss.stm.Container;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    import org.jboss.stm.Container;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Container&lt;FlightService&gt; container = new Container&lt;&gt;(); &lt;1&gt;
    FlightServiceImpl instance = new FlightServiceImpl(); &lt;2&gt;
    FlightService flightServiceProxy = container.create(instance); &lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    Container&lt;FlightService&gt; container = new Container&lt;&gt;(); &lt;1&gt;
    FlightServiceImpl instance = new FlightServiceImpl(); &lt;2&gt;
    FlightService flightServiceProxy = container.create(instance); &lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to tell each Container about the type of objects for which it will be responsible. In this example it will be instances that implement the FlightService interface.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各コンテナーに、処理するオブジェクトの種類を伝える必要があります。この例では、FlightService インターフェースを実装したインスタンスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you create an instance that implements `FlightService`. You should not use it directly at this stage because access to it is not being managed by the STM subsystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、`FlightService` を実装したインスタンスを作成します。この段階では、STM サブシステムによってアクセスが管理されていないため、直接使用してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To obtain a managed instance, pass the original object to the STM `container` which then returns a reference through which you will be able to perform transactional operations. This reference can be used safely from multiple threads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理されたインスタンスを取得するには、元のオブジェクトを STM `container` に渡します。すると、トランザクション的な操作を実行できるようになる参照を返します。この参照は、複数のスレッドから安全に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining transaction boundaries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションの境界の定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once an object is placed within an STM container the application developer can manage the scope of transactions within which it is used. There are some annotations which can be applied to the STM-aware class to have the container automatically create a transaction whenever a specific method is invoked.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一度オブジェクトを STM コンテナー内に配置すると、アプリケーション開発者はそれが使用されるトランザクションの範囲を管理することができます。特定のメソッドが呼び出されたときにコンテナーが自動的にトランザクションを作成するように、STM を意識したクラスに適用できるアノテーションがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `@NestedTopLevel` or `@Nested` annotation is placed on a method signature then the STM container will start a new transaction when that method is invoked and attempt to commit it when the method returns. If there is a transaction already associated with the calling thread then each of these annotations behaves slightly differently: the former annotation will always create a new top-level transaction within which the method will execute, so the enclosing transaction does not behave as a parent, i.e., the nested top-level transaction will commit or abort independently; the latter annotation will create a transaction with is properly nested within the calling transaction, i.e., that transaction acts as the parent of this newly created transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@NestedTopLevel` または `@Nested` アノテーションがメソッドのシグネチャーに配置されている場合、STM コンテナーは、そのメソッドが呼び出されたときに新しいトランザク ションを開始し、そのメソッドが戻ってきたときにコミットを試みます。呼び出したスレッドに既にトランザクションが関連付けられている場合、これらのアノテーションの動作はそれぞれ若干異なります。前者のアノテーションでは、メソッドが実行される新しいトップレベルのトランザクションが常に作成されるため、周囲のトランザクションは親として動作せず、入れ子になったトップレベルのトランザクションは独立してコミットまたはアボートします。後者のアノテーションでは、呼び出したトランザクションの中に適切に入れ子になったトランザクションが作成され、そのトランザクションが新しく作成されたトランザクションの親として動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラム的アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can programmatically start a transaction before accessing the methods of STM objects:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは、STM オブジェクトのメソッドにアクセスする前に、プログラム的にトランザクションを開始することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AtomicAction aa = new AtomicAction(); &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AtomicAction aa = new AtomicAction(); &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>aa.begin(); &lt;2&gt;
{
    try {
        flightService.makeBooking("BA123 ...");
        taxiService.makeBooking("East Coast Taxis ..."); &lt;3&gt;
        &lt;4&gt;
        aa.commit();
        &lt;5&gt;
    } catch (Exception e) {
        aa.abort(); &lt;6&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>aa.begin(); &lt;2&gt;
{
    try {
        flightService.makeBooking("BA123 ...");
        taxiService.makeBooking("East Coast Taxis ..."); &lt;3&gt;
        &lt;4&gt;
        aa.commit();
        &lt;5&gt;
    } catch (Exception e) {
        aa.abort(); &lt;6&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An object for manually controlling transaction boundaries (AtomicAction and many other useful classes are included in the extension).  Refer https://narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction.html[to the javadoc] for more detail.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションの境界を手動で制御するためのオブジェクト (AtomicAction と他の多くの便利なクラスがエクステンションに含まれています)。詳細は https://narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction.html[to the javadoc] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically begin a transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラムでトランザクションを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that object updates can be composed which means that updates to multiple objects can be committed together as a single action.  [Note that it is also possible to begin nested transactions so that you can perform speculative work which may then be abandoned without abandoning other work performed by the outer transaction].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、オブジェクトの更新を構成することが可能です。つまり、複数のオブジェクトの更新を 1 つのアクションとしてまとめてコミットすることができます。[なお、ネストしたトランザクションを開始することで、推論的な作業を行うことも可能です。これは、その後、外側のトランザクションで行われた他の作業を放棄することなく、破棄できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the transaction has not yet been committed the changes made by the flight and taxi services are not visible outside of the transaction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このトランザクションはまだコミットされていないため、フライトやタクシーサービスによって行われた変更は、トランザクションの外からは見えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the commit was successful the changes made by the flight and taxi services are now visible to other threads.  Note that other transactions that relied on the old state may or may not now incur conflicts when they commit (the STM library provides a number of features for managing conflicting behaviour and these are covered in the Narayana STM manual).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミットが成功したので、フライトサービスやタクシーサービスで行われた変更が他のスレッドからも見えるようになりました。古い状態に依存していた他のトランザクションがコミットする際に競合が発生する可能性があることに注意してください (STM ライブラリーは競合する動作を管理するための多くの機能を提供しており、これらについては Narayana STM マニュアルに記載されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically decide to abort the transaction which means that the changes made by the flight and taxi services are discarded.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラム的には、フライトやタクシーサービスによって行われた変更が破棄されることを意味するトランザクションの中止を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distributed transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分散型トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing a transaction between multiple services is possible but is currently an advanced use case only and the Narayana documentation should be consulted if this behaviour is required. In particular, STM does not yet support the features described in the link:context-propagation[Context Propagation guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のサービス間でトランザクションを共有することは可能ですが、現在のところ高度なユースケースのみが対象です。この動作が必要な場合は Narayana のドキュメントを参照してください。特に STM は link:context-propagation[Context Propagation ガイド] で説明されている機能をまだサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes how to test Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、Quarkus Securityのテスト方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring User Information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー情報の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:security-properties[quarkus-elytron-security-properties-file] for testing security. This supports both embedding user info in `application.properties` and standalone properties files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティーをテストするために link:security-properties[quarkus-elytron-security-properties-file] を使用することができます。これは `application.properties` へのユーザー情報の埋め込みとスタンドアロンのプロパティーファイルの両方をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following configuration will allow for configuring the users in both the production where OAuth2 is required and development modes using link:config#configuration-profiles[Configuration Profiles].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、以下の構成では、OAuth2が必要な本番モードと開発モードの両方で link:https://quarkus.io/guides/config#configuration-profiles[Configuration Profiles]を使用してユーザーを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test Security Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティーエクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides explicit support for testing with different users, and with the security subsystem disabled. To use this you must include the `quarkus-test-security` artifact:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、異なるユーザーでのテストや、セキュリティーサブシステムを無効にした状態でのテストを明示的にサポートしています。これを使用するには、 `quarkus-test-security` のアーティファクトを含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This artifact provides the `io.quarkus.test.security.TestSecurity` annotation, that can be applied to test methods and test classes to control the security context that the test is run with. This allows you to do two things, you can disable authorization so tests can access secured endpoints without needing to be authenticated, and you can specify the identity that you want the tests to run under.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアーティファクトは `io.quarkus.test.security.TestSecurity` アノテーションを提供します。これをテストメソッドやテストクラスに適用することで、テストが実行されるセキュリティーコンテキストを制御することができます。認証を必要とせずに安全なエンドポイントにテストがアクセスできるように認証を無効にすることができ、テストを実行する際の ID を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A test that runs with authorization disabled can just set the enabled property to false:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認可を無効にして実行されるテストは、enabled プロパティーを false に設定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will disable all access checks, which allows the test to access secured endpoints without needing to authenticate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、すべてのアクセスチェックが無効になり、認証を必要とせずに保護されたエンドポイントにアクセスできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use this to configure the current user that the test will run as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを使用して、テストを実行する現在のユーザーを設定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will run the test with an identity with the given username and roles. Note that these can be combined, so you can disable authorization while also providing an identity to run the test under, which can be useful if the endpoint expects an identity to be present.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、指定されたユーザー名とロールを持つ ID でテストを実行します。これらを組み合わせることができるので、認証を無効にしながらテストを実行するための ID を提供することができることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The feature is only available for `@QuarkusTest` and will **not** work on a `@NativeImageTest`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能は `@QuarkusTest` でのみ利用可能で、 `@NativeImageTest` では動作 *しません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing security tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティーテストの混合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it becomes necessary to test security features using both `@TestSecurity` and Basic Auth (which is the fallback auth mechanism when none is defined), then Basic Auth needs to be enabled explicitly, for example by setting `quarkus.http.auth.basic=true` or `%test.quarkus.http.auth.basic=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@TestSecurity` と Basic Auth の両方を使ってセキュリティー機能をテストする必要が出てきた場合 (何も定義されていない場合のフォールバック認証メカニズムです)、明示的に有効にする必要があり、例えば `quarkus.http.auth.basic=true` や`%test.quarkus.http.auth.basic=true` と設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Wiremock for Integration Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合テストにWiremockを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus gRPC</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://grpc.io/[gRPC] is a high-performance RPC framework.  It can efficiently connect services implemented using various languages and frameworks.  It is also applicable in the last mile of distributed computing to connect devices, mobile applications, and browsers to backend services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://grpc.io/[gRPC] は高性能なRPCフレームワークです。様々な言語やフレームワークを使って実装されたサービスを効率的に接続することができます。また、デバイスやモバイルアプリケーション、ブラウザとバックエンドサービスを接続するために、分散コンピューティングのラストワンマイルにも適用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, gRPC uses HTTP/2, TLS, and https://developers.google.com/protocol-buffers[Protobuf (Protocol Buffers)].  In a microservice architecture, gRPC is an efficient, type-safe alternative to HTTP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的に、gRPCはHTTP/2、TLS、 link:https://developers.google.com/protocol-buffers[Protobuf(プロトコルバッファ)] を使用します。マイクロサービスアーキテクチャでは、gRPCはHTTPに代わる効率的で型安全な代替手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus gRPC extension integrate gRPC in Quarkus application.  It:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのgRPCエクステンションは、QuarkusアプリケーションにgRPCを統合します。それは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>supports implementing gRPC services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービスの実装をサポートしています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>supports consuming gRPC services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC サービスの利用をサポートしています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integrates with the reactive engine from Quarkus as well as the reactive development model</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのリアクティブエンジンやリアクティブ開発モデルと統合されています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>allows plain-text communication as well as TLS, and TLS with mutual authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>平文通信に加えてTLS、相互認証付きのTLSも可能です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus gRPC is based on https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus gRPCは link:https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC] をベースにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence offers a fluent query builder API on top of JPA with a deep Hibernate ORM integration that enables the use of advanced SQL features like Common Table Expressions while staying in the realm of the JPA model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Blaze-Persistenceは、Hibernate ORMとの深い統合により、JPAの上に流れるようなクエリビルダAPIを提供し、JPAモデルの範囲内でありながら、共通テーブル式のような高度なSQL機能の使用を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of that, the Blaze-Persistence Entity-View module allows for DTO definitions that can be applied to business logic queries which are then transformed to optimized queries that only fetch the data that is needed to construct the DTO instances.  The same DTO definitions can further be used for applying database updates, leading to a great reduction in boilerplate code and removing the need for object mapping tools.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、Blaze-Persistence Entity-Viewモジュールは、ビジネスロジッククエリに適用出来るDTO定義を可能にし、そのクエリはDTOインスタンスを構築するために必要なデータのみを取得する最適化されたクエリに変換されます。同じDTO定義をデータベースの更新にも使用することができます。これにより、ボイラプレートコードが大幅に削減され、オブジェクトマッピングツールの必要性がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension comes with default producers for `CriteriaBuilderFactory` and `EntityViewManager` that work out of the box given a working Hibernate ORM configuration. For customization, overriding of the default producers is possible via the standard mechanism as documented in the link:cdi-reference#default_beans[Quarkus CDI reference].  This is needed if you need to set custom link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#anchor-configuration-properties[Blaze-Persistence properties].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションには、 `CriteriaBuilderFactory` と `EntityViewManager` のデフォルトプロデューサーが付属しており、動作する Hibernate ORM 設定があればすぐに動作します。カスタマイズのために、 link:{quarkus-home-url}/guides/cdi-reference#default_beans[Quarkus CDIリファレンス]に記載されている標準的なメカニズムを使用して、デフォルトのプロデューサーをオーバーライドすることができます。これは、カスタムの link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#anchor-configuration-properties[Blaze-Persistenceプロパティー]を設定する場合に必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Inject` `CriteriaBuilderFactory` or `EntityViewManager` and use it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CriteriaBuilderFactory` または `EntityViewManager` を `@Inject` し、使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Blaze-Persistence extension: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Blaze-Persistence エクステンション: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jackson` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson] の為に `blaze-persistence-integration-jackson`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jaxrs` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]の為に `blaze-persistence-integration-jaxrs`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use in native images requires a dependency on the entity view annotation processor that may be extracted into a separate `native` profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージでの使用には、別の `native` プロファイルに抽出される可能性のあるエンティティービューアーノテーションプロセッサーへの依存関係が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `CriteriaBuilderFactory` and an `EntityViewManager` will be created based on the configured `EntityManagerFactory` as provided by the link:hibernate-orm[Hibernate-ORM extension].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CriteriaBuilderFactory` と `EntityViewManager` は、 link:{quarkus-home-url}/guides/hibernate-orm[Hibernate-ORM エクステンション]で提供される設定された `EntityManagerFactory` に基づいて作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then access these beans via injection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、注入によってこれらのBeanにアクセスすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityManager`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EntityManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CriteriaBuilderFactory`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CriteriaBuilderFactory` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityViewManager`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EntityViewManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark your CDI bean method as `@Transactional` so that a transaction is started or joined.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションが開始またはトランザクションに参加されるように、CDI Beanメソッドを `@Transactional` としてマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity-View</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティービューの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example updatable Entity-View</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更新可能なEntity-Viewの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various optional properties useful to refine your `EntityViewManager` and `CriteriaBuilderFactory` or guide guesses of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EntityViewManager` と `CriteriaBuilderFactory` を洗練させたり、またはQuarkusの推測をガイドするのに便利な様々なオプションのプロパティーがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no required properties, as long as the Hibernate ORM extension is configured properly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMエクステンションが適切に設定されている限り、必須のプロパティーはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When no property is set, the Blaze-Persistence defaults apply.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーが設定されていない場合は、Blaze-Persistenceのデフォルトが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Derby</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Derby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence currently does not come with support for Apache Derby.  This limitation could be lifted in the future, if there's a compelling need for it and if someone contributes it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Blaze-Persistenceは現在、Apache Derbyをサポートしていません。切実なニーズが存在し、誰かがコントリビュートしてくれれば、この制限は、将来的には解除されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're looking for information how to make a Quarkus extension configurable then see the &lt;&lt;writing-extensions.adoc#configuration,Writing Your Own Extension&gt;&gt; guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus エクステンションを設定可能にする方法については、link:writing-extensions.html#configuration[独自のエクステンションの作成] ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>System properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>システムプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS_DATASOURCE_PASSWORD=youshallnotpass &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QUARKUS_DATASOURCE_PASSWORD=youshallnotpass &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>greeting.message=hello &lt;1&gt;
quarkus.http.port=9090 &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>greeting.message=hello &lt;1&gt;
quarkus.http.port=9090 &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a user-defined configuration property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ユーザー定義の設定プロパティーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a configuration property consumed by the `quarkus-vertx-http` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `quarkus-vertx-http` 拡張モジュールによって消費される設定プロパティーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Config Sources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の設定ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] アノテーションを使用して、アプリケーションに設定プロパティーを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "greeting.message") &lt;1&gt;
String message;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ConfigProperty(name = "greeting.message") &lt;1&gt;
String message;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "greeting.suffix", defaultValue="!") &lt;2&gt;
String suffix;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ConfigProperty(name = "greeting.suffix", defaultValue="!") &lt;2&gt;
String suffix;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "greeting.name")
Optional&lt;String&gt; name; &lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ConfigProperty(name = "greeting.name")
Optional&lt;String&gt; name; &lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロパティーに値を指定しないと、アプリケーションの起動は失敗し、`javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message` が出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is injected if the configuration does not provide a value for `greeting.suffix`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト値は、設定が `greeting.suffix` の値を提供していない場合に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロパティーは任意です。設定が `greeting.name` の値を提供していない場合は、空の `Optional` が注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String databaseName = ConfigProvider.getConfig().getValue("database.name", String.class);
Optional&lt;String&gt; maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue("database.name", String.class);
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>String databaseName = ConfigProvider.getConfig().getValue("database.name", String.class);
Optional&lt;String&gt; maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue("database.name", String.class);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.port=9090
%dev.quarkus.http.port=8181
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.port=9090
%dev.quarkus.http.port=8181
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dev* - Activated when in development mode (i.e. `quarkus:dev`)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dev* - 開発モードのときに有効になる (つまり `quarkus:dev`)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*test* - Activated when running tests
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*test* - テストを実行しているときに有効になる
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*prod* - The default profile when not running in development or test mode
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*prod* - 開発モードまたはテストモード以外で使用されるデフォルトプロファイル
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.port=9090
%staging.quarkus.http.port=9999
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.port=9090
%staging.quarkus.http.port=9999
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@ConfigProperty("quarkus.profile")` will *not* work properly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ConfigProperty("quarkus.profile")` を使用すると正常に**動作しません**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parent Profile</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>親プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Runtime Profile</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの実行時プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw package -Pnative -Dquarkus.profile=prod-aws
./target/my-app-1.0-runner // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw package -Pnative -Dquarkus.profile=prod-aws
./target/my-app-1.0-runner // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false
quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false
quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%dev.application.server=localhost
application.server=remotehost
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%dev.application.server=localhost
application.server=remotehost
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `HOST` 環境変数を展開し、`HOST` が設定されていない場合は、プロパティー `remote.host` の値をデフォルト値として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clearing properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーの削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>remote.host=quarkus.io
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>remote.host=quarkus.io
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indexed Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インデックスされたプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/mvnw quarkus:generate-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/mvnw quarkus:generate-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># # The HTTP port # #quarkus.http.port=8080</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># # The HTTP port # #quarkus.http.port=8080</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile` parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルの設定ファイルを生成するのではなく、`-Dfile` パラメーターを設定して実際の設定ファイルに追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/mvnw quarkus:generate-config -Dfile=application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/mvnw quarkus:generate-config -Dfile=application.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in `application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 自体は、アプリケーションと同じメカニズムで設定されます。Quarkus は、独自の設定のために `quarkus.` ネームスペースを予約します。たとえば、HTTPサーバーのポートを設定するには、 `application.properties` で `quarkus.http.port` を設定します。Quarkusの設定プロパティーはすべて link:all-config[文書化されており、検索可能です] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時に固定されたプロパティーは、link:all-config[設定オプションの一覧] でロックアイコン (icon:lock[]) マークが付きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors for configuration value resolution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定値解決のためのインターセプタ―</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, please check the link:https://smallrye.io/docs/smallrye-config/index.html[SmallRye Config documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は、link:https://smallrye.io/docs/smallrye-config/index.html[SmallRye Config のドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This technology is considered {extension-status}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この技術は、{extension-status}と考えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_experimental_ モードでは、アイデアを成熟させるために早期のフィードバックが求められます。ソリューションが成熟するまでの間、プラットフォームの安定性や長期的な存在を保証するものではありません。フィードバックは link:https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] や link:https://github.com/quarkusio/quarkus/issues[GitHubの課題管理] で受け付けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _preview_, backward compatibility and presence in the ecosystem is not guaranteed.  Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_preview_ では、下位互換性やエコシステムでの存在は保証されていません。具体的な改善には設定や API の変更が必要になるかもしれませんが、 _stable_ 版になるための計画は現在進行中です。フィードバックは link:https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] や link:https://github.com/quarkusio/quarkus/issues[GitHub の課題管理] で受け付けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being _stable_, backward compatibility and presence in the ecosystem are taken very seriously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_stable_ では、下位互換性があること、エコシステムの中に存在していることが、非常に重要だと考えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a full list of possible extension statuses, check our https://quarkus.io/faq/#extension-status[FAQ entry].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>とりうるエクステンションステータスの完全なリストについては、 link:https://quarkus.io/faq/#extension-status[FAQの項目] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query parameter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリーパラメーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with link:hibernate-orm[Hibernate ORM] or link:hibernate-orm-panache[Hibernate ORM with Panache].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用し、 link:hibernate-orm[Hibernate ORM]または link:hibernate-orm-panache[Hibernate ORM with Panache]を使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers three endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、3つのエンドポイントを提供する非常にシンプルなマイクロサービスを構築します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/public`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/public`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/users/me`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/users/me`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/admin`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/public` endpoint can be accessed anonymously.  The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `admin` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.  The `/api/users/me` endpoint is also protected with RBAC (Role-Based Access Control) where only users granted with the `user` role can access. As a response, it returns a JSON document with details about the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/public` エンドポイントは匿名でアクセスできます。 `/api/admin` エンドポイントは RBAC (Role-Based Access Control) で保護されており、 `admin` の役割を与えられたユーザーのみがアクセスできます。このエンドポイントでは、 `@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。 `/api/users/me` エンドポイントも RBAC (Role-Based Access Control) で保護されており、 `user` ロールで付与されたユーザーのみがアクセスできます。レスポンスとして、ユーザーに関する詳細を含むJSONドキュメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to add the database connector library of choice. Here we are using PostgreSQL as identity store.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>選択したデータベースコネクタライブラリを追加することを忘れないでください。ここでは、PostgreSQLをIDストアとして使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `security-jpa` extension which allows you to map your security source to JPA entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、セキュリティー ソースを JPA エンティティーにマップできる `security-jpa` エクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `security-jpa` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `security-jpa` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/public` endpoint. As you can see from the source code below, it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/public` エンドポイントの実装から始めましょう。以下のソースコードから分かるように、通常のJAX-RSリソースです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple. The main difference here is that we are using a `@RolesAllowed` annotation to make sure that only users granted with the `admin` role can access the endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` エンドポイントのソースコードも非常にシンプルです。ここでの主な違いは、 `admin` ロールで付与されたユーザーだけがエンドポイントにアクセスできるように `@RolesAllowed` アノテーションを使用していることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's consider the `/api/users/me` endpoint. As you can see from the source code below, we are trusting only users with the `user` role.  We are using `SecurityContext` to get access to the current authenticated Principal and we return the user's name. This information is loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、 `/api/users/me` エンドポイントを考えてみましょう。下のソースコードを見ればわかるように、 `user` の役割を持つユーザのみを信頼しています。現在認証されているプリンシパルへのアクセスを得るために `SecurityContext` を使用しており、ユーザーの名前を返します。この情報はデータベースから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining our user entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーエンティティーの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now describe how our security information is stored in our model by adding a few annotations to our `User` entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、 `User` エンティティーにいくつかのアノテーションを追加することで、セキュリティー情報がモデルにどのように保存されているかを説明することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension is only initialized if there is a single entity annotated with `@UserDefinition`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`security-jpa` エクステンションは、 `@UserDefinition` でアノテーションされた単一のエンティティーがある場合にのみ初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation must be present on a single entity. It can be a regular Hibernate ORM entity or a Hibernate ORM with Panache entity as in this example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションは、単一のエンティティーに存在しなければなりません。この例のように、通常のHibernate ORMエンティティーまたはHibernate ORM with Panacheエンティティーにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the user name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ユーザー名に使用されるフィールドを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the password. This defaults to using bcrypt hashed passwords, but you can also configure it for clear text passwords or custom passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、パスワードに使用するフィールドを示します。これはデフォルトでは bcrypt ハッシュ化されたパスワードを使用するように設定されていますが、クリアテキストパスワードやカスタムパスワード用に設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the comma-separated list of roles added to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、対象のプリンシパル表現属性に追加されたロールのコンマ区切りリストを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to add users while hashing the password with the proper bcrypt hash.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この方法では、パスワードを適切なbcryptハッシュでハッシュしながらユーザーを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`security-jpa` エクステンションは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store. The database schema is created by Hibernate ORM automatically on startup (change this in production) and we initialize the database with users and roles in the `Startup` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのコンテキストでは、IDストアとしてPostgreSQLを使用しています。データベーススキーマはHibernate ORMによって起動時に自動的に作成され(本番ではこれを変更します)、 `Startup` クラスのユーザーとロールでデータベースを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environments ;-).  As a result, the `security-jpa` defaults to using bcrypt-hashed passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おそらく役に立たないと思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください。)その結果、 `security-jpa` はデフォルトで bcrypt でハッシュ化されたパスワードを使用するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following tests we use the basic authentication mechanism, you can enable it by setting `quarkus.http.auth.basic=true` in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のテストでは、基本的な認証メカニズムを使用していますが、 `application.properties` ファイルに `quarkus.http.auth.basic=true` を設定することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is now protected and the identities are provided by our database.  The very first thing to check is to ensure the anonymous access works.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが保護され、アイデンティティがデータベースから提供されるようになりました。非常に最初に確認しなければならないことは、匿名アクセスが機能することを確認することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's try a to hit a protected resource anonymously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、匿名で保護されたリソースを攻撃してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far so good, now let's try with an allowed user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここまでは順調ですが、今度は許可されたユーザーで試してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By providing the `admin:admin` credentials, the extension authenticated the user and loaded their roles.  The `admin` user is authorized to access to the protected resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`admin:admin` 資格情報を提供することで、エクステンションはユーザーを認証し、そのロールをロードしました。 `admin` ユーザーは、保護されたリソースへのアクセスを許可されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user `admin` should be forbidden to access a resource protected with `@RolesAllowed("user")` because it doesn't have this role.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `admin` は、この役割を持っていないので、 `@RolesAllowed("user")` で保護されたリソースへのアクセスを禁止する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, using the user `user` works and the security context contains the principal details (username for instance).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、ユーザー `user` を使用すると動作し、セキュリティーコンテキストには主要な詳細(例えばユーザー名)が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported model types</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているモデルの種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@UserDefinition` class must be a JPA entity (with Panache or not).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@UserDefinition` クラスは JPA エンティティーである必要があります(Panache を使用しているかどうかは問いません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Username` and `@Password` field types must be of type `String`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Username` と `@Password` フィールドの型は `String` でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Roles` field must either be of type `String` or `Collection&lt;String&gt;` or alternately a `Collection&lt;X&gt;` where `X` is an entity class with one `String` field annotated with the `@RolesValue` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Roles` フィールドは `String` か `Collection&amp;amp;lt;String&amp;amp;gt;` のいずれかのタイプであるか、または `Collection&amp;amp;lt;X&amp;amp;gt;` である必要があります。 `X` はエンティティークラスで、 `@RolesValue` アノテーションが付与された `String` フィールドが 1 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `String` role element type will be parsed as a comma-separated list of roles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各 `String` role 要素の型は、カンマで区切られたロールのリストとして解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Storing roles in another entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のエンティティーにロールを格納する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also store roles in another entity:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、別のエンティティーにロールを格納することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Password storage and hashing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パスワードの保存とハッシュ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, we consider passwords to be stored hashed with https://en.wikipedia.org/wiki/Bcrypt[bcrypt] under the https://en.wikipedia.org/wiki/Crypt_(C)[Modular Crypt Format] (MCF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、パスワードは MCF ( link:https://en.wikipedia.org/wiki/Crypt_©[Modular Crypt Format]) の下で link:https://en.wikipedia.org/wiki/Bcrypt[bcrypt]でハッシュ化されて保存されると考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to create such a hashed password we provide the convenient `String BcryptUtil.bcryptHash(String password)` function, which defaults to creating a random salt and hashing in 10 iterations (though you can specify the iterations and salt too).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなハッシュ化されたパスワードを作成する必要がある場合は、便利な `String BcryptUtil.bcryptHash(String password)` 関数を用意しています。デフォルトでは、ランダムなソルトを作成して 10 回の繰り返しでハッシュ化します (繰り返しとソルトも指定できます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with MCF you don't need dedicated columns to store the hashing algorithm, the iterations count or the salt because they're all stored in the hashed value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MCF を使うと、ハッシュアルゴリズムや反復回数、 ソルトを格納するための専用のカラムは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You also have the possibility to store password using different hashing algorithm `@Password(value = PasswordType.CUSTOM, provider = CustomPasswordProvider.class)`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、異なるハッシュアルゴリズム（ `@Password(value = PasswordType.CUSTOM, provider = CustomPasswordProvider.class)` ）を使用してパスワードを保存することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARN: you can also store passwords in clear text with `@Password(PasswordType.CLEAR)` but we strongly recommend against it in production.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>警告: `@Password(PasswordType.CLEAR)` を使ってパスワードをクリアテキストで保存することもできますが、本番では絶対にしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format for durations uses the standard `java.time.Duration` format.  You can learn more about it in the link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>期間のフォーマットは標準の `java.time.Duration` フォーマットを使用します。詳細は link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide duration values starting with a number.  In this case, if the value consists only of a number, the converter treats the value as seconds.  Otherwise, `PT` is implicitly prepended to the value to obtain a standard `java.time.Duration` format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数値で始まる期間の値を指定することもできます。この場合、値が数値のみで構成されている場合、コンバーターは値を秒として扱います。そうでない場合は、 `PT` が暗黙的に値の前に付加され、標準の `java.time.Duration` 形式が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - SmallRye Health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - SmallRye Health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use https://github.com/smallrye/smallrye-health/[SmallRye Health] an implementation of the https://github.com/eclipse/microprofile-health/[MicroProfile Health] specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:https://github.com/eclipse/microprofile-health/[MicroProfile Health]仕様の実装である link:https://github.com/smallrye/smallrye-health/[SmallRye Health]をQuarkusアプリケーションで使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Health allows applications to provide information about their state to external viewers which is typically useful in cloud environments where automated processes must be able to determine whether the application should be discarded or restarted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Healthは、アプリケーションがその状態に関する情報を外部のビューアーに提供することを可能にします。これは、典型的には自動化されたプロセスがアプリケーションを破棄すべきか再起動すべきかを判断できなければならないクラウド環境において、有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we build a simple REST application that exposes MicroProfile Health functionalities at the `/q/health/live` and `/q/health/ready` endpoints according to the specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、仕様書に従って `/q/health/live` と `/q/health/ready` のエンドポイントで MicroProfile Health の機能を公開するシンプルな REST アプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `microprofile-health-quickstart` {quickstarts-tree-url}/microprofile-health-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このソリューションは、 `microprofile-health-quickstart` {quickstarts-tree-url}/microprofile-health-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-health-quickstart \
    -Dextensions="smallrye-health"
cd microprofile-health-quickstart
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-health-quickstart \
    -Dextensions="smallrye-health"
cd microprofile-health-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-health` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、 `smallrye-health` エクステンションをインポートした Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-health` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、 `smallrye-health` エクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the health check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Importing the `smallrye-health` extension directly exposes three REST endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`smallrye-health` エクステンションを直接インポートすると、3つのRESTエンドポイントが公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/q/health/live` - The application is up and running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/q/health/live` - アプリケーションが起動していること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/q/health/ready` - The application is ready to serve requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/q/health/ready` - アプリケーションは、リクエストに対応する準備ができていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/q/health` - Accumulating all health check procedures in the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/q/health` - アプリケーションのすべてのヘルスチェック手順の累積</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To check that the `smallrye-health` extension is working as expected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`smallrye-health` エクステンションが期待通りに動作しているかのチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start your Quarkus application with `./mvnw compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `./mvnw compile quarkus:dev` でQuarkusアプリケーションを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>access the `http://localhost:8080/q/health/live` endpoint using your browser or `curl http://localhost:8080/q/health/live`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/q/health/live` エンドポイントにブラウザか、 `curl http://localhost:8080/q/health/live` でアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All of the health REST endpoints return a simple JSON object with two fields:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのヘルスRESTエンドポイントは、2つのフィールドを持つシンプルなJSONオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The general `status` of the health check is computed as a logical AND of all the declared health check procedures. The `checks` array is empty as we have not specified any health check procedure yet so let's define some.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックの一般的な `status` は、宣言されたすべてのヘルスチェックの論理的な AND として計算されます。 `checks` 配列は、まだヘルスチェックの手順を指定していないので空ですが、いくつか定義してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating your first health check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初めてのヘルスチェックの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we create our first simple health check procedure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、最初の簡単なヘルスチェック手順を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `org.acme.microprofile.health.SimpleHealthCheck` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.microprofile.health.SimpleHealthCheck` クラスを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's recommended to annotate the health check class with `@ApplicationScoped` or the `@Singleton` scope so that a single bean instance is used for all health check requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのヘルスチェック要求に単一のBeanインスタンスが使用されるように、ヘルスチェッククラスに `@ApplicationScoped` または `@Singleton` のスコープでアノテーションを付けることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a bean class annotated with one of the health check annotations declares no scope then the `@Singleton` scope is used automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックアノテーションの1つでアノテーションされたBeanクラスがスコープを宣言していない場合、 `@Singleton` のスコープが自動的に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, the health check procedures are defined as CDI beans that implement the `HealthCheck` interface and are annotated with one of the health check qualifiers, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご覧のように、ヘルスチェック・プロシージャは、 `HealthCheck` インターフェースを実装するCDI Beanとして定義され、次のようなヘルスチェック修飾子の1つでアノテーションされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Liveness` - the liveness check accessible at `/q/health/live`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Liveness` - `/q/health/live` でアクセス可能なLivenessチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Readiness` - the readiness check accessible at `/q/health/ready`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Readiness` - `/q/health/ready` でアクセス可能なReadinessチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`HealthCheck` is a functional interface whose single method `call` returns a `HealthCheckResponse` object which can be easily constructed by the fluent builder API shown in the example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`HealthCheck` は関数インターフェースで、その単一のメソッド `call` は `HealthCheckResponse` オブジェクトを返します。このオブジェクトは、例で示した fluent builder API で簡単に構築することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have started our Quarkus application in dev mode simply repeat the request to `http://localhost:8080/q/health/live` by refreshing your browser window or by using `curl http://localhost:8080/q/health/live`. Because we defined our health check to be a liveness procedure (with `@Liveness` qualifier) the new health check procedure is now present in the `checks` array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションを開発モードで起動しているので、 `http://localhost:8080/q/health/live` へのリクエストを ブラウザウィンドウを更新するか `curl http://localhost:8080/q/health/live` で単に繰り返してください。ヘルスチェックをlivenessプロシージャ（ `@Liveness` 修飾子付き）と定義したため、新しいヘルスチェックプロシージャが `checks` 配列に存在するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations! You've created your first Quarkus health check procedure. Let's continue by exploring what else can be done with SmallRye Health.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おめでとうございます。初めてのQuarkus Health Checkプロシージャを作成しました。続けて、SmallRye Healthで他にどのようなことができるかを調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding a readiness health check procedure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レディネス・ヘルスチェック手順の追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous section, we created a simple liveness health check procedure which states whether our application is running or not. In this section, we will create a readiness health check which will be able to state whether our application is able to process requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のセクションでは、アプリケーションが実行されているかどうかを示す単純な liveness ヘルスチェックプロシージャを作成しました。このセクションでは、アプリケーションがリクエストを処理することができるかどうかを示すことができるReadinessヘルスチェックを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create another health check procedure that simulates a connection to an external service provider such as a database. For starters, we will always return the response indicating the application is ready.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、データベースなどの外部サービスプロバイダへの接続をシミュレートする別のヘルスチェックプロシージャを作成します。まずは、アプリケーションの準備ができていることを示すレスポンスを常に返すようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create `org.acme.microprofile.health.DatabaseConnectionHealthCheck` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.microprofile.health.DatabaseConnectionHealthCheck` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now rerun the health check at `http://localhost:8080/q/health/live` the `checks` array will contain only the previously defined `SimpleHealthCheck` as it is the only check defined with the `@Liveness` qualifier. However, if you access `http://localhost:8080/q/health/ready` (in the browser or with `curl http://localhost:8080/q/health/ready`) you will see only the `Database connection health check` as it is the only health check defined with the `@Readiness` qualifier as the readiness health check procedure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/q/health/live`のヘルスチェックを再実行すると、 `checks` の配列には、以前に定義した `SimpleHealthCheck` のみが含まれます。これは `@Liveness` という修飾子で定義された唯一のチェックだからです。しかし、次のようにアクセスすると `http://localhost:8080/q/health/ready` (ブラウザや `curl http://localhost:8080/q/health/ready`)にアクセスすると、 `Database connection health check` のみが表示されます。これは、Readinessヘルスチェック手順として `@Readiness` の修飾子で定義された唯一のヘルスチェックだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you access `http://localhost:8080/q/health` you will get back both checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/q/health` にアクセスすると、両方のチェックが戻ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about which health check procedures should be used in which situation is detailed in the MicroProfile Health specification. Generally, the liveness procedures determine whether the application should be restarted while readiness procedures determine whether it makes sense to contact the application with requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どのような状況でどのヘルスチェック手順を使用すべきかについての詳細は、MicroProfile Health 仕様に記載されています。一般的には、liveness手続きはアプリケーションを再起動すべきかどうかを判断し、readiness手続きはアプリケーションにリクエストを出すことが意味のあることかどうかを判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Negative health check procedures</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネガティブヘルスチェックの手順</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we extend our `Database connection health check` with the option of stating that our application is not ready to process requests as the underlying database connection cannot be established. For simplicity reasons, we only determine whether the database is accessible or not by a configuration property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、 `Database connection health check` を拡張して、基礎となるデータベース接続が確立できないために、アプリケーションがリクエストを処理する準備ができていないことを示すオプションを追加します。簡略化のため、データベースにアクセスできるかどうかの判断は、設定プロパティでのみ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the `org.acme.microprofile.health.DatabaseConnectionHealthCheck` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.microprofile.health.DatabaseConnectionHealthCheck` クラスを以下のように更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now we used a simplified method of building a `HealthCheckResponse` through the `HealthCheckResponse#up(String)` (there is also `HealthCheckResponse#down(String)`) which will directly build the response object.  From now on, we utilize the full builder capabilities provided by the `HealthCheckResponseBuilder` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、レスポンスオブジェクトを直接構築する `HealthCheckResponse#up(String)` （ `HealthCheckResponse#down(String)` もあります）を通して `HealthCheckResponse` を構築するという単純な方法を使っていました。今後は、 `HealthCheckResponseBuilder` クラスが提供する完全なビルダー機能を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now rerun the readiness health check (at `http://localhost:8080/q/health/ready`)  the overall `status` should be DOWN. You can also check the liveness check at `http://localhost:8080/q/health/live` which will return the overall `status` UP because it isn't influenced by the readiness checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>再度、Readinessヘルスチェック `http://localhost:8080/q/health/ready`)を再実行すると、全ての `status` がDOWNするはずです。また、以下の場所でlivenessチェックを行うこともできます。 `http://localhost:8080/q/health/live`この場合、全体の `status` はUPです。これは、Readinessチェックの影響を受けないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we shouldn't leave this application with a readiness check in a DOWN state and because we are running Quarkus in dev mode you can add `database.up=true` in `src/main/resources/application.properties` and rerun the readiness health check again</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをReadinessチェックがDOWNの状態のままにしておくべきではない為、また、Quarkusを開発モードで実行しているため、 `src/main/resources/application.properties` に `database.up=true` を追加して、レディネスチェックを再実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it should be up again.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>再びUPになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding user-specific data to the health check response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックのレスポンスにユーザー固有のデータを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In previous sections, we saw how to create simple health checks with only the minimal attributes, namely, the health check name and its status (UP or DOWN). However, the MicroProfile Health specification also provides a way for the applications to supply arbitrary data in the form of key-value pairs sent to the consuming end. This can be done by using the `withData(key, value)` method of the health check response builder API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のセクションでは、最小限の属性、すなわちヘルスチェック名とそのステータス（UPまたはDOWN）のみを持つ単純なヘルスチェックを作成する方法を説明しました。しかし、MicroProfile Health仕様では、アプリケーションが任意のデータを、コンシューマーに送信されるキー・バリュー・ペアの形で供給する方法も提供しています。これは、ヘルスチェックレスポンスビルダーAPIの `withData(key, value)` メソッドを使用することで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create a new health check procedure `org.acme.microprofile.health.DataHealthCheck`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいヘルスチェック・プロシージャ `org.acme.microprofile.health.DataHealthCheck` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you rerun the liveness health check procedure by accessing the `/q/health/live` endpoint you can see that the new health check `Health check with data` is present in the `checks` array. This check contains a new attribute called `data` which is a JSON object consisting of the properties we have defined in our health check procedure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/q/health/live` エンドポイントにアクセスしてLivenessヘルスチェック・プロシージャを再実行すると、新しいヘルスチェック `Health check with data` が `checks` 配列に存在していることがわかります。このチェックには、 `data` という新しい属性が含まれています。この属性は、ヘルスチェック手順で定義したプロパティで構成されるJSONオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This functionality is specifically useful in failure scenarios where you can pass the error along with the health check response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能は、ヘルスチェックの応答と一緒にエラーを渡すことができる障害シナリオで特に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension health checks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extension may provide default health checks, including the extension will automatically register its health checks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一部のエクステンションでは、デフォルトのヘルスチェックを提供している場合があり、その場合、エクステンションは自動的にヘルスチェックを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, `quarkus-agroal` that is used to manage Quarkus datasource(s) automatically register a readiness health check that will validate each datasources: link:datasource#datasource-health-check[Datasource Health Check].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、Quarkusのデータソースを管理するために使用される `quarkus-agroal` は、各データソースを検証するReadinessヘルスチェックを自動的に登録します: link:datasource#datasource-health-check[データソースのヘルスチェック]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable extension health check via the property `quarkus.health.extensions.enabled` so none will be automatically registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのヘルスチェックは、プロパティ（ `quarkus.health.extensions.enabled` ）で無効にすることができ、自動的に登録されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health UI </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Health UI </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Experimental - not included in the MicroProfile specification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実験的 - MicroProfileの仕様に含まれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`health-ui` allows you to see your Health Checks in a Web GUI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`health-ui` はヘルスチェックの内容をWeb GUIで確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus `smallrye-health` extension ships with `health-ui` and enables it by default in dev and test modes, but it can also be explicitly configured for production mode as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの `smallrye-health` エクステンションは、 `health-ui` を同梱しており、devおよびtestモードでデフォルトで有効になりますが、productionモードでも同様に明示的に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`health-ui` can be accessed from http://localhost:8080/q/health-ui/ .</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`health-ui` は、 http://localhost:8080/q/health-ui/ からアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:health-ui-screenshot01.png[alt=Health UI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:health-ui-screenshot01.png[alt=Health UI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Health provides a way for your application to distribute information about its healthiness state to state whether or not it is able to function properly.  Liveness checks are utilized to tell whether the application should be restarted and readiness checks are used to tell whether the application is able to process requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Healthは、アプリケーションが正常に機能できるかどうかを表明するために、その健全性の状態に関する情報を配布する方法を提供します。Liveness チェックは、アプリケーションを再起動すべきかどうかを判断するために使用され、Readinessチェックは、アプリケーションがリクエストを処理できるかどうかを判断するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All that is needed to enable the SmallRye Health features in Quarkus is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusでSmallRye Healthの機能を有効にするために必要なのは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>adding the `smallrye-health` Quarkus extension to your project using the `quarkus-maven-plugin`: +</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `quarkus-maven-plugin`. で`smallrye-health` Quarkusエクステンションをプロジェクトに追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or simply adding the following Maven dependency: +</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、単に以下のMaven依存関係を追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize a bearer token access to protected resources using https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak Authorization Services].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションが link:https://www.keycloak.org/docs/latest/authorization_services/index.html[Keycloak Authorization Services] を使用して保護されたリソースへのベアラートークンアクセスを認証する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-keycloak-authorization` extension is based on `quarkus-oidc` and provides a policy enforcer that enforces access to protected resources based on permissions managed by Keycloak and currently can only be used with the Quarkus link:security-openid-connect[OIDC service applications].  It provides a flexible and dynamic authorization capability based on Resource-Based Access Control.  In other words, instead of explicitly enforcing access based on some specific access control mechanism (e.g.: RBAC), you just check whether or not a request is allowed to access a resource based on its name, identifier or URI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-keycloak-authorization` エクステンションは `quarkus-oidc` をベースにしており、Keycloakによって管理されるパーミッションに基づいて保護されたリソースへのアクセスを強制するポリシーエンフォーサーを提供しており、現在はQuarkus link:security-openid-connect[OIDCサービスアプリケーション] でのみ使用できます。これは、Resource-Based Access Controlに基づいた柔軟で動的な権限付与機能を提供します。言い換えれば、特定のアクセス制御メカニズム(RBACなど)に基づいて明示的にアクセスを強制するのではなく、名前、識別子、またはURIに基づいて、リクエストがリソースへのアクセスを許可されているかどうかをチェックするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By externalizing authorization from your application, you are allowed to protect your applications using different access control mechanisms as well as avoid re-deploying your application every time your security requirements change, where Keycloak will be acting as a centralized authorization service from where your protected resources and their associated permissions are managed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションから認証を外部化することで、異なるアクセス制御メカニズムを使用してアプリケーションを保護することができ、セキュリティー要件が変更されるたびにアプリケーションを再デプロイする必要がなくなります。Keycloakは、保護されたリソースおよび関連する権限が管理される一元化された認可サービスとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are already familiar with Keycloak, you’ll notice that the extension is basically another adapter implementation but specific for Quarkus applications.  Otherwise, you can find more information in the Keycloak https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにKeycloakに慣れ親しんでいる方は、このエクステンションは基本的にはアダプターの別実装ですが、Quarkusアプリケーションに特化したものであることにお気づきでしょう。それ以外の場合は、Keycloakの link:https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview[ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.keycloak.org/docs/latest/server_installation/index.html[Keycloak]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.keycloak.org/docs/latest/server_installation/index.html[Keycloak]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers two endpoints:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、2つのエンドポイントを提供する非常にシンプルなマイクロサービスを構築しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These endpoints are protected and can only be accessed if a client is sending a bearer token along with the request, which must be valid (e.g.: signature, expiration and audience) and trusted by the microservice.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのエンドポイントは保護されており、クライアントがリクエストと一緒にベアラートークンを送信している場合にのみアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for.  For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラートークンは、Keycloakサーバーによって発行され、トークンが発行された対象を表します。OAuth 2.0 認可サーバーであるため、トークンはユーザーの代わりに動作するクライアントも参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/users/me` endpoint can be accessed by any user with a valid token.  As a response, it returns a JSON document with details about the user where these details are obtained from the information carried on the token.  This endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `user` role can access this endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/users/me` エンドポイントは、有効なトークンを持つ任意のユーザーがアクセスできます。応答として、ユーザーに関する詳細が記載された JSON ドキュメントを返却します。このエンドポイントは RBAC (Role-Based Access Control) で保護されており、 `user` のロールで許可されたユーザーのみがこのエンドポイントにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) and only users granted with the `admin` role can access it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` エンドポイントは RBAC (役割ベースのアクセス制御) で保護されており、 `admin` の役割を付与されたユーザーのみがアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very simple example using RBAC policies to govern access to your resources.  However, Keycloak supports other types of policies that you can use to perform even more fine-grained access control.  By using this example, you'll see that your application is completely decoupled from your authorization policies with enforcement being purely based on the accessed resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、RBACポリシーを使用してリソースへのアクセスを制御する非常にシンプルな例です。しかし、Keycloakは他のタイプのポリシーをサポートしており、より詳細なアクセス制御を行うために使用することができます。この例を使用すると、アプリケーションが認可ポリシーから完全に切り離されており、エンフォースメントは純粋にアクセスされたリソースに基づいていることがわかるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-keycloak-authorization-quickstart` {quickstarts-tree-url}/security-keycloak-authorization-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-keycloak-authorization-quickstart` {quickstarts-tree-url}/security-keycloak-authorization-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project.  Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `keycloak-authorization` extension which is an implementation of a Keycloak Adapter for Quarkus applications and provides all the necessary capabilities to integrate with a Keycloak Server and perform bearer token authorization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Quarkusアプリケーション用のKeycloakアダプターの実装であり、Keycloakサーバーと統合してベアラートークン認証を実行するために必要なすべての機能を提供する `keycloak-authorization` エクステンションをインポートして、Mavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `oidc` and `keycloak-authorization` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで次のコマンドを実行することで、 `oidc` と `keycloak-authorization` のエクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/users/me` endpoint.  As you can see from the source code below it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは `/api/users/me` エンドポイントを実装してみましょう。下のソースコードを見るとわかるように、これは通常の JAX-RS リソースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` エンドポイントのソースコードも非常にシンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we did not define any annotation such as `@RoleAllowed` to explicitly enforce access to a resource.  The extension will be responsible to map the URIs of the protected resources you have in Keycloak and evaluate the permissions accordingly, granting or denying access depending on the permissions that will be granted by Keycloak.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースへのアクセスを明示的に強制するために `@RoleAllowed` のようなアノテーションは定義していないことに注意してください。このエクステンションは、Keycloakに保存されている、保護されているリソースのURIをマッピングし、 Keycloakで付与されるパーミッションに応じてアクセスを許可したり拒否したりして、パーミッションを評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenID Connect extension allows you to define the adapter configuration using the `application.properties` file which should be located at the `src/main/resources` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenID Connect エクステンションを使用すると、`src/main/resources` ディレクトリーに配置される `application.properties` ファイルを使用してアダプター設定を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should be able to access your Keycloak Server at http://localhost:8180/auth[localhost:8180/auth] or https://localhost:8543/auth[localhost:8543/auth].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloakサーバーには、 link:http://localhost:8180/auth[localhost:8180/auth] または link:https://localhost:8543/auth[localhost:8543/auth] でアクセスできるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log in as the `admin` user to access the Keycloak Administration Console.  Username should be `admin` and password `admin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak 管理 Consoleにアクセスするには、 `admin` ユーザーとしてログインしてください。ユーザー名は `admin` 、パスワードは `admin` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the {quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm.  For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-tree-url}/security-keycloak-authorization-quickstart/config/quarkus-realm.json[realm設定ファイル]をインポートして、新しいrealmを作成します。詳細については、 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[新しいレルムを作成する] 方法についてのKeycloakのドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is using bearer token authorization and the first thing to do is obtain an access token from the Keycloak Server in order to access the application resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションはベアラートークン認可を使用しており、まず最初に行うべきことは、アプリケーションのリソースにアクセスするためにKeycloak Serverからアクセストークンを取得することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example above obtains an access token for user `alice`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の例では、ユーザー `alice` のアクセストークンを取得しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any user is allowed to access the `http://localhost:8080/api/users/me` endpoint which basically returns a JSON payload with details about the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どのユーザーでも `http://localhost:8080/api/users/me` エンドポイントで、ユーザーに関する詳細情報を含む JSON ペイロードを取得することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role.  If you try to access this endpoint with the previously issued access token, you should get a `403` response from the server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/api/admin` エンドポイントは、 `admin` ロールを持つユーザーのみがアクセスできます。先程発行されたアクセストークンを使用してこのエンドポイントにアクセスしようとすると、サーバーから `403` 応答が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to access the admin endpoint you should obtain a token for the `admin` user:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>admin エンドポイントにアクセスするには、 `admin` ユーザーのトークンを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Checking Permissions Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラムで権限をチェックする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, you may want to programmatically check whether or not a request is granted to access a protected resource. By injecting a `SecurityIdentity` instance in your beans, you are allowed to check permissions as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>場合によっては、保護されたリソースにアクセスするためのリクエストが許可されているかどうかを プログラムでチェックしたいこともあるでしょう。Beanに `SecurityIdentity` インスタンスを注入することで、以下のようにパーミッションをチェックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Protected Resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>保護リソースのマッピング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the extension is going to fetch resources on-demand from Keycloak where their `URI` are used to map the resources in your application that should be protected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、エクステンションは Keycloak からオンデマンドでリソースを取得します。 `URI` は、保護されるべきアプリケーション内のリソースをマップするために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable this behavior and fetch resources during startup, you can use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作を無効にして、起動時にリソースをフェッチしたい場合は、以下の設定を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that, depending on how many resources you have in Keycloak the time taken to fetch them may impact your application startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloakにあるリソースの数によっては、それらを取得するのにかかる時間がアプリケーションの起動時間に影響することに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the default configuration, Keycloak is responsible for managing the roles and deciding who can access which routes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの構成では、Keycloakはロールを管理し、誰がどのルートにアクセスできるかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is based on the official https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_filter[Keycloak Policy Enforcer Configuration]. If you are looking for more details about the different configuration options, please take a look at this documentation,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定は、 link:https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_filter[Keycloak Policy Enforcer] の公式設定に基づいています。異なる設定オプションについての詳細をお探しの方は、こちらのドキュメントをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vault</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のような出力が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can use https://tika.apache.org/[Apache Tika] to parse the documents.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus アプリケーションが link:https://tika.apache.org/[Apache Tika] を使用してドキュメントを解析する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tika.apache.org/[Apache Tika] is a content analysis toolkit which is used to parse the documents in PDF, Open Document, Excel and many other well known binary and text formats using a simple uniform API. Both the document text and properties (metadata) are available once the document has been parsed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tika.apache.org/[Apache Tika] はコンテンツ分析ツールキットで、シンプルな統合 API を使した PDF、Open Document、Excel やその他多くのよく知られたバイナリーやテキスト形式の文書解析に使われます。文書のテキストとプロパティー (メタデータ) の両方が、文書が解析されると利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are planning to run the application as a native executable and parse documents that may have been created with charsets different than the standard ones supported in Java such as `UTF-8` then you should configure Quarkus to get the native image generator include all the charsets available to the JVM:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをネイティブ実行ファイルとして実行し、`UTF-8` のような Java でサポートされている標準の文字セットと異なる文字セットで作成された可能性のあるドキュメントを解析する場合は、Quarkus Maven Plugin を設定して、ネイティブイメージジェネレーターがJVM で利用可能なすべての文字セットを含むようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided solution contains a few additional elements such as tests and testing infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供されるソリューションには、テストやテストのインフラストラクチャなど、いくつかの追加要素が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `tika` and `resteasy` extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、`tika` と `resteasy` のエクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured you can add the `tika` and `resteasy` extensions to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで、次のコマンドを実行することで、 `tika` と `resteasy` のエクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the generated JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたJAX-RS リソースを調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/tika/TikaParserResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/java/org/acme/tika/TikaParserResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.tika;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package org.acme.tika;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next update `TikaParserResource` to accept and parse PDF and OpenDocument format documents:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に `TikaParserResource` を更新して、PDF および OpenDocument 形式の文書を受け入れて解析するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        return text;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        return text;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see the JAX-RS resource method was renamed to `extractText`, `@GET` annotation was replaced with `POST` and `@Path(/text)` annotation was added, and `@Consumes` annotation shows that PDF and OpenDocument media type formats can now be accepted. An injected `TikaParser` is used to parse the documents and report the extracted text. It also measures how long does it take to parse a given document.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご覧のように、JAX-RS のリソースメソッドの名前が `extractText` に変更され、`@GET` アノテーションが `POST` に置き換わり、`@Path(/text)` アノテーションが追加されました。また、`@Consumes` アノテーションでは、PDF と OpenDocument のメディアタイプのフォーマットが受け入れられるようになったことが示されています。注入された `TikaParser` は、文書を解析し、抽出されたテキストを報告するために使用されます。また、指定の文書の解析に要する時間を測定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and you should see output similar to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のような出力が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus:dev Output</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus:dev 出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the REST endpoint is running, we can get it to parse PDF and OpenDocument documents using a command line tool like curl:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使用して PDF や OpenDocument ドキュメントを解析することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.  Running it is as simple as executing `./target/tika-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常のコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドできます。`./target/tika-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.vaultproject.io/[HashiCorp Vault] is a multi-purpose tool aiming at protecting sensitive data, such as credentials, certificates, access tokens, encryption keys, ... In the context of Quarkus, several use cases are supported:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.vaultproject.io/[HashiCorp Vault] は、クレデンシャル、証明書、アクセストークン、暗号化キーなどの機密データの保護を目的とした多目的ツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mounting a map of properties stored into the https://www.vaultproject.io/docs/secrets/kv/index.html[Vault kv secret engine] as an Eclipse MicroProfile config source</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.vaultproject.io/docs/secrets/kv/index.html[Vault kv シークレットエンジン] に保存されたプロパティーのマップを Eclipse MicroProfile の設定ソースとしてマウントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>fetching credentials from Vault when configuring an Agroal datasource, as documented in the {vault-datasource-guide}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Agroal データソースを構成する際に、{vault-datasource-guide} で説明されているように、Vault から資格情報をフェッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>accessing Vault _kv secret engine_ programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vault _kv のシークレットエンジンに_ プログラムでアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>support for the https://www.vaultproject.io/docs/secrets/transit[Transit Secret Engine] as documented in the {vault-transit-guide}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.vaultproject.io/docs/secrets/transit[トランジットシークレットエンジン] のサポートは {vault-transit-guide} で文書化されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>support for several authentication methods as documented in the {vault-auth-guide}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{vault-auth-guide} で説明されているように、いくつかの認証方法をサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting Vault</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ボールトの起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start Vault in development mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでVaultを起動してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can check that vault is running with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のコマンドでVaultが実行されていることを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In development mode, Vault gets configured with several options that makes it convenient:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでは、Vaultはそれを便利にするいくつかのオプションが設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vault is already initialized with one key share (whereas in normal mode this has to be done explicitly and the number of key shares is 5 by default)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vault はすでに 1 つのキーシェアで初期化されています (通常のモードではこれは明示的に行う必要があり、キーシェアの数はデフォルトでは 5 となっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a _kv secret engine v2_ is mounted at `secret/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_kvシークレットエンジン v2_ `secret/` にマウントされています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First open a shell inside the vault container:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、Vaultのコンテナの中の貝殻を開けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now compile the application and run it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、アプリケーションをコンパイルして実行してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally test the new endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に新しいエンドポイントをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.vaultproject.io/[HashiCorp Vault]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.vaultproject.io/[HashiCorp Vault]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのエクステンションは、コアサービスに開発者向けの新しい動作を追加するもので、ビルド時の拡張とランタイムコンテナという2つの異なる部分から構成されています。拡張部分は、アノテーションやXML記述子の読み込みなど、すべてのメタデータ処理を担当します。この拡張フェーズの出力は、関連するランタイムサービスを直接インスタンス化するためのバイトコードとして記録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that metadata is only processed once at build time, which both saves on startup time, and also on memory usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、メタデータがビルド時に一度だけ処理されることを意味し、起動時間の節約と、処理に使用されるクラスなどがランタイムJVMにロードされない（あるいは存在しない）ため、メモリ使用量の節約の両方を実現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an in-depth documentation, see the link:building-my-first-extension[building my first extension] if you need an introduction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、詳細に踏み込むドキュメントです。入門ドキュメントが必要な場合は、 link:building-my-first-extension[初めてのエクステンションの作成]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension philosophy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション哲学</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section is a work in progress and gathers the philosophy under which extensions should be designed and written.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションは作業中であり、エクステンションがどのように設計され、どのように書かれるべきかの哲学を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why an extension framework</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜエクステンションフレームワークなのか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact that uses significantly less resources than traditional approaches. These can then be used to build native applications using GraalVM.  To do this you need to analyze and understand the full "closed world" of the application.  Without the full and complete context, the best that can be achieved is partial and limited generic support.  By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの使命は、使用するライブラリを含むアプリケーション全体を、従来のアプローチよりも大幅に少ないリソースしか使用しないアーティファクトに変換することです。これらを使用して、GraalVMを使用してネイティブアプリケーションを構築することができます。これを行うためには、アプリケーションの完全な「クローズドワールド」を分析し、理解する必要があります。完全で完璧なコンテキストがなければ、達成可能なものは最高でも部分的で限定的、一般的なサポートです。Quarkusのエクステンションアプローチを使用することで、Kubernetesやクラウドプラットフォームのようなメモリフットプリントに制約のある環境にJavaアプリケーションを合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the actions an extension performs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエクステンションフレームワークは、GraalVMを使用していない場合（HotSpotなど）でも、リソース利用率を大幅に改善します。エクステンションが実行するアクションをリストアップしてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gather build time metadata and generate code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時のメタデータを収集し、コードを生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この部分はGraalVMとは何の関係もありませんが、Quarkusがフレームワークを"ビルド時" に起動する方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションフレームワークは、必要に応じてメタデータの読み込み、クラスのスキャン、クラスの生成を容易にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張作業のごく一部は生成されたクラスを介して実行時に実行され、作業の大部分はビルド時に行われます (デプロイメント時と呼ばれます)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no `@Entity` does not need to start Hibernate ORM)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの近い世界観に基づいて、定見に基づいた賢明なデフォルトを強制（例えば、 `@Entity` のないアプリケーションは、Hibernate ORM を起動する必要はありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An extension hosts Substrate VM code substitution so that libraries can run on GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは Substrate VM のコード置換をホストし、ライブラリを GraalVM 上で実行できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most changes are pushed upstream to help the underlying library run on GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどの変更は、基礎となるライブラリがGraalVM上で動作するようにupstreamにプッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての変更をupstreamにプッシュできるわけではないので、エクステンションは Substrate VM 置換をホスト。これはコードパッチの一形態で、ライブラリが実行できるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Host Substrate VM code substitution to help dead code elimination based on the application needs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Substrate VMコード置換のホストにより、アプリケーションのニーズに基づいたデッドコードの排除を支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is application dependant and cannot really be shared in the library itself</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはアプリケーションに依存しており、ライブラリ自体で共有することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、Quarkusは、特定の接続プールとキャッシュプロバイダだけが必要であることを知っているため、Hibernateコードを最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send metadata to GraalVM for example classes in need of reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メタデータをGraalVMに送信。例えば、リフレクションに必要なクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この情報はライブラリ(Hibernateなど)ごとに静的ではありませんが、フレームワークはセマンティックな知識を持っており、どのクラスがリフレクションを必要とするかを知っています(例えば@Entityクラスなど)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Favor build time work over runtime work</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムワークよりもビルドタイムワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).  The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可能な限り、フレームワークに起動時（ランタイム）に作業をさせるのではなく、ビルド時（エクステンションのデプロイメント部分）に作業を行うことをお勧めします。そこでの作業が多いほど、そのエクステンションを使用しているQuarkusアプリケーションは小さくなり、ロードが速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to expose configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定を公開する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus simplifies the most common usages.  This means that its defaults might be different than the library it integrates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、最も一般的な使用法を簡略化しています。つまり、そのデフォルトは、統合されているライブラリとは異なる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.  For example `quarkus.database.url` and friends are shared between extensions as defining a database access is a shared task (instead of a `hibernate.` property for example).  The most useful configuration options should be exposed as `quarkus.[extension].` instead of the natural namespace of the library.  Less common properties can live in the library namespace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは、ライブラリの体験に焦点を当てるのではなく、Quarkusアプリケーションとして全体的に設定を見るべきです。例えば、データベースアクセスの定義が共有タスクであるように、 `quarkus.database.url` 等々がエクステンション間で共有されます（例えば `hibernate.` プロパティを使用される代わりに）。最も便利な設定オプションは、ライブラリの自然な名前空間ではなく、 `quarkus.[extension].` として公開されるべきです。あまり一般的ではないプロパティは、ライブラリの名前空間に置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.  Of course properties like host, port, password should be overridable at runtime.  But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusが最適化できる閉じた世界の仮定を完全に有効にするには、ビルド時に設定された設定オプションと実行時にオーバーライド可能な設定オプションのどちらを採用するか検討するべきでしょう。もちろん、ホスト、ポート、パスワードなどのプロパティは、実行時にオーバーライド可能でなければなりません。しかし、キャッシングを有効にしたり、JDBCドライバを設定したりするような多くのプロパティは、アプリケーションの再構築を安全に要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since CDI is the central programming model when it comes to component composition, frameworks and extensions should expose their components as beans that are easily consumable by user applications.  For example, Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the connection pool exposes `DataSource` beans etc.  Extensions must register these bean definitions at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI がコンポーネントの構成に関して中心的なプログラミングモデルであるため、フレームワークやエクステンションはそのコンポーネントを、ユーザアプリケーションが容易に消費できるBeanとして公開しなければなりません。例えば、Hibernate ORM は `EntityManagerFactory` と `EntityManager` の Bean を公開し、コネクションプールは `DataSource` のBeanを公開します。エクステンションは、ビルド時にこれらのBean定義を登録しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans backed by classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスに裏付けられたBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An extension can produce an &lt;&lt;cdi-reference.adoc#additional_beans,`AdditionalBeanBuildItem`&gt;&gt; to instruct the container to read a bean definition from a class as if it was part of the original application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは link:cdi-reference.html#additional_beans[`AdditionalBeanBuildItem`] コンテナに、元のアプリケーションの一部であるかのようにクラスからBeanの定義を読み込むように指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Class Registered by `AdditionalBeanBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>登録されている Bean クラス `AdditionalBeanBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a bean registered by an `AdditionalBeanBuildItem` does not specify a scope then `@Dependent` is assumed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AdditionalBeanBuildItem` で登録された Bean がスコープを指定しない場合は `@Dependent` とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All other beans can inject such a bean:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のすべての Bean は、このような Bean を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AdditionalBeanBuildItem` によって構築された Bean をインジェクトするBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And vice versa - the extension bean can inject application beans and beans provided by other extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、その逆に、 エクステンション Bean は、他のエクステンションによって提供されるアプリケーション Bean やアプリケーション Bean を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Bean Injection Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション Bean インジェクト例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a bean provided by other extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のエクステンションで提供されているBeanをインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject all beans matching the type `List&lt;String&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプ `List&lt;String&gt;` に一致するすべてのBeanを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some components may require additional initialization based on information collected during augmentation.  The most straightforward solution is to obtain a bean instance and call a method directly from a build step.  However, it is _illegal_ to obtain a bean instance during the augmentation phase.  The reason is that the CDI container is not started yet.  It's started during the &lt;&lt;bootstrap-three-phases,Static init bootstrap phase&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンポーネントによっては、拡張中に収集された情報に基づいて、追加の初期化が必要になる場合があります。最も簡単な解決策は、Bean のインスタンスを取得し、ビルドステップから直接メソッドを呼び出すことです。しかし、拡張フェーズ中にBeanインスタンスを取得することは _違反_ です。理由は、CDIコンテナがまだ起動していないからです。CDIコンテナは link:#bootstrap-three-phases[Static initブートストラップフェーズ] の間に起動されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in any bean. `RUN_TIME` config roots should only be injected after the bootstrap though.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`BUILD_AND_RUN_TIME_FIXED` と `RUN_TIME` 設定ルートは、どのBeanにも注入することができます。 `RUN_TIME` 設定ルールは、ブートストラップの後にのみ注入すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to invoke a bean method from a &lt;&lt;bytecode-recording,recorder method&gt;&gt; though.  If you need to access a bean in a `@Record(STATIC_INIT)` build step then is must either depend on the `BeanContainerBuildItem` or wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple - we need to make sure the CDI container is fully initialized and started.  However, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、 link:#bytecode-recording[recorderメソッド] からBeanメソッドを呼び出すことは可能です。 `@Record(STATIC_INIT)` ビルドステップで Bean にアクセスする必要がある場合は、 `BeanContainerBuildItem` に依存するか、 `BeanContainerListenerBuildItem` でロジックをラップしなければなりません。理由は簡単で、CDIコンテナが完全に初期化されて起動していることを確認する必要があるからです。しかし、CDI コンテナは `@Record(RUNTIME_INIT)` ビルドステップで完全に初期化されて実行されていると思っておいた方が安全です。コンテナへの参照は、 `CDI.current()` またはQuarkus固有の `Arc.container()` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to make sure the bean state guarantees the visibility, e.g. via the `volatile` keyword.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanの状態が可視性を保証していることを担保することを忘れないでください。たとえば、`volatile` キーワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one significant drawback of this "late initialization" approach.  An _uninitialized_ bean may be accessed by other extensions or application components that are instantiated during bootstrap.  We'll cover a more robust solution in the &lt;&lt;synthetic_beans&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この「遅延初期化」アプローチには、1つの重大な欠点があります。 _初期化されていない_ Beanは、ブートストラップ中にインスタンス化された他のエクステンションやアプリケーションコンポーネントからアクセスされる可能性があります。 link:#synthetic_beans[synthetic_beans]] で、よりロバストな解決策を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very useful pattern of creating such beans but also giving application code the ability to easily override some of the beans with custom implementations, is to use the `@DefaultBean` that Quarkus provides.  This is best explained with an example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような Bean を作成しつつ、アプリケーションコードにカスタム実装で Bean の一部を簡単にオーバーライドする機能を与えるという非常に便利なパターンは、Quarkusが提供している `@DefaultBean` を使用することです。これは例を挙げて説明するのが一番です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let us assume that the Quarkus extension needs to provide a `Tracer` bean which application code is meant to inject into its own beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、Quarkusエクステンションが `Tracer` Bean を提供する必要があると仮定して、アプリケーションコードがそれ自身の Bean に注入することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Dependent
public class TracerConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Dependent
public class TracerConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    public Tracer tracer(Reporter reporter, Configuration configuration) {
        return new Tracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    public Tracer tracer(Reporter reporter, Configuration configuration) {
        return new Tracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @DefaultBean
    public Configuration configuration() {
        // create a Configuration
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @DefaultBean
    public Configuration configuration() {
        // create a Configuration
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @DefaultBean
    public Reporter reporter(){
        // create a Reporter
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @DefaultBean
    public Reporter reporter(){
        // create a Reporter
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example application code wants to use `Tracer`, but also needs to use a custom `Reporter` bean, such a requirement could easily be done using something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、アプリケーションコードが `Tracer` を使用したいが、カスタムの `Reporter` Bean を使用する必要がある場合、そのような要件は、次のようなものを使用して簡単に行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Dependent
public class CustomTracerConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Dependent
public class CustomTracerConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    public Reporter reporter(){
        // create a custom Reporter
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    public Reporter reporter(){
        // create a custom Reporter
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although `@DefaultBean` is the recommended approach, it is also possible for application code to override beans provided by an extension by marking beans as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a simple example.  Suppose we work on an imaginary "quarkus-parser" extension and we have a default bean implementation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@DefaultBean` が推奨されていますが、CDI `@Alternative` としてBeanをマークし、 `@Priority` アノテーションを含めることで、アプリケーションコードがエクステンションによって提供されるBeanをオーバーライドすることも可能です。簡単な例を示しましょう。架空の"quarkus-parser"エクステンションで作業をしていて、デフォルトのBeanの実装を持っているとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And our extension also consumes this parser:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、私たちのエクステンションはこのパーサも消費します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, if a user or even some other extension needs to override the default implementation of the `Parser` the simplest solution is to use CDI `@Alternative` + `@Priority`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、ユーザーや他のエクステンションが `Parser` のデフォルトの実装を上書きする必要がある場合、最も簡単な解決策は CDI `@Alternative` + `@Priority` を使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`MyParser` is an alternative bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`MyParser` は代替 Beanです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代替 Beanを有効にします。優先度はデフォルトの Bean を上書きするために任意の数値を指定できますが、複数の代替 Bean がある場合は、最も高い優先度のものが優先されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI の代替 Beanは、インジェクションと型安全解決の間のみ考慮されます。例えば、デフォルトの実装では、オブザーバー通知を受け取ることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合成Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it is very useful to be able to register a synthetic bean.  Bean attributes of a synthetic bean are not derived from a java class, method or field.  Instead, the attributes are specified by an extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合成 Beanを登録できると非常に便利なことがあります。合成 Beanのビーン属性は，javaクラス，メソッド，フィールドから派生したものではありません。その代わりに、属性はエクステンションによって指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the CDI container does not control the instantiation of a synthetic bean the dependency injection and other services (such as interceptors) are not supported.  In other words, it's up to the extension to provide all required services to a synthetic bean instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDIコンテナは合成Beanのインスタンス化を制御しないので、依存性注入や他のサービス(インターセプタなど)はサポートされていません。言い換えれば、合成 Bean のインスタンスに必要なすべてのサービスを提供するのはエクステンション次第ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to register a &lt;&lt;cdi-reference.adoc#synthetic_beans,synthetic bean&gt;&gt; in Quarkus.  In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to &lt;&lt;bean_init&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusで link:cdi-reference.html#synthetic_beans[合成Bean] を登録する方法はいくつかあります。この章では、（ link:#bean_init[[bean_init]] と比較して）安全な方法でエクステンションBeanを初期化できるユースケースを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `SyntheticBeanBuildItem` can be used to register a synthetic bean:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`SyntheticBeanBuildItem` で合成 Bean を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>whose instance can be easily produced through a &lt;&lt;bytecode-recording,recorder&gt;&gt;,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのインスタンスは、 link:#bytecode-recording[レコーダー] を介して簡単に生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to provide a "context" bean that holds all the information collected during augmentation so that the real components do not need any "late initialization" because they can inject the context bean directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実際のコンポーネントはコンテキスト Beanを直接注入することができるので"遅延初期化"を必要としないように、拡張中に収集されたすべての情報を保持する"コンテキスト" Beanを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instance Produced Through Recorder</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコーダーを通して生成されたインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The string value is recorded in the bytecode and used to initialize the instance of `Foo`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文字列の値はバイトコードに記録され、 `Foo` のインスタンス初期化に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Context" Holder</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"コンテキスト"ホルダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "real" components can inject the `TestContext` directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>「本物の」コンポーネントは、 `TestContext` を直接注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some types of extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There exist multiple stereotypes of extension, let's list a few.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの定型的なタイプは複数存在しますが、いくつか挙げてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bare library running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアライブラリの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the less sophisticated extension.  It consists of a set of patches to make sure a library runs on GraalVM.  If possible, contribute these patches upstream, not in extensions.  Second best is to write Substrate VM substitutions, which are patches applied during native image compilation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはあまり洗練されていないエクステンションです。これは、ライブラリがGraalVM上で動作するようにするためのパッチのセットで構成されています。可能であれば、これらのパッチはエクステンションの中ではなく、アップストリームで貢献してください。二番目に良いのは、ネイティブイメージのコンパイル時に適用されるパッチである Substrate VM 置換を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get a framework running</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行中のフレームワークを取得する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc. + These operations should be done at build time and the metamodel be passed to the recorder DSL that will generate classes that will be executed at runtime and boot the framework.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時のフレームワークは通常、設定を読み込み、クラスパスとクラスをスキャンしてメタデータ(アノテーションやゲッターなど)を探し、その上にメタモデルを構築し、サービスローダパターンを介してオプションを見つけ、実行呼び出し(リフレクション)やプロキシインターフェイスなどを準備します。これらの操作はビルド時に行われ、メタモデルは実行時に実行されるクラスを生成するレコーダDSLに渡され、フレームワークを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI portable extension model is very flexible.  Too flexible to benefit from the build time boot promoted by Quarkus.  Most extension we have seen do not make use of these extreme flexibility capabilities.  The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parlance).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDIポータブルエクステンションモデルは非常に柔軟性が高いです。Quarkusが推進するビルドタイムブートの恩恵を受けるには、あまりにも柔軟性が高すぎます。私たちが見てきたほとんどのエクステンションは、このような極端な柔軟性の機能を利用していません。CDIエクステンションをQuarkusに移植する方法は、ビルド時（エクステンションの言い方ではデプロイ時）に様々なBeanを定義するQuarkusエクステンションとして書き換えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Technical aspect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>技術的な側面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three distinct bootstrap phases of a Quarkus app:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリには、3つの異なるブートストラップフェーズがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Static Init</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタティック初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime Init</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイム初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above `maven-compiler-plugin` configuration requires version 3.5+.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の `maven-compiler-plugin` の設定には、バージョン 3.5+ が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides `create-extension` Maven Mojo to initialize your extension project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、 `create-extension` Maven Mojo を提供し、拡張プロジェクトを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will try to auto-detect its options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションの自動検出が試行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from `quarkus` (Quarkus Core) or `quarkus/extensions` directory, it will use the 'Quarkus Core' extension layout and defaults.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus` (Quarkus Core) または `quarkus/extensions` ディレクトリからアクセスすると、'Quarkus Core' エクステンションのレイアウトとデフォルトが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with `-DgroupId=io.quarkiverse.[extensionId]`, it will use the 'Quarkiverse' extension layout and defaults.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`-DgroupId=io.quarkiverse.[extensionId]` を使用すると、'Quarkiverse' エクステンションのレイアウトとデフォルトを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in other cases it will use the 'Standalone' extension layout and defaults.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それ以外の場合は 'Standalone' エクステンションのレイアウトとデフォルトを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>we may introduce other layout types in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将来的には他のレイアウトタイプを導入する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creates four new Maven modules:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>4つの新しいMavenモジュールを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; a basic `MyExtProcessor` class is generated in this module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`extensions/my-ext/deployment` ディレクトリに `quarkus-my-ext-deployment` ; 基本的な `MyExtProcessor` クラスはこのモジュールで生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/deployment` directory; an empty JAX-RS Resource class and two test classes (for JVM mode and native mode) are generated in this module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`integration-tests/my-ext/deployment` ディレクトリに `quarkus-my-ext-integration-test` ; 空の JAX-RS Resource クラスと 2 つのテストクラス (JVM モードとネイティブモード用) がこのモジュールで生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Links these three modules where necessary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要に応じて、これらの3つのモジュールをリンクします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext` is added to the `&lt;dependencyManagement&gt;` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのBOM（Bill of Materials） `bom/application/pom.xml` の `&lt;dependencyManagement&gt;` に `quarkus-my-ext` が追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext-deployment` is added to the `&lt;dependencyManagement&gt;` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのBOM（Bill of Materials） `bom/application/pom.xml` の `&lt;dependencyManagement&gt;` に `quarkus-my-ext-deployment` が追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enum values (config items) are translated to skewed-case (hyphenated) by default. The table below illustrates an enum name and their canonical equivalence:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>列挙型の値(設定項目)は、デフォルトではスキュード・ケース(ハイフン付き)に変換されます。以下の表は、列挙型名とその正規の同等表現を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java enu</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java enu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Canonical equivalent</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正規の同等表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>discard</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>discard</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>read-uncommitted</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>read-uncommitted</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sigusr1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>sigusr1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JavaEnum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JavaEnum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>java-enum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>java-enum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MAKING_LifeDifficult</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MAKING_LifeDifficult</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>making-life-difficult</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>making-life-difficult</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YeOldeJBoss</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>YeOldeJBoss</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ye-olde-jboss</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ye-olde-jboss</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>camelCaseEnum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>camelCaseEnum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>camel-case-enum</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>camel-case-enum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the default behaviour which is based on implicit converter or a custom defined one add `@DefaultConverter` annotation to the configuration item</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>暗黙のコンバータまたはカスタム定義されたコンバータに基づくデフォルトの動作を使用するには、設定項目に `@DefaultConverter` アノテーションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the default converter (built in or a custom converter) to convert `Level.class` enum.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Level.class` enum を変換するには、デフォルトのコンバータ（内蔵またはカスタムコンバータ）を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primitives</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プリミティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health checks are provided via the `quarkus-smallrye-health` extension. It provides both liveness and readiness checks capabilities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックは `quarkus-smallrye-health` のエクステンションを介して提供されます。これは、livenessとreadinessのチェック機能の両方を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing an extension, it's beneficial to provide health checks for the extension, that can be automatically included without the developer needing to write their own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションを書くときには、開発者が自分で書かなくても自動的に含まれるようにすることができるエクステンションのヘルスチェックを提供することが有益です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to provide a health check, you should do the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックを行うためには、以下のようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the `quarkus-smallrye-health` extension as an **optional** dependency in your runtime module so it will not impact the size of the application if health check is not included.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` ヘルスチェックを *オプションの* 依存関係としてランタイムモジュールにインポートすることで、ヘルスチェックが含まれていない場合でもアプリケーションのサイズに影響を与えないようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションメトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` extension provide support for collecting metrics.  As a compatibility note, the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer library primitives, so the `quarkus-micrometer` extension can be enabled without breaking code that relies on the MP Metrics API.  Note that the metrics emitted by Micrometer are different, see the `quarkus-micrometer` extension documentation for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-micrometer` エクステンションと `quarkus-smallrye-metrics` エクステンションは、メトリクスを収集するためのサポートを提供します。互換性についての注意点として、 `quarkus-micrometer` エクステンションは MP Metrics API を Micrometer ライブラリのプリミティブに適応させているので、MP Metrics API に依存しているコードを壊すことなく `quarkus-micrometer` エクステンションを有効にすることができます。Micrometer が出力するメトリクスは異なることに注意してください。詳細は `quarkus-micrometer` エクステンションのドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The compatibility layer for MP Metrics APIs will move to a different extension in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MP Metrics API の互換性レイヤは、将来的には別のエクステンションに移行する予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding metrics for your extension, you may find yourself in one of the following situations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのメトリクスを追加するとき、以下のいずれかの状況に陥ることがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Case 3: It is necessary to collect metrics within the extension code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ケース3：エクステンションコード内でメトリクスを収集する必要がある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing JSON handling from an extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションからJSON処理をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions often need to register serializers and/or deserializers for types the extension provides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションはしばしば、エクステンションが提供する型のシリアライザやデシリアライザを登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, both Jackson and JSON-B extensions provide a way to register serializer/deserializer from within an extension deployment module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このため、Jackson 拡張モジュールと JSON-B 拡張モジュールの両方で、エクステンション内からシリアライザ/デシリアライザを登録する方法を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that not everybody will need JSON, so you need to make it optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての人がJSONを必要とするわけではないことを覚えておいてください。そのため、オプションとする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an extension intends to provide JSON related customization, it is strongly advised to provide customization for both Jackson and JSON-B.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションがJSON関連のカスタマイズを提供しようとする場合は、JacksonとJSON-Bの両方のカスタマイズを提供することを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add an *optional* dependency to `quarkus-jackson` on your extension's runtime module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、エクステンションのランタイムモジュールに `quarkus-jackson` への *オプションの* 依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then create a serializer or a deserializer (or both) for Jackson, an example of which can be seen in the `mongodb-panache` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、Jackson 用のシリアライザまたはデシリアライザ (またはその両方) を作成します。 `mongodb-panache` のエクステンションで例を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Jackson extension will then use the produced build item to register a module within Jackson automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、Jackson エクステンションは、生成されたビルドアイテムを使用して、Jackson 内で自動的にモジュールを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing of Quarkus extensions should be done with the `io.quarkus.test.QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-style tests that test specific functionalities.  It is not intended for testing user applications, as this should be done via `io.quarkus.test.junit.QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the application once at the start of the run, while `QuarkusUnitTest` deploys a custom Quarkus application for each test class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus エクステンションのテストは `io.quarkus.test.QuarkusUnitTest` JUnit 5 拡張モジュールを使用してください。このエクステンションを使用すると、特定の機能をテストする Arquillian スタイルのテストを行うことができます。ユーザーアプリケーションのテストは `io.quarkus.test.junit.QuarkusTest` を経由して行う必要があるため、ユーザーアプリケーションのテストを目的としたものではありません。主な違いは、 `QuarkusTest` は実行開始時にアプリケーションを起動するだけで、 `QuarkusUnitTest` は各テストクラスごとにカスタムの Quarkus アプリケーションを展開するという点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `QuarkusUnitTest` extension must be used with a static field. If used with a non-static field, the test application is not started.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusUnitTest` エクステンションは、静的フィールドと一緒に使用する必要があります。静的でないフィールドで使用した場合、テストアプリケーションは開始されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells JUnit that the Quarkus deployment should fail with a specific exception</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Quarkus のデプロイが特定の例外で失敗することを JUnit に伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing hot reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ホットリロードのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to write tests that verify an extension works correctly in development mode and can correctly handle updates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでエクステンションが正しく動作し、アップデートを正しく処理できるかどうかを検証するテストを書くことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For most extensions this will just work 'out of the box', however it is still a good idea to have a smoke test to verify that this functionality is working as expected. To test this we use `QuarkusDevModeTest`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどのエクステンションでは、これは「箱から出してすぐに」動作しますが、この機能が期待通りに動作しているかどうかを確認するためにスモークテストを行うことをお勧めします。このテストには `QuarkusDevModeTest` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method modifies a static resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは静的リソースを変更します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method adds a new static resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは新しい静的リソースを追加します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Includes static resources into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルに静的なリソースをインクルードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Includes directory's static resources into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディレクトリの静的リソースをネイティブ実行ファイルにインクルードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that all charsets should be enabled in native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージですべての文字セットを有効にすることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>EclipseでQuarkusエクステンションを書く際の唯一の特別な点は、エクステンションのビルドの一部としてAPT（Annotation Processing Tool）が必要であることです。つまり、以下が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://marketplace.eclipse.org/content/m2e-apt から `m2e-apt` をインストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define this property in your `pom.xml`: `&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;`, although if you rely on `io.quarkus:quarkus-build-parent` you will get it for free.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` にこのプロパティを追加します : `&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;` 。`io.quarkus:quarkus-build-parent` に依存している場合、既に追加済です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Troubleshooting / Debugging Tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トラブルシューティング / デバッグのヒント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.debug.generated-classes-dir` - to dump the generated classes, such as bean metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.debug.generated-classes-dir` - Beanのメタデータのような、生成されたクラスをダンプします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e.g. Panache entities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.debug.transformed-classes-dir` - Panache エンティティのような、変換されたクラスをダンプします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Test Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルテストエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特徴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manage Non-CDI Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非CDIサービスの管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a Non-CDI Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非CDIサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting a Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスの開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting/Stopping a Non-CDI Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非CDIサービスの開始/停止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We consume a ShutdownContextBuildItem to register the service shutdown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ShutdownContextBuildItemを消費してサービスのシャットダウンを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Startup and Shutdown Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタートアップとシャットダウンのイベント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object Substitution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オブジェクトの置換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering an Object Substitution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オブジェクト置換の登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replacing Classes in the Native Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージにおいてクラスを置換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Graal SDK supports substitutions of classes in the native image. An example of how one could replace the `XmlConfig/XmlData` classes with versions that have no JAXB annotation dependencies is shown in these example classes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Graal SDK は、ネイティブイメージ内のクラスの置換をサポートしています。 `XmlConfig/XmlData` のクラスを、JAXB アノテーションに依存しないバージョンのクラスに置き換える方法の例を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration reference documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定リファレンスドキュメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is an important part of each extension and therefore needs to be properly documented.  Each configuration property should have a proper Javadoc comment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定は各エクステンションの重要な部分なので、適切に文書化する必要があります。それぞれの設定プロパティには、適切な Javadoc コメントが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is handy to have the documentation available when coding, this configuration documentation must also be available in the extension guides.  The Quarkus build automatically generates the configuration documentation for you based on the Javadoc comments but you need to explicitly include it in your guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コーディング時にドキュメントを利用できるようにしておくと便利ですが、この設定ドキュメントはエクステンションガイドでも利用できるようにしておく必要があります。Quarkusのビルドでは、Javadocのコメントに基づいて設定ドキュメントが自動的に生成されますが、ガイドに明示的に含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we will explain everything you need to know about the configuration reference documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、設定リファレンスドキュメントについて知っておくべきことをすべて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each configuration property, you need to write some Javadoc explaining its purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それぞれの設定プロパティに対して、その目的を説明するJavadocを書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Always make the first sentence meaningful and self-contained as it is included in the summary table.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サマリーテーブルに記載されるので、必ず最初の一文に意味を持たせ、自己完結させましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can either use standard Javadoc comments or Asciidoc directly as a Javadoc comment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準のJavadocコメントかAsciidocを直接Javadocコメントとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We assume you are familiar with writing Javadoc comments so let's focus on our Asciidoc support.  While standard Javadoc comments are perfectly fine for simple documentation (recommended even), if you want to include tips, source code extracts, lists... Asciidoc comes in handy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、Javadocのコメントを書くことに慣れていることを前提としているので、Asciidocのサポートに焦点を当ててみましょう。標準的なJavadocのコメントは単純な文書化には完全に適していますが（推奨されています）、もしあなたがTipsやソースコードの抜粋、リストなどを含めたい場合は、Asciidocが便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a typical configuration property commented with Asciidoc:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、Asciidocでコメントされた典型的な設定プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the simple case: you just have to write Asciidoc and mark the comment with the `@asciidoclet` tag.  This tag has two purposes: it is used as a marker for our generation tool but it is also used by the `javadoc` process for proper Javadoc generation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは簡単なケースです: Asciidoc を書いて、コメントに `@asciidoclet` タグを付ければいいだけです。このタグには2つの目的があります: 生成ツールのマーカーとして使用されますが、 `javadoc` のプロセスで適切な Javadoc 生成のためにも使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's consider a more complicated example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、もう少し複雑な例を考えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few comments on this one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これについてのコメントをいくつか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every time you will need the indentation to be respected in the Javadoc comment (think list items spread on multiple lines or indented source code), you will need to disable temporarily the automatic Eclipse formatter (this, even if you don't use Eclipse as the formatter is included in our build).  To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the fact that they are separate comments and there is a space after the `//` marker. This is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javadocのコメントでインデントを尊重する必要がある場合（複数行にまたがるリスト項目やインデントされたソースコードを考えてみてください）には、Eclipseの自動フォーマッタを一時的に無効にする必要があります（これはEclipseを使用していない場合でも同様です。私たちのビルドにはフォーマッタが含まれている為です）。これを行うには、 `// @formatter:off` / `// @formatter:on` マーカーを使用してください。これらは別々のコメントであり、 `//` マーカーの後にスペースがあることに注意してください。これは必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, you can use the full power of Asciidoctor (except for the limitation below)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>見ての通り、Asciidoctorのフルパワーが使えます（以下の制限を除く）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use open blocks (`--`) in your Asciidoctor documentation.  All the other types of blocks (source, admonitions...) are supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Asciidoctor のドキュメントでは、オープンブロック ( `--` ) を使用することはできません。他のすべてのタイプのブロック (ソース、アドミッション...) がサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the doc generator will use the hyphenated field name as the key of a `java.util.Map` configuration item.  To override this default and have a user friendly key (independent of implementation details), you may use the `io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the following example,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、doc ジェネレータは `java.util.Map` 設定項目のキーとしてハイフンで囲まれたフィールド名を使用します。このデフォルトを上書きして（実装の詳細とは無関係に）ユーザーフレンドリーなキーを持つためには、 `io.quarkus.runtime.annotations.ConfigDocMapKey` アノテーションを使用することができます。以下の例を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will generate a configuration map key named `quarkus.some."cache-name"` instead of `quarkus.some."namespace"`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `quarkus.some."namespace"` の代わりに `quarkus.some."cache-name"` という名前の設定マップキーが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing section documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクションのドキュメントを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to generate configuration section of a given `@ConfigGroup`, Quarkus has got you covered with the `@ConfigDocSection` annotation.  See the code example below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ある `@ConfigGroup` の設定セクションを生成したい場合は、 `@ConfigDocSection` アノテーションで対応できます。以下のコード例を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating the documentation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating the documentation is easy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントの生成は簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `./mvnw clean install -DskipTests -DskipITs` will do.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw clean install -DskipTests -DskipITs` を実行すればOKです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can either do it globally or in a specific extension directory (e.g. `extensions/mailer`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グローバルに行うことも、特定のエクステンションディレクトリ ( `extensions/mailer` など) で行うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The documentation is generated in the global `target/asciidoc/generated/config/` located at the root of the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントはプロジェクトのルートにあるグローバル `target/asciidoc/generated/config/` で生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including the documentation in the extension guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションガイドにドキュメントを含める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you have generated the configuration reference documentation for your extension, you need to include it in your guide (and review it).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、あなたのエクステンションの設定参照ドキュメントが生成されたので、それをガイドに含める必要があります (そして、それをレビューする必要があります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is simple, include the generated documentation in your guide:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは簡単で、ガイドで生成されたドキュメントを含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in including the generated documentation for the config group, you can use the include statement below</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定グループのために生成されたドキュメントを含めたい場合は、以下のinclude文を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` configuration group will be generated in a file named `quarkus-vertx-http-config-group-form-auth-config.adoc`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `io.quarkus.vertx.http.runtime.FormAuthConfig` 設定グループは `quarkus-vertx-http-config-group-form-auth-config.adoc` という名前のファイルに生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few recommendations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>幾つかの推奨事項:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`opts=optional` is mandatory as we don't want the build to fail if only part of the configuration documentation has been generated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`opts=optional` は、設定ドキュメントの一部しか生成されていない場合にビルドを失敗させたくないので必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The documentation is generated with a title level of 2 (i.e. `==`).  You usually need to adjust it.  It can be done with `leveloffset=+N`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントはタイトルレベルが2(例: `==` )で生成されます。通常はこれを調整する必要があります。これは `leveloffset=+N` で行うことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, at the end of your documentation, include the extensive documentation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、文書の最後には、エクステンションのドキュメントをインクルードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, generate the documentation and check it out.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後にドキュメントを生成して確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous testing of your extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの継続的なテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview of what the process looks like.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの作者が、Quarkusの最新のスナップショットに対して自分のエクステンションを毎日簡単にテストできるようにするために、QuarkusはエコシステムCIという概念を導入しました。Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] には、この機能を利用するためのGitHub Actionsジョブの設定方法の詳細がすべて記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle support is considered preview.  You can use Gradle to create Quarkus projects as outlined in our guides. If you go beyond there will be cases where the Gradle tasks https://github.com/quarkusio/quarkus/issues/10189[does not behave as expected].  This is just a caution, and we recommend if you like Gradle you try it out and give us feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の Gradle サポートはプレビューとされています。このガイドで Gradle を使用して Quarkus プロジェクトを作成する方法の概要を説明しています。これを超えると、Gradleのタスクが link:https://github.com/quarkusio/quarkus/issues/5101[期待通りに動作しない場合があります] 。これはあくまでも注意事項であり、Gradle が好きな方は試してみてフィードバックをいただくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新規プロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to scaffold a Gradle project, is currently to use the Quarkus Maven plugin like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleプロジェクトをスキャフォールドにする最も簡単な方法は、現在のところ、このようにQuarkus Mavenプラグインを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you just launch `mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create` the Maven plugin asks for user inputs. You can disable (and use default values) this interactive mode by passing `-B` to the Maven command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create`  を起動するだけで、Maven プラグインはユーザー入力を要求します。 `-B`  を Maven コマンドに渡すことで、この対話型モードを無効にすることができます (デフォルト値を使用します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus project scaffolding automatically installs the Gradle wrapper (`./gradlew`) in your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトのスキャフォールドは、プロジェクトにGradleラッパー( `./gradlew` )を自動的にインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use a standalone Gradle installation, please use Gradle {gradle-version}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタンドアロンのGradleを使用したい場合は、Gradle {gradle-version} を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the attributes you can pass to the `create` command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の表は、 `create`  コマンドに渡すことができる属性の一覧です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`projectGroupId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`projectGroupId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.sample`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.sample`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The group id of the created project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作成されたプロジェクトのグループID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`projectArtifactId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`projectArtifactId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The artifact id of the created project. Not passing it triggers the interactive mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作成されたプロジェクトのアーティファクトID。これを渡さないと、インタラクティブモードがトリガされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`projectVersion`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`projectVersion`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of the created project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作成されたプロジェクトのバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`className`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`className`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Not created if omitted_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_省略された場合は作成されない_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fully qualified name of the generated resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソースの完全修飾名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`path`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/hello`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/hello`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The resource path, only relevant if `className` is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースパス、 `className` が設定されている場合のみ関連します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`extensions`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`extensions`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of extensions to add to the project (comma-separated)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトに追加するエクステンションのリスト (カンマ区切り)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you decide to generate a REST resource (using the `className` attribute), the endpoint is exposed at: `http://localhost:8080/$path`.  If you use the default `path`, the URL is: http://localhost:8080/hello.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST リソースを生成することにした場合 ( `className` 属性を使用)、エンドポイントは次の場所で公開されます: `http://localhost:8080/$path` 。デフォルトの `path` を使用する場合、URL は http://localhost:8080/hello です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is either generated in the current directory or in a directory named after the passed artifactId.  If the current directory is empty, the project is generated in-place.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトは、カレント・ディレクトリーに生成されるか、渡されたartifactIdにちなんだ名前のディレクトリーに生成されます。カレントディレクトリーが空の場合,プロジェクトはその場で生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A pair of Dockerfiles for native and jvm mode are also generated in `src/main/docker`.  Instructions to build the image and run the container are written in those Dockerfiles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードと jvm モード用の Dockerfile も `src/main/docker`  に生成されています。イメージのビルドとコンテナーの実行の指示は、これらの Dockerfile に書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom test configuration profile in JVM mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMモードでのカスタムテスト構成プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus tests in JVM mode are run using the `test` configuration profile. If you are not familiar with Quarkus configuration profiles, everything you need to know is explained in the link:config#configuration-profiles[Configuration Profiles Documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、JVMモードでのQuarkusテストは、 `test`  設定プロファイルを使用して実行されます。Quarkusの設定プロファイルについてよく知らない場合は、必要な情報はすべて link:config#configuration-profiles[設定プロファイルのドキュメント]で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Gradle build configuration shown below.  This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、以下に示す Gradle ビルド設定でテスト用のカスタム設定プロファイルを使用することは可能です。これは例えば、デフォルトのテストデータベースではない特定のデータベースを使ってテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `foo` configuration profile will be used to run the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`foo`  設定プロファイルがテストの実行に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to use a custom test configuration profile in native mode for now. Native tests are always run using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところ、ネイティブモードでカスタムテスト設定プロファイルを使用することはできません。ネイティブテストは常に `prod`  プロファイルを使用して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションへの対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside a Quarkus project, you can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトの内部から、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable an extension using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下を使ってエクステンションを有効化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions are passed using a comma-separated list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは、カンマ区切りのリストを使用して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension name is the GAV name of the extension: e.g. `io.quarkus:quarkus-agroal`.  But you can pass a partial name and Quarkus will do its best to find the right extension.  For example, `agroal`, `Agroal` or `agro` will expand to `io.quarkus:quarkus-agroal`.  If no extension is found or if more than one extensions match, you will see a red check mark ❌ in the command result.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-agroal` エクステンション名は、エクステンションのGAV名です。しかし、部分的な名前を渡すことができ、Quarkusは適切なエクステンションを見つけるために最善を尽くします。例えば、 `agroal`  、 `Agroal`  、 `agro`  は `io.quarkus:quarkus-agroal`  に展開されます。エクステンションが見つからなかったり、複数のエクステンションが一致した場合は、コマンドの結果に赤いチェックマーク❌が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グロブパターンに一致するエクステンションをすべてインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then update the application sources, resources and configurations.  The changes are automatically reflected in your running application.  This is great to do development spanning UI and database as you see changes reflected immediately.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、アプリケーションのソース、リソース、および設定を更新することができます。変更は実行中のアプリケーションに自動的に反映されます。変更がすぐに反映されるので、UIやデータベースにまたがった開発をするのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkusDev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkusDev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティーファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the working directory the development environment runs on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発環境が動作する作業ディレクトリーを変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `quarkusDev` task uses `compileJava` compiler options. These can be overridden by setting the `compilerArgs` property in the task.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `quarkusDev`  タスクは `compileJava`  コンパイラ・オプションを使用します。これらは、タスクの `compilerArgs`  プロパティーを設定することで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkusDev` sets the debug host to `localhost` (for security reasons). If you need to change this, for example to enable debugging on all hosts, you can use the `-DdebugHost` option like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `quarkusDev` はデバッグホストを `localhost` に設定します (セキュリティー上の理由から)。これを変更する必要がある場合、例えばすべてのホストでデバッグを有効にしたい場合は、 `-DdebugHost` オプションを次のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The plugin also exposes a `quarkusDev` configuration. Using this configuration to declare a dependency will restrict the usage of that dependency to development mode.  The `quarkusDev` configuration can be used as following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプラグインは `quarkusDev` の設定も公開しています。この設定を使って依存関係を宣言すると、その依存関係の使用が開発モードに制限されます。 `quarkusDev` の設定は以下のように使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモート開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to use development mode remotely, so that you can run Quarkus in a container environment (such as OpenShift)  and have changes made to your local files become immediately visible.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードをリモートで使用することができるので、コンテナー環境(OpenShiftなど)でQuarkusを実行して、ローカルファイルに加えられた変更をすぐに確認できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to develop in the same environment you will actually run your app in, and with access to the same services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、実際にアプリを実行するのと同じ環境で、同じサービスにアクセスしながら開発することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production applications in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must build a mutable application, using the `mutable-jar` format. Set the following properties in `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのためには、 `mutable-jar` のフォーマットを使って mutable アプリケーションを構築する必要があります。 `application.properties` で以下のプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Quarkus to use the mutable-jar format. Mutable applications also include the deployment time parts of Quarkus, so they take up a bit more disk space. If run normally they start just as fast and use the same memory as an immutable application, however they can also be started in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、QuarkusにMutable-jar形式を使用するように指示します。ミュータブルアプリケーションには、Quarkusのデプロイメント時間の部分も含まれているため、より多くのディスクスペースを占有します。普通に実行した場合は、イミュータブルアプリケーションと同じ速度で起動し、同じメモリーを使用しますが、devモードで起動することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The password that is used to secure communication between the remote side and the local side.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモート側とローカル側の通信を安全に保つためのパスワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL that your app is going to be running in dev mode at. This is only needed on the local side, so you may want to leave it out of the properties file and specify it as a system property on the command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリがdevモードで実行されるURL。これはローカル側でのみ必要なので、プロパティー ファイルから除外して、コマンド ラインでシステム プロパティーとして指定するとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mutable-jar` is then built in the same way that a regular Quarkus jar is built, i.e. by issuing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mutable-jar` は、通常のQuarkus jarをビルドするのと同じ方法でビルドできます。つまり、次を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./gradlew build
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./gradlew build
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you start Quarkus on the remote host set the environment variable `QUARKUS_LAUNCH_DEVMODE=true`. If you are on bare metal you can set it via the `export QUARKUS_LAUNCH_DEVMODE=true` command and then run the application with the proper `java -jar ...` command to run the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートホストでQuarkusを起動する前に、環境変数 `QUARKUS_LAUNCH_DEVMODE=true` を設定してください。ベアメタルの場合は、 `export QUARKUS_LAUNCH_DEVMODE=true` コマンドで設定し、その後、適切な `java -jar …​` コマンドでアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan on running the application via Docker, then you'll need to add `-e QUARKUS_LAUNCH_DEVMODE=true` to the `docker run` command.  When the application starts you should now see the following line in the logs: `Profile dev activated. Live Coding activated`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをDocker経由で実行する場合は、 `docker run` コマンドに `-e QUARKUS_LAUNCH_DEVMODE=true` を追加する必要があります。アプリケーションが起動すると、ログに次のような行が表示されるはずです： `Profile dev activated. Live Coding activated`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The remote side does not need to include Maven or any other development tools. The normal `fast-jar` Dockerfile that is generated with a new Quarkus application is all you need. If you are using bare metal launch the Quarkus runner jar, do not attempt to run normal devmode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモート側にはMavenなどの開発ツールを入れる必要はありません。新しいQuarkusアプリケーションで生成される通常の `fast-jar`  Dockerfileがあれば大丈夫です。ベアメタルでQuarkus runner jarを起動している場合は、通常のdevmodeを実行しようとしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to connect your local agent to the remote host, using the `remote-dev` command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `remote-dev` コマンドを使用し、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでブラウザを更新するたびに、ローカルで行った変更がリモートアプリにすぐに表示されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the config options are shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての設定項目を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In development mode, Quarkus starts by default with debug mode enabled, listening to port `5005` without suspending the JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでは、Quarkusはデフォルトでデバッグモードを有効にして起動し、JVMをサスペンドせずにポート `5005`  をリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be changed by giving the `debug` system property one of the following values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、 `debug` システム・プロパティーに以下の値のいずれかを与えることで変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false` - the JVM will start with debug mode disabled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`false`  - JVMはデバッグモードを無効にして起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true` - The JVM is started in debug mode and will be listening on port `5005`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`true`  - JVM はデバッグモードで起動され、 `5005`ポートをリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client` - the JVM will start in client mode and attempt to connect to `localhost:5005`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`client`  - JVM はクライアントモードで起動し、 `localhost:5005`に接続を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{port}` - The JVM is started in debug mode and will be listening on `{port}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{port}` - JVM はデバッグモードで起動されています。 `{port}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An additional system property `suspend` can be used to suspend the JVM, when launched in debug mode. `suspend` supports the following values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のシステム・プロパティー `suspend` は、デバッグ・モードで起動されたときに JVM をサスペンドするために使用できます。 `suspend` は以下の値をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`y` or `true` - The debug mode JVM launch is suspended</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`y` または `true` - デバッグモードの JVM 起動が中断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`n` or `false` - The debug mode JVM is started without suspending</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`n` または `false` - デバッグモードの JVM をサスペンドせずに起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./gradlew quarkusDev -Dsuspend -Ddebug` which is a shorthand for `./gradlew quarkusDev -Dsuspend=true -Ddebug=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./gradlew quarkusDev -Dsuspend -Ddebug`  を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます。 `./gradlew quarkusDev -Dsuspend=true -Ddebug=true` の短縮版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, attach your debugger to `localhost:5005`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、デバッガーを `localhost:5005`  にアタッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#project-creation[プロジェクトを生成] したら、お気に入りのIDEでインポートすることができます。唯一の条件は、Gradleプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Eclipse**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**Eclipse**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Gradle -&gt; Existing Gradle Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Gradle → Existing Gradle Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish`  をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./gradlew quarkusDev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離された端末で `./gradlew quarkusDev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**IntelliJ**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**IntelliJ**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside IntelliJ select `File -&gt; New -&gt; Project From Existing Sources...` or, if you are on the welcome dialog, select `Import project`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IntelliJの内部から `File → New → Project From Existing Sources…​`  を選択するか、ウェルカム・ダイアログであれば `Import project`  を選択してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select the project root</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのルートを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Gradle`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Import project from external model`  を選択して `Gradle`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the last screen click on Finish</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後の画面でFinishをクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離された端末または埋め込み端末で、 `./gradlew quarkusDev`  を実行してください。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `File -&gt; Open Project`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`File → Open Project` を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on `Open Project`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Open Project` をクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./gradlew quarkusDev`  を実行します。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>VS Codeでプロジェクトディレクトリーを開きます。Java Extension Pack(Javaエクステンションのセットをグループ化したもの)をインストールしている場合、プロジェクトはGradleプロジェクトとして読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executables make Quarkus applications ideal for containers and serverless workloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルにより、Quarkusアプリケーションはコンテナーやサーバーレスのワークロードに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(必ずGraalVMのJava 11バージョンを使用してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./gradlew build -Dquarkus.package.type=native`.  A native executable will be present in `build/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./gradlew build -Dquarkus.package.type=native` を実行し、ネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `build/` に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `buildNative` task has been deprecated in favor of `build -Dquarkus.package.type=native`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`buildNative` タスクは非推奨となり、 `build -Dquarkus.package.type=native` に代わりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native related properties can either be added in `application.properties` file, as command line arguments or in the `quarkusBuild` task.  Configuring the `quarkusBuild` task can be done as following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ関連のプロパティーは、 `application.properties`  ファイルにコマンドライン引数として追加するか、 `quarkusBuild`  タスクに追加することができます。 `quarkusBuild`  タスクの設定は以下のように行います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using the Gradle Kotlin DSL:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、Gradle Kotlin DSLを使用している場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.containerBuild` property to `true`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.native.containerBuild`  プロパティーを `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.buildImage` property to `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.native.buildImage`  プロパティーを `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the Gradle Groovy DSL, property keys must follow lower camel case notation.  e.g. `container-build` is not valid, and should be replaced by `containerBuild`.  This limitation does not apply to the Gradle Kotlin DSL.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle Groovy DSL を使用する場合、プロパティーキーは小文字のキャメルケース表記に従わなければなりません。例: `container-build` は無効なので、 `containerBuild` で置き換えてください。この制限は Gradle Kotlin DSL には適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build a container friendly executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーフレンドリーな実行ファイルをビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable will be specific to your operating system.  To create an executable that will run in a container, use the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルは、お使いのオペレーティングシステムに固有のものになります。コンテナー内で実行される実行ファイルを作成するには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a Docker container.  Note that in this case the build itself runs in a Docker container too, so you don't need to have GraalVM installed locally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成される実行ファイルは64bitのLinux実行ファイルになるので、OSによっては実行できなくなる可能性があります。しかし、Dockerコンテナーにコピーするので問題ありません。この場合、ビルド自体もDockerコンテナー内で動作するので、ローカルにGraalVMをインストールする必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the native executable will be generated using the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` Docker image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`  Dockerイメージを使用してネイティブ実行ファイルが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build a native executable with a different Docker image (for instance to use a different GraalVM version), use the `-Dquarkus.native.builder-image=&lt;image name&gt;` build argument.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>異なるDockerイメージでネイティブ実行ファイルをビルドしたい場合(例えば、異なるGraalVMのバージョンを使用するなど)、 `-Dquarkus.native.builder-image=&lt;image name&gt;` のbuild引数を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of the available Docker images can be found on https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io].  Be aware that a given Quarkus version might not be compatible with all the images available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能なDockerイメージのリストは、 link:https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io]にあります。特定のQuarkusのバージョンは、利用可能なすべてのイメージと互換性がない場合があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running native tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブテストの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the native tests using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のようにネイティブテストを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This task depends on `quarkusBuild`, so it will generate the native image before running the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このタスクは `quarkusBuild`  に依存しているので、テストを実行する前にネイティブイメージを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `native-test` source set is based on `main` and `test` source sets. It is possible to add an extra source set. For example, if your integration tests are located in an `integrationTest` source set, you can specify it as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `native-test` のソースセットは、 `main` と `test` のソースセットに基づいています。ソースセットを追加することも可能です。たとえば、統合テストが `integrationTest` のソースセットにある場合は、次のように指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using fast-jar</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>fast-jar の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fast-jar` is now the default quarkus package type. The result of `./gradlew build` command is a new directory under `build` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fast-jar` がデフォルトの quarkus パッケージタイプになりました。 `./gradlew build` コマンドの結果、 `build` の下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを実行するには、次のようにします: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to successfully run the produced jar, you need to have the entire contents of the `quarkus-app` directory. If any of the files are missing, the application will not start or might not function correctly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された jar を正常に実行するためには、 `quarkus-app` ディレクトリのすべての内容が必要です。いずれかのファイルが欠落していると、アプリケーションが起動しなかったり、正しく機能しない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `fast-jar` packaging results in creating an artifact that starts a little faster and consumes slightly less memory than a legacy Quarkus jar because it has indexed information about which dependency jar contains classes and resources. It can thus avoid the lookup into potentially every jar on the classpath that the legacy jar necessitates, when loading a class or resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fast-jar` パッケージングでは、どの依存関係のjarにクラスやリソースが含まれているかという情報がインデックス化されているため、レガシーのQuarkus jarよりも起動が少し速く、メモリ消費量もわずかに少ないアーティファクトを作成できます。このため、クラスやリソースをロードする際に、レガシー jar が必要とするクラスパス上のすべての jar を検索する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle plugin supports the generation of Uber-Jars by specifying a `quarkus.package.type` argument as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Gradleプラグインは、以下のように `--uber-jar`  引数を指定して UberJar の生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `--ignored-entry` argument:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UberJar を作成する際に、 `--ignored-entry`  引数を使用して生成された jar から除外したいエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entries are relative to the root of the generated Uber-Jar. You can specify multiple entries by adding extra `--ignored-entry` arguments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エントリーは、生成された Uber-Jar のルートからの相対的なものです。追加の `--ignored-entry`  引数を追加することで、複数のエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module projects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチモジュールプロジェクトでの作業</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus will not discover CDI beans inside another module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusは別のモジュール内のCDI Bean を検出しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include a `META-INF/beans.xml` file, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチモジュールプロジェクトのモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されていない限り、`META-INF/beans.xml`  ファイルをインクルードすることです。モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されている場合は、自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, there is some unofficial link:https://plugins.gradle.org/search?term=jandex[Gradle Jandex plugins] that can be used instead of the `META-INF/beans.xml` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、 `META-INF/beans.xml` ファイルの代わりに使える非公式の link:https://plugins.gradle.org/search?term=jandex[Gradle Jandex プラグイン] もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on this topic can be found on the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このトピックの詳細については、CDIガイドの link:cdi-reference#bean_discovery[Bean Discovery]セクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with `./gradlew build`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./gradlew build` によるビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from 1.1.0.Final, `./gradlew build` will no longer build the native image. Add `-Dquarkus.package.type=native` build argument explicitly as explained above if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.1.1.0.Final から、 `./gradlew build`  はネイティブイメージをビルドしなくなりました。必要であれば、上記で説明したように `-Dquarkus.package.type=native`  のビルド引数を明示的に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elasticsearch is a well known full text search engine and NoSQL datastore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchはよく知られた全文検索エンジンであり、NoSQLデータストアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will see how you can get your REST services to use an Elasticsearch cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスでElasticsearchクラスターを使用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides two ways of accessing Elasticsearch: via the lower level `RestClient` or via the `RestHighLevelClient` we will call them the low level and the high level clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはElasticsearchにアクセスするための2つの方法を提供しています:低レベルの `RestClient` 経由、または `RestHighLevelClient` 経由であり、低レベルと高レベルのクライアントと呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server is formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザとサーバー間の情報はすべてJSON形式になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements are stored in Elasticsearch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要素はElasticsearchに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution for the low level client is located in the `elasticsearch-rest-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>低レベルクライアントのソリューションは `elasticsearch-rest-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-client-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution for the high level client is located in the `elasticsearch-rest-high-level-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-high-level-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高レベルクライアントのソリューションは `elasticsearch-rest-high-level-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-high-level-client-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, and the Elasticsearch low level client extensions.  After this, the `quarkus-elasticsearch-rest-client` extension has been added to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、Elasticsearch低レベルクライアントエクステンションをインポートするMaven構造体を生成します。この後、 `quarkus-elasticsearch-rest-client` エクステンションが `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the high level client instead, replace the `elasticsearch-rest-client` extension by the `elasticsearch-rest-high-level-client` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりに高レベルクライアントを使いたい場合は、 `elasticsearch-rest-client` のエクステンションを `elasticsearch-rest-high-level-client` のエクステンションで置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `resteasy-jackson` extension here and not the JSON-B variant because we will use the Vert.x `JsonObject` helper to serialize/deserialize our objects to/from Elasticsearch and it uses Jackson under the hood.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは JSON-B などではなく `resteasy-jackson` エクステンションを使用しています。これは Vert.x `JsonObject` ヘルパーを使用して Elasticsearch との間でオブジェクトをシリアライズ/デシリアライズし、Jackson を使用するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don’t want to generate a new project, add the following dependencies to your pom.xml.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいプロジェクトを生成したくない場合は、以下の依存関係を pom.xml に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the Elasticsearch low level client, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchの低レベルクライアントの場合は、以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the Elasticsearch high level client, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchの高レベルクライアントの場合は、以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.elasticsearch.FruitService` that will be the business layer of our application and store/load the fruits from the Elasticsearch instance.  Here we use the low level client, if you want to use the high level client instead follow the instructions in the link:#using-the-high-level-rest-client[Using the High Level REST Client] paragraph instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、アプリケーションのビジネス層となる `org.acme.elasticsearch.FruitService` を作成し、Elasticsearch インスタンスからのフルーツを保存/ロードします。ここでは低レベルのクライアントを使用していますが、高レベルのクライアントを使用したい場合は、 link:#using-the-high-level-rest-client[高レベルのRESTクライアントの使用] パラグラフの指示に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example you can note the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、次のことに注意してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We inject an Elasticsearch low level `RestClient` into our service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearch の低レベル `RestClient` をサービスに注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create an Elasticsearch request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchリクエストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchに送信する前にオブジェクトをシリアライズするためにVert.x `JsonObject` を使用していますが、JSONにシリアライズしたものは何でも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We send the request (indexing request here) to Elasticsearch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchにリクエスト(ここではインデックス作成のリクエスト)を送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchからオブジェクトをデシリアライズするために、再びVert.x `JsonObject` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.elasticsearch.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `org.acme.elasticsearch.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装はとても簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義し、 `FruitService` を使って新しいフルーツをリストアップ/追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main property to configure is the URL to connect to the Elasticsearch cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定する主なプロパティーは、Elasticsearchクラスターに接続するためのURLです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A sample configuration should look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定のサンプルは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we are using a single instance running on localhost:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、ローカルホスト上で実行されている単一のインスタンスを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a more advanced configuration, you can find the comprehensive list of supported configuration properties at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より高度な設定が必要な場合は、このガイドの最後に、サポートされている設定プロパティーの包括的なリストがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of the parametric configuration, you can also programmatically apply additional configuration to the client by implementing a `RestClientBuilder.HttpClientConfigCallback` and annotating it with `ElasticsearchClientConfig`. You may provide multiple implementations and configuration provided by each implementation will be applied in a randomly ordered cascading manner.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パラメーターによる設定に加えて、 `RestClientBuilder.HttpClientConfigCallback` を実装して `ElasticsearchClientConfig` とアノテーションを付けることで、追加の設定をプログラムでクライアントに適用することもできます。複数の実装を追加することができ、各実装で提供された設定はランダムに順序付けられたカスケード方式で適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, when accessing an Elasticsearch cluster that is set up for TLS on the HTTP layer, the client needs to trust the certificate that Elasticsearch is using. The following is an example of setting up the client to trust the CA that has signed the certificate that Elasticsearch is using, when that CA certificate is available in a PKCS#12 keystore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、HTTPレイヤでTLS用に設定されているElasticsearchクラスタにアクセスする場合、クライアントはElasticsearchが使用している証明書を信頼する必要があります。以下は、Elasticsearchが使用している証明書に署名したCAの証明書がPKCS#12のキーストアで利用可能な場合に、クライアントがそのCAの証明書を信頼するように設定する例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_encrypted_communication.html[Elasticsearch documentation] for more details on this particular example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例の詳細については、 link:https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_encrypted_communication.html[Elasticsearchのドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes marked with `@ElasticsearchClientConfig` are made application scoped CDI beans by default.  You can override the scope at the class level if you prefer a different scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ElasticsearchClientConfig` と書かれたクラスは、デフォルトでアプリケーション・スコープ付きのCDI Beanになります。異なるスコープを希望する場合は、クラスレベルでスコープを上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As by default, the Elasticsearch client is configured to access a local Elasticsearch cluster on port 9200 (the default Elasticsearch port), if you have a local running instance on this port, there is nothing more to do before being able to test it!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Elasticsearchクライアントはポート9200(Elasticsearchのデフォルトポート)でローカルのElasticsearchクラスターにアクセスするように設定されているので、このポートでローカルで実行中のインスタンスがある場合、テストできるようにするためにやるべきことは何もありません!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Docker to run an Elasticsearch instance, you can use the following command to launch one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dockerを使ってElasticsearchインスタンスを起動したい場合は、以下のコマンドで起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/elasticsearch-low-level-client-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `FruitResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的なリソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/elasticsearch-low-level-client-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html]ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with `./mvnw quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw quarkus:dev` でQuarkusを起動する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add new fruits to the list via the 'Add fruit' form</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>「フルーツを追加」フォームで新しいフルーツをリストに追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>search for fruits by name or color via the 'Search Fruit' form</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前や色でフルーツを 'Search Fruit' フォームで検索することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the High Level REST Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高レベルRESTクライアントの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for the Elasticsearch High Level REST Client but keep in mind that it comes with some caveats:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはElasticsearch High Level REST Clientのサポートを提供していますが、いくつかの注意点があることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It drags a lot of dependencies - especially Lucene -, which doesn't fit well with Quarkus philosophy. The Elasticsearch team is aware of this issue and it might improve sometime in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは多くの依存関係(特に Lucene)を引きずっており、Quarkus の哲学にはあまり合っていません。Elasticsearch チームはこの問題を認識しており、将来的には改善されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is tied to a certain version of the Elasticsearch server: you cannot use a High Level REST Client version 7 to access a server version 6.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはElasticsearchサーバーの特定のバージョンに縛られています: 高レベルRESTクライアントのバージョン7を使用してサーバーのバージョン6にアクセスすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a version of the `FruitService` using the high level client instead of the low level one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、低レベルのクライアントの代わりに高レベルのクライアントを使用したバージョンの `FruitService` を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We inject an Elasticsearch `RestHighLevelClient` inside the service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービス内部にElasticsearch `RestHighLevelClient` を注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create an Elasticsearch index request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchのインデックスリクエストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We send the request to Elasticsearch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearchにリクエストを送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports Hibernate Search with Elasticsearch via the `hibernate-search-orm-elasticsearch` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `hibernate-search-orm-elasticsearch` エクステンションを介してElasticsearchでHibernate Searchをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search Elasticsearch allows to synchronize your JPA entities to an Elasticsearch cluster and offers a way to query your Elasticsearch cluster using the Hibernate Search API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search Elasticsearchでは、JPAエンティティーをElasticsearchクラスターに同期させることができ、Hibernate Search APIを使ってElasticsearchクラスターにクエリを発行する方法を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're interested in it, you can read the link:hibernate-search-orm-elasticsearch[Hibernate Search with Elasticsearch guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>興味のある方は、 link:hibernate-search-orm-elasticsearch[Hibernate Search with Elasticsearchガイド] を読んでみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cluster Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスターヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, both the extension will automatically add a readiness health check to validate the health of the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、どちらのエクステンションも、クラスターの健全性を検証するための readiness ヘルスチェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health/ready` endpoint of your application you will have information about the cluster status.  It uses the cluster health endpoint, the check will be down if the status of the cluster is **red**, or the cluster is not available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、アプリケーションの `/q/health/ready` エンドポイントにアクセスすると、クラスターの状態に関する情報を得ることができます。これはクラスターヘルスエンドポイントを使用しており、クラスターの状態が **赤** であったり、クラスターが利用できなかったりするとチェックが失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.elasticsearch.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、 `application.properties` の `quarkus.elasticsearch.health.enabled` プロパティーを `false` に設定することで無効にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use both clients in a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルで両方のクライアントを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/elasticsearch-low-level-client-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行は `./target/elasticsearch-low-level-client-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing an Elasticsearch cluster from a low level or a high level client is easy with Quarkus as it provides easy configuration, CDI integration and native support for it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、簡単な設定、CDIの統合、ネイティブサポートが提供されているため、低レベルまたは高レベルのクライアントからElasticsearchクラスターにアクセスすることが簡単にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events).  It is also usable as a standalone service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqyは、Quarkusのサーバーレス戦略の一環で、AWS Lambda、Azure Functions、Knative、Knative Events（クラウドイベント）など、様々なFaaS環境にデプロイ可能な関数を書くためのポータブルなJava APIを提供することを目的としています。スタンドアロンサービスとしても利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Funqy is an abstraction that spans multiple different cloud/function providers and protocols it has to be a very simple API and thus, might not have all the features you are used to in other remoting abstractions.  A nice side effect though is that Funqy is as optimized and as small as possible.  This means that because Funqy sacrifices a little bit on flexibility, you'll get a framework that has little to no overhead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy は複数の異なるクラウド/ファンクションプロバイダやプロトコルにまたがる抽象化なので、非常にシンプルな API でなければならず、あなたが使い慣れている他のリモーティング抽象化で提供される機能をすべて備えているわけではないかもしれません。しかし、良い副作用として、Funqyは可能な限り最適化されていて小さいということがあります。つまり、Funqy は柔軟性を少し犠牲にしているので、オーバーヘッドがほとんどないフレームワークを手に入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter and may or may not return a response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy API はシンプルです。メソッドに `@Funq` をアノテーションします。このメソッドはオプションの入力パラメータを1つだけ持つことができ、レスポンスを返すこともあれば返さないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java classes can also be used as input and output and must follow the Java bean convention and have a default constructor.  The Java type that is declared as the parameter or return type is the type that will be expected by the Funqy runtime.  Funqy does type introspection at build time to speed up boot time, so any derived types will not be noticed by the Funqy marshalling layer at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javaクラスは入力と出力としても使用でき、Java Bean の規約に従う必要があり、デフォルトのコンストラクタを持たなければなりません。パラメータや戻り値の型として宣言されたJavaの型は、Funqyのランタイムが期待する型です。Funqyは起動時間を短縮するためにビルド時に型のイントロスペクションを行いますので、派生型は実行時にFunqyのマーシャリング層に意識されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's an example of using a POJO as input and output types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POJO を入出力タイプとして使用した例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Async Reactive Types</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期リアクティブ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy supports the https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` reactive type as a return type.  The only requirement is that the `Uni` must fill out the generic type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqyは戻り値の型として link:https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` リアクティブ型をサポートしています。唯一の要件は、 `Uni` がジェネリック型を保持しなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function name defaults to the method name and is case sensitive.  If you want your function referenced by a different name, parameterize the `@Funq` annotation as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数名の既定値はメソッド名で、大文字と小文字を区別します。関数を別の名前で参照したい場合は、 `@Funq` アノテーションを次のようにパラメータ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy DI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy DI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Funqy Java class is a Quarkus Arc component and supports dependency injection through CDI or Spring DI.  Spring DI requires including the `quarkus-spring-di` dependency in your build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各Funqy JavaクラスはQuarkus Arcコンポーネントであり、CDIまたはSpring DIによる依存性注入をサポートしています。Spring DIでは、ビルドに `quarkus-spring-di` 依存関係を含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default object lifecycle for a Funqy class is `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy クラスのデフォルトのオブジェクトライフサイクルは `@Dependent` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキスト注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy API will usually not allow you to inject or use abstractions that are specific to a protocol (i.e. HTTP) or function API (i.e. AWS Lambda).  There are exceptions to the rule though and you may be able to inject contextual information that is specific to the environment you are deploying in.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy APIは通常、プロトコル(例:HTTP)や関数API(例:AWS Lambda)に固有の抽象化を注入したり使用したりすることはできません。しかし、ルールには例外があり、デプロイしている環境に固有のコンテキスト情報を注入できるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムに固有のコンテキスト情報を注入することはお勧めしません。 Function を移植性の高いものにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contextual information is injected via the `@Context` annotation which can be used on a function parameter or a class field.  A good example is the `CloudEvent` interface that comes with our Funqy Knative Cloud Events integration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキスト情報は `@Context` アノテーションを介して注入され、関数パラメータやクラスフィールドで使用することができます。良い例としては、Funqy Knative Cloud Events 統合に付属する `CloudEvent` インターフェイスがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Should I Use Funqy?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy を使うべきか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of Funqy is to allow you to write cross-provider functions so that you can move off of your current function provider if, for instance, they start charging you a lot more for their service.  Another reason you might not want to use Funqy is if you need access specific APIs of the target function environment.  For example, developers often want access to the AWS Context on Lambda.  In this case, we tell them they may be better off using the link:amazon-lambda[Quarkus Amazon Lambda] integration instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqyの目的は、クロスプロバイダの関数を書けるようにすることで、例えば、現在の Function プロバイダがサービスの料金を高くし始めた場合に、現在の Function プロバイダから離れることができるようにすることです。Funqyを使わないもう一つの理由は、ターゲットの Function 環境の特定のAPIにアクセスする必要がある場合です。例えば、開発者はLambda上のAWSコンテキストにアクセスしたいことがよくあります。この場合、代わりに link:amazon-lambda[Quarkus Amazon Lambda] インテグレーションを使った方が良いかもしれないと伝えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをネイティブ実行ファイルとして実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can of course create a native image using the instructions of the link:building-native-image[Building a native executable guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もちろん、 link:building-native-image[ネイティブ実行ファイルの構築ガイド] の指示を使ってネイティブイメージを作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the extension by running this command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドを実行してエクステンションを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Navigate to link:http://localhost:8080/q/swagger-ui/[localhost:8080/q/swagger-ui/] and you will see the Swagger UI screen:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://localhost:8080/q/swagger-ui/[localhost:8080/q/swagger-ui/] に移動すると、Swagger UIの画面が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Spring Web functionalities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているSpring Webの機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below summarizes the supported annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下の表は、サポートされているアノテーションをまとめたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Nam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RestController</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RestController</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RequestMapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RequestMapping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@GetMapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@GetMapping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PostMapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PostMapping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PutMapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PutMapping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@DeleteMapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@DeleteMapping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PatchMapping</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PatchMapping</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RequestParam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RequestParam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RequestHeader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RequestHeader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@MatrixVariable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@MatrixVariable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PathVariable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PathVariable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CookieValue</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@CookieValue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RequestBody</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RequestBody</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ResponseStatus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ResponseStatus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ExceptionHandler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ExceptionHandler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controller method return types</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コントローラメソッドの戻り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following method return types are supported:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のメソッドの戻り値の型がサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primitive types</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プリミティブ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String (which will be used as a literal, no Spring MVC view support is provided)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文字列 (リテラルとして使用されます。Spring MVC ビューのサポートはありません)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.springframework.http.ResponseEntity`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.springframework.http.ResponseEntity`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.Map`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.Map`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversion Table</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>変換テーブル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RequestMapping(path="/api")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RequestMapping(path="/api")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/api")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/api")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RequestMapping(consumes="application/json")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RequestMapping(consumes="application/json")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Consumes("application/json")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Consumes("application/json")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Produces("application/json")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Produces("application/json")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@QueryParam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@QueryParam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PathParam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PathParam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No equivalent in JAX-RS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSには同等のものはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document explains various HTTP features that you can use in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、Quarkus で使用できるさまざまな HTTP 機能について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP is provided using Eclipse Vert.x as the base HTTP layer. Servlet's are supported using a modified version of Undertow that runs on top of Vert.x, and RESTEasy is used to provide JAX-RS support. If Undertow is present RESTEasy will run as a Servlet filter, otherwise it will run directly on top of Vert.x with no Servlet involvement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP はベースとなる HTTP レイヤーとして Eclipse Vert.x を使用して提供されます。サーブレットは Vert.x の上で動作する Undertow の修正版を使用してサポートされています。また、JAX-RS のサポートには RESTEasy が使用されています。Undertow が存在する場合、RESTEasy はサーブレットフィルターとして動作します。そうでない場合は、サーブレットの関与なしに Vert.x の上で直接動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serving Static Resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>静的リソースの提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To serve static resources you must place them in the `META-INF/resources` directory of your application. This location was chosen as it is the standard location for resources in `jar` files as defined by the Servlet spec. Even though Quarkus can be used without Servlet following this convention allows existing code that places its resources in this location to function correctly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>静的リソースを提供するには、アプリケーションの `META-INF/resources` ディレクトリーに配置する必要があります。この場所が選ばれたのは、Servlet 仕様で定義されているように `jar` ファイル内のリソースの標準的な場所であるためです。Quarkus は Servlet なしで使用することができますが、この規則に従うことで、リソースをこの場所に配置する既存のコードが正しく機能するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and rather write `/webjars/jquery/jquery.min.js` instead of `/webjars/jquery/3.1.1/jquery.min.js` in your HTML files, you can add the `quarkus-webjars-locator` extension to your project.  To use it, add the following to your project's dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTMLファイルに `/webjars/jquery/3.1.1/jquery.min.js` の代わりに `/webjars/jquery/jquery.min.js` と書き、プロジェクトに `quarkus-webjars-locator` という拡張を追加することができます。これを使用するには、プロジェクトの依存関係に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-webjars-locator&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-webjars-locator&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Context path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキストパスの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will serve content from under the root context. If you want to change this you can use the `quarkus.http.root-path` config key to set the context path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkus はルートコンテキストの下からコンテンツを提供します。これを変更したい場合は、`quarkus.http.root-path` 設定キーを使用してコンテキストパスを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Servlet you can control the Servlet context path via `quarkus.servlet.context-path`. This item is relative to the http root above, and will only affect Servlet and things that run on top of Servlet. Most applications will want to use the HTTP root as this affects everything that Quarkus serves.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Servlet を使用している場合は、`quarkus.servlet.context-path` を通して Servlet のコンテキストパスを制御することができます。この項目は、上記の http ルートに相対的で、Servlet と、Servlet の上で実行されるものにのみ影響します。多くのアプリケーションでは、Quarkus が提供するすべてのサービスに影響するため、HTTP ルートを使用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If both are specified then all non-Servlet web endpoints will be relative to `quarkus.http.root-path`, while Servlet's will be served relative to `{quarkus.http.root-path}/{quarkus.servlet.context-path}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>両方を指定した場合、サーブレット以外のすべてのウェブエンドポイントは `quarkus.http.root-path` からの相対的なものになり、サーブレットは `{quarkus.http.root-path}/{quarkus.servlet.context-path}` からの相対的なものになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If REST Assured is used for testing and `quarkus.http.root-path` is set then Quarkus will automatically configure the base URL for use in Quarkus tests, so test URL's should not include the root path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストに REST Assured を使用し、`quarkus.http.root-path` が設定されている場合、Quarkus は自動的に Quarkus テストで使用するためのベース URL を設定します。そのため、テストの URL はルートパスには含めないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to have Quarkus support secure connections, you must either provide a certificate and associated key file, or supply a keystore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus でセキュアな接続をサポートするには、証明書と関連するキーファイルを提供するか、キーストアを提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both cases, a password must be provided. See the designated paragraph for a detailed description of how to provide it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いずれの場合も、パスワードを提供する必要があります。提供方法の詳細については、指定の段落を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable SSL support with native executables, please refer to our link:native-and-ssl[Using SSL With Native Executables guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルで SSL サポートを有効にするには、link:native-and-ssl[ネイティブ実行ファイルとの SSL の使用ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing a certificate and key file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>証明書とキーファイルの提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the certificate has not been loaded into a keystore, it can be provided directly using the properties listed below.  Quarkus will first try to load the given files as resources, and uses the filesystem as a fallback.  The certificate / key pair will be loaded into a newly created keystore on startup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>証明書がキーストアにロードされていない場合は、以下のプロパティーを使用して直接提供することができます。Quarkus はまず、与えられたファイルをリソースとしてロードしようとし、ファイルシステムをフォールバックとして使用します。証明書/キーペアは、起動時に新しく作成されたキーストアにロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your `application.properties` would then look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.ssl.certificate.file=/path/to/certificate
quarkus.http.ssl.certificate.key-file=/path/to/key
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.ssl.certificate.file=/path/to/certificate
quarkus.http.ssl.certificate.key-file=/path/to/key
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing a keystore</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーストアの提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternate solution is to directly provide a keystore which already contains a default entry with a certificate
 You will need to at least provide the file and a password.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別の解決策としては、すでに証明書付きのデフォルトのエントリーを含むキーストアを直接提供する方法もあります。
少なくともファイルとパスワードを提供する必要があります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the certificate/key file combination, Quarkus will first try to resolve the given path as a resource, before attempting to read it from the filesystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>証明書とキーファイルの組み合わせと同様に、Quarkus はまず、ファイルシステムからの読み込みを試みる前に、指定されたパスをリソースとして解決しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following property to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のプロパティーを `application.properties` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.ssl.certificate.key-store-file=/path/to/keystore
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.ssl.certificate.key-store-file=/path/to/keystore
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an optional hint, the type of keystore can be provided as one of the options listed.  If the type is not provided, Quarkus will try to deduce it from the file extensions, defaulting to type JKS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションのヒントとして、キーストアのタイプは、リストされているオプションの 1 つとして提供することができます。タイプが指定されていない場合、Quarkus はファイル拡張子からキーストアのタイプの推測を試行し、デフォルトでは JKS タイプになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.ssl.certificate.key-store-file-type=[one of JKS, JCEKS, P12, PKCS12, PFX]
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.ssl.certificate.key-store-file-type=[one of JKS, JCEKS, P12, PKCS12, PFX]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the password</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パスワードの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both aforementioned scenarios, a password needs to be provided to create/load the keystore with.  The password can be set in your `application.properties` (in plain-text) using the following property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述のいずれのシナリオでも、キーストアを作成/ロードするためにパスワードを指定する必要があります。パスワードは、以下のプロパティーを使用して `application.properties` で (プレーンテキストで) 設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.ssl.certificate.key-store-password=your-password
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.ssl.certificate.key-store-password=your-password
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, instead of providing the password as plain-text in the configuration file (which is considered bad practice), it can instead be supplied (using link:https://github.com/eclipse/microprofile-config[MicroProfile Config])  as the environment variable `QUARKUS_HTTP_SSL_CERTIFICATE_KEY_STORE_PASSWORD`.  This will also work in tandem with link:https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables[Kubernetes secrets].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、設定ファイルでパスワードをプレーンテキストとして提供する代わりに (これは悪い習慣と考えられています)、環境変数 `QUARKUS_HTTP_SSL_CERTIFICATE_KEY_STORE_PASSWORD` として ( link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile config を] 使用して) パスワードを提供することができます。これは、 link:https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables[Kubernetes secrets] と連動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Note: in order to remain compatible with earlier versions of Quarkus (before 0.16) the default password is set to "password". It is therefore not a mandatory parameter!_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意: Quarkus の以前のバージョン (0.16以前) との互換性を維持するために、デフォルトのパスワードは "password" に設定されています。したがって、これは必須のパラメーターではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to disable the HTTP port and only support secure requests. This is done via the `quarkus.http.insecure-requests` property in `application.properties`. There are three possible values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP ポートを無効にして、セキュアなリクエストのみをサポートすることも可能です。これは `application.properties` の `quarkus.http.insecure-requests` プロパティーで行います。3 つの値を利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`enabled`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`enabled`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default, HTTP works as normal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、HTTP は通常通りに動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`redirect`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`redirect`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP requests will be redirected to the HTTPS port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP リクエストは HTTPS ポートにリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`disabled`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`disabled`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP port will not be opened.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP ポートは開けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you use `redirect` or `disabled` and have not added a SSL certificate or keystore, your server will not start!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`redirect` または `disabled` を使用していて、SSL 証明書またはキーストアを追加していない場合は、サーバーが起動しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP/2 is enabled by default, and will be used by browsers if SSL is in use on JDK11 or higher. JDK8 does not support ALPN so cannot be used to run HTTP/2 over SSL. Even if SSL is not in use HTTP/2 via cleartext upgrade is supported, and may be used by non-browser clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP/2 はデフォルトで有効になっており、JDK11 以降で SSL が使用されている場合はブラウザーで使用されます。JDK8 は ALPN をサポートしていないため、SSL 上で HTTP/2 を実行するために使用することはできません。SSL が使用されていない場合でも、クリアテキストのアップグレードによる HTTP/2 はサポートされており、ブラウザー以外のクライアントでも使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable HTTP/2 you can set:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP/2 を無効にしたい場合は、以下を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.http2=false
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.http2=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening on a Random Port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランダムポートでのリスニング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to specify a port you can set `quarkus.http.port=0` or `quarkus.http.test-port=0`. A random open port will be picked by the OS, and a log message printed in the console. When the port is bound the `quarkus.http.port` system property will be set to the actual port that was selected, so you can use this to get the actual port number from inside the application. If you are in a test you can inject the URL normally and this will be configured with the actual port, and REST Assured will also be configured appropriately.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ポートを指定したくない場合は、`quarkus.http.port=0` または `quarkus.http.test-port=0` を指定することができます。ランダムに開いているポートが OS によって選ばれ、コンソールにログメッセージが表示されます。ポートがバインドされると、`quarkus.http.port` システムプロパティーには選択された実際のポートが設定されます。そのため、これを利用して、アプリケーション内から実際のポート番号を取得できます。テスト中の場合は普通に URL を注入することができ、これは実際のポートで設定され、REST Assured も適切に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As this sets a system property you can access `quarkus.http.port` via MicroProfile Config, however if you use injection the injected value may not always be correct. This port allocation is one of the last things to happen in Quarkus startup, so if your object that is being injected is created eagerly before the port has opened the injected value will not be correct.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはシステムプロパティを設定するものなので、MicroProfile Config から `quarkus.http.port` にアクセスできます。ただし、インジェクションを使用した場合は、注入された値が常に正しいとは限りません。このポート割り当ては、Quarkus の起動時に最後に起こることの 1 つなので、インジェクションされるオブジェクトがポートが開く前にしきりに作成された場合、インジェクションされた値は正しくなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a CORS filter which implements the `javax.servlet.Filter` interface and intercepts all incoming HTTP requests. It can be enabled in the Quarkus configuration file, `src/main/resources/application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus には、`javax.servlet.Filter` インターフェースを実装し、すべての受信 HTTP リクエストを遮断する CORS フィルターが付属しています。これは、Quarkus の設定ファイル (`src/main/resources/application.properties`) で有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the filter is enabled and an HTTP request is identified as cross-origin, the CORS policy and headers defined using the following properties will be applied before passing the request on to its actual target (servlet, JAX-RS resource, etc.):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィルターが有効になっていて、HTTP 要求がクロスオリジンであると識別された場合は、要求を実際のターゲット (サーブレット、JAX-RS リソースなど) に渡す前に、以下のプロパティーを使用して定義された CORS ポリシーとヘッダーが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property Nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Property Nam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors.origin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors.origin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors.method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors.method</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comma-separated list of HTTP methods allowed for CORS. The filter allows any method if this is
not set or set to '*'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CORS に許可されるオリジンのコンマ区切りの HTTP メソッドのリスト。これが設定されていないか '*' に設定されている場合、フィルターは任意のメソッドを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors.header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors.header</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comma-separated list of HTTP headers allowed for CORS. The filter allows any header if this is
not set or set to '*'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CORS に許可されるオリジンのコンマ区切りの HTTP ヘッダーのリスト。これが設定されていないか '*' に設定されている場合、フィルターは任意のヘッダーを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors.exposed-header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors.exposed-header</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comma-separated list of HTTP headers exposed in CORS. The filter allows any headers to be exposed if this is
not set or set to '*'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CORS で公開されているコンマ区切りの HTTP ヘッダーのリスト。これが設定されていないか '*' に設定されている場合、フィルターはヘッダーの公開を許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors.access-control-max-ag</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors.access-control-max-ag</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The duration (see note below) indicating how long the results of a pre-flight request can be cached.
This value will be returned in a `Access-Control-Max-Age` response header.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プリフライトリクエストの結果がキャッシュされる時間を示す持続時間 (以下の注釈を参照)。この値は `Access-Control-Max-Age` 応答ヘッダーで返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors.access-control-allow-credential</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors.access-control-allow-credential</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boolean value to tell the browsers to expose the response to front-end JavaScript code
when the request’s credentials mode Request.credentials is “include”</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストの認証情報モード Request.credentials が “include” の場合に、フロントエンドの JavaScript コードにレスポンスを公開するようにブラウザーに指示するためのブール値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add HTTP request logging by configuring it in `application.properties`. There are two options for logging, either logging to the standard JBoss logging output, or logging to a dedicated file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` で設定することで、HTTP リクエストのロギングを追加することができます。ロギングには、標準の JBoss ロギング出力にロギングするか、専用ファイルにロギングするかの 2 つのオプションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Short For</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ショートフォーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Long Form</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロングフォーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote IP address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモート IP アドレス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%a`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%a`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local IP address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカル IP アドレス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bytes sent, excluding HTTP headers, or '-' if no bytes were sent</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP ヘッダーを除いた、送信済みバイト数。送信されなかった場合は '-'。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%b`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%b`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bytes sent, excluding HTTP headers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>送信済みバイト数 (HTTP ヘッダーを除く)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote host name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートホスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%h`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%h`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request protocol</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要求プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要求メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%m`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%m`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local port</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%p`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%p`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query string (prepended with a '?' if it exists, otherwise an empty string)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリー文字列 (存在する場合は '?' が前に付き、そうでない場合は空文字列)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%q`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%q`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First line of the request</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要求の最初の行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%r`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%r`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP status code of the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>応答の HTTP ステータスコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%s`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%s`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date and time, in Common Log Format format</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Common Log Format 形式の日時</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%t`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%t`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote user that was authenticated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証されたリモートユーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%u`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%u`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requested URL path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要求された URL パス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request relative path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相対パスのリクエスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local server name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルサーバー名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%v`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%v`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time taken to process the request, in millis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストの処理にかかった時間 (ミリ秒)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time taken to process the request, in seconds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要求の処理にかかった時間 (秒単位)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time taken to process the request, in micros</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストの処理にかかった時間 (マイクロ秒)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time taken to process the request, in nanos</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストの処理にかかった時間 (ナノ秒)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Current request thread name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のリクエストスレッド名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All request headers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのリクエストヘッダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cookie value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クッキーの値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%{c,cookie_name}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%{c,cookie_name}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%{q,query_param_name}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%{q,query_param_name}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストヘッダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%{i,request_header_name}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%{i,request_header_name}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Response header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスヘッダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`%{o,response_header_name}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`%{o,response_header_name}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Servlet Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーブレット設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Servlet you need to explicitly include `quarkus-undertow`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Servlet を使用するには、明示的に `quarkus-undertow` を含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-undertow&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-undertow&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>undertow-handlers.conf</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>undertow-handlers.conf</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can make use of the Undertow predicate language using an `undertow-handlers.conf` file. This file should be placed in the `META-INF` directory of your application jar. This file contains handlers defined using the link:http://undertow.io/undertow-docs/undertow-docs-2.0.0/index.html#predicates-attributes-and-handlers[Undertow predicate language].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`undertow-handlers.conf` ファイルを使用することで、Undertow 述語言語を利用することができます。このファイルは、アプリケーション jar の `META-INF` ディレクトリーに配置する必要があります。このファイルには、Undertow link:http://undertow.io/undertow-docs/undertow-docs-2.0.0/index.html#predicates-attributes-and-handlers[述語言語] を使用して定義されたハンドラーが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>web.xml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>web.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a `web.xml` file as your configuration file, you can place it in the `src/main/resources/META-INF` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定ファイルとして `web.xml` ファイルを使用している場合は、`src/main/resources/META-INF` ディレクトリーに配置します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports deploying your application to Google Cloud Functions via the following extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、次のエクステンションを使用して、アプリケーションをGoogle Cloud Functionsにデプロイすることをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gcp-functions[Google Cloud Functions]: Build functions using the Google Cloud Functions API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gcp-functions[Google Cloud Functions] : Google Cloud Functions API を使用して Function をビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gcp-functions-http[Google Cloud Functions HTTP binding]: Build functions using Quarkus HTTP APIs: RESTEasy (JAX-RS), Undertow (Servlet), Vert.x Web, or link:funqy-http[Funqy HTTP].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gcp-functions-http[Google Cloud Functions HTTPバインディング] : Quarkus HTTP APIを使用して Function をビルドします: RESTEasy(JAX-RS)、Undertow(サーブレット)、Vert.x Web、または link:funqy-http[Funqy HTTP] </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:funqy-gcp-functions[Funky Google Cloud Functions]: Build functions using Funqy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:funqy-gcp-functions[Funqy Google Cloud Functions] : Funqyを使って Function をビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each extension supports a specific kind of application development, follow the specific guides for more information on how to develop, package and deploy your applications using them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各エクステンションは特定の種類のアプリケーション開発をサポートしており、それらを使用してアプリケーションを開発、パッケージ化、デプロイする方法の詳細については、特定のガイドに従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will only cover the Java 11 runtime as the Java 8 runtime uses its own Servlet engine which is not compatible with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 8 ランタイムはQuarkusと互換性のない独自のサーブレットエンジンを使用しているため、Java 11 ランタイムのみをカバーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure to have an App Engine environment initialized for your Google Cloud project, if not, initialize one via `gcloud app create --project=[YOUR_PROJECT_ID]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`gcloud app create --project=[YOUR_PROJECT_ID]` まず最初に、Google Cloud プロジェクト用に App Engine 環境が初期化されていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you will need to create a `src/main/appengine/app.yaml` file, let's keep it minimalistic with only the selected engine:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 `src/main/appengine/app.yaml` ファイルを作成する必要がありますが、選択したエンジンだけで最低限のものにしておきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a default service for your App Engine application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、App Engineアプリケーションのデフォルトサービスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can choose to build the application by yourself or letting `gcloud` or the Google Cloud Maven plugin build it for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、自分でアプリケーションを構築するか、 `gcloud` または Google Cloud Maven プラグインに構築を任せるかを選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building the application manually</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを手動でビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set up your application to be packaged as an uber-jar via your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` ファイルを介して、アプリケーションをuber-jarとしてパッケージ化するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Maven to build the application using `mvn clean package`, it will generate a single JAR that contains all the classes of your application including its dependencies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn clean package` を使用してアプリケーションをビルドするために Maven を使用します。依存関係を含むアプリケーションのすべてのクラスを含む単一の JAR を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, use `gcloud` to deploy your application as an App Engine service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、 `gcloud` を使用して、アプリケーションを App Engine サービスとしてデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will upload your application jar and launch it on App Engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、アプリケーション jar をアップロードし、App Engine で起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When done, the output will display the URL of your application (target url), you can use it with curl or directly open it in your browser using `gcloud app browse`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完了すると、出力にはアプリケーションの URL (ターゲット URL) が表示されます。curlを使うか、 `gcloud app browse` を使ってブラウザで直接開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building the application via gcloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gcloud 経由でアプリケーションをビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can choose to let `gcloud` build your application for you, this is the simplest way to deploy to App Engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`gcloud` にアプリケーションをビルドさせることができます。これは App Engine にデプロイする最もシンプルな方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just launch `gcloud app deploy` in the root of your project, it will upload all your project files (the list can be reduced via the `.gcloudignore` file), package your JAR via Maven (or Gradle) and launch it on App Engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのルートで `gcloud app deploy` を実行するだけで、すべてのプロジェクトファイルをアップロードし( `.gcloudignore` ファイルを介してリストを減らすことができます)、Maven(または Gradle)を介して JAR をパッケージ化し、App Engine で起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also let Maven control the deployment of your application using the App Engine Maven plugin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、App Engine Mavenプラグインを使用して、Mavenでアプリケーションのデプロイを制御することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the plugin to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、プラグインを `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the default `gcloud` configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの `gcloud` 設定を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Override the default JAR name to the one generated by the Quarkus Maven plugin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのJAR名を、Quarkus Mavenプラグインによって生成されたものにオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you would be able to use Maven to build and deploy your application to App Engine via `mvn clean package appengine:deploy`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、Mavenを使用してアプリケーションをビルドし、 `mvn clean package appengine:deploy` を経由してApp Engineにデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it’s done, the output will display the URL of your application (target URL), you can use it with curl or directly open it in your browser using `gcloud app browse`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それが完了すると、出力にはアプリケーションの URL (ターゲット URL) が表示されます。curlを使うか、 `gcloud app browse` を使ってブラウザで直接開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before all, make sure to have an App Engine environment initialized for your Google Cloud project, if not, initialize one via `gcloud app create --project=[YOUR_PROJECT_ID]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずはじめに、Google Cloud プロジェクト用に App Engine 環境が初期化されていることを確認してください。もしまだであれば、 `gcloud app create --project=[YOUR_PROJECT_ID]` によって初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>App Engine Flexible Custom Runtimes uses a Docker image to run your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>App Engine Flexible Custom RuntimesはDockerイメージを使用してアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create an `app.yaml` file at the root of your project with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、プロジェクトのルートに以下の内容の `app.yaml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>App Engine Flexible Custom Runtimes deploys your application as a Docker container, you can choose to deploy one of the Dockerfile provided inside your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>App Engine Flexible Custom Runtimesは、アプリケーションをDockerコンテナーとしてデプロイしますが、アプリケーション内で提供されるDockerfileのいずれかを選択してデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both JVM and native executable versions will work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVM版とネイティブ実行ファイル版の両方が動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a JVM application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMアプリケーションをデプロイするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the JVM Dockerfile to the root directory of your project: `cp src/main/docker/Dockerfile.jvm Dockerfile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMのDockerfileをプロジェクトのルートディレクトリーにコピーします: `cp src/main/docker/Dockerfile.jvm Dockerfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build your application using `mvn clean package`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn clean package` を使用してアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a native application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブアプリケーションをデプロイするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the native Dockerfile to the root directory of your project: `cp src/main/docker/Dockerfile.native Dockerfile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブのDockerfileをプロジェクトのルートディレクトリーにコピーします: `cp src/main/docker/Dockerfile.native Dockerfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build your application as a native executable using `mvn clean package -Dnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn clean package -Dnative` を使用して、アプリケーションをネイティブ実行ファイルとしてビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, launch `gcloud app deploy` in the root of your project, it will upload all your project files (the list can be reduced via the `.gcloudignore` file), build your Dockerfile and launch it on App Engine Flexible custom runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、プロジェクトのルートで `gcloud app deploy` を起動すると、すべてのプロジェクトファイルをアップロードし( `.gcloudignore` ファイルを介してリストを縮小することができます)、Dockerfile をビルドし、App Engine Flexible カスタムランタイム上で起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It uses Cloud Build to build your Docker image and deploy it to Google Container Registry (GCR).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud Buildを使用してDockerイメージをビルドし、Google Container Registry(GCR)にデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>App Engine Flexible custom runtimes support link:https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#updated_health_checks[health checks], it is strongly advised to provide them thanks to Quarkus link:microprofile-health[Microprofile Health] support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>App Engine Flexibleカスタムランタイムは link:https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#updated_health_checks[ヘルスチェック] をサポートしていますが、Quarkus link:microprofile-health[Microprofile Health] のサポートにより、 link:https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#updated_health_checks[ヘルスチェック] を提供することを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Run allows you to run your Docker containers inside Google Cloud Platform in a managed way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Runでは、Google Cloud Platform内でDockerコンテナーをマネージドな方法で実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus listens on port 8080, and it's also the Cloud Run default port.  No need to use the `PORT` environment variable defined in Cloud Run to customize the Quarkus HTTP port.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusは8080番ポートをリッスンし、これはCloud Runのデフォルトポートでもあります。Cloud Runで定義された環境変数 `PORT` を使用して、QuarkusのHTTPポートをカスタマイズする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Run will use Cloud Build to build your Docker image and deploy it to Google Container Registry (GCR).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud RunはCloud Buildを使用してDockerイメージを構築し、Google Container Registry(GCR)にデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a `.gcloudignore` file to tell gcloud which files should be not be uploaded for Cloud Build, without it, it defaults to `.gitignore` that usually exclude the target directory where you packaged application has been created.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、Cloud Buildのためにアップロードすべきでないファイルをgcloudに伝えるための `.gcloudignore` ファイルを作成します。これがない場合、デフォルトは `.gitignore` で、通常はパッケージ化されたアプリケーションが作成されたターゲットディレクトリーを除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, I only exclude the `src` directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、 `src` ディレクトリーだけを除外しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, use Cloud Build to build your image, it will upload to a Google Cloud Storage bucket all the files of your application (except the ones ignored by the `.gcloudignore`file), build your Docker image and push it to Google Container Registry (GCR).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、Cloud Buildを使ってイメージをビルドすると、アプリケーションのすべてのファイル(`.gcloudignore`fileで無視されたファイルを除く)をGoogle Cloud Storageバケットにアップロードし、DockerイメージをビルドしてGoogle Container Registry (GCR)にプッシュします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also build your image locally and push it to a publicly accessible Docker registry, then use this image in the next step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、イメージをローカルにビルドして、公開されているDockerレジストリーにプッシュし、次のステップでこのイメージを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, use Cloud Run to launch your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、Cloud Runを使ってアプリケーションを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud run will ask you questions on the service name, the region and whether or not unauthenticated calls are allowed.  After you answer to these questions, it will deploy your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud run は、サービス名、リージョン、認証されていない呼び出しが許可されているかどうかについて質問をします。これらの質問に答えると、アプリケーションがデプロイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the deployment is done, the output will display the URL to access your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイが完了すると、出力にはアプリケーションにアクセスするためのURLが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find some documentation about them in the link:https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse Google Cloud Services repository].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらについてのドキュメントは、 link:https://github.com/quarkiverse/quarkiverse-google-cloud-services[QuarkiverseのGoogle Cloud Servicesリポジトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Simple Email Service (SES) is a flexible and highly-scalable email sending and receiving service.  Using SES, you can send emails with any type of correspondence. You can find more information about SES at https://aws.amazon.com/ses/[the Amazon SES website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Simple Email Service(SES)は、柔軟で拡張性の高いメール送受信サービスです。SESを利用することで、あらゆる対応でメールを送信することができます。SESの詳細については、 link:https://aws.amazon.com/ses/[Amazon SESのウェブサイト] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The SES extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SESのエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供し、1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use SES locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスを利用してローカルおよびAWS上でSESを利用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker for your system to run SES locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手元のシステムでテスト目的でローカルにSESを実行するためのDocker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set up SES locally</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルでSESをセットアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with SES is to run a local instance as a container.  However, local instance of SES is only mocks the SES APIs without the actual email sending capabilities. You can still use it for this guide to verify an API communication or integration test purposes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SESを使い始める最も簡単な方法は、コンテナーとしてローカルインスタンスを実行することです。しかし、SESのローカルインスタンスは、実際のメール送信機能を持たずにSESのAPIをモックしているに過ぎません。それでも、このガイドではAPI通信の検証や統合テストの目的で使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a SES instance that is accessible on port `8012`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ポート `8012` でアクセス可能な SES インスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon applies certain restrictions to new Amazon SES accounts, mainly to prevent fraud and abuse. All new accounts are in the Amazon SES *sandbox*.  All the features of the Amazon SES are still available while in sandbox, but a following restrictions applies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazonは、主に詐欺や悪用を防ぐために、Amazon SESの新規アカウントに一定の制限を適用しています。新規アカウントはすべてAmazon SESの *サンドボックス* に入っています。サンドボックスにいる間もAmazon SESの機能はすべて利用できますが、以下の制限が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can send mail to verified email addresses and domains or to the https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-simulator.html[Amazon SES mailbox simulator]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証済みのメールアドレスやドメイン、 link:https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-simulator.html[Amazon SESのメールボックスシミュレータ] にメールを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can only send mail from verified email addresses and domains</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証済みのメールアドレスとドメインからのみメールを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can send a maximum of 1 message per second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1秒間に最大1メッセージまで送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going production, you'd need to get your account of the sandbox following the https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html[Amazon procedure].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番では、 link:https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html[Amazonの手順] に沿ってサンドボックスのアカウントを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We assume you are going to use AWS SES sandbox for the sake of this guide. But before sending any email, you must verify sender and recipient email addresses using AWS CLI.  You can use your personal email or any temporary email service available if you wish.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、AWS SESサンドボックスを使用することを想定しています。しかし、メールを送信する前に、AWS CLIを使って送信者と受信者のメールアドレスを確認する必要があります。必要に応じて、個人のメールや利用可能な一時的なメールサービスを利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, you need to open a mailboxes of those email addresses in order to follow confirmation procedure. Once email is approved you can use it in your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、確認のためにメールアドレスのメールボックスを開く必要があります。メールが承認されれば、アプリケーションに使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using local SES you still need to verify email addresses, otherwise your send email in order to let local SES accepting your request.  However, no emails to be send as it only mocks the service APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルSESを使用している場合でも、メールアドレスを確認する必要があります。確認ができない場合は、ローカルSESにリクエストを受け付けるためにメールを送信します。ただし、サービスのAPIをモックするだけなので、メールは送信されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built here allows sending text emails to the recipients that are verified on AWS SES.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで構築したアプリケーションでは、AWS SES上で確認された受信者にテキストメールを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amazon-ses-quickstart` {quickstarts-tree-url}/amazon-ses-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `amazon-ses-quickstart` {quickstarts-tree-url}/amazon-ses-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SES Client extensions.  After this, the `amazon-ses` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RS、Mutiny、Amazon SES ClientエクステンションをインポートするMavenディレクトリ構造を生成します。 この後、RESTEasyのMutinyサポートと同様に、 `amazon-ses` エクステンションが `pom.xml` に追加されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lets create a `org.acme.ses.QuarkusSesSyncResource` that will provide an API to send emails using the synchronous client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同期クライアントを使用して電子メールを送信するためのAPIを提供する `org.acme.ses.QuarkusSesSyncResource` を作成しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both SES clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.  Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses the URL connection HTTP client, so you need to add a URL connection client dependency to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SES クライアント (sync と async) は、 `src/main/resources` ディレクトリーにある `application.properties` ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、エクステンションは URL connection HTTP クライアントを使用するので、URL connection クライアントの依存関係を `pom.xml` ファイルに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add the following dependency to the application `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、以下の依存関係をアプリケーションの `pom.xml` に追加します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're going to use a local SES instance, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルのSESインスタンスを使用する場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.ses.aws.region` - It's required by the client, but since you're using a local SES instance use `us-east-1` as it's a default region of localstack's SES.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.ses.aws.region` - クライアントによって必要とされますが、ローカルのSESインスタンスを使用しているので、ローカルスタックのSESのデフォルトリージョンである `us-east-1` を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.ses.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.ses.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-id` と `secret-access-key` について任意の値で設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work with an AWS account, you can simply remove or comment out all Amazon SES related properties. By default, the SES client extension will use the `default` credentials provider chain that looks for credentials in this order:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWSアカウントで作業したい場合は、Amazon SES関連のプロパティーをすべて削除するかコメントアウトするだけです。デフォルトでは、SESクライアントエクステンションは、次の順番でクレデンシャルを探す `default` クレデンシャルプロバイダチェーンを使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the region from your AWS CLI profile will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、AWS CLIプロファイルからのリージョンが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.ses.QuarkusSesAsyncResource` REST resource that will be similar to our `QuarkusSesSyncResource` but using an asynchronous programming model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.ses.QuarkusSesAsyncResource` RESTリソースを作成します。 `QuarkusSesSyncResource` と似ていますが、非同期プログラミングモデルを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create `Uni` instances from the `CompletionStage` objects returned by the asynchronous SES client, and then transform the emitted item.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期SESクライアントから返された `CompletionStage` オブジェクトから `Uni` インスタンスを作成し、生成されたアイテムを変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we need to add the Netty HTTP client dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、Netty HTTPクライアント依存関係を `pom.xml` に追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use Quarkus OpenID Connect Extension to protect your JAX-RS applications using Bearer Token Authorization where Bearer Tokens are issued by OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus OpenID Connect Extensionを使用して、ベアラートークンがOpenId Connectや link:https://www.keycloak.org/about.html[Keycloak] などのOAuth 2.0準拠の認可サーバーによって発行されるベアラートークン認可を使用して、JAX-RSアプリケーションを保護する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bearer Token Authorization is the process of authorizing HTTP requests based on the existence and validity of a Bearer Token which provides valuable information to determine the subject of the call as well as whether or not an HTTP resource can be accessed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラートークン認可とは、ベアラートークンの存在と有効性に基づいて HTTP リクエストを認証するプロセスで、HTTP リソースにアクセスできるかどうかだけでなく、呼び出しの対象を決定するための価値のある情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please read the link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Applications] guide if you need to authenticate and authorize the users using OpenId Connect Authorization Code Flow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenId Connect Authorization Code Flow を使用してユーザーの認証と認可を行う必要がある場合は、 link:security-openid-connect-web-authentication[OpenID Connect を使用したウェブアプリケーションの保護] ガイドをお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Keycloak and Bearer tokens then also see the link:security-keycloak-authorization[Using Keycloak to Centralize Authorization] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak と Bearer トークンを使用する場合は、 link:security-keycloak-authorization[Using Keycloak to Centralize Authorization]ガイドも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for. For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラートークンは、Keycloakサーバーによって発行され、トークンが発行された対象を表します。OAuth 2.0 認可サーバーであるため、トークンはユーザーの代わりに動作するクライアントも参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/users/me` endpoint can be accessed by any user with a valid token. As a response, it returns a JSON document with details about the user where these details are obtained from the information carried on the token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/users/me` エンドポイントは、有効なトークンを持つ任意のユーザーがアクセスできます。レスポンスとして、トークンに記録されている情報から取得したユーザーの詳細を含む JSON ドキュメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `admin` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` エンドポイントは RBAC (Role-Based Access Control) で保護されており、 `admin` ロールで許可されたユーザーのみがアクセスできます。このエンドポイントでは、 `@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-openid-connect-quickstart` {quickstarts-tree-url}/security-openid-connect-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-openid-connect-quickstart` {quickstarts-tree-url}/security-openid-connect-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `keycloak` extension which is an implementation of a Keycloak Adapter for Quarkus applications and provides all the necessary capabilities to integrate with a Keycloak Server and perform bearer token authorization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Quarkusアプリケーション用のKeycloakアダプターの実装であり、Keycloakサーバーと統合してベアラートークン認証を実行するために必要なすべての機能を提供する `keycloak` エクステンションをインポートして、Mavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/users/me` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは `/api/users/me` エンドポイントを実装してみましょう。下のソースコードを見るとわかるように、これは通常の JAX-RS リソースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of the `SecurityIdentity` is supported in both `@RequestScoped` and `@ApplicationScoped` contexts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`SecurityIdentity` のインジェクションは、 `@RequestScoped` と `@ApplicationScoped` の両方のコンテキストでサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to access `JsonWebToken` claims, you may simply inject the token itself:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonWebToken` クレームにアクセスする必要がある場合は、トークン自体を注入するだけでOKです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of the `JsonWebToken` is supported in both `@RequestScoped` and `@ApplicationScoped` contexts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonWebToken` のインジェクションは、 `@RequestScoped` と `@ApplicationScoped` の両方のコンテキストでサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the {quickstarts-tree-url}/security-openid-connect-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm. For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいレルムを作成するには、{quickstarts-tree-url}/security-openid-connect-quickstart/config/quarkus-realm.json[realm設定ファイル] をインポートします。 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[新しいレルムを作成する] 方法について詳しくはKeycloakのドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the Keycloak Admin Client to configure your server from your application you need to include the `quarkus-keycloak-admin-client` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak Admin Clientを使用して、アプリケーションからサーバーを設定したい場合は、 `quarkus-keycloak-admin-client` エクステンションを含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `http://localhost:8080/api/admin` endpoint can only be accessed by users with the `admin` role. If you try to access this endpoint with the
 previously issued access token, you should get a `403` response
 from the server.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/api/admin` エンドポイントは、 `admin` ロールを持つユーザーのみがアクセスできます。以前に発行されたアクセストークンを使用してこのエンドポイントにアクセスしようとすると、サーバーから `403` 応答が返ってくるはずです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.oidc.user-info-required=true` if a UserInfo JSON object from the OIDC userinfo endpoint has to be requested.  A request will be sent to the OpenId Provider UserInfo endpoint and an `io.quarkus.oidc.UserInfo` (a simple `javax.json.JsonObject` wrapper) object will be created.  `io.quarkus.oidc.UserInfo` can be either injected or accessed as a SecurityIdentity `userinfo` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDC userinfo エンドポイントから UserInfo JSON オブジェクトを要求する必要がある場合は `quarkus.oidc.user-info-required=true` を設定します。リクエストが OpenId Provider UserInfo エンドポイントに送信され、 `io.quarkus.oidc.UserInfo` (単純な `javax.json.JsonObject` ラッパー) オブジェクトが作成されます。 `io.quarkus.oidc.UserInfo` は、SecurityIdentity `userinfo` 属性として注入、アクセスすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SecurityIdentity roles can be mapped from the verified JWT access tokens as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SecurityIdentity ロールは、検証済みの JWT アクセストークンから以下のようにマッピングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `quarkus.oidc.roles.role-claim-path` property is set and a matching array or string claim is found then the roles are extracted from this claim.  For example, `customroles`, `customroles/array`, `scope`, `"http://namespace-qualified-custom-claim"/roles`, `"http://namespace-qualified-roles"`, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.oidc.roles.role-claim-path` プロパティーが設定されており、一致する配列または文字列のクレームが見つかった場合、このクレームからロールが抽出されます。例えば、 `customroles` 、 `customroles/array` 、 `scope` 、 `"http://namespace-qualified-custom-claim"/roles` 、 `"http://namespace-qualified-roles"` 、などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `groups` claim is available then its value is used</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`groups` クレームが利用可能な場合は、その値が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `realm_access/roles` or `resource_access/client_id/roles` (where `client_id` is the value of the `quarkus.oidc.client-id` property) claim is available then its value is used.  This check supports the tokens issued by Keycloak</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`realm_access/roles` または `resource_access/client_id/roles` (ここで `client_id` は `quarkus.oidc.client-id` プロパティーの値)クレームが利用可能な場合は、その値が使用されます。このチェックは、Keycloakが発行するトークンをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the token is opaque (binary) then a `scope` property from the remote token introspection response will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンが不透明(バイナリー)の場合は、リモートトークンイントロスペクションレスポンスの `scope` プロパティーが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single Page Application (SPA) typically uses `XMLHttpRequest`(XHR) and the Java Script utility code provided by the OpenId Connect provider to acquire a bearer token and use it to access Quarkus `service` applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シングルページアプリケーション(SPA)は通常、 `XMLHttpRequest` (XHR)とOpenId Connectプロバイダーが提供するJava Scriptユーティリティーコードを使用してベアラートークンを取得し、それを使用してQuarkus `service` アプリケーションにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, here is how you can use `keycloak.js` to authenticate the users and refresh the expired tokens from the SPA:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `keycloak.js` を使用してユーザーを認証し、SPA から期限切れのトークンをリフレッシュする方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OIDC `service` application needs to know OpenId Connect provider's token, `JsonWebKey` (JWK) set and possibly `UserInfo` and introspection endpoint addresses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDC `service` アプリケーションは、OpenId Connect プロバイダのトークン、 `JsonWebKey` (JWK) セット、そして時には `UserInfo` とイントロスペクションのエンドポイントアドレスを知る必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the bearer JWT token's signature has been verified and its `expires at` (`exp`) claim has been checked, the `iss` (`issuer`) claim value is verified next.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラのJWTトークンの署名が検証され、 `expires at` ( `exp`) のクレームが確認されると、次に `iss` ( `issuer`) クレーム値が検証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `iss` claim value is compared to the `issuer` property which may have been discovered in the well-known provider configuration.  But if `quarkus.oidc.token.issuer` property is set then the `iss` claim value is compared to it instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `iss` クレーム値は、well-knownプロバイダの設定で発見された `issuer` プロパティと比較されます。しかし、 `quarkus.oidc.token.issuer` プロパティが設定されている場合は、代わりに `iss` クレーム値がそれと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, this `iss` claim verification may not work. For example, if the discovered `issuer` property contains an internal HTTP/IP address while the token `iss` claim value contains an external HTTP/IP address. Or when a discovered `issuer` property contains the template tenant variable but the token `iss` claim value has the complete tenant-specific issuer value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>場合によっては、この `iss` クレームの検証がうまくいかないことがあります。例えば、発見された `issuer` プロパティに内部の HTTP/IP アドレスが含まれている一方で、トークン `iss` クレーム値に外部の HTTP/IP アドレスが含まれている場合です。あるいは、発見された `issuer` プロパティにテンプレートのテナント変数が含まれているが、トークン `iss` クレーム値には完全なテナント固有の発行者の値が含まれている場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such cases you may want to consider skipping the issuer verification by setting `quarkus.oidc.token.issuer=any`. Please note that it is not recommended and should be avoided unless no other options are available:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような場合には、 `quarkus.oidc.token.issuer=any` を設定して、issuer認証を省略することを検討してください。なお、この設定は推奨されておらず、他に選択肢がない場合を除き、避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you work with Keycloak and observe the issuer verification errors due to the different host addresses then configure Keycloak with a `KEYCLOAK_FRONTEND_URL` property to ensure the same host address is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloakを使用していて、ホストアドレスが異なるために発行者検証エラーが発生する場合は、Keycloakに `KEYCLOAK_FRONTEND_URL` プロパティを設定して、同じホストアドレスが使用されるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `iss` property is tenant specific in a multi-tenant deployment then you can use the `SecurityIdentity` `tenant-id` attribute to check the issuer is correct in the endpoint itself or the custom JAX-RS filter, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチテナント展開で `iss` プロパティがテナント固有のものである場合は、 `SecurityIdentity` `tenant-id` 属性を使用して、エンドポイント自体やカスタム JAX-RS フィルタなどでissuerが正しいかどうかを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note it is also recommended to use `quarkus.oidc.token.audience` property to verify the token `aud` (`audience`) claim value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なお、トークン `aud` ( `audience`) のクレーム値を検証するために `quarkus.oidc.token.audience` プロパティを使用することも推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security-openid-connect-client#token-propagation[Token Propagation] section about the Bearer access token propagation to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下流サービスへのベアラアクセストークンの伝播については、 link:security-openid-connect-client#token-propagation[トークン伝播] の項を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependencies to your test project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストプロジェクトに以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prepare the REST test endpoint, set `application.properties`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTテストエンドポイントを用意し、例えば以下のように `application.properties` を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing your `quarkus-oidc` `service` application with `OidcWiremockTestResource` provides the best coverage as even the communication channel is tested against the Wiremock HTTP stubs.  `OidcWiremockTestResource` will be enhanced going forward to support more complex Bearer token test scenarios.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` `service` アプリケーションを `OidcWiremockTestResource` でテストすると、通信チャネルが Wiremock HTTP スタブに対してテストされるため、最高のカバレッジが得られます。 `OidcWiremockTestResource` は、より複雑な Bearer トークンのテストシナリオをサポートするために、今後強化される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local Public Key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカル公開鍵</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use a local inlined public key for testing your `quarkus-oidc` `service` applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `quarkus-oidc` `service` アプリケーションのテストに、ローカルのインライン公開鍵を使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>copy `privateKey.pem` from the `integration-tests/oidc-tenancy` in the `main` Quarkus repository and use a test code similar to the one in the `Wiremock` section above to generate JWT tokens. You can use your own test keys if preferred.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`integration-tests/oidc-tenancy` から `main` のQuarkusリポジトリに `privateKey.pem` をコピーし、上記 `Wiremock` のセクションと同様のテストコードを使用してJWTトークンを生成します。必要であれば、独自のテストキーを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach provides a more limited coverage compared to the Wiremock approach - for example, the remote communication code is not covered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプローチは、Wiremockのアプローチと比較して、より限定された範囲をカバーします。例えば、リモート通信コードはカバーされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DynamoDB is a scalable AWS managed *NoSQL* database.  It supports both key-value and document data models, that enables to have a flexible schema for your data.  This extension provides functionality that allows the client to communicate with the service when running in Quarkus.  You can find more information about DynamoDB at https://aws.amazon.com/dynamodb/[the Amazon DynamoDB website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DynamoDBは、AWSで管理されているスケーラブルな *NoSQL* データベースです。DynamoDBはキーバリューとドキュメントの両方のデータモデルをサポートしており、データに対して柔軟なスキーマを持つことができます。このエクステンションは、Quarkusで実行しているときにクライアントがサービスと通信できるようにする機能を提供します。DynamoDBの詳細については、 link:https://aws.amazon.com/dynamodb/[Amazon DynamoDBのウェブサイト] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The DynamoDB extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).  Keep in mind it's actively developed and does not support yet all the features available in SDK 1.x such as https://github.com/aws/aws-sdk-java-v2/issues/36[Document APIs] or https://github.com/aws/aws-sdk-java-v2/issues/35[Object Mappers]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DynamoDBエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしています。1.xのコードベースを大幅に書き換えたもので、2つのプログラミングモデル(ブロッキングと非同期)を提供しています。このエクステンションは積極的に開発されており、 link:https://github.com/aws/aws-sdk-java-v2/issues/36[ドキュメントAPI] や link:https://github.com/aws/aws-sdk-java-v2/issues/35[オブジェクトマッパー] のようなSDK 1.xで利用可能な機能はまだサポートしていないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use the DynamoDB locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスでDynamoDBをローカルとAWS上で利用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, Docker for your system to run DynamoDB locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションで、Dockerを使ってシステムをテスト用にローカルでDynamoDBを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with DynamoDB is to run a local instance as a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DynamoDBで作業を始める最も簡単な方法は、ローカルインスタンスをコンテナーとして実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a DynamoDB instance that is accessible on port `8000`.  You can check it's running by accessing the web shell on `http://localhost:8000/shell`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ポート `8000` でアクセス可能な DynamoDB インスタンスを起動します。`http://localhost:8000/shell` のWebシェルにアクセスして、実行中であることを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a look at the https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html[Setting Up DynamoDB Local guide] for other options to run DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DynamoDBを実行するための他のオプションについては、 link:https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html[Setting Up DynamoDB Local ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8000/shell` in your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラザで `http://localhost:8000/shell` を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy and paste the following code to the shell and run it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコードをシェルにコピー&amp;ペーストして実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you can use the AWS SDKs with DynamoDB, you must get an AWS access key ID and secret access key.  For more information, see https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SettingUp.DynamoWebService.html[Setting Up DynamoDB (Web Service)].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DynamoDBでAWS SDKを利用する前に、AWSのアクセスキーIDとシークレットアクセスキーを取得する必要があります。詳しくは、 link:https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SettingUp.DynamoWebService.html[DynamoDB(Webサービス)] のセットアップを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend to use the AWS CLI to provision the table:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テーブルのプロビジョニングにはAWS CLIを利用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built here allows to manage elements (fruits) stored in Amazon DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで構築したアプリケーションでは、Amazon DynamoDBに格納されている要素(果物)を管理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amazon-dynamodb-quickstart` {quickstarts-tree-url}/amazon-dynamodb-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `amazon-dynamodb-quickstart` {quickstarts-tree-url}/amazon-dynamodb-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and DynamoDB Client extensions.  After this, the `amazon-dynamodb` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RS、Mutiny、DynamoDBクライアントエクステンションをインポートするMaven構造を生成します。 `pom.xml` この後、RESTEasyのMutinyサポートと同様に、 `amazon-dynamodb` エクステンションが追加されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits. The example application will demonstrate the two programming models supported by the extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このサンプルでは、果物のリストを管理するアプリケーションを作成します。サンプルアプリケーションでは、エクステンションでサポートされている2つのプログラミングモデルをデモします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer. The static `from` method creates a bean based on the `Map` object provided by the DynamoDB client response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、JSONシリアライズレイヤーによって要求されるということです。static `from` メソッドは、DynamoDB クライアントのレスポンスで提供された `Map` オブジェクトをベースにBeanを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.dynamodb.AbstractService` that will consist of helper methods that prepare DynamoDB request objects for reading and adding items to the table.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、テーブルにアイテムを読み込んで追加するためのDynamoDBリクエストオブジェクトを準備するヘルパーメソッドで構成される `org.acme.dynamodb.AbstractService` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a `org.acme.dynamodb.FruitSyncService` that will be the business layer of our application and stores/loads the fruits from DynamoDB using the synchronous client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、アプリケーションのビジネスレイヤーとなる `org.acme.dynamodb.FruitSyncService` を作成し、同期クライアントを使用して DynamoDB からフルーツを保存/ロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.dynamodb.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `org.acme.dynamodb.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitSyncService` to list/add new fruits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装はとても簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義し、 `FruitSyncService` を使って新しいフルーツをリストアップ/追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both DynamoDB clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.  Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses the `java.net.URLConnection` HTTP client, so you need to add a URL connection client dependency to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DynamoDBクライアント(syncとasync)はどちらも、 `src/main/resources` ディレクトリーで提供されている `application.properties` ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、エクステンションは `java.net.URLConnection` HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` ファイルに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the Apache HTTP client instead, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりにApache HTTPクライアントを使いたい場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're going to use a local DynamoDB instance, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルのDynamoDBインスタンスを使用する場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.region` - It's required by the client, but since you're using a local DynamoDB instance you can pick any valid AWS region.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.dynamodb.aws.region` - クライアントが必要としますが、ローカルのDynamoDBインスタンスを使用しているので、有効なAWSリージョンを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.dynamodb.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-id` と `secret-access-key` の任意の値で設定します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.region` you should set it to the region where you provisioned the DynamoDB table,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.dynamodb.aws.region` 、DynamoDBテーブルをプロビジョニングしたリージョンに設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.credentials.type` - use the `default` credentials provider chain that looks for credentials in this order:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.dynamodb.aws.credentials.type` - `default` クレデンシャル・プロバイダ・チェーンを使用して、この順番でクレデンシャルを検索します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.dynamodb.FruitAsyncService` that will be similar to our `FruitSyncService` but using an asynchronous programming model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`FruitSyncService` と同様の `org.acme.dynamodb.FruitAsyncService` を作成しますが、非同期プログラミングモデルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous code, we create `Uni` instances from the `CompletionStage` objects returned by the asynchronous DynamoDB client, and then transform the emitted item.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどのコードでは、非同期のDynamoDBクライアントから返された `CompletionStage` オブジェクトから `Uni` インスタンスを作成し、発行されたアイテムを変換しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create an asynchronous REST resource that consumes this async service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、この非同期サービスをコンシュームする非同期RESTリソースを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add Netty HTTP client dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `pom.xml` に Netty HTTP クライアントの依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following IDEs have support for the community developed Quarkus Tools:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のIDEは、コミュニティで開発されたQuarkus Toolsをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition IntelliJ has additional support for Quarkus in their Ultimate non-open source version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらにIntelliJは、非オープンソースのUltimate版でQuarkusを追加サポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below gives an overview of the current IDEs with links and a high-level overview of their features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下の表では、現在のIDEの概要とリンク、その機能のハイレベルな概要をご紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{vscode-logo}[VSCode,100,100]
{empty} +
VSCode Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{vscode-logo}[VSCode,100,100]
{empty} +
VSCode Quarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{eclipse-logo}[Eclipse,100,100]
{empty} +
Eclipse Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{eclipse-logo}[Eclipse,100,100]
{empty} +
Eclipse Quarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Quarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Ultimate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Ultimate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{che-logo}[Eclipse Che,100,100]
{empty} +
Eclipse Che</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:{che-logo}[Eclipse Che,100,100]
{empty} +
Eclipse Che</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual Studio Code extension to install using the marketplace</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マーケットプレイスを使用してインストールするVisual Studioのコードエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse plugin to install into Eclipse using an updatesite</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アップデートサイトを使ってEclipseにインストールするEclipseプラグイン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IntelliJ plugin that works in IntelliJ Community and Ultimate. Available from Marketplace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IntelliJ CommunityとUltimateで動作するIntelliJプラグイン。マーケットプレイスから入手可能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Quarkus features available in Eclipse Che incl. che.openshift.io.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse Cheで利用可能なQuarkusの組込機能にはche.openshift.ioなどがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Status</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステータス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Downloads</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[Marketplace]
{empty} +
 https://download.jboss.org/jbosstools/vscode/snapshots/vscode-quarkus/?C=M;O=D[Development Builds]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[Marketplace]
{empty} +
 https://download.jboss.org/jbosstools/vscode/snapshots/vscode-quarkus/?C=M;O=D[Development Builds]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://download.jboss.org/jbosstools/photon/snapshots/builds/jbosstools-quarkus_master/[Development Update Site]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://download.jboss.org/jbosstools/photon/snapshots/builds/jbosstools-quarkus_master/[Development Update Site]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://plugins.jetbrains.com/plugin/13234-quarkus/versions[Marketplace]
{empty} +
https://download.jboss.org/jbosstools/intellij/snapshots/intellij-quarkus/[Development Builds]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://plugins.jetbrains.com/plugin/13234-quarkus/versions[Marketplace]
{empty} +
https://download.jboss.org/jbosstools/intellij/snapshots/intellij-quarkus/[Development Builds]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.jetbrains.com/idea/nextversion/[Installer]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.jetbrains.com/idea/nextversion/[Installer]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://che.openshift.io/f?url=https://raw.githubusercontent.com/redhat-developer/devfile/master/getting-started/quarkus/devfile.yaml[Start Che Workspace]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://che.openshift.io/f?url=https://raw.githubusercontent.com/redhat-developer/devfile/master/getting-started/quarkus/devfile.yaml[Start Che Workspace]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Closed-Source</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クローズドソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/redhat-developer/quarkus-ls[Quarkus Language Server]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/redhat-developer/quarkus-ls[Quarkus Language Server]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:check[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:check[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:times[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:times[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wizards w/code.quarkus.io</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>code.quarkus.ioのウィザード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://issues.jboss.org/browse/JBIDE-26950[icon:times[]]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://issues.jboss.org/browse/JBIDE-26950[icon:times[]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Wizard</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムウィザード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config editor</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定エディタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config autocompletion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定の自動補完</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config jump to definition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定の定義へのジャンプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config profiles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config outline</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定アウトライン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Launch debug/dev:mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>debug/dev:mode の簡単起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection Discovery/Navigation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションディスカバリー/ナビゲーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, you need to configure Maven as indicated in the link:maven-config.html[Maven configuration page].  Then, you can scaffold a new project with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:maven-config.html[Mavenの設定ページ] に示されているように、Mavenを設定する必要があることを思い出して下さい。その後、以下のように新しいプロジェクトをスキャフォールド (骨組の生成) 出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you decide to generate a REST resource (using the `className` attribute), the endpoint is exposed at: `http://localhost:8080/$root/$path`.  If you use the default `root` and `path`, the URL is: http://localhost:8080/hello.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST リソースを生成することにした場合 ( `className` 属性を使用)、エンドポイントは次の場所で公開されます: `http://localhost:8080/$root/$path` 。デフォルトの `root` と `path` を使用する場合、URL は http://localhost:8080/hello です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `Dockerfile` is also generated in `src/main/docker`.  Instructions to build the image and run the container are written in the `Dockerfile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Dockerfile` `src/main/docker` も生成されています。イメージをビルドしてコンテナーを実行する手順は `Dockerfile` に書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can list extensions with: `mvn quarkus:list-extensions`.  You can enable an extension using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをリストアップするには、次のようにします: `mvn quarkus:list-extensions` 。エクステンションの有効化は次のコマンドで可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a built-in development mode.  Run you application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには開発モードが組み込まれています。次のようにアプリケーションを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn compile quarkus:dev</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn compile quarkus:dev</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then update the application sources, resources and configurations.  The changes are automatically reflected in your running application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、アプリケーションのソース、リソース、および設定を更新することができます。変更は、実行中のアプリケーションに自動的に反映されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run a Quarkus application in debug mode using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のコマンドで、Quarkusアプリケーションをデバッグモードで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn compile quarkus:dev -Ddebug=true</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn compile quarkus:dev -Ddebug=true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Maven project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;project-creation, プロジェクトを生成したら&gt;&gt;、お気に入りのIDEでインポートすることができます。唯一の要件は、Mavenプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Maven -&gt; Existing Maven Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Maven → Existing Maven Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish` をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `mvn compile quarkus:dev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルで `mvn compile quarkus:dev` を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Maven`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Import project from external model` を選択して `Maven` を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `mvn compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルまたは組込ターミナルで、 `mvn compile quarkus:dev` を実行してください。では、お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Apache Netbeans**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**Apache Netbeans**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `mvn compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルまたは組込ターミナルで、プロジェクトのルートに移動し、 `mvn compile quarkus:dev` を実行してください。では、お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Maven project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>VS Codeでプロジェクトディレクトリーを開きます。Java Extension Pack(Javaエクステンションのセットをグループ化したもの)をインストールしている場合、プロジェクトはMavenプロジェクトとしてロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions enhance your application just as projects dependencies do.  The role of the extensions is to leverage Quarkus paradigms to integrate seamlessly a library into Quarkus architecture - e.g. do more things at build time.  This is how you can use your battle-tested ecosystem and take advantage of Quarkus performance and native compilation.  Go to https://code.quarkus.io/[code.quarkus.io] to get the list of the supported extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus のエクステンションは、プロジェクトの依存関係がそうであるように、アプリケーションを強化します。エクステンションの役割は、Quarkus のパラダイムを活用して、ライブラリを Quarkus アーキテクチャにシームレスに統合することです。たとえば、ビルド時に、より多くのことを行います。これが、実績のあるエコシステムを利用して、Quarkus のパフォーマンスとネイティブコンパイルを活用することができる仕組みです。https://code.quarkus.io/[code.quarkus.io] にアクセスして、サポートされているエクステンションのリストを入手してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we are going to develop the *Sample Greeting Extension*.  The extension will expose a customizable HTTP endpoint which simply greets the visitor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、*サンプル Greeting エクステンション* を開発します。このエクステンションは、ビジターに挨拶をするだけのカスタマイズ可能な HTTP エンドポイントを公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disclaimer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>免責事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be sure it's extra clear you don't need an extension to add a Servlet to your application.  This guide is a simplified example to explain the concepts of extensions development, see the link:writing-extensions[full documentation] if you need more information.  Keep in mind it's not representative of the power of moving things to build time or simplifying the build of native images.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションにサーブレットを追加するのにエクステンションは必要ありません。このガイドはエクステンション開発の概念を説明するための単純化された例であり、より多くの情報が必要な場合は link:writing-extensions[完全なドキュメント] を参照してください。これは、ビルド時間を短縮したり、ネイティブイメージのビルドを簡略化したりする機能を示すものではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>less than 30 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>三十分以内</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Concepts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本概念</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First things first, we will need to start with some basic concepts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず最初に、いくつかの基本的な概念から始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is first and foremost a Java framework, that means you can develop, package and run classic JAR applications, that's what we call *JVM mode*.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は最初の Java フレームワークです。つまり、従来の *JAR* アプリケーションの開発、パッケージ化、実行を行うことができます。これは、*JAM モード* と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to https://graalvm.org/[GraalVM] you can compile your Java application into machine specific code (like you do in Go or C++) and that's what we call *Native mode*.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://graalvm.org/[GraalVM] により、Java アプリケーションをマシン固有のコード (Go や C++ のように) にコンパイルすることができます。これは、*ネイティブモード* と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operation of compiling Java bytecode into a native system-specific machine code is named *Ahead of Time Compilation* (aka AoT).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java バイトコードをネイティブシステム固有のマシンコードにコンパイルする操作は、*Ahead of Time Compilation* (AoT) と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The build time corresponds to all the actions you apply to your Java source files to convert them into something runnable (class files, jar/war, native images).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時間は、Java ソースファイルを実行可能なもの (クラスファイル、jar/war、ネイティブイメージ) に変換するために Java ソースファイルに適用するすべてのアクションに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually this stage is composed by the compilation, annotation processing, bytecode generation, etc. At this point, everything is under the developer's scope and control.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常、この段階はコンパイル、アノテーション処理、バイトコード生成などで構成されます。この時点では、すべてが開発者のスコープとコントロール下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime is all the actions that happen when you execute your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムとは、アプリケーションを実行するときに発生するすべてのアクションのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's obviously focused on starting your business-oriented actions but it relies on a lot of technical actions like loading libraries and configuration files, scanning the application's classpath, configuring the dependency injection, setting up your Object-Relational Mapping, instantiating your REST controllers, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは明らかにビジネス指向のアクションを開始することに焦点を当てていますが、ライブラリや設定ファイルのロード、アプリケーションのクラスパスのスキャン、依存性インジェクションの設定、オブジェクトリレーショナルマッピングの設定、REST コントローラのインスタンス化など、多くの技術的なアクションに依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually, Java frameworks do their bootstrapping during the runtime before actually starting the application "Business oriented layer". During bootstrap, frameworks dynamically collect metadata by scanning the classpath to find configurations, entity definitions, dependency injection binding, etc. in order to instantiate proper objects through reflection. The main consequences are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常、Javaフレームワークは、アプリケーションの "ビジネス志向のレイヤー" を実際に起動する前に、実行時中にブートストラップを行います。ブートストラップの際、フレームワークは、リフレクションによって適切なオブジェクトをインスタンス化するために、設定、エンティティー定義、依存関係の注入バインディングなどを見つけるためにクラスパスをスキャンします。これにより、動的にメタデータを収集します。主な結果は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delaying the readiness of your application: you need to wait a couple of seconds before actually serving a business request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの準備が遅れる: 実際にビジネスリクエストに対応する前に数秒待つ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having a peak of resource consumption at bootstrap: in a constrained environment, you will need to size the needed resources based on your technical bootstrap needs rather than your actual business needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブートストラップでリソース消費のピークを持つ: 制約のある環境では、実際のビジネスニーズではなく、技術的なブートストラップのニーズに基づいて、必要なリソースのサイズを決定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus' philosophy is to prevent as much as possible slow and memory intensive dynamic code execution by shifting left these actions and eventually do them during the build time.  A Quarkus extension is a Java piece of code acting as an adapter layer for your favorite library or technology.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の概念は、これらのアクションの左シフトを行い、最終的にはビルド時に実行することで、可能な限り低速でメモリー集約的な動的コードの実行を防ぐことです。Quarkus のエクステンションは、お気に入りのライブラリやテクノロジーのアダプターレイヤーとして機能する Java のコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkus extension consists of two parts:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus のエクステンションは、2 つの部分から構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *runtime module* which represents the capabilities the extension developer exposes to the application's developer (an authentication filter, an enhanced data layer API, etc).  Runtime dependencies are the ones the users will add as their application dependencies (in Maven POMs or Gradle build scripts).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション開発者がアプリケーション開発者に公開する機能を表す *ランタイムモジュール* (認証フィルター、強化されたデータ層 API など)。ランタイム依存関係は、ユーザーがアプリケーションの依存関係として追加するものです (Maven POM または Gradle ビルドスクリプト)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *deployment module* which is used during the augmentation phase of the build, it describes how to "deploy" a library following the Quarkus philosophy.  In other words, it applies all the Quarkus optimizations to your application during the build.  The deployment module is also where we prepare things for GraalVM's native compilation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドの拡張フェーズで使用される *デプロイモジュール* で、Quarkus の概念に従ったライブラリを「デプロイ」する方法を説明しています。つまり、ビルド中にアプリケーションに Quarkus のすべての最適化を適用します。このデプロイメントモジュールは、GraalVM のネイティブコンパイルのための準備をする場所でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users should not be adding the deployment modules of extension as application dependencies. The deployment dependencies are resolved by Quarkus during the augmentation phase from the runtime dependencies of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーは、エクステンションのデプロイメントモジュールをアプリケーションの依存関係として追加すべきではありません。デプロイメントの依存関係は、拡張フェーズの間に Quarkus によってアプリケーションの実行時依存関係から解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you should have understood that most of the magic will happen at the Augmentation build time thanks to the deployment module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この時点で、このデプロイメントモジュールにより、多くのマジックは拡張ビルド時に起こることを理解しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three distinct bootstrap phases of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus アプリケーションには、3 つの異なるブートストラップフェーズがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Augmentation*. During the build time, the Quarkus extensions will load and scan your application's bytecode (including the dependencies) and configuration.
At this stage, the extension can read configuration files, scan classes for specific annotations, etc.
Once all the metadata has been collected, the extensions can pre-process the libraries bootstrap actions like your ORM, DI or REST controllers configurations.
The result of the bootstrap is directly recorded into bytecode and will be part of your final application package.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*拡張 (Augmentation)*。ビルド時に、Quarkus エクステンションはアプリケーションのバイトコード (依存関係を含む) と設定をロードしてスキャンします。
この段階で、エクステンションは設定ファイルを読み込んだり、特定のアノテーションのためにクラスをスキャンしたりすることができます。
すべてのメタデータが収集されたら、エクステンションは、ORM、DI、または REST コントローラーの設定のようなライブラリーのブートストラップアクションを前処理することができます。
ブートストラップの結果はバイトコードに直接記録され、最終的なアプリケーションパッケージの一部となります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Static Init*. During the run time, Quarkus will execute first a static init method which contains some extensions actions/configurations.
When you will do your native packaging, this static method will be pre-processed during the build time and the objects it has generated will be serialized into the final native executable, so the initialization code will not be executed in the native mode (imagine you execute a Fibonacci function during this phase, the result of the computation will be directly recorded in the native executable).
When running the application in JVM mode, this static init phase is executed at the start of the application.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*静的 Init* 実行時に、Quarkus は最初に、いくつかの拡張アクション/設定を含む最初の静的 init メソッドを実行します。
ネイティブパッケージングを行う場合、このスタティックメソッドはビルド時に前処理され、生成されたオブジェクトは最終的なネイティブ実行ファイルにシリアライズされるため、初期化コードはネイティブモードでは実行されません (このフェーズではフィボナッチ関数を実行すると想像してください。計算の結果は、ネイティブ実行ファイルに直接記録されます)。
JVM モードでアプリケーションを実行している場合、この静的 init フェーズはアプリケーションの開始時に実行されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Runtime Init*. Well nothing fancy here, we do classic run time code execution.
So, the more code you run during the two phases above, the faster your application will start.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*ランタイム Init* このフェーズでは特に目立つことはありません。従来的なランタイムコード実行を行います。
つまり、上記の 2 つのフェーズでより多くのコードを実行すればするほど、アプリケーションの起動が速くなります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that everything is explained, we can start coding!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで全てが説明されたので、さっそくコーディングに取り掛かりましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may call it without any parameter to use the interactive mode: `mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パラメータなしで呼び出してインタラクティブモードを使用することができます。`mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N \
    -DgroupId=org.acme \ #&lt;1&gt;
    -DextensionId=greeting-extension \  #&lt;2&gt;
    -DwithoutTests #&lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N \
    -DgroupId=org.acme \ #&lt;1&gt;
    -DextensionId=greeting-extension \  #&lt;2&gt;
    -DwithoutTests #&lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[INFO] --- quarkus-maven-plugin:{quarkus-version}:create-extension (default-cli) @ standalone-pom ---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[INFO] --- quarkus-maven-plugin:{quarkus-version}:create-extension (default-cli) @ standalone-pom ---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Detected layout type is 'standalone' #&lt;4&gt;
Generated runtime artifactId is 'greeting-extension' #&lt;5&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Detected layout type is 'standalone' #&lt;4&gt;
Generated runtime artifactId is 'greeting-extension' #&lt;5&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>👍 extension has been successfully generated in: --&gt; /Users/ia3andy/workspace/redhat/quarkus/demo/greeting-extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> extension has been successfully generated in: --&gt; /Users/ia3andy/workspace/redhat/quarkus/demo/greeting-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.659 s
[INFO] Finished at: 2021-01-25T16:17:16+01:00
[INFO] ------------------------------------------------------------------------
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.659 s
[INFO] Finished at: 2021-01-25T16:17:16+01:00
[INFO] ------------------------------------------------------------------------
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension groupId</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション groupId</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension id (not namespaced).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション ID (名前空間ではない)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that we don't want to generate any test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テスト不要を示す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From a directory with no pom.xml and without any further options, the generator will automatically pick the 'standalone' extension layout</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それ以上のオプションなしで、pom.xml のないディレクトリから、ジェネレーターは自動的に 'standalone' 拡張レイアウトを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the 'standalone' layout, the `namespaceId` is empty by default, so the computed runtime module artifactId is the `extensionId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'standalone' レイアウトでは、 `namespaceId` はデフォルトでは空なので、計算されるランタイムモジュールの artifactId は `extensionId` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven has generated a `greeting-extension` directory containing the extension project which consists of the parent `pom.xml`, the `runtime` and the `deployment` modules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven は、親 `pom.xml`、`runtime` 、`deployment` モジュールから成る拡張プロジェクトを含む `quarkus-greeting` ディレクトリーを生成しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parent pom.xml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>親 pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your extension is a multi-module project. So let's start by checking out the parent POM at `./greeting-extension/pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お使いのエクステンションはマルチモジュールプロジェクトです。まずは、`./quarkus-greeting/pom.xml` の親 POM から見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your extension declares 2 sub-modules `deployment` and `runtime`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは、2 つのサブモジュール `deployment` と `runtime` を宣言しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus requires a recent version of the Maven compiler plugin supporting the annotationProcessorPaths configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、annotationProcessorPaths 設定に対応する、最新バージョンの Maven コンパイラープラグインのが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-bom` aligns your dependencies with those used by Quarkus during the augmentation phase.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-bom` は、オーグメンテーションの段階で Quarkus が使用している依存関係を調整します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus requires these configs to run tests properly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、テストを適切に実行するために、これらの設定が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's have a look at the deployment's `./greeting-extension/deployment/pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメントの `./quarkus-greeting/deployment/pom.xml` を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.acme&lt;/groupId&gt;
        &lt;artifactId&gt;greeting-extension-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.acme&lt;/groupId&gt;
        &lt;artifactId&gt;greeting-extension-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;artifactId&gt;greeting-extension-deployment&lt;/artifactId&gt; &lt;!--1--&gt;
    &lt;name&gt;Greeting Extension - Deployment&lt;/name&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;artifactId&gt;greeting-extension-deployment&lt;/artifactId&gt; &lt;!--1--&gt;
    &lt;name&gt;Greeting Extension - Deployment&lt;/name&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
          &lt;artifactId&gt;quarkus-arc-deployment&lt;/artifactId&gt; &lt;!--2--&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.acme&lt;/groupId&gt;
            &lt;artifactId&gt;greeting-extension&lt;/artifactId&gt; &lt;!--3--&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
          &lt;artifactId&gt;quarkus-junit5-internal&lt;/artifactId&gt;
          &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
          &lt;artifactId&gt;quarkus-arc-deployment&lt;/artifactId&gt; &lt;!--2--&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.acme&lt;/groupId&gt;
            &lt;artifactId&gt;greeting-extension&lt;/artifactId&gt; &lt;!--3--&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
          &lt;artifactId&gt;quarkus-junit5-internal&lt;/artifactId&gt;
          &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;annotationProcessorPaths&gt;
                        &lt;path&gt;
                            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                            &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;  &lt;!--4--&gt;
                            &lt;version&gt;${quarkus.version}&lt;/version&gt;
                        &lt;/path&gt;
                    &lt;/annotationProcessorPaths&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;annotationProcessorPaths&gt;
                        &lt;path&gt;
                            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                            &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;  &lt;!--4--&gt;
                            &lt;version&gt;${quarkus.version}&lt;/version&gt;
                        &lt;/path&gt;
                    &lt;/annotationProcessorPaths&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/project&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;/project&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The key points are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>主なポイント:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By convention, the deployment module has the `-deployment` suffix (`greeting-extension-deployment`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>決まりとして、配置モジュールのサフィックスは `-deployment` (`greeting-deployment`) です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deployment module depends on the `quarkus-arc-deployment` artifact.  We will see later which dependencies are convenient to add.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメントモジュールは `quarkus-core-deployment` アーティファクトに依存しています。どの依存関係を追加するのが便利かは後ほど見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deployment module also *must* depend on the runtime module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメントモジュールも実行時モジュールに依存している *必要があります* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We add the `quarkus-extension-processor` to the compiler annotation processors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンパイラーのアノテーションプロセッサーに `quarkus-extension-processor` を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the `pom.xml` `create-extension` also generated the `org.acme.greeting.extension.deployment.GreetingExtensionProcessor` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` `create-extension` に加えて `org.acme.quarkus.greeting.deployment.GreetingProcessor` クラスも生成されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.greeting.extension.deployment;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package org.acme.greeting.extension.deployment;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.deployment.annotations.BuildStep;
import io.quarkus.deployment.builditem.FeatureBuildItem;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.deployment.annotations.BuildStep;
import io.quarkus.deployment.builditem.FeatureBuildItem;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class GreetingExtensionProcessor {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>class GreetingExtensionProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private static final String FEATURE = "greeting-extension";
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    private static final String FEATURE = "greeting-extension";
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep
    FeatureBuildItem feature() {
        return new FeatureBuildItem(FEATURE);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep
    FeatureBuildItem feature() {
        return new FeatureBuildItem(FEATURE);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`FeatureBuildItem` represents a functionality provided by an extension.  The name of the feature gets displayed in the log during application bootstrap.  An extension should provide at most one feature.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`FeatureBuildItem` はエクステンションによって提供される機能を表します。機能の名前は、アプリケーションの起動時にログに表示されます。エクステンションは最大でも 1 つの機能を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be patient, we will explain the `Build Step Processor` concept and all the extension deployment API later on.  At this point, you just need to understand that this class explains to Quarkus how to deploy a feature named `greeting` which is your extension.  In other words, you are augmenting your application to use the `greeting` extension with all the Quarkus benefits (build time optimization, native support, etc.).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Build Step Processor` の概念とすべてのエクステンションのデプロイメント API については、後で説明します。この時点では、このクラスは、`greeting` というエクステンションをデプロイする方法を Quarkus に説明していることを理解する必要があります。つまり、アプリケーションを拡張して、Quarkus のすべての利点 (ビルド時間の最適化、ネイティブサポートなど) とともに `greeting` エクステンションを使用することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Runtime module</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムモジュール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally `./greeting-extension/runtime/pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に `./greeting-extension/runtime/pom.xml` を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/pom/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.acme&lt;/groupId&gt;
        &lt;artifactId&gt;greeting-extension-parent&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-snapshot&lt;/version&gt;
    &lt;/parent&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/pom/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.acme&lt;/groupId&gt;
        &lt;artifactId&gt;greeting-extension-parent&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-snapshot&lt;/version&gt;
    &lt;/parent&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;artifactId&gt;greeting-extension&lt;/artifactId&gt;  &lt;!--1--&gt;
    &lt;name&gt;Greeting Extension - Runtime&lt;/name&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;artifactId&gt;greeting-extension&lt;/artifactId&gt;  &lt;!--1--&gt;
    &lt;name&gt;Greeting Extension - Runtime&lt;/name&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupid&gt;io.quarkus&lt;/groupid&gt;
          &lt;artifactid&gt;quarkus-arc&lt;/artifactid&gt; &lt;!--2--&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupid&gt;io.quarkus&lt;/groupid&gt;
          &lt;artifactid&gt;quarkus-arc&lt;/artifactid&gt; &lt;!--2--&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By convention, the runtime module has no suffix (`greeting-extension`) as it is the artifact exposed to the end user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>決まりとして、ランタイムモジュールはエンドユーザーに公開されるアーティファクトであるため、接尾辞 (`greeting`) を持たない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime module depends on the `quarkus-arc` artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムモジュールは `quarkus-arc` アーティファクトに依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We add the `quarkus-bootstrap-maven-plugin` to generate the Quarkus extension descriptor included into the runtime artifact which links it with the corresponding deployment artifact.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムアーティファクトに含まれる Quarkus 拡張記述子を生成するために `quarkus-bootstrap-maven-plugin` を追加し、これを対応するデプロイメントアーティファクトとリンクさせています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic version of the Sample Greeting extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプル Greeting エクステンションの基本バージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The (killer) feature proposed by our extension is to greet the user.  To do so, our extension will deploy, in the user application, a Servlet exposing the HTTP endpoint `/greeting` which responds to the GET verb with a plain text `Hello`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでのエクステンションの素晴らしい機能は、ユーザーに挨拶をすることです。これを行うには、このエクステンションはユーザーアプリケーションで、平文 `Hello` で GET 動詞に応答する HTTP エンドポイント `/greeting` を公開するサーブレットを展開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `runtime` module is where you develop the feature you want to propose to your users, so it's time to create our Web Servlet.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この `ランタイム` モジュールは、ユーザーに提案したい機能を開発するところなので、そろそろ Web Servlet を作成しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Servlets in your applications you need to have a Servlet Container such as http://undertow.io[Undertow].  Luckily, `quarkus-bom` imported by our parent `pom.xml` already includes the Undertow Quarkus extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションでサーブレットを使用するには、 link:http://undertow.io[Undertow] のようなサーブレットコンテナーが必要です。幸い、`pom.xml`にインポートされる `quarkus-bom` には、すでに Undertow Quarkus エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All we need to do is add `quarkus-undertow` as dependency to our `./greeting-extension/runtime/pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要なのは、 `quarkus-undertow` を依存関係として `./greeting-extension/runtime/pom.xml` に追加することだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-undertow&lt;/artifactId&gt;
    &lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-undertow&lt;/artifactId&gt;
    &lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The dependency on `quarkus-arc` generated by the `create-extension` mojo can now be removed since `quarkus-undertow` already depends on it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`create-extension` mojo で生成された `quarkus-core-deployment` への依存関係は、`quarkus-undertow-deployment` が既に依存しているため削除できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we can create our Servlet `org.acme.greeting.extension.GreetingExtensionServlet` in the `runtime` module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、`runtime` モジュールでサーブレット `org.acme.quarkus.greeting.GreetingServlet` を作成することができるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mkdir -p ./greeting-extension/runtime/src/main/java/org/acme/greeting/extension
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mkdir -p ./greeting-extension/runtime/src/main/java/org/acme/greeting/extension
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.greeting.extension;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package org.acme.greeting.extension;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@WebServlet
public class GreetingExtensionServlet extends HttpServlet { // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@WebServlet
public class GreetingExtensionServlet extends HttpServlet { // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { // &lt;2&gt;
        resp.getWriter().write("Hello");
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { // &lt;2&gt;
        resp.getWriter().write("Hello");
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, defining a servlet requires to extend `javax.servlet.http.HttpServlet`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常通り、サーブレットを定義するには `javax.servlet.http.HttpServlet` の拡張が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we want to respond to the HTTP GET verb, we override the `doGet` method and write `Hello` in the Servlet response's output stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP GET 動詞に応答したいので、`doGet` メソッドをオーバーライドして、サーブレット応答の出力ストリームに `Hello` を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus magic relies on bytecode generation at build time rather than waiting for the runtime code evaluation, that's the role of your extension's `deployment` module.  Calm down, we know, bytecode is hard and you don't want to do it manually, Quarkus proposes a high level API to make your life easier.  Thanks to basic concepts, you will describe the items to produce/consume and the corresponding steps in order to generate the bytecode to produce during the deployment time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`deployment` Quarkus magic は、実行時のコード評価を待つのではなく、ビルド時のバイトコード生成に依存しています。これは、エクステンションの `deployment` モジュールのロールです。安心してください。バイトコードは難しいので、手動での作業は理想的でないことは理解しています。基本的な概念のおかげで、デプロイ時に生成するバイトコード生成のために、生成/消費するアイテムとそれに対応するステップを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.builder.item.BuildItem` concept represents object instances you will produce or consume (and at some point convert into bytecode) thanks to methods annotated with `@io.quarkus.deployment.annotations.BuildStep` which describe your extension's deployment tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.builder.item.BuildItem` の概念は、`@io.quarkus.deployment.annotations.BuildStep` でアノテーションされたメソッドのおかげで、生成または消費 (そしてある時点でバイトコードに変換したり) するオブジェクトインスタンスを表しています。このアノテーションは、エクステンションのデプロイメントタスクを説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:all-builditems[the complete list of BuildItem implementations in core] for more information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は  link:all-builditems[BuildItem 実装の完全リスト] 参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go back to the generated `org.acme.greeting.extension.deployment.GreetingExtensionProcessor` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `org.acme.quarkus.greeting.deployment.GreetingProcessor` クラスに戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep // &lt;1&gt;
    FeatureBuildItem feature() {
        return new FeatureBuildItem(FEATURE); // &lt;2&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep // &lt;1&gt;
    FeatureBuildItem feature() {
        return new FeatureBuildItem(FEATURE); // &lt;2&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`feature()` method is annotated with `@BuildStep` which means it is identified as a deployment task Quarkus will have to execute during the deployment.  `BuildStep` methods are run concurrently at augmentation time to augment the application.  They use a producer/consumer model, where a step is guaranteed not to be run until all the items that it is consuming have been produced.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`feature()` メソッドには `@BuildStep` というアノテーションが付けられています。これは、Quarkus がデプロイ時に実行しなければならないデプロイタスクとして識別されます。`BuildStep` メソッドは、アプリケーションを拡張するための拡張時に同時に実行されます。これらは、プロデューサー/コンシューマーモデルを使用しています。このステップは、消費しているすべての項目が生成されるまで、実行されないことが保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.FeatureBuildItem` is an implementation of `BuildItem` which represents the description of an extension.  This `BuildItem` will be used by Quarkus to display information to the users when the application is starting.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.deployment.builditem.FeatureBuildItem` は、エクステンションの説明を表す `BuildItem` の実装です。この `BuildItem` は、アプリケーションの起動時にユーザーに情報を表示するために Quarkus が使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many `BuildItem` implementations, each one represents an aspect of the deployment process.  Here are some examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くの `BuildItem` 実装があり、それぞれが展開プロセスの一面を表しています。ここではいくつかの例を紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ServletBuildItem`: describes a Servlet (name, path, etc.) we want to generate during the deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ServletBuildItem`: デプロイ時に生成したいサーブレット (名前、パスなど) を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`BeanContainerBuildItem`: describes a container used to store and retrieve object instances during the deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`BeanContainerBuildItem`: デプロイ時にオブジェクトインスタンスを保存・取得するために使用するコンテナーについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't find a `BuildItem` for what you want to achieve, you can create your own implementation. Keep in mind that a `BuildItem` should be as fine-grained as possible, representing a specific part of the deployment.  To create your `BuildItem` you can extend:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実現したいことに対応する `BuildItem` が見つからない場合は、独自の実装を作成することができます。 `BuildItem` は、デプロイメントの特定の部分を表すもので、できるだけ細かいものでなければならないということを覚えておいてください。`BuildItem` を作成する方法:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.builder.item.SimpleBuildItem` if you need only a single instance of the item during the deployment (e.g. `BeanContainerBuildItem`, you only want one container).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.builder.item.SimpleBuildItem` デプロイ時にアイテムのインスタンスを1つだけ必要とする場合 (例: `BeanContainerBuildItem`、コンテナーが 1 つのみ必要な場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.builder.item.MultiBuildItem` if you want to have multiple instances (e.g. `ServletBuildItem`, you can produce many Servlets during the deployment).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のインスタンスを使いたい場合は `io.quarkus.builder.item.MultiBuildItem` (例: `ServletBuildItem`、デプロイ時に多くのサーブレットを生成することができます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's now time to declare our HTTP endpoint. To do so, we need to produce a `ServletBuildItem`.  At this point, we are sure you understood that if the `quarkus-undertow` dependency proposes Servlet support for our `runtime` module, we will need the `quarkus-undertow-deployment` dependency in our `deployment` module to have access to the `io.quarkus.undertow.deployment.ServletBuildItem`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次は、HTTP エンドポイントを宣言します。これを行うには、`ServletBuildItem` を生成する必要があります。この時点では、 `quarkus-undertow` 依存関係が `runtime` モジュールの Servlet サポートを提案している場合は、`deployment` モジュールの `quarkus-undertow-deployment` 依存関係が `io.quarkus.undertow.deployment.ServletBuildItem` にアクセスできるようにする必要があることをご理解いただけたと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's add `quarkus-undertow-deployment` as dependency to our `./greeting-extension/deployment/pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-undertow-deployment` を依存関係として `./greeting-extension/deployment/pom.xml` に追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-undertow-deployment&lt;/artifactId&gt;
    &lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-undertow-deployment&lt;/artifactId&gt;
    &lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The dependency on `quarkus-arc-deployment` generated by the `create-extension` mojo can now be removed since `quarkus-undertow-deployment` already depends on it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`create-extension` mojo で生成された `quarkus-core-deployment` への依存は、 `quarkus-undertow-deployment` が既に依存しているので、これで削除できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now update `org.acme.greeting.extension.deployment.GreetingExtensionProcessor`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで `org.acme.quarkus.greeting.deployment.GreetingProcessor` を更新できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.deployment.annotations.BuildStep;
import io.quarkus.deployment.builditem.FeatureBuildItem;
import org.acme.greeting.extension.GreetingExtensionServlet;
import io.quarkus.undertow.deployment.ServletBuildItem;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.deployment.annotations.BuildStep;
import io.quarkus.deployment.builditem.FeatureBuildItem;
import org.acme.greeting.extension.GreetingExtensionServlet;
import io.quarkus.undertow.deployment.ServletBuildItem;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep
    ServletBuildItem createServlet() { // &lt;1&gt;
      ServletBuildItem servletBuildItem = ServletBuildItem.builder("greeting-extension", GreetingExtensionServlet.class.getName())
        .addMapping("/greeting")
        .build(); // &lt;2&gt;
      return servletBuildItem;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep
    ServletBuildItem createServlet() { // &lt;1&gt;
      ServletBuildItem servletBuildItem = ServletBuildItem.builder("greeting-extension", GreetingExtensionServlet.class.getName())
        .addMapping("/greeting")
        .build(); // &lt;2&gt;
      return servletBuildItem;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We add a `createServlet` method which returns a `ServletBuildItem` and annotate it with `@BuildStep`.  Now, Quarkus will process this new task which will result in the bytecode generation of the Servlet registration at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ServletBuildItem` を返す `createServlet` メソッドを追加し、`@BuildStep` でアノテーションを付けます。これで、Quarkus はこの新しいタスクを処理して、ビルド時にサーブレット登録のバイトコードを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ServletBuildItem` proposes a fluent API to instantiate a Servlet named `greeting-extension` of type `GreetingExtensionServlet` (it's our class provided by our extension `runtime` module), and map it the `/greeting` path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ServletBuildItem` は、流ちょうな API を処理して `GreetingExtensionServlet` 型の `greeting-extension` というサーブレットをインスタンス化し (エクステンション `runtime` によって提供されるクラスです)、`/greeting` パスにマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the Greeting Extension feature</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グリーティングエクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When developing a Quarkus extension, you mainly want to test your feature is properly deployed in an application and works as expected.  That's why the tests will be hosted in the `deployment` module.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus エクステンションを開発する際には、主に機能がアプリケーションに正しくデプロイされ、期待通りに動作するかどうかをテストすることを考える必要があります。そのため、テストは `deployment` モジュールでホストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus proposes facilities to test extensions via the `quarkus-junit5-internal` artifact (which should already be in the deployment pom.xml), in particular the `io.quarkus.test.QuarkusUnitTest` runner which starts an application with your extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、既に deployment pom.xml にある `quarkus-junit5-internal` アーティファクトを介してエクステンションをテストするための機能を処理します (エクステンションでアプリケーションを起動する `io.quarkus.test.QuarkusUnitTest` ランナー)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will use http://rest-assured.io[RestAssured] (massively used in Quarkus) to test our HTTP endpoint.  Let's add the `rest-assured` dependency into the `./greeting-extension/deployment/pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://rest-assured.io[RestAssured] (Quarkus で非常によく使われる) を使用して HTTP エンドポイントをテストします。`rest-assured` の依存関係を `./greeting-extension/deployment/pom.xml` に追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    ...
    &lt;dependency&gt;
      &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
      &lt;artifactId&gt;rest-assured&lt;/artifactId&gt; &lt;!--2--&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    ...
    &lt;dependency&gt;
      &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
      &lt;artifactId&gt;rest-assured&lt;/artifactId&gt; &lt;!--2--&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `create-extension` Maven Mojo can create the test and integration-test structure (drop the `-DwithoutTests`). Here, we'll create it ourselves:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在、`create-extension` Maven Mojo はテストと統合テスト構造 (`-DwithoutTests` をドロップ) を作成できます。ここでは、自分たちで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mkdir -p ./greeting-extension/deployment/src/test/java/org/acme/greeting/extension/deployment
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mkdir -p ./greeting-extension/deployment/src/test/java/org/acme/greeting/extension/deployment
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start testing your extension, create the following `org.acme.greeting.extension.deployment.GreetingExtensionTest` test class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのテストを開始するには、次の `org.acme.quarkus.greeting.deployment.GreetingTest` テストクラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.test.QuarkusUnitTest;
import io.restassured.RestAssured;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.test.QuarkusUnitTest;
import io.restassured.RestAssured;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import static org.hamcrest.Matchers.containsString;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import static org.hamcrest.Matchers.containsString;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class GreetingExtensionTest {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class GreetingExtensionTest {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @RegisterExtension
  static final QuarkusUnitTest config = new QuarkusUnitTest()
    .setArchiveProducer(() -&gt; ShrinkWrap.create(JavaArchive.class)); // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @RegisterExtension
  static final QuarkusUnitTest config = new QuarkusUnitTest()
    .setArchiveProducer(() -&gt; ShrinkWrap.create(JavaArchive.class)); // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Test
  public void testGreeting() {
    RestAssured.when().get("/greeting").then().statusCode(200).body(containsString("Hello")); // &lt;2&gt;
  }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Test
  public void testGreeting() {
    RestAssured.when().get("/greeting").then().statusCode(200).body(containsString("Hello")); // &lt;2&gt;
  }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We register a Junit Extension which will start a Quarkus application with the Greeting extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Greeting エクステンションで Quarkus アプリを起動する Junit エクステンションを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We verify the application has a `greeting` endpoint responding to a HTTP GET request with a OK status (200) and a plain text body containing `Hello`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが `greeting` エンドポイントから OK ステータス (200) の HTTP GET 要求に応答していることと、`Hello` を含むプレーンテキスト本文があることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time to test and install to our local maven repository!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストしてローカルの maven リポジトリーにインストールしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks good! Congratulations you just finished your first extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題なさそうですね。初めてのエクステンションの作成、おつかれさまでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging your extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_If debugging is the process of removing bugs, then programming must be the process of putting them in._ Edsger W. Dijkstra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デバッグ作業がバグを取り除く作業であるならば、プログラミングとは、バグを入れ込む作業ということになる。エドガー・W・ダイクストラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging your application build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションビルドのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since your extension deployment is made during the application build, this process is triggered by your build tool.  That means if you want to debug this phase you need to launch your build tool with the remote debug mode switched one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのデプロイはアプリケーションのビルド中に行われるため、このプロセスはビルドツールによってトリガーされます。つまり、このフェーズをデバッグしたい場合は、リモートデバッグモードを 1 に切り替えてビルドツールを起動する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can activate Maven remote debugging by using `mvnDebug`.  You can launch your application with the following command line:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvnDebug` を使用して、Maven リモートデバッグを有効にすることができます。以下のコマンドラインでアプリケーションを起動できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvnDebug clean compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvnDebug clean compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Maven will wait for a connection on `localhost:8000`.  Now, you can run your IDE `Remote` configuration to attach it to `localhost:8000`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Maven は、`localhost:8000` 上の接続を待ちます。これで、`localhost:8000` にアタッチするために、IDE `Remote` の設定を実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can activate Gradle remote debugging by using the flags `org.gradle.debug=true` or `org.gradle.daemon.debug=true` in daemon mode.  You can launch your application with the following command line:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle のリモートデバッグは、デーモンモードでフラグ `org.gradle.debug=true` または `org.gradle.daemon.debug=true` を使用して有効にすることができます。以下のコマンドラインでアプリケーションを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./gradlew quarkusDev -Dorg.gradle.daemon.debug=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./gradlew quarkusDev -Dorg.gradle.daemon.debug=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Gradle will wait for a connection on `localhost:5005`.  Now, you can run your IDE `Remote` configuration to attach it to `localhost:5005`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Gradle は、`localhost:5005` 上の接続を待ちます。これで、`localhost:5005` にアタッチするために、IDE `Remote` の設定を実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging your extension tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションテストのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have seen together how to test your extension and sometimes things don't go so well and you want to debug your tests.  Same principle here, the trick is to enable the Maven Surefire remote debugging in order to attach an IDE `Remote` configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをテストする方法を一緒に見てきましたが、時にはうまくいかず、テストをデバッグしたい場合もあります。ここでも同じ原理で、IDE `Remote` の設定をアタッチするために Maven Surefire リモートデバッグを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cd ./greeting-extension
mvn clean test -Dmaven.surefire.debug
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cd ./greeting-extension
mvn clean test -Dmaven.surefire.debug
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Maven will wait for a connection on `localhost:5005`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Maven は `localhost:5005` で接続を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time to use your new extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you just finished building your first extension you should be eager to use it in a Quarkus application!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のエクステンションを構築し終えたばかりなので、Quarkus アプリケーションで使いたいと思うことでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Classic Maven publication*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*お約束の Maven キャッチ*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not already done in the previous step, you should install the `greeting-extension` in your local repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のステップでまだ行っていない場合は、ローカルリポジトリに `greeting-extension` をインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cd ./greeting-extension
mvn clean install
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cd ./greeting-extension
mvn clean install
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then from another directory, use our tooling to create a new `greeting-app` Quarkus application with your new extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、別のディレクトリから、我々のツールを使用して、新しいエクステンションを持つ新しい `greeting-app` Quarkus アプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
     -DprojectGroupId=org.acme \
     -DprojectArtifactId=greeting-app \
     -Dextensions="org.acme:greeting-extension:1.0.0-SNAPSHOT" \
     -DnoExamples
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
     -DprojectGroupId=org.acme \
     -DprojectArtifactId=greeting-app \
     -Dextensions="org.acme:greeting-extension:1.0.0-SNAPSHOT" \
     -DnoExamples
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`cd` into `greeting-app`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`cd` into `greeting-app`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `greeting-extension` extension has to be installed in the local Maven repository to be usable in the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-greeting` エクステンションをアプリケーションで使用できるようにするには、ローカルの Maven リポジトリにインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application and notice the `Installed Features` list contains the `greeting-extension` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを実行して、 `Installed Features` のリストに `quarkus-greeting` のエクステンションが含まれていることに注目してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From an extension developer standpoint the Maven publication strategy is very handy and fast but Quarkus wants to go one step further by also ensuring a reliability of the ecosystem for the people who will use the extensions.  Think about it, we all had a poor Developer Experience with an unmaintained library, an incompatibility between dependencies (and we don't even talk about legal issues).  That's why there is the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの開発者の立場からすると、Maven の公開戦略は非常に便利で高速ですが、Quarkus は、エクステンションを使用する人々のためにエコシステムの信頼性も確保することで、さらに一歩進んでいきたいと考えています。考えてみてください。私たちは皆、メンテナンスされていないライブラリや依存関係間の非互換性 (法的な問題は除く) で、開発体験が著しく低下したことを経験していることでしょう。Quarkus Platform は、そのためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Quarkus Platform*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Quarkus Platform*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus proposes a `quarkus-universe-bom` which is a certified list of extensions placed under the Quarkus Platform label. From an application developer, the objectives of the platform are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、Quarkus Platform ラベルの下に置かれたエクステンションの認定リストである `quarkus-universe-bom` を提案しています。アプリケーション開発者からすると、このプラットフォームの目的は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To guarantee a supportability of the extension (bugfix, security issues, dependency upgrades)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのサポート性を保証する (バグフィックス、セキュリティー問題、依存関係のアップグレード)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ensure a global consistency of the extension ecosystem</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションエコシステムのグローバルな整合性を確保する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Should I publish my extension to the platform?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをプラットフォームに公開すべきかどうか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you feel your extensions is for you or a limited group, simply publishing to Maven is fine.  If the extension solves a general problem, it is very handy for Quarkus users to see it on https://code.quarkus.io.  But this comes with some responsibility for you, keeping it up to date with Quarkus minor releases (every month or so at the moment).  When in doubt, have a conversation with the community in the https://groups.google.com/forum/#!forum/quarkus-dev[Quarkus Google Group]. We can make a collective decision.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションが自分自信や限定されたグループのためのものだと感じるのであれば、Maven に公開するだけでも構いません。エクステンションが一般的な問題を解決する場合は、Quarkus ユーザーが https://code.quarkus.io で見つけられることは有益です。しかし、これには、Quarkus のマイナーリリース (現時点では 1 か月に 1 回程度) に合わせて最新の状態に保たなければならないという責任が伴います。質問がある場合は、Quarkus の link:https://groups.google.com/forum/#!forum/quarkus-dev[Google グループ] でコミュニティと話してください。ここでは、集団的な決定を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to contribute a new extension, we strongly suggest you to host it in the Quarkiverse Hub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションを提供したい場合は、Quarkiverse Hub でホストすることを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Quarkiverse Hub*
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Quarkiverse Hub*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/quarkiverse[Quarkiverse Hub] is the GitHub organization that provides repository hosting (including build, CI and release publishing setup) for Quarkus extension projects contributed by the community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkiverse[Quarkiverse Hub] は、コミュニティから投稿された Quarkus エクステンションプロジェクトのリポジトリーホスティング (ビルド、CI、リリースパブリッシングのセットアップを含む) を提供する GitHub 組織です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get started by creating an link:https://github.com/quarkusio/quarkus/issues/new/choose[Extension Request] issue (check first if one wasn't already submitted link:https://github.com/quarkusio/quarkus/labels/kind%2Fextension-proposal[here]) and asking to lead it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/issues/new/choose[エクステンションリクエスト] 投稿を作成 (link:https://github.com/quarkusio/quarkus/labels/kind%2Fextension-proposal[こちら]) で、まだ投稿されていないかどうかを最初に確認してください) し、それをリードするように依頼することから始めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll take care of provisioning a new repository and set it up to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我々は、新しいリポジトリのプロビジョニングを行い、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be supported by our tooling;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我々のツールでサポート。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Publish the documentation you produce for your extension to the Quarkiverse website;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのために作成したドキュメントを Quarkiverse の Web サイトに公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure your extension to use the link:https://github.com/quarkusio/quarkus-ecosystem-ci#quarkus-ecosystem-ci[Quarkus Ecosystem CI] to build against the latest Quarkus Core changes;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus-ecosystem-ci#quarkus-ecosystem-ci[Quarkus エコシステム CI] を使用して、最新の Quarkus Core の変更に対応してビルドするようにエクステンションを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Give you the freedom to manage the project and release to Maven Central as you like.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトを管理し、好きなように Maven Central にリリースする自由を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, check link:https://github.com/quarkiverse/quarkiverse/wiki[the Quarkiverse Wiki] and link:https://quarkus.io/blog/quarkiverse/[this blog post].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳しくは、link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki] と link:https://quarkus.io/blog/quarkiverse/[このブログ記事を] チェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating new extensions may appear to be an intricate task at first but once you understood the Quarkus game-changer paradigm (build time vs runtime) the structure of an extension makes perfectly sense.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションの作成は、最初は複雑な作業に見えるかもしれませんが、Quarkus の変革をもたらすパラダイム (ビルド時間とランタイム) を理解してしまえば、エクステンションの構造は完璧に理にかなったものになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, along the path Quarkus simplifies things under the hood (Maven Mojo, bytecode generation or testing) to make it pleasant to develop new features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、Quarkus は地道に、新機能の開発を快適にするために、Maven Mojo、バイトコード生成またはテストといった作業を簡素化するために努めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:writing-extensions[Writing your own extension] for the full documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全なドキュメント link:writing-extensions[独自のエクステンションを書く]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:dev-console[Quarkus DEV Console] to learn how to support the DEV Console in your extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションで DEV Console をサポートする方法については、link:dev-console[Quarkus DEV Console] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to measure the test coverage of your application. This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのテストカバレッジを測定する方法をご紹介します。このガイドでは、以下の内容をカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your Unit Tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユニットテストのカバレッジを測定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your Integration Tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合テストのカバレッジを測定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Separating the execution of your Unit Tests and Integration Tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユニットテストと統合テストの実行を分離する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consolidating the coverage for all your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのテストのカバレッジを統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that code coverage is not supported in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードではコードカバレッジはサポートされていませんのでご注意ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having completed the link:getting-started-testing[Testing your application guide]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://quarkus.io/guides/getting-started-testing[アプリケーションガイドのテスト] が完了済であること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is just a JAX-RS endpoint (hello world) that relies on dependency injection to use a service.  The service will be tested with JUnit 5 and the endpoint will be annotated via a `@QuarkusTest` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで構築されたアプリケーションは、サービスを使用するために依存性インジェクションに依存した JAX-RS エンドポイント (hello world) に過ぎません。サービスは JUnit 5 でテストされ、エンドポイントには `@QuarkusTest` のアノテーションが付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example.  Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。しかし、完成した例にすぐに進むことができます。Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、または {quickstarts-archive-url}[archive] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `tests-with-coverage-quickstart` {quickstarts-tree-url}/tests-with-coverage-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `tests-with-coverage-quickstart` {quickstarts-tree-url}/tests-with-coverage-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from a simple project and two tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単なプロジェクトと2つのテストから始める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start from an empty application created with the Quarkus Maven plugin:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Mavenプラグインで作成した空のアプリケーションから始めてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we'll be adding all the elements necessary to have an application that is properly covered with tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、アプリケーションをテストで適切にカバーするために必要な要素をすべて追加していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, an application serving a hello endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、helloエンドポイントを提供するアプリケーション:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint uses a greeting service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエンドポイントは、グリーティングサービスを利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project will also need a test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトにはテストも必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we need to add Jacoco to our project. To do this we need to add the following to the `pom.xml` dependencies section:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、Jacocoをプロジェクトに追加する必要があります。そのためには、 `pom.xml` dependenciesセクションに以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This Quarkus extension takes care of everything that would usually be done via the Jacoco maven plugin, so no additional config is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このQuarkusのエクステンションは、通常はJacoco mavenプラグインで行われることをすべて行いますので、追加の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using both the extension and the plugin requires special configuration, if you add both you will get lots of errors about classes already being instrumented. The configuration needed is detailed below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションとプラグインの両方を使用するには、特別な設定が必要です。両方を追加すると、すでにインスツルメンテーションされているクラスに関する多くのエラーが発生します。必要な設定の詳細は以下のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the tests with coverage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カバレッジ付きテストの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run `mvn verify`, the tests will be run and the results will end up in `target/jacoco-reports`. This is all that is needed, the `quarkus-jacoco` extension allows Jacoco to just work out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mvn verify` を実行すると、テストが実行され、その結果が `target/jacoco-reports` に反映されます。必要なのはこれだけで、 `quarkus-jacoco` のエクステンションを使えば、Jacoco はすぐに動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some config options that affect this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにはいくつかの設定オプションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus automatic Jacoco config will only work for tests that are annotated with `@QuarkusTest`. If you want to check the coverage of other tests as well then you will need to fall back to the Jacoco maven plugin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの自動Jacoco設定は、 `@QuarkusTest` でアノテーションされたテストに対してのみ機能します。他のテストのカバレッジもチェックしたい場合は、Jacoco mavenプラグインを利用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to including the `quarkus-jacoco` extension in your pom you will need the following config:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jacoco` エクステンションをpomに含めるのに加えて、以下のような設定が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This config tells it to ignore `@QuarkusTest` related classes, as they are loaded by `QuarkusClassLoader`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定では、 `@QuarkusTest` 関連のクラスを無視するようになっています。これらのクラスは `QuarkusClassLoader` で読み込まれる為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is only needed if you are using Failsafe to run integration tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Failsafeを使って統合テストを実行する場合にのみ必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This config will only work if at least one `@QuarkusTest` is being run. If you are not using `@QuarkusTest` then you can simply use the Jacoco plugin in the standard manner with no additional config.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定は、少なくとも1つの `@QuarkusTest` が実行されている場合にのみ機能します。 `@QuarkusTest` を使用していない場合は、追加の設定をすることなく、通常の方法で Jacoco プラグインを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now have all the information you need to study the coverage of your tests! But remember, some code that is not covered is certainly not well tested. But some code that is covered is not necessarily *well* tested. Make sure to write good tests!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、テストのカバレッジを研究するために必要なすべての情報を手に入れることができました!しかし、カバーされていないコードは、確かに十分にテストされていないものがありますが、カバーされているコードの中には、必ずしも *十分に* テストされていないものもあることを覚えておいてください。良いテストを書くようにしましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.kafka;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package org.acme.kafka;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>version: '2'
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>version: '2'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>services:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>services:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize https://github.com/smallrye/smallrye-jwt/[SmallRye JWT] to verify https://tools.ietf.org/html/rfc7519[JSON Web Token]s, represent them as MicroProfile JWT `org.eclipse.microprofile.jwt.JsonWebToken` and provide secured access to the Quarkus HTTP endpoints using Bearer Token Authorization and https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションが https://github.com/smallrye/smallrye-jwt/[SmallRye JWT] を利用して、 link:https://tools.ietf.org/html/rfc7519[JSON Web Token] を検証し、MicroProfile JWT `org.eclipse.microprofile.jwt.JsonWebToken` として表現し、Bearer Token Authorizationと link:https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control] を使用してQuarkus HTTPエンドポイントへのセキュアなアクセスを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus OpenId Connect extension also supports Bearer Token Authorization and uses `smallrye-jwt` to represent the bearer tokens as `JsonWebToken`, please read the link:security-openid-connect[Using OpenID Connect to Protect Service Applications] guide for more information.  OpenId Connect extension has to be used if the Quarkus application needs to authenticate the users using OIDC Authorization Code Flow, please read link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Applications] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus OpenId Connect エクステンションは、ベアラートークンの認証もサポートしており、 `smallrye-jwt` を使用してベアラートークンを `JsonWebToken` として表現します。詳しくは link:security-openid-connect[Using OpenID Connect to Protect Service Applications] ガイドをご覧ください。OpenId Connect extensionは、QuarkusアプリケーションがOIDC Authorization Code Flowを使用してユーザーを認証する必要がある場合に使用する必要があります。詳しくは link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Applications] ガイドをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-jwt-quickstart` {quickstarts-tree-url}/security-jwt-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `smallrye-jwt` extension, which includes the {mp-jwt} support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、{mp-jwt}サポートを含む `smallrye-jwt` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-jwt` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-jwt` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/security/jwt/TokenSecuredResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/java/org/acme/security/jwt/TokenSecuredResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic REST Endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本的なRESTエンドポイント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl command for /secured/permit-all</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> /secured/permit-all に対するcurl コマンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have not provided any JWT in our request, so we would not expect that there is any security state seen by the endpoint, and the response is consistent with that:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリクエストではJWTを設定していませんので、エンドポイントから見たセキュリティーステートがあるとは期待できず、レスポンスもそれに沿ったものとなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>isHttps is false as https is not used</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>isHttps は https を使用しないので false です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>authScheme is null</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>authScheme は null です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hasJWT is false</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>hasJWTは false です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Ctrl-C to stop the Quarkus server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Ctrl-Cを使用してQuarkusサーバーを停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイル例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.publickey</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.publickey</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.publickey.location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.publickey.location</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Signature algorithm. Set it to `ES256` to support the Elliptic Curve signature algorithm.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>署名アルゴリズム。 `ES256` に設定して、楕円曲線署名アルゴリズムをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.jwt.verify.issuer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.jwt.verify.issuer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Authorization`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Authorization`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Key (JWK)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON Web Key (JWK)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON Web Key Set (JWKS)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON Web Key Set (JWKS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT provides more properties which can be used to customize the token processing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye JWTには、トークン処理をカスタマイズするために使用できる、より多くのプロパティーが用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.key.location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.key.location</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.key-format</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.key-format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.relax-key-validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.relax-key-validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.certificate-thumbprint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.certificate-thumbprint</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.token.header</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.token.header</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.token.cooki</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.token.cooki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.always-check-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.always-check-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.token.scheme</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.token.scheme</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bearer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Bearer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.token.ki</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.token.ki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.time-to-liv</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.time-to-liv</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.require.named-principa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.require.named-principa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`false`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.path.sub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.path.sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.claims.sub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.claims.sub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.path.group</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.path.group</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.groups-separator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.groups-separator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>' '</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>' '</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.claims.group</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.claims.group</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.jwks.refresh-interva</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.jwks.refresh-interva</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.jwks.forced-refresh-interva</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.jwks.forced-refresh-interva</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.expiration.grac</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.expiration.grac</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.verify.au</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.verify.au</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.required.claim</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.required.claim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.decrypt.key.location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.decrypt.key.location</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.decrypt.algorith</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.decrypt.algorith</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decryption algorithm.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>復号化アルゴリズム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.token.decryption.ki</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.token.decryption.ki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token Decryption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークン復号化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proactive Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロアクティブ認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Factories</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムファクトリー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`none`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`none`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Location of a private key which will be used to sign the claims when either a no-argument `sign()` or `innerSign()` method is called.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引数なし `sign()` または `innerSign()` メソッドが呼び出されたときに、クレームに署名するために使用される秘密鍵の場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Location of a public key which will be used to encrypt the claims or inner JWT when a no-argument `encrypt()` method is called.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引数無し `encrypt()` メソッドが呼び出された際に、クレームまたは内部 JWT を暗号化するために使用される公開鍵の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.new-token.lifespan</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.new-token.lifespan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token lifespan in seconds which will be used to calculate an `exp` (expiry) claim value if this claim has not already been set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>exp (expiry) クレームがまだ設定されていない場合、このクレーム値を計算するために使用される トークン生存期間の秒数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>smallrye.jwt.new-token.issuer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>smallrye.jwt.new-token.issuer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token issuer which can be used to set an `iss` (issuer) claim value if this claim has not already been set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`iss` (発行者)クレームがまだ設定されていない場合に、このクレーム値を設定するために使用できるトークン発行者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token audience which can be used to set an `aud` (audience) claim value if this claim has not already been set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`aud` (オーディエンス) クレームがまだ設定されていない場合に、このクレーム値を設定するために使用できるトークンオーディエンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set this property to `true` for `smallrye.jwt.new-token.issuer` and `smallrye.jwt.new-token.audience` values to override the already initialized `iss` (issuer) and `aud` (audience) claims.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既に初期化されている `iss` （発行者）と `aud` （視聴者）のクレームを `smallrye.jwt.new-token.issuer` と `smallrye.jwt.new-token.audience` の値で上書きするために、 このプロパティを `true` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/smallrye/smallrye-jwt[SmallRye JWT]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/smallrye/smallrye-jwt[SmallRye JWT]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7519[JSON Web Token]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7519[JSON Web Token]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7515[JSON Web Signature]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7515[JSON Web Signature]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7516[JSON Web Encryption]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7516[JSON Web Encryption]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://tools.ietf.org/html/rfc7518[JSON Web Algorithms]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://tools.ietf.org/html/rfc7518[JSON Web Algorithms]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Funqy HTTP Binding with Amazon Lambda </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Amazon Lambda用Funqy HTTPバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to allow HTTP clients to invoke on your Funqy functions on AWS Lambda, Quarkus allows you to expose multiple Funqy functions through HTTP deployed as one AWS Lambda.  This approach does add overhead over the regular Funqy AWS Lambda integration and also requires you to use AWS API Gateway.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTPクライアントがAWS Lambda上のFunqy関数を呼び出すことを許可したい場合、Quarkusでは、1つのAWS LambdaとしてデプロイされたHTTPを通して複数のFunqy関数を公開することができます。この方法では、通常のFunqy AWS Lambdaの統合よりもオーバーヘッドが追加され、AWS API Gatewayを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the link:amazon-lambda-http[Amazon Lambda Http Guide].  It walks through using a variety of HTTP frameworks on Amazon Lambda, including Funqy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:amazon-lambda-http[Amazon Lambda Http Guide] に従ってください。ガイドでは、Funqyを含むAmazon Lambda上で様々なHTTPフレームワークを使用する方法が説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + AWS Lambda binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Route link:amazon-lambda-http[support] instead.  They also work with Quarkus and AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy HTTP + AWS LambdaバインディングはHTTP上のRESTを置き換えるものではありません。Funqyは多くの異なるプロトコルや関数プロバイダに移植する必要があるため、HTTPバインディングは非常にミニマムで、リンクのようなRESTの機能やキャッシュコントロールや条件付きGETのようなHTTPの機能を利用する機能を失うことになります。代わりに、QuarkusのJAX-RS、Spring MVC、またはVert.x Web Reactive Routeの link:amazon-lambda-http[サポート] を使用することを検討するとよいでしょう。また、QuarkusやAWS Lambdaとも連携しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An additional Quickstart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のクイックスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond generating an AWS project that is covered in the link:amazon-lambda-http[Amazon Lambda Http Guide], there's also a quickstart for running Funqy HTTP on AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:amazon-lambda-http[Amazon Lambda Http Guide] でカバーされているAWSプロジェクトを生成する以外にも、AWS Lambda上でFunqy HTTPを実行するためのクイックスタートもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-http-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードには何も特別なものはありませんし、もっと重要なのはAWSに特化したものは何もありません。Funqy関数は様々な環境にデプロイすることができ、AWS Lambdaもその一つです。Javaのコードは、実は{quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]と全く同じコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The steps to get this quickstart running are exactly the same as defined in the link:amazon-lambda-http[Amazon Lambda HTTP Guide].  This differences are that you are running from a quickstart and the maven dependencies are slightly different.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクイックスタートを実行するための手順は、 link:amazon-lambda-http[Amazon Lambda HTTP Guide] で定義されているものと全く同じです。この違いは、クイックスタートから実行していることと、mavenの依存関係が若干異なることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides extensions for building (and pushing) container images. Currently it supports:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、コンテナーイメージを構築 (およびプッシュ) するためのエクステンションを提供しています。現在は以下をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jib</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-jib` is powered by https://github.com/GoogleContainerTools/jib[Jib] for performing container image builds.  The major benefit of using Jib with Quarkus is that all the dependencies (everything found under `target/lib`) are cached in a different layer than the actual application making rebuilds really fast and small (when it comes to pushing).  Another important benefit of using this extension is that it provides the ability to create a container image without having to have any dedicated client side tooling (like Docker) or running daemon processes (like the Docker daemon)  when all that is needed is the ability to push to a container image registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション `quarkus-container-image-jib` は、コンテナーイメージのビルドを実行するために link:https://github.com/GoogleContainerTools/jib[Jib] を使用しています。Jib を Quarkus で使用する主な利点は、すべての依存関係 (`target/lib` の下にあるすべてのもの) が実際のアプリケーションとは別のレイヤーにキャッシュされるため、リビルドが非常に高速かつ小規模に (プッシュする場合) 行えることです。このエクステンションを使用するもう 1 つの重要な利点は、コンテナーイメージレジストリーにプッシュする機能さえあれば、専用のクライアントサイドツール (Docker など) やデーモンプロセス (Docker デーモンなど) を実行しなくてもコンテナーイーメージを作成できることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In situations where all that is needed to build a container image and no push to a registry is necessary (essentially by having set `quarkus.container-image.build=true` and left `quarkus.container-image.push` unset - it defaults to `false`), then this extension creates a container image and registers it with the Docker daemon. This means that although Docker isn't used to build the image, it is nevertheless necessary. Also note that using this mode, the built container image *will* show up when executing `docker images`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要なことがコンテナーイメージを構築するだけで、レジストリーへのプッシュが不要な場合 (基本的には `quarkus.container-image.build=true` を設定して `quarkus.container-image.push` のままにしておくことで、デフォルトは `false` になります)、このエクステンションはコンテナーイメージを作成し、Docker デーモンに登録します。これは、Docker がイメージのビルドには使われなくても必要であることを意味します。また、このモードを使用すると、`docker images` を実行するとコンテナーイメージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including extra files</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加ファイルの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases when additional files (other than ones produced by the Quarkus build) need to be added to a container image.  To support these cases, Quarkus copies any file under `src/main/jib` into the built container image (which is essentially the same idea that the Jib Maven and Gradle plugins support).  For example, the presence of `src/main/jib/foo/bar` would result in `/foo/bar` being added into the container filesystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージに追加のファイル(Quarkus のビルドで作成されたもの以外)を追加する必要がある場合があります。このような場合に対応するため、Quarkus は、`src/main/jib` 以下のファイルをすべてビルドされたコンテナーイメージにコピーします (これは、Jib Maven や Gradle プラグインがサポートしているのと基本的に同じ考え方です)。例えば、`src/main/jib/foo/bar` が存在すると、`/foo/bar` がコンテナファイルシステムに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-docker` is using the Docker binary and the generated Dockerfiles under `src/main/docker` in order to perform Docker builds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション `quarkus-container-image-docker` は、Docker ビルドを実行するために `src/main/docker` 下で Docker バイナリーと生成された Dockerfiles を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-s2i` is using S2I binary builds in order to perform container builds inside the OpenShift cluster.  The idea behind the binary build is that you just upload the artifact and its dependencies to the cluster and during the build they will be merged to a builder image (defaults to `fabric8/s2i-java`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション `quarkus-container-image-s2i` は、OpenShift クラスター内でコンテナービルドを実行するために S2I バイナリービルドを使用しています。バイナリービルドの考え方は、アーティファクトとその依存関係をクラスタにアップロードするだけで、ビルド中にそれらがビルダーイメージにマージされます (デフォルトは `fabric8/s2i-java`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The benefit of this approach, is that it can be combined with OpenShift's `DeploymentConfig` that makes it easy to roll out changes to the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプローチの利点は、クラスターへの変更を簡単にロールアウトできる OpenShift の `DeploymentConfig` と組み合わせることができることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I builds require creating a `BuildConfig` and two `ImageStream` resources, one for the builder image and one for the output image.  The creation of such objects is being taken care of by the Quarkus Kubernetes extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>S2I のビルドでは、`BuildConfig` と 2 つの `ImageStream` リソースを作成する必要があります。このようなオブジェクトの作成は、Quarkus Kubernetes エクステンションによって行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build a container image for your project, `quarkus.container-image.build=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト用のコンテナーイメージを作成するには、Quarkus がサポートしている方法のいずれかで、 `quarkus.container-image.build=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pushing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To push a container image for your project, `quarkus.container-image.push=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトにコンテナーイメージをプッシュするには、Quarkus がサポートしている方法のいずれかで、`quarkus.container-image.push=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no registry is set (using `quarkus.container-image.registry`) then `docker.io` will be used as the default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジストリーが設定されていない場合 (`quarkus.container-image.registry` を使用) は、 `docker.io` がデフォルトとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selecting among multiple extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のエクステンションから選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not make sense to use multiple extension as part of the same build. When multiple container image extensions are present, an error will be raised to inform the user. The user can either remove the uneeded extensions or select one using `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のエクステンションを同じビルドの一部として使用するのは意味がありません。複数のコンテナー-イメージエクステンションが存在する場合は、エラーが発生してユーザーに通知されます。ユーザーは不要なエクステンション削除するか、`application.properties` を使って選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if both `container-image-docker` and `container-image-s2i` are present and the user needs to use `container-image-docker`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、`container-image-docker` と `container-image-s2i` の両方が存在し、ユーザーが `container-image-docker` を使用する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to customize the container image build process.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のプロパティーを使用して、コンテナーイメージのビルドプロセスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image Options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various CI environments provide a ready to use container-image registry which can be combined with the container-image Quarkus extensions in order to effortlessly create and push a Quarkus application to said registry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さまざまな CI 環境では、Quarkus アプリケーションを作成してレジストリーをプッシュするために、コンテナーイメージ Quarkus エクステンションと組み合わせることで、すぐに使えるコンテナーイメージレジストリ-を利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, https://gitlab.com/[GitLab] provides such a registry and in the provided CI environment, makes available the `CI_REGISTRY_IMAGE` environment variable (see GitLab's https://docs.gitlab.com/ee/ci/variables/[documentation]) for more information), which can be used in Quarkus like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 link:https://gitlab.com/[GitLab] はこのようなレジストリーを提供しており、提供されている CI 環境では、環境変数 `CI_REGISTRY_IMAGE` (詳しくは GitLab の link:https://docs.gitlab.com/ee/ci/variables/[ドキュメント] を参照) を利用できるようになっています。なお、Quarkus ではこのように利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:config.adoc#combine-property-env-var[this] for more information on how to combine properties with environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>環境変数とプロパティーを組み合わせる方法については link:config.adoc#combine-property-env-var[こちら] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-jib` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-jib` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-docker` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-docker` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I  Options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>S2I オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-s2i` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-s2i` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>価格リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Final touch, the HTML page reading the converted prices using SSE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、SSE を使って変換された価格を読み込む HTML ページです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/prices.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザーで `http://localhost:8080/prices.html` を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下ででネイティブ実行ファイルをビルドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - SmallRye Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - SmallRye Fault Tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the challenges brought by the distributed nature of microservices is that communication with external systems is inherently unreliable. This increases demand on resiliency of applications. To simplify making more resilient applications, Quarkus provides https://github.com/smallrye/smallrye-fault-tolerance/[SmallRye Fault Tolerance] an implementation of the https://github.com/eclipse/microprofile-fault-tolerance/[MicroProfile Fault Tolerance] specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイクロサービスの分散した性質がもたらす課題の1つは、外部システムとの通信が本質的に信頼できないことです。これにより、アプリケーションの耐障害性に対する要求が高まります。耐障害性の高いアプリケーションを簡単に作るために、Quarkusは link:https://github.com/eclipse/microprofile-fault-tolerance/[MicroProfile Fault Tolerance]仕様の実装である link:https://github.com/smallrye/smallrye-fault-tolerance/[SmallRye Fault Tolerance]を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we demonstrate usage of MicroProfile Fault Tolerance annotations such as `@Timeout`, `@Fallback`, `@Retry` and `@CircuitBreaker`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 `@Timeout` 、 `@Fallback` 、 `@Retry` 、 `@CircuitBreaker` などの MicroProfile Fault Tolerance アノテーションの使用方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Scenario</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シナリオ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide simulates a simple backend for a gourmet coffee e-shop. It implements a REST endpoint providing information about coffee samples we have on store.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで作成したアプリケーションは、グルメ・コーヒーのe-ショップのシンプルなバックエンドをシミュレートしています。このアプリケーションは、店舗で販売しているコーヒーのサンプルに関する情報を提供するRESTエンドポイントを実装しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine, although it's not implemented as such, that some of the methods in our endpoint require communication to external services like a database or an external microservice, which introduces a factor of unreliability.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのようには実装されていませんが、エンドポイントの一部のメソッドが、データベースや外部のマイクロサービスなどの外部サービスとの通信を必要とし、それによって信頼性の低い要素が導入されていることを想像してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `microprofile-fault-tolerance-quickstart` {quickstarts-tree-url}/microprofile-fault-tolerance-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `microprofile-fault-tolerance-quickstart` {quickstarts-tree-url}/microprofile-fault-tolerance-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure, importing the extensions for RESTEasy/JAX-RS and SmallRye Fault Tolerance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RSとSmallRye Fault ToleranceのエクステンションをインポートしたMaven構造を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-fault-tolerance` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-fault-tolerance` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preparing an Application: REST Endpoint and CDI Bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの準備: RESTエンドポイントとCDI Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section we create a skeleton of our application, so that we have something that we can extend and to which we can add fault tolerance features later on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、アプリケーションのスケルトン (骨組) を作成します。これにより、後から拡張したり、フォールトトレランス機能を追加したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a simple entity representing a coffee sample in our store:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、お店のコーヒーサンプルを表すシンプルなエンティティを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's continue with a simple CDI bean, that would work as a repository of our coffee samples.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>続いて、コーヒーのサンプルのrepositoryとして動作するシンプルなCDIビーンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, edit the `org.acme.microprofile.faulttolerance.CoffeeResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、 `org.acme.microprofile.faulttolerance.CoffeeResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, we expose a single REST method that will show a list of coffee samples in a JSON format. Note that we introduced some fault making code in our `CoffeeResource#maybeFail()` method, which is going to cause failures in the `CoffeeResource#coffees()` endpoint method in about 50 % of requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この時点で、コーヒーのサンプルのリストをJSON形式で表示するRESTメソッドを1つ公開しています。なお、 `CoffeeResource#maybeFail()` メソッドに障害を起こすコードを導入したため、約50%のリクエストで `CoffeeResource#coffees()` エンドポイント・メソッドに障害が発生することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why not check that our application works? Run the Quarkus development server with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが動作することを確認してみましょう。次のようにQuarkusの開発サーバーを起動してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and open `http://localhost:8080/coffee` in your browser. Make couple of requests (remember, some of them we expect to fail). At least some of the requests should show us the list of our coffee samples in JSON, the rest will fail with a `RuntimeException` thrown in `CoffeeResource#maybeFail()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/coffee`をブラウザで開きます。いくつかのリクエストを行います（いくつかのリクエストは失敗することを想定しています）。少なくともいくつかのリクエストは、コーヒーサンプルのリストをJSONで表示してくれるはずです。残りのリクエストは、 `RuntimeException` thrown in `CoffeeResource#maybeFail()` で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations, you've just made a working (although somewhat unreliable) Quarkus application!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おめでとうございます！（多少信頼性に欠けるものの）Quarkusアプリケーションが完成しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding Resiliency: Retries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジリエンスの追加: リトライ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let the Quarkus development server running and in your IDE add the `@Retry` annotation to the `CoffeeResource#coffees()` method as follows and save the file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus開発サーバーを起動し、IDEで `@Retry` アノテーションを `CoffeeResource#coffees()` メソッドに以下のように追加し、ファイルを保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit refresh in your browser. The Quarkus development server will automatically detect the changes and recompile the app for you, so there's no need to restart it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザの更新ボタンを押してください。Quarkus開発サーバーが自動的に変更を検出し、アプリを再コンパイルしますので、再起動する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can hit refresh couple more times. Practically all requests should now be succeeding. The `CoffeeResource#coffees()` method is still in fact failing in about 50 % of time, but every time it happens, the platform will automatically retry the call!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに何度か更新ボタンを押してみてください。実質的にすべてのリクエストが成功しているはずです。 `CoffeeResource#coffees()` メソッドは、実際にはまだ約50％の確率で失敗していますが、そのたびにプラットフォームは自動的に呼び出しを再試行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see that that the failures still happen, check the output of the development server. The log messages should be similar to these:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>障害がまだ発生していることを確認するには、開発サーバーの出力をチェックします。ログメッセージは以下のようになっているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see that every time an invocation fails, it's immediately followed by another invocation, until one succeeds.  Since we allowed 4 retries, it would require 5 invocations to fail in a row, in order for the user to be actually exposed to a failure. Which is fairly unlikely to happen.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>呼び出しが失敗するたびに、すぐに次の呼び出しが行われ、1つが成功するまで繰り返されることがわかります。4回の再試行を許可しているので、ユーザーが実際に失敗にさらされるためには、5回連続して失敗する必要があります。これはかなり起こりにくいことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding Resiliency: Timeouts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジリエンスの追加: タイムアウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So what else have we got in MicroProfile Fault Tolerance? Let's look into timeouts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、MicroProfile Fault Toleranceには他に何があるのでしょうか。タイムアウトについて見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add following two methods to our `CoffeeResource` endpoint. Again, no need to restart the server, just paste the code and save the file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CoffeeResource` のエンドポイントに以下の2つのメソッドを追加します。繰り返しになりますが、サーバーを再起動する必要はなく、コードを貼り付けてファイルを保存するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We added some new functionality. We want to be able to recommend some related coffees based on a coffee that a user is currently looking at. It's not a critical functionality, it's a nice-to-have. When the system is overloaded and the logic behind obtaining recommendations takes too long to execute, we would rather time out and render the UI without recommendations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの新しい機能を追加しました。ユーザーが現在見ているコーヒーに基づいて、関連するコーヒーをお勧めできるようにしたいのです。これは重要な機能ではなく、あれば望ましい機能です。システムに負荷がかかり、おすすめ情報を得るためのロジックの実行に時間がかかりすぎる場合は、むしろタイムアウトしておすすめ情報のないUIを表示したいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the timeout was configured to 250 ms, and a random artificial delay between 0 to 500 ms was introduced into the `CoffeeResource#recommendations()` method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なお、タイムアウトは250msに設定し、0～500msのランダムな人工的な遅延を `CoffeeResource#recommendations()` メソッドに導入しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your browser, go to `http://localhost:8080/coffee/2/recommendations` and hit refresh a couple of times.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お使いのブラウザで `http://localhost:8080/coffee/2/recommendations` にアクセスして、2、3回更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see some requests time out with `org.eclipse.microprofile.faulttolerance.exceptions.TimeoutException`.  Requests that do not time out should show two recommended coffee samples in JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.faulttolerance.exceptions.TimeoutException` でいくつかのリクエストがタイムアウトになるはずです。タイムアウトにならなかったリクエストでは、JSONに2つのおすすめコーヒーサンプルが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding Resiliency: Fallbacks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジリエンスの追加: フォールバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's make our recommendations feature even better by providing a fallback (and presumably faster) way of getting related coffees.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関連するコーヒーを入手するための代替手段（おそらくより迅速な方法）を提供することで、おすすめ機能をさらに改善しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a fallback method to `CoffeeResource` and a `@Fallback` annotation to `CoffeeResource#recommendations()` method as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CoffeeResource` にフォールバック・メソッドを、 `CoffeeResource#recommendations()` メソッドに `@Fallback` アノテーションを以下のように追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit refresh several times on `http://localhost:8080/coffee/2/recommendations`.  The `TimeoutException` should not appear anymore. Instead, in case of a timeout, the page will display a single recommendation that we hardcoded in our fallback method `fallbackRecommendations()`, rather than two recommendations returned by the original method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/coffee/2/recommendations` を何回も更新してください。 `TimeoutException` はもう表示されないはずです。代わりに、タイムアウトが発生した場合、元のメソッドが返す2つのレコメンデーションではなく、フォールバックメソッド `fallbackRecommendations()` にハードコードされた1つのレコメンデーションが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the server output to see that fallback is really happening:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールバックが本当に行われているかどうか、サーバーの出力を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fallback method is required to have the same parameters as the original method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールバックメソッドには、元のメソッドと同じパラメータが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding Resiliency: Circuit Breaker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジリエンスの追加: サーキットブレーカー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A circuit breaker is useful for limiting number of failures happening in the system, when part of the system becomes temporarily unstable. The circuit breaker records successful and failed invocations of a method, and when the ratio of failed invocations reaches the specified threshold, the circuit breaker _opens_ and blocks all further invocations of that method for a given time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーキットブレーカーは，システムの一部が一時的に不安定になったときに，システム内で発生する障害の数を制限するのに有効です。サーキットブレーカーは、あるメソッドの成功と失敗を記録し、失敗したメソッドの割合が指定された閾値に達すると、サーキットブレーカーが _開き_、それ以降のメソッドの呼び出しを一定時間ブロックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following code into the `CoffeeRepositoryService` bean, so that we can demonstrate a circuit breaker in action:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のコードを `CoffeeRepositoryService` ビーンに追加して、サーキットブレーカーの動作をデモできるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And inject the code below into the `CoffeeResource` endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、以下のコードを `CoffeeResource` のエンドポイントに注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We added another functionality - the application can return the amount of remaining packages of given coffee on our store (just a random number).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つの機能を追加しました。このアプリケーションは、私たちの店における、指定されたコーヒーの残りのパッケージの量を返すことができます（単なる乱数です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time an artificial failure was introduced in the CDI bean: the `CoffeeRepositoryService#getAvailability()` method is going to alternate between two successful and two failed invocations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回は、CDIビーンに人工的な失敗を導入しました。 `CoffeeRepositoryService#getAvailability()` メソッドは、2回の成功と2回の失敗の呼び出しを交互に行うことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also added a `@CircuitBreaker` annotation with `requestVolumeThreshold = 4`. `CircuitBreaker.failureRatio` is by default 0.5, and `CircuitBreaker.delay` is by default 5 seconds. That means that a circuit breaker will open when 2 of the last 4 invocations failed and it will stay open for 5 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `requestVolumeThreshold = 4` と一緒に `@CircuitBreaker` のアノテーションを追加しました。 `CircuitBreaker.failureRatio` はデフォルトで 0.5 秒、 `CircuitBreaker.delay` はデフォルトで 5 秒です。つまり、過去4回の起動のうち2回が失敗したときにサーキットブレーカーが開き、5秒間その状態が続くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test this out, do the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを試すには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go to `http://localhost:8080/coffee/2/availability` in your browser. You should see a number being returned.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `http://localhost:8080/coffee/2/availability` をブラウザで開いて下さい。数字が返ってくるのが見えるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit refresh, this second request should again be successful and return a number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレッシュすると、この2回目のリクエストが再び成功し、数字が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refresh two more times. Both times you should see text "RuntimeException: Service failed.", which is the exception thrown by `CoffeeRepositoryService#getAvailability()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに2回リフレッシュします。2回とも、"RuntimeException:Service failed." というテキストが表示されます。これは、 `CoffeeRepositoryService#getAvailability()` によってスローされる例外です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refresh a couple more times. Unless you waited too long, you should again see exception, but this time it's "CircuitBreakerOpenException: getAvailability". This exception indicates that the circuit breaker opened and the `CoffeeRepositoryService#getAvailability()` method is not being called anymore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに数回更新します。長く待ちすぎていなければ、再び例外が表示されるはずですが、今回は "CircuitBreakerOpenException: getAvailability" となっています。この例外は、サーキットブレーカーが開き、 `CoffeeRepositoryService#getAvailability()` メソッドが呼び出されなくなったことを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Give it 5 seconds during which circuit breaker should close and you should be able to make two successful requests again.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>5秒後にサーキットブレーカーが閉じて、再び2回のリクエストを成功させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the annotations parameters at runtime inside your `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` ファイルの中で、実行時にアノテーションパラメータをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we take the retry example that we already saw:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどのリトライの例で言えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can override the `maxRetries` parameter with 6 retries instead of 4 by the following configuration item:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の設定項目により、 `maxRetries` パラメータをオーバーライドして、リトライ回数を4回から6回に変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format is `fully-qualified-class-name/method-name/annotation-name/property-name=value`.  You can also configure a property for all the annotation via `annotation-name/property-name=value`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォーマットは `fully-qualified-class-name/method-name/annotation-name/property-name=value` です。また、 `annotation-name/property-name=value` を通じて、すべてのアノテーションに対するプロパティを設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Fault Tolerance allows to improve resiliency of your application, without having an impact on the complexity of our business logic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Fault Toleranceは、ビジネスロジックの複雑さに影響を与えることなく、アプリケーションの耐障害性を向上させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All that is needed to enable the fault tolerance features in Quarkus is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのフォールトトレランス機能を有効にするために必要なのは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>adding the `smallrye-fault-tolerance` Quarkus extension to your project using the `quarkus-maven-plugin`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-maven-plugin` で `smallrye-fault-tolerance` Quarkus エクステンションをプロジェクトに追加することです :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or simply adding the following Maven dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、以下のMavenの依存関係を単純に追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before anything can be done you must first install a JVMCI build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何かをする前に、まずJVMCIビルドをインストールしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be downloaded from OTN http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[here]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらは link:http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[ここ]でOTNからダウンロードすることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, if you are installing on an alternative system, you can use the developer tools on chrome or firefox to capture a direct URL with an auth param.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のシステムにインストールする場合は、ChromeやFirefoxの開発者ツールを使用して、auth パラメーターを指定して直接 URL をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After obtaining the download install it and set `JAVA_HOME`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ダウンロードした後、インストールして `JAVA_HOME` をセットします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the latest version available as graal tends to keep updating the minimum requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>graalは最小要件を更新し続ける傾向があるので、最新版を入手しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to install Graal’s special build tool, `mx`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今、あなたはGraalの特別なビルドツール `mx` をインストールする必要があります、.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now check-out and build Substrate:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでSubstrateのチェックアウトとビルドができるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once built, you can quickly run the tools in place</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一度構築したら、その場でツールを素早く実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a custom GraalVM distribution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムGraalVMディストリビューションの構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to create a custom GraalVM distribution (necessary for usage in quarkus) you must switch to the vm subdirectory, and use special build options to pick the modules in your distribution.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムGraalVMディストリビューションを作成するためには、(quarkusで使用するために必要な)vmサブディレクトリーに切り替えて、特別なビルドオプションを使用して、ディストリビューションのモジュールを選択する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a simple subset VM with just substrate and its native tools execute the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>substrate とそのネイティブツールだけのシンプルなサブセット VM の場合は、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a stock CE build the following will do:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>純正CEビルドの場合は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `config-quickstart` {quickstarts-tree-url}/config-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.config.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.config.GreetingResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkus application uses the https://github.com/smallrye/smallrye-config[SmallRye Config] API to provide all mechanisms related with configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションは link:https://github.com/smallrye/smallrye-config[SmallRye Config] APIを使用して、設定に関連するすべてのメカニズムを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.config.GreetingResource`, and introduce the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.config.GreetingResource` を編集し、以下の設定プロパティーを導入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, modify the `hello` method to use the injected properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `hello` メソッドを修正して、注入されたプロパティーを使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once set, check the application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定したら、アプリケーションを使って確認します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/config/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/config/GreetingResourceTest.java` ファイルを編集し、 `testHelloEndpoint` メソッドの内容を変更します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.  You can add the `greeting.suffix`, remove the other properties, change the values, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定ファイルの変更はすぐに反映されます。 `greeting.suffix` の追加、他のプロパティーの削除、値の変更などが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically access the configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定にプログラムでアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをネイティブ実行ファイルにコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのコンテナーへのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは、 link:getting-started[入門ガイド] で開発されたアプリケーションを入力としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブな実行可能ファイルをビルドするには、GraalVM のディストリビューションを使用する必要があります。ディストリビューションは3つあります。Oracle GraalVM Community Edition (CE)、Oracle GraalVM Enterprise Edition (EE)、そして Mandrel です。Oracle ディストリビューションと Mandrel ディストリビューションの違いは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrelは、Oracle GraalVM CEのダウンストリームディストリビューションです。Mandrelの主な目的は、Quarkusをサポートするために特別に設計されたネイティブ実行可能ファイルを構築する方法を提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrel のリリースは、アップストリームのOracle GraalVM CEコードベースから派生したコードベースから構築されており、わずかな変更しか行われていませんが、Quarkusネイティブアプリには必要ない重要な除外事項がいくつかあります。これらのリリースは、Oracle GraalVM CEと同じ機能をサポートしており、機能に大きな変更はありません。特筆すべきは、多言語プログラミングのサポートが含まれていないことです。これらの除外の理由は、大多数のQuarkusユーザーにより良いレベルのサポートを提供するためです。また、これらの除外は、Oracle GraalVM CE/EEと比較して、Mandrelの配布サイズが大幅に縮小されていることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrelは、標準のOpenJDKプロジェクトを使用して、Oracle GraalVM CEとは少し違った形で構築されています。これは、Oracleが独自のGraalVMダウンロードを構築するために使用するOpenJDKのバージョンに追加したいくつかの小さなエクステンションから利益を得られないことを意味します。アップストリームのOpenJDKはそれらを管理しておらず、保証することができないため、このような機能強化は省略されています。これは、規格適合性とセキュリティーに関しては特に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrelは現在のところ、Linuxのコンテナー化された環境をターゲットとしたネイティブ実行ファイルの構築にのみ推奨されています。つまり、Mandrelユーザーはコンテナーを使用してネイティブ実行ファイルを構築する必要があります。もしmacOSやWindowsをターゲットにしたプラットフォーム用のネイティブ実行ファイルをビルドする場合、Mandrelは現在これらのプラットフォームをターゲットにしていないため、代わりにOracle GraalVMを使用することを検討すべきです。ベアメタルのLinux上で直接ネイティブ実行ファイルをビルドすることも可能です。詳細は https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README]と https://github.com/graalvm/mandrel/releases[Mandrelのリリース]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前提条件は、Oracle GraalVM CE/EEを使用しているか、Mandrelを使用しているかによって若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11 バージョンのGraalVMをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle GraalVM はJava 8とJava 11の両方に対して存在しますが (Mandrel はJava 11のみをサポート)、Quarkus Java 11でのみ動作します。Oracleのディストリビューションを使用する場合は、Java 11をインストールするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>動作するコンテナーランタイム(Docker, podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:getting-started[入門ガイド]で開発したアプリケーションのコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この &lt;&lt;#container-runtime, セクション&gt;&gt;をスキップして、 Mandrel のガイドを続行し、そのセクションの Mandrel 固有の指示に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A xref:configuring-c-development[working C development environment]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>xref:configuring-c-development[動作するC言語の開発環境]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM のバージョン {graalvm-version} (必ずJava 11 のサポートをインストールしてください)がインストールされ、 #configuring-graalvm[適切に設定されていること]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>動作するC言語の開発環境があるとはどういう意味でしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Linuxでは、GCC、glibc、zlibヘッダが必要です。一般的なディストリビューションでは次の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>macOS では、XCode が必要な依存関係を提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Windowsの場合は、 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools] をインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMをインストールできない場合は、マルチステージのDockerビルドを使用して、GraalVMを含むDockerコンテナー内でMavenを実行することができます。このガイドの最後にこれを行う方法の説明があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Version {graalvm-version} が必要です。コミュニティエディションで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだの場合は、GraalVM(のJava 11バージョン)をインストールしてください。いくつかポイントがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラットフォーム固有の方法を用いてください: https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>適切なコミュニティエディションのアーカイブを &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; からダウンロードし、他のJDK同様に解凍して下さい。Java 11バージョンをダウンロードしてインストールするようにして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイム環境を構成します。 `GRAALVM_HOME` 環境変数をGraalVMインストールディレクトリーに設定します。例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>macOSでは、変数を `Home`  サブディレクトリーに指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Windowsでは、コントロールパネルから環境変数を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>scoop でインストールすれば自動的に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`gu install`  を使用して `native-image`  ツールをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMの以前のリリースでは、デフォルトで `native-image`  ツールが含まれていました。現在はそのようになっておらず、GraalVM自体をインストールした後の第二ステップとしてインストールする必要があります。注意: #graal-and-catalina[macOS CatalinaでGraalVMを使用する]際に、未解決の問題が発生しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(オプション) 環境変数 `JAVA_HOME`  を GraalVM のインストールディレクトリーに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(オプション) GraalVM `bin`  ディレクトリーをパスに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>macOS CatalinaでGraalVMを使用している場合の問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この https://github.com/oracle/graal/issues/1724[GraalVMの問題]で報告されているように、GraalVMバイナリーは(まだ)macOS Catalinaに対して認証されていません。これは、`gu` 使用時に次のエラーが表示される可能性があることを意味します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>回避策として、次のコマンドを使用して、GraalVMインストールディレクトリー上の `com.apple.quarantine` 拡張属性を再帰的に削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のセクションの手順に従って、アプリケーションを段階的にパッケージ化することをお勧めします。しかしながら、完成したサンプルに直接進むこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `getting-started` ディレクトリーに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのネイティブ実行ファイルには、アプリケーション・コード、必要なライブラリ、Java API、および VM の縮小版が含まれます。VM ベースが小さくなることで、アプリケーションの起動時間が改善され、ディスクフットプリントが最小限に抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:native-executable-process.png[ネイティブ実行ファイルの生成]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前回のチュートリアルでアプリケーションを生成した場合は、 `pom.xml` に以下の _プロファイル_ があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;quarkus.native.additional-build-args&gt;` プロパティーを使用して、 `native-image` コマンドにカスタムオプションを指定できます。複数のオプションはカンマで区切ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つの可能性は、 `application.properties` に `quarkus.native.additional-build-args` 設定プロパティーを含めることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージビルド処理の設定方法については、以下の &lt;&lt;設定リファレンス&gt;&gt; の項で詳しく説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロファイルを使用しているのは、すぐにわかると思いますが、ネイティブの実行ファイルをパッケージ化するのに _数_ 分かかるからです。コマンドラインのプロパティーとして -Dquarkus.package.type=native を渡すだけでもいいのですが、プロファイルを使う方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw package -Pnative`  を使用してネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Visual Studio の Microsoft Native Tools はパッケージングを行う前に、初期化する必要があります。これは、Visual Studio ビルドツールと一緒にインストールされた `x64 Native Tools Command Prompt`  を起動することで行うことができます。 `x64 Native Tools Command Prompt` で、プロジェクト・フォルダーに移動して `mvnw package -Pnative` を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つのソリューションは、これを行うためのスクリプトを書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常のファイルに加えて、このビルドでは `target/getting-started-1.0-SNAPSHOT-runner` を生成します。これを実行するには、次のようにします: `./target/getting-started-1.0-SNAPSHOT-runner` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブな実行ファイルを生成することはいくつかの問題を引き起こす可能性があるので、ネイティブファイルで実行されているアプリケーションに対していくつかのテストを実行するのも良いアイデアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml`  ファイルには、 `native`  プロファイルが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、failsaf-maven-plugin が integration-test を実行するように指示し、生成されたネイティブ実行ファイルの場所を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`  を開きます。次の内容が含まれています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストの前にネイティブ ファイルからアプリケーションを起動する別のテスト ランナーを使用します。実行ファイルは、 _Failsafe Maven プラグイン_ で構成された `native.image.path`  システム プロパティーを使用して取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のテストを extend していますが、自分でテストを実装することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`NativeGreetingResourceIT`  がネイティブ実行ファイルに対して実行されているのを見るには、 `./mvnw verify -Pnative` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusはネイティブテストを開始し、自動的に失敗するまでに60秒待機します。この時間は、 `quarkus.test.native-image-wait-time`  システムプロパティーを使用して変更できます。たとえば、待機時間を300秒に増やすには、 `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the future, `@NativeImageTest` will be deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the link:getting-started-testing#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将来的には、 `@NativeImageTest` は廃止され、 `@NativeImageTest` のテスト機能のスーパーセットを提供する `@QuarkusIntegrationTest` が採用される予定です。 `@QuarkusIntegrationTest` の詳細については、 link:getting-started-testing#quarkus-integration-test[テストガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、ネイティブテストは `prod`  プロファイルを使用して実行されます。これは `quarkus.test.native-image-profile`  プロパティーを使用して上書きすることができます。たとえば、 `application.properties`  ファイルに `quarkus.test.native-image-profile=test`  を追加します。あるいは、次のようにしてテストを実行することもできます: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` .ただし、ネイティブの実行ファイルがビルドされたときに `prod`  プロファイルが有効になっていることを忘れないでください。したがって、この方法で有効にしたプロファイルは、生成された実行ファイルと互換性がなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルとして実行している場合のテストの除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この方法でテストを実行する場合、実際にネイティブで実行されるのはアプリケーションのエンドポイントのみで、HTTP 呼び出しでしかテストできません。テストコードは実際にはネイティブには実行されないので、HTTP エンドポイントを呼び出さないコードをテストしている場合は、ネイティブテストの一部として実行するのは良い考えではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のようにJVMとネイティブ実行でテストクラスを共有している場合、特定のテストをJVM上でのみ実行するために、 `@DisabledOnNativeImage`  アノテーションを付けておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにビルドされているネイティブ実行ファイルに対してテストを再実行することも可能です。これを行うには `./mvnw test-compile failsafe:integration-test`  を実行してください。これにより、既存のネイティブイメージが検出され、フェイルセーフを使用してそれに対してテストが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何らかの理由でプロセスがネイティブイメージを見つけられない場合や、ターゲットディレクトリーにないネイティブイメージをテストしたい場合は、 `-Dnative.image.path=`  システムプロパティーで実行ファイルを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先に進む前に、コンテナーランタイム(Docker、podman)の動作環境が整っていることを確認しておきましょう。WindowsでDockerを使用している場合は、Docker Desktopのファイル共有設定でプロジェクトのドライブを共有し、Docker Desktopを再起動する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くの場合、Quarkusアプリケーション用のネイティブLinux実行ファイルを作成する必要があります(例えば、コンテナー化された環境で実行するためなど)、このタスクを達成するために適切なGraalVMバージョンをインストールする手間を省きたいと考えています(例えば、CI環境では、できるだけ少ないソフトウェアをインストールするのが一般的です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このため、Quarkusでは、Dockerやpodmanなどのコンテナーランタイムを利用して、ネイティブのLinux実行ファイルを作成する非常に便利な方法を提供しています。このタスクを達成する最も簡単な方法は、次を実行することです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusはコンテナーランタイムを自動的に検出します。コンテナーランタイムを明示的に選択したい場合は、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらは通常のQuarkusの設定プロパティーなので、常にコンテナーでビルドしたい場合は、毎回指定しなくて済むように、 `application.properties`  に追加することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you see the following invalid path error for your application JAR when trying to create a native executable using a container build, even though your JAR was built successfully, you're most likely using a remote daemon for your container runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JARが正常にビルドされているにもかかわらず、コンテナビルドでネイティブ実行ファイルを作成しようとすると、アプリケーションJARに対して以下のようなinvalid pathエラーが表示される場合は、コンテナランタイムにリモートデーモンを使用している可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error: Invalid Path entry getting-started-1.0.0-SNAPSHOT-runner.jar
Caused by: java.nio.file.NoSuchFileException: /project/getting-started-1.0.0-SNAPSHOT-runner.jar
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Error: Invalid Path entry getting-started-1.0.0-SNAPSHOT-runner.jar
Caused by: java.nio.file.NoSuchFileException: /project/getting-started-1.0.0-SNAPSHOT-runner.jar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, use the parameter `-Dquarkus.native.remote-container-build=true` instead of `-Dquarkus.native.container-build=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、パラメータ `-Dquarkus.native.container-build=true` の代わりに `-Dquarkus.native.remote-container-build=true` を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason for this is that the local build driver invoked through `-Dquarkus.native.container-build=true` uses volume mounts to make the JAR available in the build container, but volume mounts do not work with remote daemons. The remote container build driver copies the necessary files instead of mounting them. Note that even though the remote driver also works with local daemons, the local driver should be preferred in the local case because mounting is usually more performant than copying.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その理由は、 `-Dquarkus.native.container-build=true` を通して起動されるローカルビルドドライバは、ビルドコンテナで JAR を利用できるようにするためにボリュームマウントを使用しますが、ボリュームマウントはリモートデーモンでは機能しません。リモートコンテナのビルドドライバは、必要なファイルをマウントするのではなく、コピーします。リモートドライバはローカルデーモンでも動作しますが、ローカルの場合はローカルドライバを使用した方が良いことに注意してください。なぜなら、マウントの方がコピーよりもパフォーマンスが高いからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のコマンドはフローティングタグを指していることに注意してください。ビルダーイメージを最新かつ安全に保つために、フローティングタグを使用することを強く推奨します。どうしても必要な場合は、特定のタグをハードコーディングしても構いませんが(利用可能なタグについては https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[こちら]を参照してください)、その方法ではセキュリティーアップデートが受けられず、サポートされていないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージのエクステンションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションからコンテナーイメージを作成する最も簡単な方法は、コンテナーイメージ エクステンションの1つを利用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのエクステンションのいずれかが存在する場合、ネイティブ実行ファイル用のコンテナーイメージを作成することは、基本的には単一のコマンドを実行することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.native.container-build=true`  では GraalVM がインストールされていなくても Linux の実行ファイルを作成することができます(ローカルに GraalVM がインストールされていない場合や、ローカルのオペレーティングシステムが Linux ではない場合にのみ必要です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.container-image.build=true`  最終的なアプリケーションアーティファクト(この場合はネイティブの実行ファイル)を使用してコンテナーイメージを作成するようにQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:container-image[コンテナーイメージガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Mavenプラグインで生成されたJARを使用して、コンテナー内でアプリケーションを実行することができます。ただし、このセクションでは、生成されたネイティブ実行ファイルを使用してコンテナーイメージを作成することに焦点を当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:containerization-process.png[Containerization Process]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:containerization-process.png[alt="Containerization Process"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルのGraalVMインストール環境を使用する場合、ネイティブの実行ファイルは、ローカルのオペレーティングシステム(Linux、macOS、Windowsなど)をターゲットにしています。しかし、コンテナーはオペレーティングシステムによって生成されたものと同じ _実行_ 形式を使用しない場合があるため、コンテナーランタイムを活用して実行形式を生成するようにMavenビルドに指示します(この &lt;&lt;#container-runtime, セクション&gt;&gt; で説明されているように)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成される実行ファイルは64ビットのLinux実行ファイルになりますので、お使いのOSによっては実行できなくなる可能性があります。しかし、コンテナーにコピーするので問題ありません。プロジェクト生成では、 `src/main/docker`  ディレクトリーに `Dockerfile.native`  を用意し、以下のような内容にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ubi?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Ubi?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供されている `Dockerfiles`  は親イメージとして https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI](Universal Base Image) を使用しています。このベースイメージはコンテナー内で完全に動作するように調整されています。 `Dockerfiles`  では、生成されるイメージのサイズを小さくするためにベースイメージの https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_最小_バージョン]を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UBIについての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あとは、生成されたネイティブ実行ファイルを削除していなければ、dockerイメージを使ってビルドします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして最後に、以下を実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチステージDockerビルドの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MavenでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このファイルは、Getting started quickstartには含まれていないので、 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GradleでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトでGradleを使用している場合は、このサンプルDockerfileを使用することができます。 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルにSSLサポートが必要な場合は、Dockerイメージに必要なライブラリを簡単に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳しくは native-and-ssl#working-with-containers[ネイティブ実行可能ファイルでのSSL利用ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle GraalVM 20.2またはMandrel 20.1から、Linux環境用にネイティブ実行ファイルのデバッグシンボルを生成できるようになりました(Windowsのサポートはまだ開発中です)。これらのシンボルは、 `gdb`  のようなツールを使用してネイティブ実行ファイルをデバッグするために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デバッグシンボルを生成するには、ネイティブ実行ファイルの生成時に `-Dquarkus.native.debug.enabled=true`  フラグを追加してください。ネイティブ実行ファイルのデバッグシンボルは、ネイティブ実行ファイルの隣にある `.debug`  ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.debug`  ファイルの生成は `objcopy`  に依存します。一般的な Linux ディストリビューションや macOS では、 `binutils`  パッケージをインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`objcopy`  が利用できない場合、デバッグシンボルが実行ファイルに埋め込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デバッグシンボルとは別に、 `-Dquarkus.native.debug.enabled=true`  フラグを設定すると、ネイティブ実行ファイル生成時に解決された JDK ランタイムクラス、GraalVM クラス、アプリケーションクラスのソースファイルのキャッシュが生成されます。このソースキャッシュは、シンボルと一致するソースコード間のリンクを確立するために、ネイティブデバッグツールにとって有用です。ネイティブ実行ファイルをデバッグする際に、必要なソースだけをデバッガー/IDEが利用できるようにする便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのソースコードを含むサードパーティのjar依存関係のソースは、デフォルトではソースキャッシュに追加されません。これらを含めるには、まず `mvn dependency:sources`  を起動してください。このステップは、これらの依存関係のソースを引き出し、ソースキャッシュに含めるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースキャッシュは `target/sources`  フォルダーにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`gdb`  を `target`  とは異なるディレクトリーから実行している場合、ソースは以下を</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `gdb`  プロンプトで実行することで読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、 `gdb`  を以下のように起動してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルの生成方法に影響を与える設定オプションがたくさんあります。これらは他の設定プロパティーと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、アプリケーション用のネイティブ(バイナリー)実行ファイルの作成について説明しました。これにより、迅速な起動時間と少ないメモリー消費を示すアプリケーションを提供します。しかし、それだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:deploying-to-kubernetes[KubernetesとOpenShiftへのデプロイ]で探検を続けることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://picocli.info/[Picocliは] 、リッチなコマンドラインアプリケーションを作成するためのオープンソースツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、Picocli を使用するためのサポートを提供しています。このガイドには、 `picocli` エクステンションの使用例が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus のコマンドモードに詳しくない場合は、まず link:command-mode-reference[コマンドモードのリファレンスガイド] を読むことを検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `picocli` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus プロジェクトを設定すると、プロジェクトのベースディレクトリーで次のコマンドを実行することで、 `picocli` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple command line application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple PicocliApplication with only one `Command` can be created as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Command` を 1 つだけ使ったシンプルな PicocliApplication は、以下のように作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスが 1 つだけある場合、これは Picocli CommandLine のエントリーポイントとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスはすべて CDI Bean として登録されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans with `@CommandLine.Command` should not use proxied scopes (e.g. do not use `@ApplicationScope`)  because Picocli will not be able set field values in such beans. This extension will register classes with `@CommandLine.Command` annotation using `@Depended` scope. If you need to use proxied scope, then annotate setter and not field, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CommandLine.Command` を持つ Bean では、プロキシーされるスコープを使用してはいけません (例: `@ApplicationScope` は使用しないでください)。Picocli はそのような Bean でフィールド値を設定できないためです。このエクステンションは `@CommandLine.Command` アノテーションを持つクラスを `@Depended` スコープを使って登録します。プロキシーされるスコープを使用する必要がある場合は、フィールドではなくセッターを次の例のようにアノテーションしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line application with multiple Commands</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のコマンドを使用したコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.  This can be overwritten with the `quarkus.picocli.top-command` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のクラスが `picocli.CommandLine.Command` アノテーションを持つ場合、そのうちの 1 つに `io.quarkus.picocli.runtime.annotations.TopCommand` アノテーションを付ける必要があります。これは `quarkus.picocli.top-command` プロパティーで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>独自の Bean インスタンスを生成することで、 `picocli` エクステンションで使用される CommandLine クラスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PicocliCommandLineFactory` は、 `TopCommand` と `CommandLine.IFactory` を注入した CommandLine のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different entry command for each profile</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロファイルごとに異なるエントリーコマンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create different entry command for each profile, using `@IfBuildProfile`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@IfBuildProfile` を使用して、プロファイルごとに異なるエントリーコマンドを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return instance of `java.lang.Class` here. In such case `CommandLine` will try to instantiate this class using `CommandLine.IFactory`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは `java.lang.Class` のインスタンスを返すことができます。この場合、 `CommandLine` は `CommandLine.IFactory` を使ってこのクラスのインスタンスを作成しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure CDI Beans with parsed arguments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解析された引数での CDI Beans の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Event&lt;CommandLine.ParseResult&gt;` or just `CommandLine.ParseResult` to configure CDI beans based on arguments parsed by Picocli.  This event will be generated in `QuarkusApplication` class created by this extension. If you are providing your own `@QuarkusMain` this event will not be raised.  `CommandLine.ParseResult` is created from default `CommandLine` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Picocli によって解析された引数に基づいて CDI Bean を設定するために、 `Event&lt;CommandLine.ParseResult&gt;` 、または単に `CommandLine.ParseResult` を使用することができます。このイベントは、このエクステンションによって作成された `QuarkusApplication` クラスで生成されます。独自の `@QuarkusMain` を提供している場合、このイベントは発生しません。 `CommandLine.ParseResult` はデフォルトの `CommandLine` Bean から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing own QuarkusMain</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>独自の QuarkusMain の提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide your own application entry point annotated with `QuarkusMain` (as described in link:command-mode-reference[Command Mode reference guide]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `QuarkusMain` でアノテーションされた独自のアプリケーションのエントリーポイントを提供することもできます (link:command-mode-reference[コマンドモードのリファレンスガイド] に記載されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus-compatible `CommandLine.IFactory` bean created by `picocli` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`picocli` のエクステンションで作成された Quarkus 互換の `CommandLine.IFactory` Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native mode support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension uses the Quarkus standard build steps mechanism to support GraalVM Native images. In the exceptional case that incompatible changes in a future picocli release cause any issue, the following configuration can be used to fall back to the annotation processor from the picocli project as a temporary workaround:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションでは、Quarkus 標準のビルドステップメカニズムを使用して、GraalVM Nativeイメージをサポートしています。将来のpicocliリリースで互換性のない変更が問題を引き起こす例外的なケースでは、一時的な回避策として、以下の設定を使用してpicocliプロジェクトのアノテーションプロセッサーにフォールバックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle, you need to add the following in `dependencies` section of the `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle の場合は、 `build.gradle` ファイルの `dependencies` セクションに以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once created, run `docker-compose up`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作成したら、`docker-compose up` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a development cluster, do not use in production.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは開発クラスターであり、本番では使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price generator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>価格ジェネレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.time.Duration;
import java.util.Random;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import java.time.Duration;
import java.util.Random;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private Random random = new Random();
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    private Random random = new Random();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Outgoing("generated-price")                        // &lt;1&gt;
    public Multi&lt;Integer&gt; generate() {                  // &lt;2&gt;
        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))
                .onOverflow().drop()
                .map(tick -&gt; random.nextInt(100));
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Outgoing("generated-price")                        // &lt;1&gt;
    public Multi&lt;Integer&gt; generate() {                  // &lt;2&gt;
        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))
                .onOverflow().drop()
                .map(tick -&gt; random.nextInt(100));
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、5 秒ごとにランダムな _価格_ を生成する Mutiny _ストリーム_ (`Multi`) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price converter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>価格 (price) コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private static final double CONVERSION_RATE = 0.88;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    private static final double CONVERSION_RATE = 0.88;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the item are dispatched to all _subscribers_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アイテムがすべての _サブスクライバー_ に発送されていることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Channel;
import org.reactivestreams.Publisher;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.smallrye.reactive.messaging.annotations.Channel;
import org.reactivestreams.Publisher;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injects the `my-data-stream` channel using the `@Channel` qualifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the content is sent using `Server Sent Events`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Server Sent Events` を使用してコンテンツが送信されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the stream (_Reactive Stream_)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ストリーム (_Reactive Stream_) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`channel-name` セグメントは、 `@Incoming` および `@Outgoing` アノテーションで設定された値と一致する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`generated-price` -&gt; sink in which we write the prices</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`generated-price` -&gt; sink (価格の書き込み先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`prices` -&gt; source in which we read the prices</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`prices` -&gt; source (価格の読み取り先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about `my-data-stream`? This is an in-memory stream, not connected to a message broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`my-data-stream` はどうでしょうか? これはインメモリストリームであり、メッセージブローカーには接続されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;h2&gt;Last price&lt;/h2&gt;
    &lt;div class="row"&gt;
    &lt;p class="col-md-12"&gt;The last price is &lt;strong&gt;&lt;span id="content"&gt;N/A&lt;/span&gt;&amp;nbsp;&amp;euro;&lt;/strong&gt;.&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var source = new EventSource("/prices/stream");
    source.onmessage = function (event) {
        document.getElementById("content").innerHTML = event.data;
    };
&lt;/script&gt;
&lt;/html&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    &lt;h2&gt;Last price&lt;/h2&gt;
    &lt;div class="row"&gt;
    &lt;p class="col-md-12"&gt;The last price is &lt;strong&gt;&lt;span id="content"&gt;N/A&lt;/span&gt;&amp;nbsp;&amp;euro;&lt;/strong&gt;.&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var source = new EventSource("/prices/stream");
    source.onmessage = function (event) {
        document.getElementById("content").innerHTML = event.data;
    };
&lt;/script&gt;
&lt;/html&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here. On each received price, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特に目を見張るようなものは何もありません。受信した価格ごとに、ページが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative usage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令的な使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you can use an `Emitter`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合には `Emitter` が利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非推奨</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.annotations.Emitter`、`io.smallrye.reactive.messaging.annotations.Channel`、`io.smallrye.reactive.messaging.annotations.OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると、`CompletionStage` の完了を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに詳しく知りたい場合は、Quarkusで使用されている実装である link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] のドキュメントを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusを使用してリアクティブアプリケーションを作成する方法と、Quarkusが提供するさまざまなリアクティブ機能について説明します。このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick glance at the Quarkus engine and how it enables reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエンジンの概要と、それがどのようにリアクティブを可能にしているかを簡単に説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな JAX-RS エンドポイントの作成（非同期、ストリーム...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータベースアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のリアクティブAPIの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solutions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;bootstrapping-the-project,プロジェクトのブートストラップ&gt;&gt;とそれ以降の解説に従って、ステップバイステップでアプリを作成していくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかしながら、完成した例をすぐ確認することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-archive-url}[アーカイブ] をダウンロードするか、gitレポジトリをクローンします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `getting-started-reactive` と `getting-started-reactive-crud` のディレクトリにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusはリアクティブです。ボンネットの下を見ると、Quarkusアプリケーションの動力源となっているリアクティブエンジンを見つけることができます。このエンジンはEclipse Vert.x（ https://vertx.io ）です。すべてのネットワークI/Oは、ノンブロッキングでリアクティブなVert.xエンジンを通過します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:quarkus-reactive-stack.png[alt="Quarkusはリアクティブなエンジンをベースとしている", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つの例を挙げて、その仕組みを説明してみましょう。入ってくるHTTPリクエストを想像してみてください。Quarkusに組み込まれたHTTPサーバー（Vert.x）がリクエストを受信し、アプリケーションにルーティングします。リクエストが _命令的な_ メソッド（従来のJAX-RS、 `@Blocking` ...で注釈されたコード）をターゲットにしている場合、ルーティング層は _ワーカースレッド_ でリソースメソッドを呼び出し、データが利用可能になるとレスポンスを書き込みます。今のところ、目新しいものも目立ったものもありません。次の図は、この動作を示しています。この場合、アプリケーションコードはワーカースレッドで呼び出され、ビジネスロジックはそのスレッドをブロックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:http-blocking-sequence.png[alt="命令的な route を使ったときの挙動", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、HTTPリクエストがリアクティブなメソッド（RESTEasy Reactiveを使用したJAX-RS、リアクティブなルート、 `@Incoming` メソッドは `@Blocking` ...でアノテーションされていない）をターゲットにしている場合、ルーティング層はI/Oスレッド上でルートを呼び出し、より高い同時実行性とパフォーマンスなどの多くの利点を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:http-reactive-sequence.png[alt="リアクティブな route を使ったときの挙動", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはI/Oスレッドを使用してコードを呼び出すため、コンテキストスイッチを節約し、大規模なスレッドプール管理を回避し、リソースの利用率を向上させます。ただし、コードはそのスレッドをブロックしてはいけ *ませ* ん。なぜでしょうか？なぜなら、I/O スレッドは複数の同時リクエストを処理するために使用されます。リクエストの処理がいくつかのI/Oを実行する必要があるために進行できなくなるとすぐに、これらのI/Oをスケジュールし、継続(continuation)を渡します。別のリクエストを処理できるスレッドを解放します。スケジュールされたI/Oが完了すると、I/Oスレッドに戻って継続(continuation)が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>結果として、多くのQuarkusコンポーネントは、データベースアクセス（PostgreSQL、MySQL、Mongoなど）、アプリケーションサービス（メール、テンプレートエンジンなど）、メッセージング（Kafka、AMQPなど）など、リアクティブを念頭に置いて設計されています。しかし、このモデルの恩恵を十分に受けるためには、アプリケーションコードはノンブロッキングで書かれなければなりません。そこで、リアクティブ API を持つことが究極の武器となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/smallrye/smallrye-mutiny[Mutiny] は、非同期アクションを表現したり構成したりすることができるリアクティブプログラミングライブラリです。2つのタイプがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.mutiny.Multi` - マルチアイテム（バックプレッシャー付き）ストリーム用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらのタイプも lazy で、サブスクリプションパターンに従います。計算は、実際に必要とされる場合にのみ開始されます (すなわち、サブスクライバがエンリストした場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni` も `Multi` もイベント駆動型の API を公開しています: 与えられたイベント (成功、失敗など) に対して何をしたいかを表現します。これらのAPIはグループ(操作の種類)に分けられており、より表現力を高め、1つのクラスに100個ものメソッドをアタッチすることを避けています。主な操作の種類は、失敗に反応するもの、完了するもの、アイテムを操作するもの、抽出するもの、収集するものなどです。ナビゲーション可能なAPIでスムーズなコーディングを実現し、結果的にリアクティブ周りの知識をあまり必要としないようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.reactive-streams.org/ `Multi` は Reactive Streams `Publisher` を実装しているので、Reactive Streams のバックプレッシャーメカニズムを実装しています。 `Uni` へのサブスクリプションは結果に興味があることを示すのに十分なので、 `Uni` は `Publisher` を実装していません。これは、Reactive Streams のサブスクリプション/リクエスト式がより複雑であるため、よりシンプルでスムーズな API のアイデアを念頭に置いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのリアクティブな面と命令的な面の統合を受け入れた `Uni` と `Multi` は、両方とも命令的構造への橋渡しをしてくれます。たとえば、 `Multi` を `Iterable` に変換したり、 `Uni` .NET で生成されたアイテムを _待っ_ たりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この時点で、あなたがRxJavaやReactorのユーザーであれば、お馴染みの `Flowable` , `Single` , `Flux` , , `Mono` ... Mutinyでは、 `Unis` と `Multis` をRX JavaやReactorの型に変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、Vert.xはどうでしょうか？Vert.xのAPIはMutiny型を使っても利用できます。以下のスニペットは、Vert.x Web Clientの使い方を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with SmallRye Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後になりますが重要なこととして、MutinyにはMicroProfile Context Propagationとの統合が組み込まれているので、リアクティブパイプラインでトランザクションやトレーサビリティデータなどを伝搬することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But enough talking, let's get our hands dirty!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>話はもういい、手を汚すんだ！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでリアクティブアプリケーションを実装するには、いくつかの方法があります。このガイドでは、Quarkusのリアクティブエンジンの恩恵を受けるRESTEasyの実装であるRESTEasy Reactiveを使用します。デフォルトでは、I/Oスレッド上のHTTPエンドポイントを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_従来の_ RESTEasy を使用することは可能ですが、 `quarkus-resteasy-mutiny` エクステンションを追加する必要があり、メソッドは _ワーカースレッド_ 上で呼び出されます。つまり、リアクティブプログラミングを使用するとはいえ、ワーカースレッドを必要とし、その目的は達成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use forward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cmd を使用する場合は、(前方スラッシュを使用しないでください `\` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Powershell を使用する場合は、 `-D` のパラメータを二重引用符で囲みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started-reactive`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./getting-started-reactive` 内に以下が生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/hello` で公開されている `org.acme.quickstart.ReactiveGreetingResource` リソース </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/docker` にある `native` と `jvm` の両方のモード用の `Dockerfile` ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive JAX-RS resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな JAX-RS リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト作成時に、 `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` ファイルは以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello RESTEasy Reactive" to requests on "/hello".  As it uses RESTEAsy Reactive, this method is called on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは非常にシンプルなRESTエンドポイントで、"/hello"上のリクエストに対して"Hello RESTEasy Reactive"を返します。RESTEAsy Reactiveを使用しているので、このメソッドはI/Oスレッド上で呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_ワーカースレッド_ でこのメソッドを呼び出すようにQuarkusに指示するには、 `io.smallrye.common.annotation.Blocking` アノテーションを付けます。メソッドやクラスで `@Blocking` を使用したり、 `Application` クラスをアノテーションすることで、アプリケーション全体で を使用できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create a `ReactiveGreetingService` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、以下の内容の `ReactiveGreetingService` クラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, edit the `ReactiveGreetingResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 `ReactiveGreetingResource` クラスを以下の内容に合わせて編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingService` クラスには、 `Uni` を生成する簡単なメソッドが含まれています。この例では、結果として得られるアイテムがすぐに出力されますが、非同期 API で `Uni` を生成することは想像できます。これについては、このガイドで後ほど説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, start the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、以下でアプリケーションを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行したら、 http://localhost:8080/hello/greeting/neo を開いて、期待通りのグリーティングメッセージが表示されているか確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ストリームの取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、非同期の結果を返すだけでした。このセクションでは、複数のアイテムを伝えるストリームを使ってアプリケーションを拡張します。これらのストリームは Kafka や他のデータソースからのものでも構いませんが、物事をシンプルに保つために、定期的にグリーティングメッセージを生成するだけにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingService`, add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingService` で、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`import io.smallrye.mutiny.Multi;` と `import java.time.Duration;` のステートメントを追加する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a greeting message every second and stops after `count` messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1秒ごとに greeting メッセージを生成し、 `count` メッセージの後に停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingResource` add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReactiveGreetingResource` で、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエンドポイントは、アイテムをJSON配列としてクライアントにストリームします。メッセージの名前と数は、パスパラメータを使用してパラメータ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So calling the endpoint produces something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、エンドポイントを呼び出すと、次のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can also generate Server-Sent Event responses by returning a `Multi`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `Multi` を返すことで Server-Sent Event レスポンスを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどのスニペットとの違いは、生成される型と、各イベントの型を示す `@RestSseElementType` アノテーションだけです。 `@Produces` アノテーションは `SERVER_SENT_EVENTS` を定義しているので、JAX-RS は各（入れ子になった）イベントのコンテンツタイプを知るために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`import org.jboss.resteasy.reactive.RestSseElementType;` の文を追加する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the result using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下で結果を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ API の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはMutinyモデルを使用した多くのリアクティブAPIを提供しています。このセクションでは、リアクティブPostgreSQLドライバを使用して、ノンブロッキングでリアクティブな方法でデータベースと対話する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下で新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application is interacting with a PostgreSQL database, so you need one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションはPostgreSQLデータベースと対話しているので、DBが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>続いて、データソースを設定してみましょう。 `src/main/resources/application.properties` を開き、以下の内容を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初の3行はデータソースを定義しています。最後の行は、アプリケーションが初期化されたときにいくつかの項目を挿入するかどうかを示すためにアプリケーションで使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、 _エンティティを_ 作成しましょう。以下の内容で `org.acme.reactive.crud.Fruit` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この _エンティティに_ は、データベースから行を検索、更新、削除するためのいくつかのフィールドとメソッドが含まれています。これらのメソッドは、結果が取得されると非同期的に生成されるので、 `Unis` または `Multis` のいずれかを返します。反応型PostgreSQLクライアントは既に `Uni` と `Multi` のインスタンスを提供していることに注意してください。つまり、データベースからの結果を _ビジネスに適した_ オブジェクトに変換するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの起動時にデータベースを初期化する目的で、以下の内容の `DBInit` という名前のクラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、この `Fruit` クラスを `FruitResource` . `FruitResource` クラスを以下の内容に合わせて編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリソースは、 `Fruit` クラスが生成した結果に基づいて `Uni` と `Multi` のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどの例では、Quarkusが提供する _サービス_ を使用しています。また、Vert.xクライアントを直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、 `quarkus-vertx` の エクステンションが存在することを確認してください。存在しない場合は、以下のコマンドを実行して エクステンションを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or add `quarkus-vertx` into your dependencies manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、手動で `quarkus-vertx` を依存関係に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x APIのMutinyバージョンがあります。このAPIは独立してインポートできるいくつかのアーティファクトに分かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>groupId:artifactId</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>groupId:artifactId</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-core`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-core`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 http://smallrye.io/smallrye-reactive-utils/apidocs/ で利用可能な API を確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example.  Add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例を挙げてみましょう。以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x Web ClientのMutiny APIを提供します。すると、以下のようにWebクライアントを利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 important points:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要なポイントは2つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションされた Vert.x インスタンスは、Vert.x の Mutiny バリアントである `io.vertx.mutiny.core.Vertx` タイプを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Web クライアントは `io.vertx.mutiny.ext.web.client.WebClient` から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny version of the Vert.x APIs also offers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x APIのMutinyバージョンも提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sendAndAwait` . `andAwait` のような `andAwait` メソッドは、結果が得られるまで呼び出し元のスレッドがブロックされていることを示しています。そのような方法でイベントループ/IOスレッドをブロックしないように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`andForget` `writeAndForget` のような `Uni` を返すメソッドが利用可能です。`andForget` は操作の成否を示す結果の `Uni` を必要としないことを示しています。しかし、サブスクライブしないと操作が発動しないことを覚えておいてください。`andForget` はこれを管理してくれるうえに、サブスクリプションも管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`toBlockingIterable` / `toBlockingStream` メソッドは、Vert.x `ReadStream` をブロッキング可能な iterable またはブロッキング可能な `java.util.Stream` に変換することができます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny は RxJava 2 と Project Reactor の型を `Uni` と `Multi` に変換するユーティリティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RxJava 2 converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RxJava 2のコンバータは以下の依存関係にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、RxJava 2 の型を返す API ( `Completable` , `Single` , `Maybe` , `Observable` , `Flowable` ) を持っている場合は、以下のように `Unis` と `Multis` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into RxJava types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Unis` と `Multis` を RxJava 型に変換することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Reactor converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Project Reactorコンバータは、以下の依存関係で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、Reactorの型を返すAPI( `Mono` , `Flux` )を持っている場合は、以下のように `Unis` と `Multis` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into Reactor types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `Unis` と `Multis` を Reactor タイプに変換することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier&lt;CompletionStage&gt;`. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CompletionStage` , `CompletableFuture` , `Publisher` を使った API に対面している場合、双方向に変換することができます。まず、 `Uni` も `Multi` も `CompletionStage` から作成することも、 `Supplier&lt;CompletionStage&gt;` から作成することもできます。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni` 上で、あなたはまた、 `subscribeAsCompletionStage()` を使用して `CompletionStage` を生成することができます。 `Uni` によって放出されたアイテムまたは障害を取得するだろう `CompletionStage` を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`createFrom().publisher(Publisher)` を使って `Unis` と `Multis` を `Publisher` のインスタンスから作成することもできます。 `Uni` を `toMulti` を使って `Publisher` に変換することもできます。実際、 `Multi` は `Publisher` を実装しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusでのリアクティブについて紹介します。Quarkusの機能の中には、すでにリアクティブになっているものがたくさんあります。以下のリストでは、いくつかの例を紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mailer[Sending email]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mailer[メール送信]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mongodb#reactive[MongoDB] と link:mongodb-panache#reactive[MongoDBをPanacheで] link:mongodb#reactive[使う]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-routes[Using reactive routes]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:reactive-routes[リアクティブルートの使用]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collections</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maps</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defaults</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バリデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension ecosystem consists of the Quarkus extensions developed and maintained by the community, including the Quarkus core development team. While the Quarkus ecosystem (sometimes also referred to as the "Quarkus universe") includes all the Quarkus extensions ever developed, there is also a concept of a Quarkus platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエクステンションエコシステムは、Quarkusコア開発チームを含むコミュニティによって開発・保守されたQuarkusエクステンションで構成されています。Quarkusエコシステム（"Quarkus universe"と呼ばれることもあります）には、これまでに開発されたすべてのQuarkusエクステンションが含まれていますが、Quarkusプラットフォームという概念もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fundamental promise of a Quarkus platform is any combination of the Quarkus extensions the platform consists of can be used in the same application without causing any conflict for each other.  Each organization creating their Quarkus platform may establish their own criterions for the extensions to be accepted into the platform and the means to guarantee the compatibility between the accepted extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプラットフォームの基本的な約束事は、プラットフォームで構成されるQuarkusエクステンションを組み合わせて、お互いに競合することなく同じアプリケーションで使用することができるということです。Quarkusプラットフォームを作成する各組織は、プラットフォームに受け入れられるエクステンションについて独自の基準を設定し、受け入れられたエクステンション間の互換性を保証する手段を確立することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Quarkus platform is defined with a few artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各Quarkusプラットフォームは、いくつかのアーティファクトで定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Quarkus Platform is expected to provide a Maven BOM artifact that</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各Quarkusプラットフォームは、次のようなMaven BOMアーティファクトを提供することが期待されています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imports a chosen version of `io.quarkus:quarkus-bom` (the platform BOM may be flattened at the end but it has to be based on some version of `io.quarkus:quarkus-bom`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-bom` の選択されたバージョンをインポートすること (プラットフォームの BOM は最後にフラット化されますが、 `io.quarkus:quarkus-bom` の何らかのバージョンに基づいていなければなりません)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>includes all the Quarkus extension artifacts (the runtime and the deployment ones) the platform consists of</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラットフォームを構成するすべてのQuarkusエクステンションアーティファクト（ランタイムとデプロイメントのもの）を含むこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>includes the &lt;&lt;platform-descriptor,platform JSON descriptor&gt;&gt; artifact</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#platform-descriptor[プラットフォームJSONディスクリプタ]アーティファクトを含むこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>possibly includes the &lt;&lt;platform-properties,platform configuration properties&gt;&gt; artifacts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;platform-properties,プラットフォーム設定プロパティ&gt;&gt; アーティファクトを含む場合があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications that want to include extensions from a Quarkus platform will be importing the Quarkus platform BOM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusプラットフォームからエクステンションをインクルードしたいQuarkusアプリケーションは、QuarkusプラットフォームのBOMをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus platform descriptor is a JSON artifact that provides information about the platform and its extensions to the Quarkus tools. E.g. http://code.quarkus.io and the Quarkus command line tools consult this descriptor to list, add and remove extensions to/from the project on user's request.  This artifact is also used as a Quarkus platform identifier. When Quarkus tools need to identify the Quarkus platform(s) used in the project, they will analyze the dependency version constraints of the project (the effective list of the managed dependencies from the `dependencyManagement` section in Maven terms) looking for the platform descriptor artifact(s) among them. Given that the platform descriptors are included into the Quarkus platform BOMs, every Quarkus application will inherit the platform descriptor artifact from the imported platform BOM(s) as a dependency version constraint (managed dependency in Maven terms).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプラットフォームディスクリプタは、プラットフォームとそのエクステンションに関する情報をQuarkusツールに提供するJSONアーティファクトです。例： http://code.quarkus.io やQuarkusコマンドラインツールは、ユーザーの要求に応じて、このディスクリプタを参照して、プロジェクトへのエクステンションのリスト化、追加、削除を行います。このアーティファクトは、Quarkusプラットフォームディスクリプタとしても使用されます。Quarkusツールがプロジェクトで使用されているQuarkusプラットフォームを識別する必要がある場合、プロジェクトの依存関係バージョン制約（Maven用語では、 `dependencyManagement` セクションから管理されている依存関係の有効なリスト）を分析して、その中からプラットフォームディスクリプタのアーティファクトを探します。プラットフォームディスクリプタがQuarkusプラットフォームBOMに含まれていることを考えると、すべてのQuarkusアプリケーションは、インポートされたプラットフォームBOMからのプラットフォームディスクリプタアーティファクトを依存関係バージョン制約（Maven用語では管理された依存関係）として継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to easily identify Quarkus platform descriptors among the project's dependency constraints, the platform descriptor Maven artifact coordinates should follow the following naming convention:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトの依存性制約の中でQuarkusプラットフォームディスクリプタを簡単に識別できるように、プラットフォームディスクリプタのMavenアーティファクト座標は、以下の命名規則に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `groupId` of the descriptor artifact should match the `groupId` of the corresponding Quarkus Platform BOM;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `groupId` は、対応するQuarkus Platform BOMの `groupId` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `artifactId` of the descriptor artifact should be the `artifactId` of the corresponding Quarkus Platform BOM with the `-quarkus-platform-descriptor` suffix;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `artifactId` は、対応するQuarkus Platform BOMの `artifactId` で、サフィックスが `-quarkus-platform-descriptor` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `classifier` of the descriptor artifact should match the `version` of the corresponding Quarkus Platform BOM;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `classifier` は、対応するQuarkus Platform BOMの `version` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `type` of the descriptor artifact should be `json`;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `type` は `json` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `version` of the descriptor artifact should match the `version` of the corresponding Quarkus Platform BOM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `version` は、対応するQuarkus Platform BOMの `version` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a string it will look like `&lt;platform-bom-groupId&gt;:&lt;platform-bom-artifactId&gt;-quarkus-platform-descriptor:&lt;platform-version&gt;:json:&lt;platform-version&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文字列としては次のようになります： `&lt;platform-bom-groupId&gt;:&lt;platform-bom-artifactId&gt;-quarkus-platform-descriptor:&lt;platform-version&gt;:json:&lt;platform-version&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the coordinates of the descriptor for Quarkus BOM `io.quarkus:quarkus-bom::pom:1.2.3` will be `io.quarkus:quarkus-bom-quarkus-platform-descriptor:1.2.3:json:1.2.3`.  And for a custom Quarkus platform defined with BOM `org.acme:acme-bom::pom:555` it will be `org.acme:acme-bom-quarkus-platform-descriptor:555:json:555`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、Quarkus BOM `io.quarkus:quarkus-bom::pom:1.2.3` のディスクリプタの座標は `io.quarkus:quarkus-bom-quarkus-platform-descriptor:1.2.3:json:1.2.3` となります。また、BOM `org.acme:acme-bom::pom:555` で定義されたカスタムQuarkusプラットフォームの場合は、 `org.acme:acme-bom-quarkus-platform-descriptor:555:json:555` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The platform descriptor will normally be generated using a Maven plugin, e.g.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラットフォームディスクリプタは通常、Mavenプラグインを使用して生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the version of the `quarkus-platform-descriptor-json-plugin`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-platform-descriptor-json-plugin` のバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`generate-extensions-json` is the goal generating the platform descriptor</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`generate-extensions-json` は、プラットフォームディスクリプタを生成するゴールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this parameter is optional, it allows to override some metadata from the Quarkus extension descriptors found in every runtime extension artifact from which the platform descriptor is generated</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このパラメータはオプションで、プラットフォームディスクリプタが生成されるすべてのランタイムエクステンションアーティファクトに含まれるQuarkusエクステンションディスクリプタのメタデータの一部をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this parameter is also optional and defaults to false. It has to be set to true in case the platform BOM *is not generated* and *is not flattened*. Which for example is the case for `io.quarkus:quarkus-bom`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このパラメータもオプションで、デフォルトは false です。プラットフォームBOMが *生成されず* 、平坦 *化されていない* 場合はtrueに設定しなければなりません。たとえば、 `io.quarkus:quarkus-bom` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkus platform may provide its own default values for some of the configuration options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプラットフォームでは、一部の設定オプションに対して独自のデフォルト値を提供している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is using https://github.com/smallrye/smallrye-config[SmallRye Config] for wiring application configuration. A Quarkus platform may be used as another source of configuration in the hierarchy of the configuration sources dominated by the application's `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、アプリケーション設定の接続に link:https://github.com/eclipse/microprofile-config[SmallRye Config]を使用しています。Quarkusプラットフォームは、アプリケーションの `application.properties` によって支配されている構成ソースの階層の別の構成ソースとして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To provide platform-specific defaults, the platform needs to include a dependency version constraint in its BOM for a properties artifact whose coordinates follow the following naming convention:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プ ラ ッ ト フ ォーム固有のデフ ォル ト を提供す る には、 プ ラ ッ ト フ ォームは、 座標が下記の命名規則に従っ てい る プ ロ パテ ィ アーテ ィ フ ァ ク ト に対 し て、 その BOM 内に依存バージ ョ ン制約を含める必要があ り ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `groupId` of the properties artifact should match the `groupId` of the corresponding Quarkus Platform BOM;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティアーティファクトの `groupId` は、対応するQuarkus Platform BOMの `groupId` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `artifactId` of the properties artifact should be the `artifactId` of the corresponding Quarkus Platform BOM with the `-quarkus-platform-properties` suffix;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティアーティファクトの `artifactId` は、対応するQuarkus Platform BOMの `artifactId` で、サフィックスが `-quarkus-platform-properties` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `classifier` of the descriptor artifact should be left empty/null;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `classifier` は空/NULL のままの必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `type` of the descriptor artifact should be `properties`;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスクリプタアーティファクトの `type` は `properties` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties artifact itself is expected to be a traditional `properties` file that will be loaded into an instance of `java.util.Properties` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティ・アーティファクト自体は、 `java.util.Properties` クラスのインスタンスにロードされる伝統的な `properties` ファイルであることが期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, platform properties are only allowed to provide the default values for a restricted set of configuration options. The property names in the platform properties file must be prefixed with the `platform.` suffix.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この時点では、プラットフォームプロパティは、制限された設定オプションのセットに対してデフォルト値を提供することのみが許可されています。プラットフォームプロパティファイルのプロパティ名の前には、 `platform.` という接尾辞を付けなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension developers that want to make their configuration options platform-specific should set their default values to properties that start with the `platform.` suffix. Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定オプションをプラットフォーム固有のものにしたいエクステンションの開発者は、デフォルト値を `platform.` で始まるプロパティに設定しなければなりません。以下に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case the default value for `quarkus.native.builder-image` will be provided by the platform. The user will still be able to set the desired value for `quarkus.native.builder-image` in its `application.properties`, of course. But in case it's not customized by the user, the default value will be coming from the platform properties.  A platform properties file for the example above would contain (the actual value is provided as an example):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、 `quarkus.native.builder-image` のデフォルト値はプラットフォームによって提供されます。もちろん、ユーザーは `application.properties` で `quarkus.native.builder-image` に希望の値を設定することができます。しかし、ユーザーがカスタマイズしていない場合は、デフォルト値はプラットフォームのプロパティから提供されます。上記の例のプラットフォームのプロパティファイルには、以下のようなものが含まれています（実際の値は例として提供されています）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also a Maven plugin goal that validates the platform properties content and its artifact coordinates and also checks whether the platform properties artifact is present in the platform's BOM. Here is a sample plugin configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、プラットフォームプロパティのコンテンツとそのアーティファクトの座標を検証し、プラットフォームプロパティのアーティファクトがプラットフォームのBOMに存在するかどうかをチェックするMavenプラグインのゴールもあります。ここでは、プラグインの構成例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case an application is importing more than one Quarkus platform and those platforms include their own platform properties artifacts, the content of those platform properties artifacts will be merged to form a single set of properties that will be used for the application build.  The order in which the properties artifacts are merged will correspond to the order in which they appear in the list of dependency version constraints of the application (in the Maven terms that will correspond to the effective list of application's managed dependencies, i.e. the flattened `managedDependencies` POM section).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが複数のQuarkusプラットフォームをインポートしており、それらのプラットフォームが独自のプラットフォームプロパティアーティファクトを含んでいる場合、それらのプラットフォームプロパティアーティファクトのコンテンツは、アプリケーションのビルドに使用される単一のプロパティセットを形成するためにマージされます。プロパティアーティファクトがマージされる順番は、アプリケーションの依存関係バージョン制約のリストに表示される順番に対応します（Maven用語では、アプリケーションの管理された依存関係の実際のリスト、すなわちフラット化された `managedDependencies` POMセクションに対応します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The content of the properties artifacts found earlier will dominate over those found later among the application's dependency constraints!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの依存性制約の中では、先に見つかったプロパティアーティファクトの内容が、後に見つかったものよりも優先されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That means if a platform needs to override a certain property value defined in the platform it is based on, it will need to include its platform properties artifact into the `managedDependencies` section of its BOM before importing the base platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>つまり、あるプラットフォームがベースとなるプラットフォームで定義されている特定のプロパティ値をオーバーライドする必要がある場合は、ベースとなるプラットフォームをインポートする前に、そのプラットフォームのプロパティアーティファクトをBOMの `managedDependencies` セクションに含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the `quarkus-universe-bom` platform is based on the `quarkus-bom` platform. In case, the `quarkus-universe-bom` platform were to override certain properties defined in `quarkus-bom-quarkus-platform-properties` included into the `quarkus-bom` platform, the `quarkus-universe-bom` would have to be composed as</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `quarkus-universe-bom` プラットフォームは `quarkus-bom` プラットフォームをベースにしています。 `quarkus-universe-bom` プラットフォームが、 `quarkus-bom` プラットフォームに含まれる `quarkus-bom-quarkus-platform-properties` で定義された特定のプロパティを上書きする場合、 `quarkus-universe-bom` は次のように構成されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That way, the `quarkus-universe-bom` platform properties will appear before the `quarkus-bom` platform properties and so will be dominating during merging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>こうすることで、 `quarkus-universe-bom` のプラットフォーム・プロパティが `quarkus-bom` のプラットフォーム・プロパティよりも先に現れる為、マージの際に優先されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがKogitoを使用してビジネスオートメーションを追加し、ビジネスプロセスとルールでパワーアップする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito is a next generation business automation toolkit that originates from well known Open Source projects Drools (for business rules) and jBPM (for business processes). Kogito aims at providing another approach to business automation where the main message is to expose your business knowledge (processes, rules and decisions)  in a domain specific way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogitoは、有名なオープンソースプロジェクトであるDrools (ビジネスルール用)とjBPM (ビジネスプロセス用)から生まれた次世代のビジネスオートメーションツールキットです。Kogitoは、ビジネスナレッジ(プロセス、ルール、意思決定)をドメイン固有の方法で公開することを主なメッセージとするビジネスオートメーションへの別のアプローチを提供することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE (Eclipse is preferred with the BPMN modeller plugin)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDE (BPMN モデラープラグインを使用したEclipseが望ましい)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install modelling plugins in your IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モデリングプラグインをIDEにインストールする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito Tooling is currently supported in Eclipse and VSCode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogito Toolingは現在EclipseとVSCodeでサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to make use of visual modelling of your processes, download Eclipse IDE and install from Market place Eclipse BPMN2 Modeller plugin (with jBPM Runtime Extension)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロセスのビジュアルモデリングを利用するには、Eclipse IDEをダウンロードし、マーケットプレイスからEclipse BPMN2 Modellerプラグイン(jBPMランタイムエクステンション付き)をインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>VSCode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download and install the VSCode Extension from https://github.com/kiegroup/kogito-tooling/releases[Kogito Tooling release page] to edit and model process definitions from VSCode IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/kiegroup/kogito-tooling/releases[Kogito Toolingのリリースページ] からVSCode Extensionをダウンロードしてインストールすると、VSCode IDEからプロセス定義を編集してモデル化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Online</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Online</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid any modeler installation you can use directly use https://bpmn.new[BPMN.new] to design and model your process through your favorite web browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>モデラーのインストールを避けるために、 link:https://bpmn.new[BPMN.new] を直接使用して、お気に入りのWebブラウザを使ってプロセスの設計とモデリングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers one REST endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、1つのRESTエンドポイントを提供する非常にシンプルなマイクロサービスを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/persons`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/persons`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint will be automatically generated based on business process, that in turn will make use of business rules to make certain decisions based on the data being processed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエンドポイントは、ビジネスプロセスに基づいて自動的に生成され、ひいてはビジネスルールを利用して処理中のデータに基づいて一定の判断を下すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business process</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスプロセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The business process will be responsible for encapsulating business logic of our microservice.  It should provide complete set of steps to achieve a business goal.  At the same time this is the entry point to the service that can be consumed by clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスプロセスは、マイクロサービスのビジネスロジックをカプセル化する責任があります。これは、ビジネス目標を達成するためのステップの完全なセットを提供する必要があります。同時に、これはクライアントが消費することができるサービスへの入り口となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business rule</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスルール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A business rule allows to externalise decision logic into reusable pieces that can be easily used in declarative way. There are multiple ways of writing rules like decision tables, decision trees, rules, etc. For this example we focus on the rule format backed by DRL (Drools Rule Language).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスルールでは、意思決定ロジックを、簡単に使える再利用可能なものに宣言的な方法で外部化することができます。ルールの書き方には、ディシジョンテーブル、ディシジョンツリー、ルールなど複数の書き方があります。この例では、DRL(Drools Rule Language)に裏打ちされたルール形式に焦点を当てています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the complete example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `kogito-quickstart` {quickstarts-tree-url}/kogito-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `kogito-quickstart` {quickstarts-tree-url}/kogito-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `kogito` extension that comes with all needed dependencies and configuration to equip your application with business automation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、アプリケーションにビジネスオートメーションを装備するために必要なすべての依存関係と設定を含む `kogito` エクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `kogito` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `kogito` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the simple data object `Person`. As you can see from the source code below it is just a POJO:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずはシンプルなデータオブジェクト `Person` を実装してみましょう。下のソースコードを見ればわかるように、ただのPOJOです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>永続化を有効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since 0.3.0 of Kogito, there is an option to enable persistence to preserve process instance state across application restarts. That supports long running process instances that can be resumed at any point in time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogito の 0.3.0 以降、アプリケーションの再起動時にプロセスインスタンスの状態を保持するために永続性を有効にするオプションがあります。これにより、いつでも再開できる長時間稼働しているプロセスインスタンスをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito uses Infinispan as the persistence service so you need to have Infinispan server installed and running.  Version of the Infinispan is aligned with Quarkus BOM so make sure the right version is installed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogitoでは、永続化サービスとしてInfinispanを使用しているため、Infinispanサーバーがインストールされている必要があります。InfinispanのバージョンはQuarkusのBOMに合わせているので、正しいバージョンがインストールされていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add dependencies to project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトに依存関係を追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add following into the src/main/resources/application.properties file (create the file if it does not exist)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/resources/application.propertiesファイルに以下を追加します(存在しない場合は作成してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adjust the host and port number according to your Infinispan server installation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan サーバーのインストールに合わせて、ホストとポート番号を調整します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test with enabled persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>永続性を有効にしたテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After configuring persistence on the project level, you can test and verify that the process instance state is preserved across application restarts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト レベルで永続性を設定した後、アプリケーションの再起動時にプロセス インスタンスの状態が保持されているかどうかをテストして確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Infinispan server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan サーバーを起動する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also verify that there is active instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アクティブなインスタンスがあることを確認することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Restart your application while keeping Infinispan server up and running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan サーバーを稼働させている間にアプリケーションを再起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check if you can see active instance which should have exactly the same id</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>全く同じ ID を持つアクティブなインスタンスが表示されているかどうかを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about persistence in Kogito visit https://github.com/kiegroup/kogito-runtimes/wiki/Persistence[this page]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogito の永続化について詳しく知りたい方は link:https://github.com/kiegroup/kogito-runtimes/wiki/Persistence[こちらのページ] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using decision tables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>意思決定テーブルの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito allows to define business rules as decision tables using the Microsoft Excel file formats.  To be able to use such assets in your application, an additional dependency is required:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kogitoでは、Microsoft Excelファイルフォーマットを使用して、ビジネスルールをディシジョンテーブルとして定義することができます。このようなアセットをアプリケーションで使用するには、追加の依存関係が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the dependency is added to the project, decision tables in `xls` or `xlsx` format can be properly handled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係がプロジェクトに追加されると、 `xls` や `xlsx` 形式のディシジョンテーブルを適切に扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kogito.kie.org[Kogito Website]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://kogito.kie.org[Kogito Website]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.jboss.org/kogito/release/latest/html_single[Kogito Documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://docs.jboss.org/kogito/release/latest/html_single[Kogito Documentation]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがOpenTracingを利用してインタラクティブなウェブアプリケーションのための分散トレースを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `smallrye-opentracing` extension, which includes the OpenTracing support and the default https://www.jaegertracing.io/[Jaeger] tracer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、OpenTracing サポートとデフォルトの link:https://www.jaegertracing.io/[Jaeger] トレーサーを含む `smallrye-opentracing` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-opentracing` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-opentracing` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/opentracing/TracedResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/java/org/acme/opentracing/TracedResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to configure the Jaeger tracer within the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション内でJaeger トレーサーを設定するには、2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `quarkus.jaeger.service-name` property (or `JAEGER_SERVICE_NAME` environment variable) is not provided then a "no-op" tracer will be configured, resulting in no tracing data being reported to the backend.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.jaeger.service-name` プロパティー (または `JAEGER_SERVICE_NAME` 環境変数) が提供されていない場合は、"no-op" トレーサーが設定され、結果としてトレースデータはバックエンドに報告されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setup a sampler, that uses a constant sampling strategy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一定のサンプリング戦略を使用するサンプラーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample all requests. Set sampler-param to somewhere between 0 and 1, e.g. 0.50, if you do not wish to sample all requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのリクエストをサンプリングします。すべてのリクエストをサンプリングしたくない場合は、sampler-param を 0 から 1 の間のどこかに設定します (例: 0.50)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add trace IDs into log message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログメッセージにトレースIDを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second approach is to supply the properties as https://www.jaegertracing.io/docs/latest/client-features/[environment variables]. These can be specified as `jvm.args` as shown in the following section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つ目の方法は、 link:https://www.jaegertracing.io/docs/latest/client-features/[環境変数] としてプロパティーを供給することです。これらは、次のセクションに示すように `jvm.args` として指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to start the tracing system to collect and display the captured traces:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、キャプチャしたトレースを収集して表示するためのトレースシステムを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once both the application and tracing system are started, you can make a request to the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションとトレースシステムの両方が起動したら、提供されたエンドポイントにリクエストを行うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the first request has been submitted, the Jaeger tracer within the app will be initialized:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のリクエストが送信されると、アプリ内のJaegerトレーサーが初期化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing additional methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加メソッドのトレース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be useful to trace incoming requests from non-REST calls (like request coming from a message) or to create spans inside a trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、非RESTコール(メッセージからのリクエストなど)からの着信リクエストをトレースしたり、トレース内にスパンを作成したりするのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of a `FrancophoneService` which methods are traced.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、メソッドがトレースされている `FrancophoneService` の例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/opentracing-contrib[OpenTracing API Contributions project] offers additional instrumentation that can be used to add tracing to a large variety of technologies/components.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/opentracing-contrib[OpenTracing API Contributionsプロジェクト] では、様々な技術/コンポーネントにトレースを追加するために使用できる追加の計器 (Instrumentation) を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/opentracing-contrib/java-jdbc[JDBC instrumentation] will add a span for each JDBC queries done by your application, to enable it, add the following dependency to your pom.xml:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/opentracing-contrib/java-jdbc[JDBC計器]は 、アプリケーションで実行されるJDBCクエリごとにスパンを追加するので、これを有効にするには、以下の依存関係をpom.xmlに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As it uses a dedicated JDBC driver, you must configure your datasource and Hibernate to use it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>専用のJDBCドライバーを使用するため、データソースとHibernateがそれを使用するように設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/opentracing-contrib/java-kafka-client[Kafka instrumentation] will add a span for each message sent to or received from a Kafka topic. To enable it, add the following dependency to your pom.xml:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/opentracing-contrib/java-kafka-client[Kafka 計器] は、Kafka トピックとの間で送受信されるメッセージごとにスパンを追加します。これを有効にするには、以下の依存関係を pom.xml に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It contains OpenTracing interceptors that must be registered on Kafka producers and consumers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KafkaのProducerとConsumerに登録しなければならないOpenTracingのインターセプターが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the link:kafka[Kafka guide], the interceptors can be added on the `generated-price` and the `prices` channels as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:kafka[Kafkaのガイド] に従った場合、以下のように `generated-price` と `prices` のチャンネルにインターセプターを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`interceptor.classes` accept a list of classes separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`interceptor.classes` はカンマで区切られたクラスのリストを受け付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanは、アプリケーションプロセスの外で実行するインメモリデータグリッドです。このエクステンションは、Quarkusを実行しているときに、クライアントがサーバに接続できる機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the https://infinispan.org/documentation[Infinispan documentation] to find out more about the Infinispan project, in particular the https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html[Hot Rod Java client guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanの link:https://infinispan.org/documentation[ドキュメント] をチェックして、Infinispanプロジェクト、特に link:https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html[Hot Rod Javaクライアントガイド] の詳細を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `infinispan-client` extension to your project by running the following from the command line in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一度Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリのコマンドラインから以下を実行して、 `infinispan-client` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your pom.xml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、以下が pom.xml に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan client is configurable in the `application.properties` file that can be provided in the `src/main/resources` directory. These are the properties that can be configured in this file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan クライアントは、 `src/main/resources` ディレクトリで提供される `application.properties` ファイルで設定できます。このファイルで設定できるプロパティは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to configure a `hotrod-client.properties` as described in the Infinispan user guide. Note that the `hotrod-client.properties` values overwrite any matching property from the other configuration values (eg. near cache).  This properties file is build time only and if it is changed, requires a full rebuild.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan ユーザガイドに記載されているように `hotrod-client.properties` を設定できます。 `hotrod-client.properties` の値は、他の設定値（例:ニアキャッシュ）から一致するプロパティを上書きすることに注意してください。このプロパティファイルはビルド時のみのもので、変更された場合は完全に再ビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization (Key Value types support)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シリアライゼーション（Key Value型のサポート）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the client will support keys and values of the following types: byte[], primitive wrappers (eg. Integer, Long, Double etc.), String, Date and Instant. User types require some additional steps that are detailed here. Let's say we have the following user classes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、クライアントは以下の型のキーとバリューをサポートします: byte[]、プリミティブラッパー(例: Integer、Long、Doubleなど)、String、Date、Instant。ユーザ型については、ここで詳しく説明される追加のステップが必要です。以下のようなユーザクラスがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Author.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Author.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Book.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Book.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization of user types uses a library based on protobuf, called Protostream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザ型のシリアライズは、Protostreamと呼ばれるprotobufをベースにしたライブラリを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotation based Serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーションに基づくシリアライゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done automatically by adding protostream annotations to your user classes.  In addition a single Initializer annotated interface is required which controls how the supporting classes are generated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ユーザクラスに protostream アノテーションを追加することで自動的に行えます。さらに、初期化子がアノテーションされたインターフェースが1つ必要です。これは、サポートするクラスの生成方法を制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of how the preceding classes should be changed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、先述のクラスをどのように変更するかの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your classes have only mutable fields, then the `ProtoFactory` annotation is not required, assuming your class has a no arg constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスが変更可能なフィールドしかない場合、 `ProtoFactory` アノテーションは必要ありません。あなたのクラスが引数なしのコンストラクタを持っていると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then all that is required is a very simple `SerializationContextInitializer` interface with an annotation on it to specify configuration settings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要なのは、非常にシンプルな `SerializationContextInitializer` インターフェイスにアノテーションを付けて設定を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BookContextInitializer.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BookContextInitializer.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So in this case we will automatically generate the marshaller and schemas for the included classes and place them in the schema package automatically. The package does not have to be provided, but if you utilize querying, you must know the generated package.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで今回は、含まれるクラスのマーシャラとスキーマを自動生成して、スキーマパッケージに自動で配置します。パッケージは用意する必要はありませんが、クエリを利用する場合は生成されたパッケージを知っておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus the `schemaFileName` and `schemaFilePath` attributes should NOT be set on the `AutoProtoSchemaBuilder` annotation, setting either will cause native runtime to error.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `schemaFileName` と `schemaFilePath` 属性は、 `AutoProtoSchemaBuilder` アノテーションに設定すべきではありません。いずれかを設定すると、ネイティブランタイムがエラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User written serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザが書いたシリアライゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous method is suggested for any case when the user can annotate their classes.  Unfortunately the user may not be able to annotate all classes they will put in the cache. In this case you must define your schema and create your own Marshaller(s)  yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前の方法は、ユーザが自分のクラスにアノテーションを付けられる場合のために提案されています。残念ながら、ユーザはキャッシュに入れるすべてのクラスにアノテーションを付けることができないかもしれません。このような場合はスキーマを定義し、自分で独自のマーシャラを作成しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can supply a protobuf schema through either one of two ways.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つの方法のいずれかでprotobufスキーマを提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+ You can put the `.proto` file in the `META-INF` directory of the project. These files will automatically be picked up at initialization time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>+ プロジェクトの `META-INF` ディレクトリに `.proto` ファイルを置けます。これらのファイルは、初期化時に自動的に取り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>library.proto</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>library.proto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+ Or you can define the proto schema directly in user code by defining a produced bean of type `org.infinispan.protostream.FileDescriptorSource`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>+ `org.infinispan.protostream.FileDescriptorSource` 型の生成されたBeanを定義することにより、ユーザコードで直接protoスキーマを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User Marshaller</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザマーシャラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last thing to do is to provide a `org.infinispan.protostream.MessageMarshaller` implementation for each user class defined in the proto schema. This class is then provided via `@Produces` in a similar fashion to the code based proto schema definition above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後にすべきことは、proto スキーマで定義された各ユーザクラスの `org.infinispan.protostream.MessageMarshaller` 実装を提供することです。このクラスは、上記のコードベースの proto スキーマの定義と同様の方法で `@Produces` を介して提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is the Marshaller class for our Author &amp; Book classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>こちらは、Author と Book クラスのマーシャラクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The type name must match the `&lt;protobuf package&gt;.&lt;protobuf message&gt;` exactly!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>型名は `&lt;protobuf package&gt;.&lt;protobuf message&gt;` と正確に一致している必要があります！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AuthorMarshaller.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AuthorMarshaller.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BookMarshaller.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BookMarshaller.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And you pass the marshaller by defining the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、以下のように定義してマーシャラを渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above produced Marshaller method MUST return `MessageMarshaller` without types or else it will not be found.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のように生成されたMarshallerメソッドは、型なしで `MessageMarshaller` を返さなければなりません。さもないと、それが見つかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存性注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you saw above we support the user injecting Marshaller configuration. You can do the inverse with the Infinispan client extension providing injection for `RemoteCacheManager` and `RemoteCache` objects.  There is one global `RemoteCacheManager` that takes all of the configuration parameters setup in the above sections.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上で見たように、Marshaller の設定をユーザが注入することをサポートしています。Infinispan クライアントエクステンションを使用すると、 `RemoteCacheManager` と `RemoteCache` オブジェクトに注入することでその逆のことができます。上記のセクションで設定したすべての設定パラメーターを受け取るグローバル `RemoteCacheManager` があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very simple to inject these components. All you need to do is to add the Inject annotation to the field, constructor or method. In the below code we utilize field and constructor injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのコンポーネントを注入するのは非常に簡単です。必要なのは、フィールド、コンストラクタ、またはメソッドに注入アノテーションを追加するだけです。以下のコードでは、フィールドとコンストラクタの注入を利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SomeClass.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SomeClass.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you notice the `RemoteCache` declaration has an additional optional annotation named `Remote`.  This is a qualifier annotation allowing you to specify which named cache that will be injected. This annotation is not required and if it is not supplied, the default cache will be injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RemoteCache` 宣言に `Remote` というオプションのアノテーションが追加されていることにお気づきでしょうか。これは、注入される名前付きキャッシュを指定するための修飾子アノテーションです。このアノテーションは必須ではなく、指定しなかった場合はデフォルトのキャッシュが注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other types may be supported for injection, please see other sections for more information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の型は注入のためにサポートされている場合がありますが、詳細については他のセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Querying</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問い合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan client supports both indexed and non indexed querying as long as the `ProtoStreamMarshaller` is configured above. This allows the user to query based on the properties of the proto schema.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan クライアントは、上記の `ProtoStreamMarshaller` が設定されている限り、インデックス付きと非インデックス付きの両方の問い合せをサポートしています。これにより、ユーザはプロトスキーマのプロパティに基づいて問い合せできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query builds upon the proto definitions you can configure when setting up the `ProtoStreamMarshaller`.  Either method of Serialization above will automatically register the schema with the server at startup, meaning that you will automatically gain the ability to query objects stored in the remote Infinispan Server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Query は、 `ProtoStreamMarshaller` の設定時に設定できるproto定義に基づいて構築されます。上記のいずれのシリアライズ方法でも、起動時に自動的にスキーマをサーバに登録し、リモートの Infinispan サーバーに保存されているオブジェクトを問い合せる機能を自動的に得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about https://infinispan.org/docs/stable/titles/developing/developing.html#creating_ickle_queries-querying[querying] in the Infinispan documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は Infinispan のドキュメント https://infinispan.org/docs/stable/titles/developing/developing.html#creating_ickle_queries-querying[問い合せ] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use either the Query DSL or the Ickle Query language with the Quarkus Infinispan client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Infinispanクライアントエクステンションでは、Query DSLまたはIckle Query 言語のいずれかを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan also has a notion of counters and the Quarkus Infinispan client supports them out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanにはカウンターという概念もあり、Quarkus Infinispanのクライアントはそれらもサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Infinispan client extension allows for Dependency Injection of the `CounterManager` directly. All you need to do is annotate your field, constructor or method and you get it with no fuss. You can then use counters as you would normally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Infinispanクライアントエクステンションを使用すると、 `CounterManager` の依存性注入を直接行えます。必要なのは、フィールド、コンストラクタ、メソッドにアノテーションを付けるだけで、手間をかけずに注入できます。そして、通常のようにカウンターを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about https://infinispan.org/docs/stable/titles/developing/developing.html#clustered_counters[clustered counters] in the Infinispan documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は Infinispan のドキュメント https://infinispan.org/docs/stable/titles/developing/developing.html#clustered_counters[クラスタカウンタ] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Near Caching</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ニアキャッシング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Near caching is disabled by default, but you can enable it by setting the profile config property `quarkus.infinispan-client.near-cache-max-entries` to a value greater than 0. You can also configure a regular expression so that only a subset of caches have near caching applied through the `quarkus.infinispan-client.near-cache-name-pattern` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ニア・キャッシングは既定では無効になっていますが、プロファイル構成プロパティ `quarkus.infinispan-client.near-cache-max-entries` を 0 より大きい値に設定することで有効にできます。 また、正規表現を構成して、`quarkus.infinispan-client.near-cache-name-pattern` 属性を通じたキャッシュの一部のみニア・キャッシングを適用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encryption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>暗号化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encryption at this point requires additional steps to get working.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この時点での暗号化には、作業を開始するための追加のステップが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to configure the `hotrod-client.properties` file to point to your truststore and/or keystore. This is further detailed https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html#hotrod_encryption[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のステップは、 `hotrod-client.properties` ファイルがトラストストアおよび/またはキーストアを指すように設定することです。これについては、 https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html#hotrod_encryption[ここで] さらに詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan Client extension enables SSL by default. You can read more about this at link:native-and-ssl[Using SSL With Native Executables].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanクライアントエクステンションは、デフォルトでSSLを有効にします。これについての詳細は link:native-and-ssl[ネイティブイメージでのSSLの利用] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chart illustrates what mechanisms have been verified to be working properly with the Quarkus Infinispan Client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この表は、Quarkus Infinispanクライアントエクステンションで正常に動作することが確認されているメカニズムを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Verified</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証済み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[green]*Y*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[green]*Y*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[red]*N*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[red]*N*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Custom</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide for configuring these can be found https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html#hotrod_authentication[here].  However you need to configure these through the `hotrod-client.properties` file if using Dependency Injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらを設定するためのガイドは https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html#hotrod_authentication[こちら] にあります。ただし、依存性注入を使用している場合は `hotrod-client.properties` ファイルから設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan Client has additional features that were not mentioned here. This means this feature was not tested in a Quarkus environment and they may or may not work. Please let us know if you need these added!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanクライアントには、ここでは触れられていない追加機能があります。これは、この機能がQuarkus環境でテストされていないことを意味し、それらは動作するかもしれないし、動作しないかもしれません。これらの機能を追加する必要がある場合は、ご連絡ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus allows different beans to interact using asynchronous events, thus promoting loose-coupling.  The messages are sent to _virtual addresses_.  It offers 3 types of delivery mechanism:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、異なる Bean が非同期イベントを使用して相互作用することができるため、疎結合化が促進されます。メッセージは _仮想アドレス_ に送信されます。3種類の配信メカニズムを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round robin is applied;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>point-to-point - メッセージを送信し、1 つのコンシューマがそれを受信します。複数のコンシューマがアドレスをリスンしている場合、ラウンドロビンが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>publish/subscribe - メッセージをパブリッシュし、アドレスをリスンしているすべてのコンシューマがメッセージを受信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>request/reply - メッセージを送信し、応答を待ちます。受信者は非同期的にメッセージに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these delivery mechanism are non-blocking, and are providing one of the fundamental brick to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの配信メカニズムはすべてノンブロッキングであり、リアクティブアプリケーションを構築するための基本的なブロックの1つを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The asynchronous message passing feature allows replying to messages which is not supported by Reactive Messaging.  However, it is limited to single-event behavior (no stream) and to local messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期メッセージパッシング機能は、Reactive Messagingではサポートされていないメッセージへの返信を可能にします。ただし、シングルイベント動作(ストリームなし)とローカルメッセージに限定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter are follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この仕組みはVert.x EventBusを利用しているので、この機能を利用するには `vertx` エクステンションを有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントのコンシューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントをコンシュームするには、 `io.quarkus.vertx.ConsumeEvent` アノテーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, the address is the fully qualified name of the bean, for instance, in this snippet it's `org.acme.vertx.GreetingService`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定されていない場合、アドレスは Bean の完全修飾名となり、例えばこのスニペットでは `org.acme.vertx.GreetingService` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter is the message body. If the method returns _something_ it's the message response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドのパラメーターはメッセージ本体です。メソッドが _何か_ を返す場合は、それがメッセージのレスポンスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the code consuming the event must be _non-blocking_, as it's called on the Vert.x event loop.  If your processing is blocking, use the `blocking` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Vert.x イベントループで呼び出されるため、イベントをコンシュームするコードは _ノンブロッキング_ でなければなりません。処理がブロッキングである場合は、 `blocking` 属性を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can annotate your method with `@io.smallrye.common.annotation.Blocking`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、メソッドに `@io.smallrye.common.annotation.Blocking` と注釈を付けることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Blocking` を使用する場合、 `@ConsumeEvent` の `blocking` 属性の値は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.mutiny.Uni` または `java.util.concurrent.CompletionStage` のどちらかを返すことで、非同期処理も可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses Mutiny reactive types, if you're not familiar with them, we recommend reading the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前の例では Mutiny リアクティブタイプを使用していますが、もしよく知らないのであれば、 link:getting-started-reactive#mutiny[Reactive の入門ガイド] を読むことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アドレスの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ConsumeEvent` annotation can be configured to set the address:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ConsumeEvent` アノテーションでアドレスを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receive the messages sent to the `greeting` address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`greeting` アドレスに送信されたメッセージを受信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replying</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>応答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _return_ value of a method annotated with `@ConsumeEvent` is used as response to the incoming message.  For instance, in the following snippet, the returned `String` is the response.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ConsumeEvent` でアノテーションされたメソッドの _戻り値_ が、着信メッセージに対するレスポンスとして使用されます。例えば、次のスニペットでは、 `String` がレスポンスとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also return a `Uni&lt;T&gt;` or a `CompletionStage&lt;T&gt;` to handle asynchronous reply:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `Uni&lt;T&gt;` や `CompletionStage&lt;T&gt;` を返すことで、非同期応答を扱うこともできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject an `executor` if you use the Context Propagation extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Context Propagation エクステンションを使えば、 `executor` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing fire and forget interactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>fire and forget インタラクションの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to reply to received messages.  Typically for a _fire and forget_ interaction, the messages are consumed and the sender does not need to know about it.  To implement this, your consumer method just returns `void`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受信したメッセージに返信する必要はありません。通常、 _fire and forget_ インタラクションでは、メッセージはコンシュームされ、送信者はそれについて知る必要はありません。これを実装するには、 consumer メソッドは `void` を返すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, this mechanism is based on the Vert.x event bus. So, you can also use `Message` directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上でも述べたように、この仕組みはVert.xイベントバスをベースにしています。なので、直接 `Message` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, we have seen how to receive messages, let's now switch to the _other side_: the sender.  Sending and publishing messages use the Vert.x event bus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、メッセージを受信する方法を見てきましたが、次は送信者 _側_ に切り替えましょう。メッセージの送信とパブリッシュは Vert.x イベントバスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントバスのインジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send a message to the address `greeting`. Message payload is `name`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アドレス `greeting` にメッセージを送信。メッセージのペイロードは `name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `EventBus` object provides methods to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EventBus` オブジェクトは、以下のメソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`send` a message to a specific address - one single consumer receives the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` 特定のアドレスへのメッセージ - 一人のコンシューマーがメッセージを受信する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`publish` a message to a specific address - all consumers receive the messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`publish` 特定のアドレスにメッセージを送る - すべてのコンシューマーがメッセージを受け取る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Putting things together - bridging HTTP and messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>物事をまとめる - HTTPとメッセージのブリッジング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.  This message is consumed by another bean and the response is sent using the _reply_ mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>greeting HTTP エンドポイントを再訪し、非同期メッセージパッシングを使用して分離された Bean に呼び出しを委譲してみましょう。リクエスト/レスポンスディスパッチの仕組みを利用しています。JAX-RS エンドポイント内にビジネスロジックを実装する代わりに、メッセージを送信しています。このメッセージは別の Bean によってコンシュームされ、応答は _返信_  機構を使用して送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First create a new project using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、新しいプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can already start the application in _dev mode_ using `./mvnw compile quarkus:dev`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw compile quarkus:dev` を実行すると、自動的に _開発者モード_ でアプリケーションを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, creates a new JAX-RS resource with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、以下の内容の JAX-RS リソースを新規に作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>src/main/java/org/acme/vertx/EventResource.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/java/org/acme/vertx/EventResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>send the `name` to the `greeting` address and request a response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`greeting` アドレスに  `name`  を送信し、レスポンスを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we get the response, extract the body and send it to the user</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスを取得したら、ボディを抽出してユーザーに送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.  So, we need a consumer listening on the `greeting` address. Create a `GreetingService` bean with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエンドポイントを呼び出すと、しばらく待ってからタイムアウトになります。実際、誰もリスンしていません。そこで、 `greeting` アドレスをリスンするコンシューマーが必要です。以下の内容の `GreetingService` Bean を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>src/main/java/org/acme/vertx/GreetingService.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/java/org/acme/vertx/GreetingService.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean receives the name, and returns the greeting message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この Bean は name を受け取り、 greeting メッセージを返します.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, open your browser to http://localhost:8080/async/Quarkus, and you should see:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、ブラウザで http://localhost:8080/async/Quarkus を開くと、以下が表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand, let's detail how the HTTP request/response has been handled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より理解しやすくするために、HTTP リクエスト/レスポンスがどのように処理されたかを詳しく見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request is received by the `hello` method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストは `hello` メソッドが受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a message containing the _name_ is sent to the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_name_ を含むメッセージがイベントバスに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another bean receives this message and computes the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別の Bean がこのメッセージを受信して、レスポンスを計算します.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This response is sent back using the reply mechanism</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このレスポンスは、応答機構を使用して返信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the reply is received by the sender, the content is written to the HTTP response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>送信者が応答を受信すると、HTTP レスポンスに内容が書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application can be packaged using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションは、以下の方法でパッケージングできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw clean package
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also compile it as a native executable with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下でネイティブ実行ファイルとしてコンパイルすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using codecs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コーデックを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.xイベントバス] では、コーデックを使用してオブジェクトの _シリアライズ_ と _デシリアライズ_ を行います。Quarkusでは、ローカル配信用のデフォルトのコーデックを提供しています。そのため、以下のようにオブジェクトを交換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use a specific codec, you need to explicitly set it on both ends:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定のコーデックを使用したい場合は、両サイドで明示的に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the name of the codec to use to send the message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージの送信に使用するコーデックの名前を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the codec to use to receive the message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージの受信に使用するコーデックを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Valu</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バリュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  There are two scheduler extensions in Quarkus.  The `quarkus-scheduler` extension brings the API and a lightweight in-memory scheduler implementation.  The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.  You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。Quarkusには2つのスケジューラーエクステンションがあります。 `quarkus-scheduler` エクステンションには、APIと軽量なインメモリースケジューラーの実装が含まれています。 `quarkus-quartz` エクステンションは、 `quarkus-scheduler` エクステンションのAPIを実装し、Quartzライブラリをベースにしたスケジューラーの実装が含まれています。 `quarkus-quartz` が必要になるのは、永続的タスク、クラスターリング、ジョブのプログラマティックスケジューリングなど、より高度なスケジューリングのユースケースのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトに `quarkus-quartz` 依存関係を追加すると、 `quarkus-scheduler` エクステンションからの軽量スケジューラーの実装は自動的に無効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduled Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジュールされたメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.  In fact, such a method must be a non-private non-static method of a CDI bean.  As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドに `@io.quarkus.scheduler.Scheduled` をアノテーションすると、自動的に呼び出されるようにスケジュールされます。実際には、そのようなメソッドはCDI Beanの非プライベート非静的メソッドでなければなりません。CDI Beanのメソッドであることの結果として、スケジュールされたメソッドは、 `@javax.transaction.Transactional` や `@org.eclipse.microprofile.metrics.annotation.Counted` のようなインターセプターバインディングでアノテーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no CDI scope defined on the declaring class then `@Singleton` is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>宣言クラスにCDIスコープが定義されていない場合は、 `@Singleton` が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、アノテーションされたメソッドは `void` を返し、パラメーターを宣言しないか、 `io.quarkus.scheduler.ScheduledExecution` 型のパラメーターを 1 つだけ宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The annotation is repeatable so a single method could be scheduled multiple times.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーションは繰り返し可能なので、1つのメソッドを複数回スケジュールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Triggers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トリガー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.  If both are specified, the cron expression takes precedence.  If none is specified, the build fails with an `IllegalStateException`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トリガーは、 `@Scheduled#cron()` 属性または `@Scheduled#every()` 属性によって定義されます。両方が指定されている場合、cron 式が優先されます。何も指定されていない場合、ビルドは `IllegalStateException` で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A CRON trigger is defined by a cron-like expression.  For example `"0 15 10 * * ?"` fires at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CRONトリガーは、cronライクな式で定義されています。例えば `"0 15 10 * * ?"` は毎日午前10時15分に起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.  The values can be `cron4j`, `quartz`, `unix` and `spring`.  `quartz` is used by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CRON 式で使用される構文は `quarkus.scheduler.cron-type` プロパティーによって制御されます。 値は `cron4j` , `quartz` , `unix` および `spring` のいづれかです。`quartz` がデフォルトで使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Intervals</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターバル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interval trigger defines a period between invocations.  The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`.  However, if an expression starts with a digit then the `PT` prefix is added automatically.  So for example, `15m` can be used instead of `PT15M` and is parsed as "15 minutes".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターバルトリガーは、呼び出しの間の期間を定義します。期間式は ISO-8601 の期間フォーマット `PnDTnHnMn.nS` に基づいており、 `@Scheduled#every()` の値は `java.time.Duration#parse(CharSequence)` で解析されます。ただし、式が数字で始まる場合は、 `PT` の接頭辞が自動的に追加されます。例えば、 `PT15M` の代わりに `15m` を使用することができ、「15 分」と解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interval Trigger Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターバルトリガーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interval Config Property Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターバル設定プロパティーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アイデンティティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a unique id is generated for each scheduled method.  This id is used in log messages and during debugging.  Sometimes a possibility to specify an explicit id may come in handy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、スケジュールされた各メソッドに対して一意の ID が生成されます。このIDはログメッセージやデバッグ中に使用されます。時には、明示的な id を指定することが便利な場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アイデンティティの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delayed Execution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遅延実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Scheduled` provides two ways to delay the time a trigger should start firing at.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled` では、トリガーが発報を開始時刻を遅らせるための2つの方法を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled#delay()` と `@Scheduled#delayUnit()` は初期遅延を一緒に形成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The trigger fires for the first time two hours after the application start.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション開始から2時間後に初めてトリガーが発射されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final value is always rounded to full second.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最終的な値は常に1秒単位で丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Scheduled#delayed()` is a text alternative to the properties above.  The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`.  However, if an expression starts with a digit, the `PT` prefix is added automatically.  So for example, `15s` can be used instead of `PT15S` and is parsed as "15 seconds".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled#delayed()` は、上記のプロパティーのテキスト形式での代替です。ピリオド式は ISO-8601 duration format `PnDTnHnMn.nS` に基づいており、値は `java.time.Duration#parse(CharSequence)` で解析されます。ただし、式が数字で始まる場合は、 `PT` の接頭辞が自動的に追加されます。そのため、例えば `PT15S` の代わりに `15s` を使用することができ、「15 秒」と解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The config property `myMethod.delay.expr` is used to set the delay.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遅延の設定には、configプロパティー `myMethod.delay.expr` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Concurrent Execution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同時実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a scheduled method can be executed concurrently.  Nevertheless, it is possible to specify the strategy to handle concurrent executions via `@Scheduled#concurrentExecution()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、スケジュールされたメソッドは同時に実行することができます。それにもかかわらず、 `@Scheduled#concurrentExecution()` を通じて同時実行を処理するための戦略を指定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Concurrent executions are skipped.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同時実行はスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Injection Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラーインジェクションの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pause all triggers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのトリガーを一時停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resume the scheduler.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラーを再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic Scheduling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラムスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to schedule a job programmatically you'll need to add the link:quartz[Quartz extension] and use the Quartz API directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラムでジョブをスケジュールする必要がある場合は、 link:quartz[Quartzエクステンション] を追加してQuartz APIを直接使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the scheduler is not started unless a `@Scheduled` business method is found. You may need to force the start of the scheduler for "pure" programmatic scheduling. See also &lt;&lt;quartz.adoc#quartz-configuration-reference,Quartz Configuration Reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `@Scheduled` ビジネスメソッドが見つからない限り、スケジューラーは起動されません。「純粋な」プログラマティックスケジューリングのために、スケジューラーを強制的に起動する必要があるかもしれません。 link:quartz.html#quartz-configuration-reference[Quartz Configuration Reference] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduled Methods and Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジュールされたメソッドとテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is often desirable to disable the scheduler when running the tests.  The scheduler can be disabled through the runtime config property `quarkus.scheduler.enabled`.  If set to `false` the scheduler is not started even though the application contains scheduled methods.  You can even disable the scheduler for particular &lt;&lt;getting-started-testing#testing_different_profiles,Test Profiles&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストを実行する際には、スケジューラーを無効にすることが望ましいことがよくあります。スケジューラーは、ランタイム設定プロパティー `quarkus.scheduler.enabled` を通じて無効にすることができます。 `false` に設定すると、アプリケーションにスケジュールされたメソッドが含まれていても、 スケジューラーは起動しません。特定の link:getting-started-testing.html#testing_different_profiles[テストプロファイル] に対してスケジューラーを無効にすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - SmallRye Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - SmallRye Metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use https://github.com/smallrye/smallrye-metrics/[SmallRye Metrics], an implementation of the https://github.com/eclipse/microprofile-metrics/[MicroProfile Metrics] specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:https://github.com/eclipse/microprofile-metrics/[MicroProfile Metrics]仕様の実装である link:https://github.com/smallrye/smallrye-metrics/[SmallRye Metrics]をQuarkusアプリケーションで使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Metrics allows applications to gather various metrics and statistics that provide insights into what is happening inside the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Metricsでは、アプリケーションが様々なメトリクスや統計情報を収集し、アプリケーション内で何が起こっているかを把握することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The metrics can be read remotely using JSON format or the OpenMetrics format, so that they can be processed by additional tools such as Prometheus, and stored for analysis and visualisation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このように、JSON 形式または OpenMetrics 形式を使用してメトリクスをリモートで読み取ることができるため、Prometheus などの追加ツールで処理したり、分析や可視化のために保存したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:micrometer[Micrometer] is the recommended approach to metrics for Quarkus.  Use the SmallRye Metrics extension when it's required to retain MicroProfile specification compatibility.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:micrometer[Micrometer]が、Quarkusで推奨されるメトリクスの手法です。MicroProfile仕様との互換性を保つために必要な場合に、SmallRye Metricsエクステンションを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers one REST endpoint and that endpoint serves for determining whether a number is prime. The implementation class is annotated with some metric annotations so that while responding to user's requests, some metrics are gathered. The meaning of each metric will be explained later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、1つのRESTエンドポイントを提供する非常にシンプルなマイクロサービスを構築し、そのエンドポイントは数値が素数であるかどうかを判断するのに役立ちます。実装クラスは、ユーザーのリクエストに応答している間に、いくつかのメトリクスが収集されるように、いくつかのメトリックアノテーションが付与されています。各メトリックの意味は後ほど説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `microprofile-metrics-quickstart` {quickstarts-tree-url}/microprofile-metrics-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `microprofile-metrics-quickstart` {quickstarts-tree-url}/microprofile-metrics-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-metrics`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、 `smallrye-metrics`をインポートしてMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-metrics` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-metrics` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application consists of a single class that implements an algorithm for checking whether a number is prime.  This algorithm is exposed over a REST interface. Additionally, we need a few annotations to make sure that our desired metrics are calculated over time and can be exported for manual analysis or processing by additional tooling.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションは、数値が素数であるかどうかをチェックするアルゴリズムを実装した単一のクラスで構成されています。このアルゴリズムは、RESTインターフェースを介して公開されています。さらに、必要なメトリクスが時間の経過とともに計算され、手動分析や追加のツールによる処理のためにエクスポートできることを確認するために、いくつかのアノテーションが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The metrics that we will gather are these:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集めようとしているメトリクスは、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`performedChecks`: A counter which is increased by one each time the user asks about a number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`performedChecks` : ユーザーが数字を尋ねるたびに1つ増えるカウンター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`highestPrimeNumberSoFar`: This is a gauge that stores the highest number that was asked about by the user and which was determined to be prime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`highestPrimeNumberSoFar` : ユーザーから質問されて素数と判断された最高の数字を保存するゲージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checksTimer`: This is a timer, therefore a compound metric that benchmarks how much time the primality tests take. We will explain that one in more details later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`checksTimer` : これはタイマーであり、したがって、プライマリテストにどれだけの時間がかかるかをベンチマークする複合メトリックです。これについては後ほど詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source code looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全なソースコードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the microservice in dev mode, use `./mvnw clean compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイクロサービスをdevモードで実行するには、次のようにします。 `./mvnw clean compile quarkus:dev`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Review the generated metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたメトリクスを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To view the metrics, execute `curl -H"Accept: application/json" localhost:8080/q/metrics/application` You will receive a response such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メトリクスを表示するには、 `curl -H"Accept: application/json" localhost:8080/q/metrics/application` を実行します。実行すると次のようなレスポンスが表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's explain the meaning of each metric:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それぞれのメトリックの意味を説明しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checksTimer`: This is a timer, therefore a compound metric that benchmarks how much time the primality tests take. All durations are measured in milliseconds. It consists of these values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`checksTimer` : これはタイマーであり、したがって、プライマリテストにどれだけの時間がかかるかをベンチマークとする複合メトリックです。すべての持続時間はミリ秒単位で測定されます。これらの値で構成されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`min`: The shortest duration it took to perform a primality test, probably it was performed for a small number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`min` : 素数チェックを行うのにかかった時間の最短所要時間、おそらく小さな数に対して行われたものではないかと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`max`: The longest duration, probably it was with a large prime number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`max` : 最長所要時間、おそらく大きな素数に対して行われたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mean`: The mean value of the measured durations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mean` : 計測された所要時間の平均値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`stddev`: The standard deviation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stddev` : 標準偏差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`count`: The number of observations (so it will be the same value as `performedChecks`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`count` : 試行回数(なので `performedChecks` と同じ値になります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`p50, p75, p95, p99, p999`: Percentiles of the durations. For example the value in `p95` means that 95 % of the measurements were faster than this duration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`p50, p75, p95, p99, p999` : 所要時間のパーセンタイル。例えば、 `p95` の値は、試行の95%がこの所要時間よりも速いことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`meanRate, oneMinRate, fiveMinRate, fifteenMinRate`: Mean throughput and one-, five-, and fifteen-minute exponentially-weighted moving average throughput.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`meanRate, oneMinRate, fiveMinRate, fifteenMinRate` : 平均スループットと 1、5、および 15 分間の指数関数的に加重された移動平均スループット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer an OpenMetrics export rather than the JSON format, remove the `-H"Accept: application/json"` argument from your command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON形式ではなくOpenMetricsのエクスポートを希望する場合は、コマンドラインから `-H"Accept: application/json"` 引数を削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Funqy関数をAmazon Lambdaにデプロイする方法をクイックスタートコードで説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] 、ローカルテスト用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy Amazon Lambdasは、 link:amazon-lambda[Quarkus Amazon Lambdaのサポート] をベースに構築されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWSのすべてのツールをインストールすることは、おそらくこのガイドでは最も難しいことです。AWS CLIをインストールするためのすべての手順に従っていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only one Funqy function can be exported per Amazon Lambda deployment.  If you have multiple functions defined within your project, then you will need to choose the function within your Quarkus `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon LambdaデプロイメントごとにエクスポートできるFunqy関数は1つだけです。プロジェクト内で複数の関数を定義している場合は、Quarkus `application.properties` 内で関数を選択する必要があります .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.funqy.export=greet
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.funqy.export=greet
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドとデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the project using maven.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mavenを使ってプロジェクトを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile and package your code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでコードがコンパイルされ、パッケージ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an Execution Role</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行ロールの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define a `LAMBDA_ROLE_ARN` environment variable in your profile or console window, Alternatively, you can edit the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS CLIを使った Lambda のデプロイ方法については、 link:https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] を参照してください。具体的には、 `Execution Role` を作成していることを確認してください。プロファイルやコンソールウィンドウで `LAMBDA_ROLE_ARN` 環境変数を定義する必要があります。また、ビルドで生成される `manage.sh` スクリプトを編集して、そこに直接ロール値を置くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra Build Generated Files</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時に追加生成されるファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function.zip` - lambda deployment file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`function.zip` - Lambda デプロイファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` - wrapper around aws lambda cli calls</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`manage.sh` - aws Lambda CLI の呼び出しのラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.jvm.yaml` - (optional) for use with sam cli and local testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.jvm.yaml` - (オプション) sam cliやローカル・テストで使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.native.yaml` - (optional) for use with sam cli and native local testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.native.yaml` - (オプション) sam cliやネイティブ・ローカル・テストで使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the function</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` supports four operation: `create`, `delete`, `update`, and `invoke`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`manage.sh` は、 `create` , `delete` , `update` , `invoke` の 4 つの操作をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys, and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.  A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS CLIがインストールされていること、AWSアクセスキーのためのaws configureを実行していること、 `LAMBDA_ROLE_ARN` 環境変数を設定していること(上記の通り)を確認するには、 `manage.sh` をパラメーターなしで実行してください。それに応じて利用方法のガイドが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `usage` statement, and validate AWS configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`usage` を参照したり、AWS の設定を検証するためには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can `create` your function using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のコマンドを使って、 Function を `create` します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、このシェルで既に `LAMBDA_ROLE_ARN` が定義されていない場合にはこうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running the `create` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Function の作成に問題がある場合は、 `delete` で Function を削除してから `create` コマンドを再実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commands may also be stacked:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドはスタックすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoke the function</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数の呼出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `invoke` command to invoke your function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数を呼び出すには `invoke` コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are working with your native image build, simply replace the template name with the native version:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージのビルドで作業している場合は、テンプレート名をネイティブバージョンに置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the function</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>functionの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux hosts execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Linuxホストの場合は以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your Maven build: `-Dnative-image.docker-build=true`, or for Gradle: `--docker-build=true`.  This requires you to have docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非Linuxシステムでビルドしている場合は、Amazon Lambdaではlinuxのバイナリーが必要なので、Quarkusにdockerビルドを使用するように指示するプロパティーを渡す必要があります。これは、このプロパティーをMavenビルドに渡すことで行うことができます: `-Dnative-image.docker-build=true` 、またはGradleの場合: `--docker-build=true` 。ただし、この場合はローカルにdockerがインストールされている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.  This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのコマンドのいずれかがコンパイルされ、ネイティブの実行イメージが作成されます。また、zip ファイル `target/function.zip` も生成されます。このzipファイルには、 `bootstrap` にリネームされたネイティブ実行イメージが含まれています。これはAWS Lambda Custom (Provided) Runtimeの要件です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change: you'll need to add `native` as the first parameter to the `manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでの説明は上記と全く同じですが、1つ変更点があります: `manage.sh` スクリプトの最初のパラメーターとして `native` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish to work with native image builds.  The script will take care of the rest of the details necessary to manage your native image function deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のように、コマンドはスタックすることができます。唯一の要件は、ネイティブイメージビルドで作業したい場合、最初のパラメーターとして `native` を指定することです。このスクリプトは、ネイティブイメージ関数のデプロイメントを管理するために必要な残りの詳細を処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note about the create command for native is that the `aws lambda create-function` call must set a specific environment variable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ用のcreateコマンドについて注意すべき点は、 `aws lambda create-function` 呼び出しで特定の環境変数を設定しなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A starter template has been generated for both JVM and native execution modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMとネイティブ実行モードの両方に対応したスターターテンプレートが生成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native image can also be locally tested using the `sam.native.yaml` template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージは、 `sam.native.yaml` テンプレートを使ってローカルでテストすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modifying `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`function.zip` の修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any you files and directories you create under your zip directory will be included within `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>zipディレクトリーの下に作成したファイルやディレクトリーは、すべて `function.zip` に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom `bootstrap` script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタム `bootstrap` スクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable must be referenced as `runner` if you include a custom `bootstrap` script.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタム `bootstrap` スクリプトを含む場合は、ネイティブ実行ファイルを `runner` として参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension generates an example script within `target/bootstrap-example.sh`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、サンプルのスクリプト `target/bootstrap-example.sh` を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers generating and deploying OpenShift resources based on sane default and user supplied configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、妥当なデフォルト設定とユーザーが提供する設定に基づいたOpenShiftリソースの生成とデプロイについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>roughly 5 minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ざっと五分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>access to an OpenShift cluster (Minishift is a viable option)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShift クラスターへのアクセス(Minishift も選択可能なオプションです)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift CLI (Optional. Only required for manually deploying)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShift CLI (オプション。手動でデプロイする場合のみ必要)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project that contains the OpenShift extension. This can be done using the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、OpenShift エクステンションを含む新しいプロジェクトが必要です。これは以下のコマンドを使用して行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers the ability to automatically generate OpenShift resources based on sane default and user supplied configuration.  The OpenShift extension is actually a wrapper extension that brings together the link:deploying-to-kubernetes[kubernetes] and link:container-image#s2i[container-image-s2i] extensions with sensible defaults so that it's easier for the user to get started with Quarkus on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、妥当なデフォルトとユーザーが提供する設定に基づいてOpenShiftリソースを自動的に生成する機能を提供します。OpenShift エクステンションは、実際には link:deploying-to-kubernetes[kubernetes] エクステンションと link:container-image#s2i[container-image-s2i] エクステンションをよく考えられたデフォルトでまとめたラッパーエクステンションであり、ユーザーがOpenShift上でQuarkusを使い始めるのを容易にするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When we added the OpenShift extension to the command line invocation above, the following dependency was added to the `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のコマンドライン呼び出しにOpenShift エクステンションを追加すると、以下のような依存関係が `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding this dependency, we now have the ability to configure the OpenShift resource generation and application using the usual `application.properties` approach that Quarkus provides.  The configuration items that are available can be found in: `io.quarkus.kubernetes.deployment.OpenShiftConfig` class.  Furthermore, the items provided by `io.quarkus.deployment.ApplicationConfig` affect the OpenShift resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この依存関係を追加することで、Quarkusが提供している通常の `application.properties` のアプローチでOpenShiftリソースの生成とアプリケーションの設定ができるようになりました。利用できる設定項目は、 `io.quarkus.kubernetes.deployment.OpenShiftConfig` クラスにあります。さらに、 `io.quarkus.deployment.ApplicationConfig` で提供されている項目は OpenShift リソースに影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy (in separate steps)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドとデプロイ(別々のステップで)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the OpenShift extension was not included during the bootstraping of the project nor was it added subsequently (check pom.xml file for it), then it can be added like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのブートストラップ時にOpenShiftエクステンションが含まれていなかったり、その後に追加されなかったりした場合(pom.xmlファイルを確認してください)、以下のように追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building is handled by the link:container-image#s2i[container-image-s2i] extension. To trigger a build:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドは link:container-image#s2i[container-image-s2i] エクステンションによって処理されます。ビルドをトリガーするには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The build that will be performed is an s2i binary build. The input of the build is the jar that has been built locally and the output of the build is an ImageStream that is configured to automatically trigger a deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行されるビルドは s2i バイナリービルドです。ビルドの入力はローカルでビルドされた jar で、ビルドの出力はデプロイを自動的に起動するように設定された ImageStream です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy the container image created in the above step to OpenShift, follow these commands:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の手順で作成したコンテナーイメージをOpenShiftにデプロイするには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above, `oc get is` will list the image stream created.  It should be tagged as &lt;project&gt;/openshift-quickstart:1.0.0-SNAPSHOT.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記では、 `oc get is` で、作成されたイメージストリームが一覧表示されます。&lt;project&gt;/openshift-quickstart:1.0.0-snapshotとタグ付けされているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, `oc get route` will list the route URL for the exposed service "greeting" so that you can use it to test the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、 `oc get route` で、公開されているサービス「greeting」のルートURLをリストアップしてくれるので、アプリケーションのテストに利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non S2i Builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非S2iビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Out of the box the openshift extension is configured to use link:container-image#s2i[container-image-s2i]. However, it's still possible to use other container image extensions like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>openshift エクステンションは link:container-image#s2i[container-image-s2i] を使用するように設定されています。しかし、次のようにして他のコンテナーイメージエクステンションを使用することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#docker[container-image-docker]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:container-image#docker[container-image-docker]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#jib[container-image-jib]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:container-image#jib[container-image-jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a non-s2i container image extension is used, an ImageStream is created that is pointing to an external `dockerImageRepository`. The image is built and pushed to the registry and the ImageStream populates the tags that are available in the `dockerImageRepository`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非 s2i コンテナーイメージエクステンションが使用されている場合、外部の `dockerImageRepository` を指す ImageStream が作成されます。イメージはビルドされてレジストリーにプッシュされ、ImageStream は `dockerImageRepository` において有効なタグを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To select which extension will be used for building the image:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イメージのビルドに使用するエクステンションを選択するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy (in a single step)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドとデプロイ(1つのステップで)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger a build and deployment in a single step:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドとデプロイを1つのステップでトリガーするためには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The aforementioned command will build a jar file locally, trigger a container image build and then apply the generated OpenShift resources.  The generated resources are using OpenShift's `DeploymentConfig` that is configured to automatically trigger a redeployment when a change in the `ImageStream` is noticed.  In other words, any container image build after the initial deployment will automatically trigger redeployment, without the need to delete, update or re-apply the generated resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述のコマンドは、ローカルで jar ファイルをビルドし、コンテナーイメージのビルドをトリガーして、生成された OpenShift リソースを適用します。生成されたリソースは、 `ImageStream` の変更に気づいたときに自動的に再デプロイをトリガーするように設定されている OpenShift の `DeploymentConfig` を使用しています。つまり、最初のデプロイ後のコンテナーイメージビルドであれば、生成されたリソースを削除、更新、再適用する必要がなく、自動的に再デプロイがトリガーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To confirm the above command has created an image stream, a service resource and has deployed the application (has a pod running), apply these commands:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記コマンドでイメージストリーム、サービスリソースが作成され、アプリケーションがデプロイされている(ポッドが実行されている)ことを確認するために、これらのコマンドを適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To expose the created service to a route and test it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作成したサービスを route に公開してテストするには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All available customization options are available in the link:deploying-to-kubernetes#openshift[OpenShift configuration options].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能なカスタマイズオプションはすべて link:deploying-to-kubernetes#openshift[OpenShiftの設定オプション] で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some examples are provided in the sections below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの例は、以下のセクションで提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To expose a `Route` for the Quarkus application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションの `Route` を公開するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.openshift.route.expose=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.openshift.route.expose=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't necessarily need to add this property in the `application.properties`. You can pass it as a command line argument:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロパティーを `application.properties` で追加する必要はありません。コマンドラインの引数として渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.openshift.route.expose=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw clean package -Dquarkus.openshift.route.expose=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same applies to all properties listed below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下にリストされているすべてのプロパティも同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a label in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソースにラベルを追加するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add an annotation in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソースにアノテーションを追加するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift provides multiple ways of defining environment variables:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShiftでは環境変数の定義方法が複数用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import all values from a Secret or ConfigMap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Secret または ConfigMap からすべての値をインポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>interpolate a single value identified by a given field in a Secret or ConfigMap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Secret または ConfigMap の指定されたフィールドで識別される単一の値を補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from key/value pairs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キー/値のペアからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a key/value pair as an environment variable in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソースに環境変数としてキーとバリューのペアを追加する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command above will add `MY_ENV_VAR=foobar` as an environment variable.  Please note that the key `my-env-var` will be converted to uppercase and dashes will be replaced by underscores resulting in `MY_ENV_VAR`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上のコマンドは `MY_ENV_VAR=foobar` を環境変数として追加します。キー `my-env-var` は大文字に変換され、ダッシュはアンダースコアに置き換えられて `MY_ENV_VAR` となることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from Secret</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シークレットからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add all key/value pairs of `Secret` as environment variables just apply the following configuration, separating each `Secret` to be used as source by a comma (`,`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Secret` のすべてのキーと値のペアを環境変数として追加するには、以下の設定を適用し、ソースとして使用する各 `Secret` をカンマ ( `,` ) で区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which would generate the following in the container definition:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>とすると、コンテナーの定義に以下のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extracts a value identified by the `keyName` field from the `my-secret` Secret into a `foo` environment variable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、 `my-secret` Secret から `keyName` フィールドで識別される値を `foo` 環境変数に抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This would generate the following in the `env` section of your container:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、コンテナーの `env` セクションに以下のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add all key/value pairs from `ConfigMap` as environment variables just apply the following configuration, separating each `ConfigMap` to be used as source by a comma (`,`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ConfigMap` からのすべてのキーと値のペアを環境変数として追加するには、以下の設定を適用し、ソースとして使用する各 `ConfigMap` をカンマ ( `,` ) で区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extracts a value identified by the `keyName` field from the `my-config-map` ConfigMap into a `foo` environment variable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、 `my-config-map` ConfigMap から `keyName` フィールドで識別される値を `foo` 環境変数に抽出したものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from fields</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィールドからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's also possible to use the value from another field to add a new environment variable by specifying the path of the field to be used as a source, as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、以下のように、ソースとして使用するフィールドのパスを指定することで、別のフィールドの値を使用して新しい環境変数を追加することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A conflict between two definitions, e.g. mistakenly assigning both a value and specifying that a variable is derived from a field, will result in an error being thrown at build time so that you get the opportunity to fix the issue before you deploy your application to your cluster where it might be more difficult to diagnose the source of the issue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、誤って両方の値を代入したり、変数がフィールドから派生したものであることを指定したりするなど、2つの定義の間で競合が発生すると、ビルド時にエラーが発生します。そのため、問題の原因を診断するのが困難なクラスターにアプリケーションをデプロイする前に問題を修正する機会を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, two redundant definitions, e.g. defining an injection from the same secret twice, will not cause an issue but will indeed report a warning to let you know that you might not have intended to duplicate that definition.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、同じシークレットからのインジェクションを2回定義するなど、2つの冗長な定義があっても問題は発生しませんが、その定義を複製することを意図していなかった可能性があることを知らせる警告が実際に報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backwards compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下位互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previous versions of the OpenShift extension supported a different syntax to add environment variables. The older syntax is still supported but is deprecated, and it's advised that you migrate to the new syntax.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShift エクステンションの以前のバージョンでは、環境変数を追加するための異なる構文がサポートされていました。古い構文はまだサポートされていますが、非推奨となっており、新しい構文に移行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Old vs. new syntax</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>古い構文と新しい構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Old</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>旧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Plain variable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>素の変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.vars.my-env-var=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.vars.my-env-var=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From field</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィールドから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.fields.my-env-var=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.fields.my-env-var=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All from `ConfigMap`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての `ConfigMap` から</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.configmaps=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.configmaps=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All from `Secret`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての `Secret` から</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.xxx.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.xxx.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.secrets=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.secrets=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From one `Secret` field</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ある `Secret` フィールドから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.foo.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.foo.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.foo.value=field`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.foo.value=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.mapping.foo.with-key=field`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.mapping.foo.with-key=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From one `ConfigMap` field</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ある `ConfigMap` フィールドから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.foo.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env-vars.foo.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.openshift.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you redefine the same variable using the new syntax while keeping the old syntax, **ONLY** the new version will be kept, and a warning will be issued to alert you of the problem. For example, if you define both `quarkus.openshift.env-vars.my-env-var.value=foobar` and `quarkus.openshift.env.vars.my-env-var=newValue`, the extension will only generate an environment variable `MY_ENV_VAR=newValue` and issue a warning.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>古い構文を維持したまま新しい構文を使用して同じ変数を再定義した場合、新しいバージョン *のみ* が保持され、警告が表示されて問題を警告します。例えば、 `quarkus.openshift.env-vars.my-env-var.value=foobar` と `quarkus.openshift.env.vars.my-env-var=newValue` の両方を定義した場合、エクステンションは環境変数 `MY_ENV_VAR=newValue` のみを生成し、警告を発行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mounting volumes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ボリュームのマウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenShift extension allows the user to configure both volumes and mounts for the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShiftエクステンションを使用すると、アプリケーションのボリュームとマウントの両方を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any volume can be mounted with a simple configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どんなボリュームでも、簡単な構成でマウントすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add a mount to my pod for volume `my-volume` to path `/where/to/mount`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 Podのパス  `/where/to/mount` にボリューム `my-volume` のマウントを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The volumes themselves can be configured as shown in the sections below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ボリューム自体は、以下のセクションに示すように設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret volumes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シークレットのボリューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift also provides the ability to use Knative via the link:https://www.openshift.com/learn/topics/serverless[OpenShift Serverless] functionality.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、OpenShiftでは、OpenShift link:https://www.openshift.com/learn/topics/serverless[Serverless] 機能を介してKnativeを利用する機能も提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first order of business is to instruct Quarkus to generate Knative resources by setting:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず最初にQuarkusの設定でKnativeのリソースを生成するように指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to leverage OpenShift S2I to build the container image on the cluster and use the resulting container image for the Knative application, we need to set a couple of configuration properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShift S2I を利用してクラスタ上にコンテナイメージを構築し、その結果のコンテナイメージをKnativeアプリケーションで使用するためには、いくつかの設定プロパティを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can then be deployed to OpenShift Serverless by enabling the standard `quarkus.kubernetes.deploy=true` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、標準の `quarkus.kubernetes.deploy=true` プロパティを有効にすることで、アプリケーションを OpenShift Serverless にデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides integration with https://jbang.dev[jbang] which allows you to write Java scripts/applications requiring no Maven nor Gradle to get running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは link:https://jbang.dev[jbang] との統合を提供しており、MavenもGradleも必要としないJavaスクリプト/アプリケーションを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will see how you can write a REST application using just a single Java file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、1つのJavaファイルだけを使ってRESTアプリケーションを書く方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM installed if you want to run in native mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードで実行する場合は、GraalVM がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally we would link to a Git repository to clone but in this case there is no additional files than the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常はGitリポジトリにリンクしてクローンするのですが、今回は以下のみで追加ファイルはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint with a single source file, no additional build files like `pom.xml` or `build.gradle` needed. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 `hello` エンドポイントを提供する簡単なアプリケーションを、 `pom.xml` や `build.gradle` のような追加のビルドファイルを必要とせず、単一のソースファイルで作成します。依存関係の注入を実証するために、このエンドポイントは `greeting` Beanを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started-architecture.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>getting-started-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the initial file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初期ファイルの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a Java file. jbang lets you create an initial version using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、Javaファイルが必要です。jbangを使うと初期バージョンを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a .java file that you can directly run on Linux and macOS, i.e. `./quarkusapp.java` - on Windows you need to use `jbang quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jbang quarkusapp.java` このコマンドは.javaファイルを生成し、LinuxやmacOS、つまり `./quarkusapp.java` で直接実行できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This initial version will print `Hello World` when run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この初期バージョンは、実行すると `Hello World` が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたら、 `quarkusapp.java` を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will find at the top a line looking like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一番上にこんな感じの行があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This line is what on Linux and macOS allows you to run it as a script. On Windows this line is ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この行は、LinuxやmacOSでスクリプトとして実行できるようにするためのものです。Windowsではこの行は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next line</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is illustrating how you add dependencies to this script. This is a feature of `jbang`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このスクリプトに依存関係を追加する方法を説明しています。これは `jbang` の機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go ahead and update this line to include the `quarkus-resteasy` dependency like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この行を更新して、 `quarkus-resteasy` 依存関係を含むようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, run `jbang quarkusapp.java` and you will see `jbang` resolving this dependency and building the jar with help from Quarkus' jbang integration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、 `jbang quarkusapp.java` を実行すると、 `jbang` がこの依存関係を解決し、Quarkus の jbang 統合の助けを借りて jar をビルドしていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now the application does nothing new.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところ、アプリケーションは何も新しいことをしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I edit this file and get content assist?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このファイルを編集してコンテンツアシストを受けるにはどうすればいいですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As there is nothing but a `.java` file, most IDE's don't handle content assist well.  To work around that you can run `jbang edit quarkusapp.java`, this will print out a directory that will have a temporary project setup you can use in your IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`.java` ファイルしかないので、ほとんどの IDE はコンテンツアシストをうまく処理できません。これを回避するには、 `jbang edit quarkusapp.java` を実行すると、IDE で使用できる一時的なプロジェクトの設定があるディレクトリーが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux/macOS you can run `&lt;idecommand&gt; `jbang edit quarkusapp.java``.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Linux/macOSでは、 `&lt;idecommand&gt; `jbang edit quarkusapp.java`` で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you add dependencies while editing you can get jbang to automatically refresh the IDE project using `jbang edit --live=&lt;idecommand&gt; quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>編集中に依存関係を追加した場合は、 `jbang edit --live=&lt;idecommand&gt; quarkusapp.java` を使用して、IDE プロジェクトを自動的に更新するように jbang を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let us replace the class with one that uses Quarkus features:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、Quarkusの機能を使用するクラスに置き換えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple class with a main method that starts Quarkus with a REST endpoint, returning "hello" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTエンドポイントでQuarkusを起動し、「/hello」上のリクエストに「hello」を返すメインメソッドを持つ非常にシンプルなクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why is the `main` method there?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜそこに `main` メソッドがあるのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `main` method is currently needed for the `jbang` integration to work - we might remove this requirement in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jbang` の統合が機能するためには、現在 `main` メソッドが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run the application you will see Quarkus start up.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでアプリケーションを実行すると、Quarkusが起動するのがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use: `jbang quarkusapp.java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用方法: `jbang quarkusapp.java`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動したら、提供されたエンドポイントにリクエストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After that, hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、 `CTRL+C` を叩いてアプリケーションを停止させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`curl -w "\n"` で自動的に改行を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例では、 `curl -w "\n"` を使用して、結果と次のコマンドプロンプトが同じ行に表示されるのを防止しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why is `quarkus-resteasy` not resolved?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy` が解決されないのはなぜですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this second run you should not see a line saying it is resolving `quarkus-resteasy` as jbang caches the dependency resolution between runs.  If you want to clear the caches to force resolution use `jbang cache clear`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この2回目の実行では、jbangが実行間の依存関係の解決をキャッシュしているため、 `quarkus-resteasy` を解決しているという行は表示されないはずです。キャッシュをクリアして強制的に解決したい場合は `jbang cache clear` を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  You can learn more about it in the link:cdi-reference[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの依存性インジェクションは、Quarkusのアーキテクチャに合わせて調整されたCDIベースの依存性インジェクションソリューションであるArCをベースにしています。ArCの詳細については、 link:cdi-reference[コンテキストと依存性注入ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ArCは `quarkus-resteasy` の依存関係として提供されているので、すでに追加済です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを修正してコンパニオンBeanを追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally you would add a separate class, but as we are aiming to have it all in one file you will add a nested class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常は別のクラスを追加しますが、一つのファイルにまとめようとしているので、入れ子クラスを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following *inside* the `quarkusapp` class body.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkusapp` クラスのボディ *内に* 以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use of nested static public classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネストされた静的パブリッククラスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using a nested static public class instead of a top level class for two reasons:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トップレベルのクラスではなく、ネストされた静的パブリッククラスを使用しているのには、2つの理由があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang currently does not support multiple source files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbangは現在、複数のソースファイルをサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Java frameworks relying on introspection have challenges using top level classes as they are not as visible as public classes; and in Java there can only be one top level public class in a file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イントロスペクションに依存するすべてのJavaフレームワークは、トップレベルのクラスを使用することに課題があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `quarksapp` class to inject the `GreetingService` and create a new endpoint using it, you should end up with something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarksapp` クラスを編集して `GreetingService` を注入し、それを使って新しいエンドポイントを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run `jbang quarkusapp.java` you can check what the new end point returns:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、 `jbang quarkusapp.java` を実行すると、新しいエンドポイントが何を返すかを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that is unexpected, why is it returning `hello null` and not `hello quarkus`?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、予想に反して、なぜそれは `hello quarkus` ではなく `hello null` を返しているのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason is that JAX-RS `@PathParam` relies on the `-parameters` compiler flag to be set to be able to map `{name}` to the `name` parameter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、JAX-RS `@PathParam` は `{name}` を `name` パラメーターにマッピングできるように `-parameters` コンパイラフラグを設定することに依存しているためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We fix that by adding the following comment instruction to the file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ファイルに以下のコメント命令を追加することで修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run with `jbang quarkusapp.java` the end point should return what you expect:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、 `jbang quarkusapp.java` で実行すると、エンドポイントは期待通りの値を返すようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To debug the application you use `jbang --debug quarkusapp.java` and you can use your IDE to connect on port 4004; if you want to use the more traditional Quarkus debug port you can use `jbang --debug=5005 quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`jbang --debug=5005 quarkusapp.java` アプリケーションのデバッグには `jbang --debug quarkusapp.java` を使用し、IDEを使用してポート4004で接続することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: `jbang` debugging always suspends thus you need to connect the debugger to have the application run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注意: `jbang` デバッグは常にサスペンドしているので、アプリケーションを実行させるにはデバッガーを接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use logging in Quarkus scripting with jbang you do as usual, with configuring a logger, i.e.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbangを使ってQuarkusスクリプトでロギングを使用するには、通常通りロガーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get it to work you need to add a Java option to ensure the logging is initialized properly, i.e.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを動作させるには、ロギングが適切に初期化されるように Java オプションを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With that in place running `jbang quarkusapp.java` will log and render as expected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで `jbang quarkusapp.java` を実行すると、期待通りにログが記録され、レンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `//Q:CONFIG &lt;property&gt;=&lt;value&gt;` to set up static configuration for your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`//Q:CONFIG &lt;property&gt;=&lt;value&gt;` を使用して、アプリケーションの静的設定を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I.e. if you wanted to add the `smallrye-openapi` and `swagger-ui` extensions and have the Swagger UI always show up you would add the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `smallrye-openapi` と `swagger-ui` のエクステンションを追加して Swagger UI を常に表示させたい場合は、以下のように追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now during build the `quarkus.swagger-ui.always-include` will be generated into the resulting jar and `http://0.0.0.0:8080/q/swagger-ui` will be available when run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでビルド中に `quarkus.swagger-ui.always-include` が生成され、結果の jar と実行時に `http://0.0.0.0:8080/q/swagger-ui` が利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running as a native application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブアプリケーションとしての実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have the `native-image` binary installed and `GRAALVM_HOME` set, you can get the native executable built and run using `jbang --native quarkusapp.java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`native-image` バイナリーがインストールされていて `GRAALVM_HOME` が設定されている場合は、 `jbang --native quarkusapp.java` を使用してネイティブの実行ファイルをビルドして実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This native build will take some time on first run but any subsequent runs (without changing `quarkusapp.java`) will be close to instant thanks to jbang cache:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このネイティブビルドは最初の実行時には時間がかかりますが、その後の実行では ( `quarkusapp.java` を変更せずに) jbang キャッシュのおかげですぐに実行できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to get started with Quarkus or write something quickly, Quarkus Scripting with jbang lets you do that. No Maven, no Gradle - just a Java file. In this guide we outlined the very basics on using Quarkus with jbang; if you want to learn more about what jbang can do, go see https://jbang.dev.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusを使い始めたい場合や、何かを素早く書きたい場合は、Quarkus Scripting with jbangを使用すると、それが可能になります。MavenもGradleも必要ありません。このガイドでは、jbangを使ったQuarkusの使い方の基本を説明しました。jbangで何ができるのかをもっと知りたい方は、 https://jbang.dev をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Cassandra® is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Cassandra®は、フリーでオープンソースの分散型ワイドカラムストアのNoSQLデータベース管理システムで、多くのコモディティサーバーにまたがる大量のデータを処理するように設計されており、単一障害点のない高可用性を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will see how you can get your REST services to use a Cassandra database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスでCassandraデータベースを使用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this quickstart guide, you need:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドを完成させるには、以下が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://www.graalvm.org/[GraalVM] installed with the `GRAALVM_HOME` environment variable configured appropriately, if you want to link:https://quarkus.io/guides/building-native-image[use the native mode];</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードを使用したい場合は、 `GRAALVM_HOME` が適切に設定された GraalVM がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running link:https://cassandra.apache.org[Apache Cassandra], link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) or link:https://astra.datastax.com[DataStax Astra] database; or alternatively, a fresh Docker installation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>稼働中の link:https://cassandra.apache.org[Apache Cassandra]、 link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise]（DSE）、または link:https://astra.datastax.com[DataStax Astra]データベース、あるいはきれいなDockerのインストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This quickstart guide shows how to build a REST application using the link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus extension], which allows you to connect to an Apache Cassandra, DataStax Enterprise (DSE) or DataStax Astra database, using the link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java driver].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクイックスタート・ガイドでは、 link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Javaドライバー]を使用してApache Cassandra、DataStax Enterprise（DSE）、またはDataStax Astraデータベースに接続できる link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkusエクステンション]を使用してRESTアプリケーションを構築する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this quickstart guide is quite simple: the user can add elements in a list using a form, and the items list is updated. All the information between the browser and the server is formatted as JSON, and the elements are stored in the Cassandra database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで構築されたアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、アイテムリストが更新されます。ブラウザーとサーバー間の情報はすべてJSONフォーマットで、各要素はCassandraデータベースに保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[quickstart directory] of the Cassandra Quarkus extension GitHub repository.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `quickstart` link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create a new Maven project and copy the `pom.xml` file that is present in the `quickstart` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、新しいMavenプロジェクトを作成し、 `quickstart` ディレクトリーに存在する `pom.xml` ファイルをコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `pom.xml` is importing all the Quarkus extensions and dependencies you need.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` 、必要なQuarkusのエクステンションや依存関係をすべてインポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Data Model and Data Access Objects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データモデルとデータアクセスオブジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create our data model – represented by the `Fruit` class – as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、以下のように `Fruit` クラスであらわされるデータもデールを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As stated above, we are using the DataStax Object Mapper. In other words, we are not going to write our CQL queries manually; instead, we will annotate our data model with a few annotations, and the mapper will generate proper CQL queries underneath.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述のとおり、ここではDataStax Object Mapperを使用しています。つまり、CQLクエリーを手動で記述するのではなく、データ・モデルにいくつかのアノテーションを付け、裏側でマッパーが適切なCQLクエリーを生成するのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is why the `Fruit` class is annotated with `@Entity`: this annotation marks it as an _entity class_ that is mapped to a Cassandra table. Its instances are meant to be automatically persisted into, and retrieved from, the Cassandra database. Here, the table name will be inferred from the class name: `fruit`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これが、 `Fruit` クラスが `@Entity` でアノテーションされている理由です。このアノテーションは、Cassandraテーブルにマッピングされる _エンティティ・クラス_としてマークされます。このクラスのインスタンスは、Cassandraデータベースに自動的に永続化され、そこから取得されます。ここでは、テーブル名はクラス名から推測されます： `fruit` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last missing piece is the REST API that will expose GET and POST methods:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に必要なのは、GETとPOSTのメソッドを公開するREST APIです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DTO classes used by the JSON serialization layer are required to have a default no-arg constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSONのシリアライゼーションレイヤーで使用されるDTOクラスは、デフォルトの引数なしのコンストラクタが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we are using a single instance running on localhost, and the keyspace containing our data is `k1`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、localhost上で動作する単一のインスタンスを使用しており、データを含むキースペースは `k1` となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A sample configuration for DataStax Astra should look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DataStax Astraのサンプル構成は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the full list of settings, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定の全リストを見るには、 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[ドライバーの設定リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure that the setting `quarkus.cassandra.local-datacenter` matches the datacenter of your Cassandra cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定 `quarkus.cassandra.local-datacenter` が、Cassandraクラスターのデータセンターと一致していることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't know the name of your local datacenter, this value can be found by running the following CQL query: `SELECT data_center FROM system.local`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルのデータセンターの名前がわからない場合は、以下の CQL クエリを実行することでこの値を見つけることができます : `SELECT data_center FROM system.local` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next you need to create the keyspace and table that will be used by your application. If you are using Docker, run the following commands:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、アプリケーションで使用するキースペースとテーブルを作成する必要があります。Dockerを使用している場合は、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、 `FruitResource` と対話するためのシンプルなウェブページを追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, the method `updateAsync` returns a `Uni` - it is automatically converted from the original result set returned by the driver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、メソッド `updateAsync` は `Uni` を返します。これは、ドライバーが返す元の結果セットから自動的に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cassandra driver uses the Reactive Streams `Publisher` API for reactive calls. The Quarkus framework however uses Mutiny. Because of that, the `CqlQuarkusSession` interface transparently converts the `Publisher` instances returned by the driver into the reactive type `Multi`.  `CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` – in this case, the publisher is expected to emit at most one row, then complete. This is suitable for write queries (they return no rows), or for read queries guaranteed to return one row at most (count queries, for example).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cassandraドライバは、リアクティブコールにReactive Streamsの `Publisher` APIを使用しています。しかし、QuarkusフレームワークではMutinyを使用しています。そのため、 `CqlQuarkusSession` インターフェイスは、ドライバが返す `Publisher` インスタンスを透過的にリアクティブ型の `Multi` に変換します。 `CqlQuarkusSession` は `Publisher` を `Uni` に変換することもできます - この場合、パブリッシャーは最大で1行を出力し、その後完了することが期待されます。これは書き込みクエリ(行を返さない)や、最大で1行を返すことが 保証されている読み込みクエリ(例えばカウントクエリ)に適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now interact with your reactive REST service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、リアクティブな REST サービスと対話できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing a Cassandra database from a client application is easy with Quarkus and the Cassandra extension, which provides configuration and native support for the DataStax Java driver for Apache Cassandra.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアント・アプリケーションからのCassandraデータベースへのアクセスは、QuarkusとCassandraエクステンションで簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>資格情報プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: guides-configuration-reference
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: guides-configuration-reference
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは以下の使い方を解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The access tokens managed by these extensions can be used as HTTP Authorization Bearer tokens to access the remote services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのエクステンションで管理されているアクセストークンをHTTP Authorization Bearerトークンとして使用して、リモートサービスにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OidcClient</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OidcClient</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using SmallRye Mutiny `Uni` and `Vert.x WebClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client` エクステンションは、SmallRye Mutiny `Uni` および `Vert.xWebClient` を使用してトークンを取得および更新するために使用できるリアクティブな `io.quarkus.oidc.client.OidcClient` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OidcClient` は自動検出または手動で構成することができる IDP トークンのエンドポイント URL でビルド時に初期化され、このエンドポイントを使用して `client_credentials` または `password` トークングラントを使用してアクセストークンを取得し、 `refresh_token` グラントを使用してトークンを更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how `OidcClient` can be configured to use the `client_credentials` grant:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OidcClient` が `client_credentials` グラントを使用するように設定する方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `client_credentials` grant allows to set extra parameters to the token request via `quarkus.oidc-client.grant-options.client.&lt;param-name&gt;=&lt;value&gt;`. Here is how to set the intended token recipient via the `audience` parameter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`client_credentials` グラントにより、`quarkus.oidc-client.grant-options.client.&lt;param-name&gt;=&lt;value&gt;` を介してトークンリクエストに追加のパラメータを設定できます。 `audience` パラメータを使用して目的のトークン受信者を設定する方法は次のとおりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how `OidcClient` can be configured to use the `password` grant:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OidcClient` が `password` グラントを使用するように設定する方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret
quarkus.oidc-client.grant.type=password
quarkus.oidc-client.grant-options.password.username=alice
quarkus.oidc-client.grant-options.password.password=alice
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret
quarkus.oidc-client.grant.type=password
quarkus.oidc-client.grant-options.password.username=alice
quarkus.oidc-client.grant-options.password.password=alice
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらの場合も、 `OidcClient` はトークンのエンドポイントURLを自動検出し、それを使ってトークンを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can use `OidcClient` directly as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のように `OidcClient` を直接使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.PostConstruct;
import javax.inject.Inject;
import javax.ws.rs.GET;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.inject.PostConstruct;
import javax.inject.Inject;
import javax.ws.rs.GET;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.oidc.client.OidcClient;
import io.quarkus.oidc.client.Tokens;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.oidc.client.OidcClient;
import io.quarkus.oidc.client.Tokens;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/service")
public class OidcClientResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/service")
public class OidcClientResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    OidcClient client;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    OidcClient client;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    volatile Tokens currentTokens;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    volatile Tokens currentTokens;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @PostConstruct
    public init() {
        currentTokens = client.getTokens().await().indefinitely();
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @PostConstruct
    public init() {
        currentTokens = client.getTokens().await().indefinitely();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    public String getResponse() {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    public String getResponse() {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Tokens tokens = currentTokens;
        if (tokens.isAccessTokenExpired()) {
            // Add @Blocking method annotation if this code is used with Reactive RestClient
            tokens = client.refreshTokens(tokens.getRefreshToken()).await().indefinitely();
            currentTokens = tokens;
        } 
        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        Tokens tokens = currentTokens;
        if (tokens.isAccessTokenExpired()) {
            // Add @Blocking method annotation if this code is used with Reactive RestClient
            tokens = client.refreshTokens(tokens.getRefreshToken()).await().indefinitely();
            currentTokens = tokens;
        } 
        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-client-filter` extension provides `io.quarkus.oidc.client.filter.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client-filter` エクステンションは `io.quarkus.oidc.client.filter.OidcClientRequestFilter` JAX-RS ClientRequestFilter を提供します。このフィルターは、`OidcClient` を使用してアクセストークンを取得し、必要に応じて更新し、HTTP `Authorization` `Bearer` スキーム値として設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short-lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、このフィルタは初期化時に `OidcClient` を取得してアクセストークンとリフレッシュトークンの最初のペアを取得します。アクセストークンが短命でリフレッシュトークンが利用できない場合は、`quarkus.oidc-client.early-tokens-acquisition=false` でトークンの取得を遅延させるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.client.filter.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.oidc.client.filter.OidcClientFilter` または `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` アノテーションを使用して `OidcClientRequestFilter` を選択的に登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.client.filter.OidcClientFilter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.client.filter.OidcClientFilter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterRestClient
@OidcClientFilter
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterRestClient
@OidcClientFilter
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    String getUserName();
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    String getUserName();
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.client.filter.OidcClientRequestFilter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.client.filter.OidcClientRequestFilter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterRestClient
@RegisterProvider(OidcClientRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterRestClient
@RegisterProvider(OidcClientRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc-client-filter.register-filter=true` property is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、 `quarkus.oidc-client-filter.register-filter=true` プロパティーが設定されている場合、すべての MP Rest または JAX-RS クライアントで `OidcClientRequestFilter` を自動的に登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use injected Tokens</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入されたトークンを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer you can use your own custom filter and inject `Tokens`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご希望の場合は、独自のカスタムフィルターを使用して、 `Tokens` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Provider
@Priority(Priorities.AUTHENTICATION)
public class OidcClientRequestCustomFilter implements ClientRequestFilter {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Provider
@Priority(Priorities.AUTHENTICATION)
public class OidcClientRequestCustomFilter implements ClientRequestFilter {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    Tokens tokens;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    Tokens tokens;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + tokens.getAccessToken());
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + tokens.getAccessToken());
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Tokens` producer will acquire and refresh the tokens, and the custom filter will decide how and when to use the token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Tokens` プロデューサーがトークンを取得・更新し、カスタムフィルターが何時、どのようにトークンを使用するかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also the previous section about delaying the token acquisition in some cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンの取得を遅らせる場合があることについては、前のセクションも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refreshing Access Tokens</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アクセストークンの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `OidcClientRequestFilter` and `Tokens` producer will refresh the current expired access token if the refresh token is available.  Additionally, `quarkus.oidc-client.refresh-token-time-skew` property can be used for a preemptive access token refreshment to avoid sending nearly expired access tokens which may cause HTTP 401 errors. For example if this property is set to `3S` and the access token will expire in less than 3 seconds then this token will be auto-refreshed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OidcClientRequestFilter` と `Tokens` の両プロデューサーは、リフレッシュトークンが利用可能な場合、現在の期限切れアクセストークンをリフレッシュします。さらに、 `quarkus.oidc-client.refresh-token-time-skew` プロパティは、HTTP 401 エラーの原因となる期限切れ間近のアクセストークンの送信を避けるために、アクセストークンのリフレッシュを先取りして行うことができます。例えば、このプロパティが `3S` に設定されていて、アクセストークンが3秒以内に期限切れになる場合、このトークンは自動的にリフレッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the access token needs to be refreshed but no refresh token is available then an attempt will be made to acquire a new token using the configured grant such as `client_credentials`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アクセストークンの更新が必要なのにリフレッシュトークンがない場合は、 `client_credentials` のように設定されたグラントを使って新しいトークンの取得を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that some OpenId Connect Providers will not return a refresh token in a `client_credentials` grant response. For example, starting from Keycloak 12 a refresh token will not be returned by default for `client_credentials`. The providers may also restrict a number of times a refresh token can be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenId Connect Providers の中には、 `client_credentials` グラントレスポンスでリフレッシュトークンを返さないものがありますのでご注意ください。例えば、Keycloak 12以降、 `client_credentials` ではデフォルトでリフレッシュ・トークンが返されません。また、プロバイダによっては、リフレッシュ・トークンの使用回数が制限されている場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OidcClients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OidcClients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.client-enabled=false
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.client-enabled=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.jwt-secret.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.jwt-secret.client-id=quarkus-app
quarkus.oidc-client.jwt-secret.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.jwt-secret.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.jwt-secret.client-id=quarkus-app
quarkus.oidc-client.jwt-secret.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note in this case the default client is disabled with a `client-enabled=false` property. The `jwt-secret` client can be accessed like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、デフォルトのクライアントは `client-enabled=false` プロパティーで無効になっていることに注意してください。 `jwt-secret` クライアントは以下のようにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you also use link:security-openid-connect-multitenancy[OIDC multitenancy] and each OIDC tenant has its own associated `OidcClient` then you can use a Vert.x `RoutingContext` `tenantId` attribute, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect-multitenancy[OIDC マルチテナンシーを] 使用し、各 OIDC テナントが独自の関連する `OidcClient` を持っている場合は、 Vert.x `RoutingContext` `tenantId` 属性を例えば次のように使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need you can also create new `OidcClient` programmatically like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要であれば、このようにプログラム的に新しい `OidcClient` を作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OidcClient` has to authenticate to the OpenId Connect Provider for the `client_credentials` and other grant requests to succeed.  All the https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication[OIDC Client Authentication] options are supported, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OidcClient` は、 `client_credentials` やその他のグラントリクエストを成功させるために OpenId Connect Provider に認証する必要があります。 link:https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication[OIDC クライアント認証] オプションはすべてサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client_secret_basic`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`client_secret_basic` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=mysecret
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=mysecret
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client_secret_post`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`client_secret_post`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.client-secret.value=mysecret
quarkus.oidc-client.credentials.client-secret.method=post
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.client-secret.value=mysecret
quarkus.oidc-client.credentials.client-secret.method=post
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client_secret_jwt`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`client_secret_jwt`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`private_key_jwt` with the PEM key file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`private_key_jwt` with the PEM key file:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.key-file=privateKey.pem
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.key-file=privateKey.pem
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`private_key_jwt` with the key store file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`private_key_jwt` PEMキーストアファイル有:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.key-store-file=keystore.jks
quarkus.oidc-client.credentials.jwt.key-store-password=mypassword
quarkus.oidc-client.credentials.jwt.key-password=mykeypassword
quarkus.oidc-client.credentials.jwt.key-id=mykey
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.key-store-file=keystore.jks
quarkus.oidc-client.credentials.jwt.key-store-password=mypassword
quarkus.oidc-client.credentials.jwt.key-password=mykeypassword
quarkus.oidc-client.credentials.jwt.key-id=mykey
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write Wiremock based `QuarkusTestResourceLifecycleManager`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Wiremockベースの `QuarkusTestResourceLifecycleManager` を例えば以下のように書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prepare the REST test endpoints, you can have the test frontend endpoint which uses the injected MP REST client with a registered OidcClient filter to invoke on the downstream endpoint which echoes the token back, for example, see the `integration-tests/oidc-client-wiremock` in the `main` Quarkus repository.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTテストエンドポイントを用意します。注入されたMP RESTクライアントを登録されたOidcClientフィルターで使用するテスト用フロントエンドエンドポイントが、トークンをエコーバックするダウンストリームエンドポイントを呼び出すことができます。例として、 `main` Quarkusリポジトリの `integration-tests/oidc-client-wiremock` を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `application.properties`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` を次のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and finally write the test code. Given the Wiremock-based resource above, the first test invocation should return `access_token_1` access token which will expire in 4 seconds. Use `awaitility` to wait for about 5 seconds, and now the next test invocation should return `access_token_2` access token which confirms the expired `access_token_1` access token has been refreshed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして最後にテストコードを書きます。上記の Wiremock ベースのリソースがある場合、最初のテスト起動では `access_token_1` アクセストークンが返却されますが、このアクセストークンは 4 秒で期限切れになります。 `awaitility` を使用して約 5 秒間待つと、次のテスト起動時に `access_token_2` アクセストークンが返され、期限切れの `access_token_1` アクセストークンがリフレッシュされたことが確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Token endpoint configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンエンドポイントの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the token endpoint address is discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc-client.auth-server-url`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、設定された `quarkus.oidc-client.auth-server-url` に `/.well-known/openid-configuration` のパスを追加することで、トークンのエンドポイントアドレスが検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, if the discovery endpoint is not available or you would like to save on the discovery endpoint roundtrip, you can disable the discovery and configure the token endpoint address with a relative path value, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、ディスカバリーエンドポイントが利用できない場合や、ディスカバリーエンドポイントのラウンドトリップを節約したい場合は、ディスカバリーを無効にして、トークンエンドポイントのアドレスを相対パスの値で設定することができます。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-token-propagation` extension provide `io.quarkus.oidc.token.propagation.AccessTokenRequestFilter` and `io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter` JAX-RS ClientRequestFilters which propagates the current link:security-openid-connect[Bearer] or link:security-openid-connect-web-authentication[Authorization Code Flow] access token as an HTTP `Authorization` `Bearer` scheme value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-token-propagation` エクステンションは、 `io.quarkus.oidc.token.propagation.AccessTokenRequestFilter` と `io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter` JAX-RS ClientRequestFilters を提供します。これは、現在のベアラーまたは認証コードフローのアクセストークンを HTTP `Authorization` `Bearer` スキーム値として伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AccessTokenRequestFilter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AccessTokenRequestFilter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AccessTokenRequestFilter` treats all tokens as Strings and as such it can work with both JWT and opaque tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AccessTokenRequestFilter` は、すべてのトークンをStringとして扱うため、JWTトークンと不透明なトークンの両方を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can selectively register `AccessTokenRequestFilter` by using either `io.quarkus.oidc.token.propagation.AccessToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.oidc.token.propagation.AccessToken` または `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` のいずれかを使用して、 `AccessTokenRequestFilter` を選択的に登録できます。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.AccessToken;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.AccessToken;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterRestClient
@AccessToken
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterRestClient
@AccessToken
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.AccessTokenRequestFilter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.AccessTokenRequestFilter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterRestClient
@RegisterProvider(AccessTokenRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterRestClient
@RegisterProvider(AccessTokenRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, `AccessTokenRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc-token-propagation.register-filter` property is set to `true` and `quarkus.oidc-token-propagation.json-web-token` property is set to `false` (which is a default value).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、 `quarkus.oidc-token-propagation.register-filter` プロパティが `true` に設定され、 `quarkus.oidc-token-propagation.json-web-token` プロパティが `false` に設定されている場合（デフォルト値です）、すべての MP Rest または JAX-RS クライアントで `AccessTokenRequestFilter` を自動的に登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JsonWebTokenRequestFilter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JsonWebTokenRequestFilter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`JsonWebTokenRequestFilter` makes it easy for `Service A` implemementations to update the injected `org.eclipse.microprofile.jwt.JsonWebToken` with the new `issuer` and `audience` claim values and secure the updated token again with a new signature. The only difficult step is to ensure `Service A` has a signing key - it should be provisioned from a secure file system or from the remote secure storage such as Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`JsonWebTokenRequestFilter` は、 `Service A` の実装が、注入された `org.eclipse.microprofile.jwt.JsonWebToken` を新しい `issuer` と `audience` のクレーム値で更新し、更新されたトークンを新しい署名で再度保護することを容易にします。唯一の難しいステップは、 `Service A` に署名鍵を持たせることです。署名鍵は、安全なファイルシステムまたは Vault などのリモートの安全なストレージからプロビジョニングする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can selectively register `JsonWebTokenRequestFilter` by using either `io.quarkus.oidc.token.propagation.JsonWebToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、 `io.quarkus.oidc.token.propagation.JsonWebToken` または `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` を使用して、 `JsonWebTokenRequestFilter` を選択的に登録することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.JsonWebToken;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.JsonWebToken;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterRestClient
@RegisterProvider(JsonWebTokenTokenRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterRestClient
@RegisterProvider(JsonWebTokenTokenRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.oidc-token-propagation.secure-json-web-token=true
smallrye.jwt.sign.key.location=/privateKey.pem
# Set a new issuer
smallrye.jwt.new-token.issuer=http://frontend-resource
# Set a new audience
smallrye.jwt.new-token.audience=http://downstream-resource
# Override the existing token issuer and audience claims if they are already set
smallrye.jwt.new-token.override-matching-claims=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.oidc-token-propagation.secure-json-web-token=true
smallrye.jwt.sign.key.location=/privateKey.pem
# Set a new issuer
smallrye.jwt.new-token.issuer=http://frontend-resource
# Set a new audience
smallrye.jwt.new-token.audience=http://downstream-resource
# Override the existing token issuer and audience claims if they are already set
smallrye.jwt.new-token.override-matching-claims=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can generate the tokens as described in link:security-openid-connect#integration-testing[OpenId Connect Bearer Token Integration testing] section.  Prepare the REST test endpoints, you can have the test frontend endpoint which uses the injected MP REST client with a registered token propagation filter to invoke on the downstream endpoint, for example, see the `integration-tests/oidc-token-propagation` in the `main` Quarkus repository.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-openid-connect#integration-testing[OpenId Connect Bearer Token Integration testing]のセクションで説明したように、トークンを生成することができます。RESTテストエンドポイントを準備します。注入されたMP RESTクライアントを使用するテストフロントエンドエンドポイントは、登録されたトークン伝搬フィルターを使用して、ダウンストリームエンドポイントで呼び出すことができます。例えば、 `main` Quarkusリポジトリの `integration-tests/oidc-token-propagation` を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブルートの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive routes propose an alternative approach to implement HTTP endpoints where you declare and chain _routes_.  This approach became very popular in the JavaScript world, with frameworks like Express.Js or Hapi.  Quarkus also offers the possibility to use reactive routes.  You can implement REST API with routes only or combine them with JAX-RS resources and servlets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Routesは、HTTPエンドポイントを実装するために、 _routes_ を宣言して連鎖させる代替アプローチを提案します。このアプローチは、Express.JsやHapiのようなフレームワークで、JavaScriptの世界で非常に人気があります。Quarkusは、Reactive Routesを使用する可能性も提供しています。ルートのみでREST APIを実装することもできますし、JAX-RSリソースやサーブレットと組み合わせて実装することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code presented in this guide is available in this {quickstarts-base-url}[Github repository] under the {quickstarts-tree-url}/reactive-routes-quickstart[`reactive-routes-quickstart` directory]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで紹介するコードは、{quickstarts-base-url}[Github リポジトリ]の{quickstarts-tree-url}/reactive-routes-quickstart[ `reactive-routes-quickstart` ディレクトリー]の下にある{quickstarts-base-url}[Github リポジトリ]にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, let's have a look at the HTTP layer of Quarkus.  Quarkus HTTP support is based on a non-blocking and reactive engine (Eclipse Vert.x and Netty).  All the HTTP requests your application receive are handled by _event loops_ (IO Thread) and then are routed towards the code that manages the request.  Depending on the destination, it can invoke the code managing the request on a worker thread (Servlet, Jax-RS) or use the IO Thread (reactive route).  Note that because of this, a reactive route must be non-blocking or explicitly declare its blocking nature (which would result by being called on a worker thread).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先に進む前に、QuarkusのHTTPレイヤーを見てみましょう。QuarkusのHTTPサポートは、ノンブロッキングでリアクティブなエンジン(Eclipse Vert.xとNetty)に基づいています。アプリケーションが受け取るすべてのHTTPリクエストは、 _イベントループ_ (IOスレッド)によって処理され、リクエストを管理するコードに向かってルーティングされます。宛先に応じて、ワーカースレッド(Servlet、Jax-RS)でリクエストを管理するコードを呼び出すか、IOスレッド(Reactive Routes)を使用します。このため、Reactive Routesはノンブロッキングであるか、そのブロッキング性を明示的に宣言しなければならないことに注意してください (ワーカースレッド上で呼び出されることで結果的にブロッキングされます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-architecture.png[alt=Quarkus HTTP Architecture]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:http-architecture.png[alt=Quarkus HTTP Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declaring reactive routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Routesの宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first way to use reactive routes is to use the `@Route` annotation.  To have access to this annotation, you need to add the `quarkus-vertx-web` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Routesを使用する最初の方法は、 `@Route` アノテーションを使用することです。このアノテーションにアクセスするには、 `quarkus-vertx-web` エクステンションを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` ファイルに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then in a _bean_, you can use the `@Route` annotation as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 _Bean_ では、以下のように `@Route` アノテーションを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.ext.web.RoutingContext`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.ext.web.RoutingContext`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.vertx.web.RoutingExchange`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.vertx.web.RoutingExchange`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.http.HttpServerRequest`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.http.HttpServerRequest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.http.HttpServerResponse`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.http.HttpServerResponse`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.lang.String`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.lang.String`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`routingContext.request().getParam()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`routingContext.request().getParam()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.Optional&lt;String&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.Optional&lt;String&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.List&lt;String&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.List&lt;String&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`routingContext.request().params().getAll()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`routingContext.request().params().getAll()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request Header Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストヘッダーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Route
String helloFromHeader(@Header("My-Header") String header) {
   return header;
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Route
String helloFromHeader(@Header("My-Header") String header) {
   return header;
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request body can be injected into a method parameter annotated with `@io.quarkus.vertx.web.Body`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストボディは、 `@io.quarkus.vertx.web.Body` でアノテーションされたメソッドパラメーターに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`routingContext.getBodyAsString()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`routingContext.getBodyAsString()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.buffer.Buffer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.buffer.Buffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`routingContext.getBody()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`routingContext.getBody()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.json.JsonObject`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.json.JsonObject`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`routingContext.getBodyAsJson()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`routingContext.getBodyAsJson()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.core.json.JsonArray`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx.core.json.JsonArray`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`routingContext.getBodyAsJsonArray()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`routingContext.getBodyAsJsonArray()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see link:openapi-swaggerui[the OpenAPI Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:openapi-swaggerui[OpenAPIガイド] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI] to better document your schema, example, adding header info, or specifying the return type on `void` methods might be usefull :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI ] を使用してスキーマをより良くドキュメント化することができます。例えば、ヘッダ情報を追加したり、 `void` メソッドでリターンタイプを指定したりすると便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Header information about your API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>APIに関するヘッダー情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will generate this OpenAPI schema:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、このOpenAPIスキーマが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:reactive-routes-guide-screenshot01.png[alt=Swagger UI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:reactive-routes-guide-screenshot01.png[alt=Swagger UI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has introduced how you can use reactive routes to define an HTTP endpoint.  It also describes the structure of the Quarkus HTTP layer and how to write filters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Reactive Routesを使用してHTTPエンドポイントを定義する方法を紹介してきました。また、Quarkus HTTPレイヤーの構造とフィルターの書き方についても説明しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with a datastore typically implies first connecting using credentials.  Those credentials will allow the client to be identified, authenticated and eventually authorized.  Username/password based authentication is very common, but that is not by any means the only one.  Such credentials information may appear in the application configuration, but it is becoming increasingly popular to store this type of sensitive information in secure stores, such as HashiCorp Vault, Azure Key Vault or the AWS Secrets Manager to name just a few.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データストアとのやりとりは、通常、最初にクレデンシャルを使用して接続することを意味します。これらのクレデンシャルによって、クライアントは識別され、認証され、最終的には認可されるようになります。ユーザー名/パスワードベースの認証は非常に一般的ですが、それだけではありません。このようなクレデンシャル情報はアプリケーションの設定に存在するかもしれませんが、HashiCorp Vault、Azure Key Vault、AWS Secrets Managerなどのセキュアなストアにこのタイプの機密情報を保存することが一般的になってきています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To bridge datastores that consume credentials, which can take different forms, and secure stores that provide those credentials, Quarkus introduces an intermediate abstraction called `Credentials Provider`, that some extensions may support to consume credentials (e.g. `agroal`), and some others may implement to produce credentials (e.g. `vault`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さまざまな形式をとることができるクレデンシャルを消費するデータストアと、それらのクレデンシャルを提供する安全なストアの橋渡しをするために、Quarkusでは、 `Credentials Provider` と呼ばれる中間的な抽象化を導入しています。これは、一部のエクステンションがクレデンシャルを消費するためにサポートしている場合もあれば(例: `agroal` )、クレデンシャルを生成するために実装している場合もあります(例: `vault` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This Service Programming Interface (SPI) may also be used by implementers that want to support custom providers not yet implemented in Quarkus (e.g. Azure Key Vault).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このService Programming Interface(SPI)は、Quarkusにまだ実装されていないカスタムプロバイダ(Azure Key Vaultなど)をサポートしたい実装者が使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, the `Credentials Provider` interface is implemented by the `vault` extension, and is supported by the following credentials consumer extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在、 `Credentials Provider` インターフェイスは `vault` エクステンションによって実装されており、以下のクレデンシャルコンシューマーエクステンションによってサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`agroal`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`agroal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reactive-db2-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`reactive-db2-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reactive-mysql-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`reactive-mysql-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reactive-pg-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`reactive-pg-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All extensions that rely on username/password authentication also allow setting configuration properties in the `application.properties` as an alternative. But the `Credentials Provider` is the only option if credentials are generated (e.g. `Vault Dynamic DB Credentials`) or if a custom credentials provider is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー名/パスワード認証に依存するすべてのエクステンションでは、代替として `application.properties` で設定プロパティーを設定することもできます。しかし、クレデンシャルが生成されている場合 (例: `Vault Dynamic DB Credentials` ) やカスタムのクレデンシャルプロバイダが必要な場合は `Credentials Provider` が唯一のオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will show how to use the `Credentials Provider` provided in the `vault` extension, then we will look at implementing a custom `Credentials Provider`, and finally we will talk about additional considerations regarding implementing a `Credentials Provider` in a new extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 `vault` エクステンションで提供されている `Credentials Provider` の使い方を紹介し、次にカスタム `Credentials Provider` の実装について見ていき、最後に新しいエクステンションで `Credentials Provider` を実装する際の追加考慮事項について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vault Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vault Credentials Provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure a `Vault Credentials Provider` you need to provide the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Vault Credentials Provider` を設定するには、以下のプロパティーを提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `&lt;name&gt;` will be used in the consumer to refer to this provider. The `&lt;property&gt;` and `&lt;value&gt;` fields are specific to the `Vault Credentials Provider`. For complete details, please refer to the {vault-datasource-guide}.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;name&gt;` は、コンシューマーがこのプロバイダーを参照するために使用されます。 `&lt;property&gt;` および `&lt;value&gt;` フィールドは、 `Vault Credentials Provider` に特有です。完全な詳細については、{vault-datasource-guide}を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once defined, the `mydatabase` provider can be used in any extension that supports the `Credentials Provider` interface. For instance in `agroal`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一度定義すると、 `mydatabase` プロバイダーは `Credentials Provider` インターフェイスをサポートするすべてのエクステンションで使用することができます。例えば、 `agroal` の場合次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `quarkus.datasource.username` is the original `agroal` property, whereas the `password` property is not included because the value will come from the `mydatabase` credentials provider we just defined.  An alternative is to define both username and password in Vault and drop the `quarkus.datasource.username` property from configuration. All consuming extensions do support the ability to fetch both the username and password from the provider, or just the password.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.datasource.username` はオリジナルの `agroal` プロパティですが、値は先ほど定義した `mydatabase`クレデンシャルプロバイダーから取得されるため、`password` プロパティは含まれていません。 別の方法としては、Vault でユーザー名とパスワードの両方を定義し、設定から プロパティーを削除する方法があります。すべてのコンシューマーエクステンションは、ユーザー名とパスワードの両方をプロバイダから取得する機能、またはパスワードのみを取得する機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムクレデンシャルプロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a custom credentials provider is the only option when a vault product is not yet supported in Quarkus, or if credentials need to be retrieved from a custom store.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムクレデンシャルプロバイダーの実装は、QuarkusでVault製品がまだサポートされていない場合や、カスタムストアからクレデンシャルを取得する必要がある場合の唯一のオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only interface to implement is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装するインターフェースはこれだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`USER_PROPERTY_NAME` and `PASSWORD_PROPERTY_NAME` are standard properties that should be recognized by any consuming extension that support username/password based authentication.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`USER_PROPERTY_NAME` と `PASSWORD_PROPERTY_NAME` は、ユーザー名/パスワードベースの認証をサポートするすべてのコンシューマーエクステンションで認識されるべき標準的なプロパティーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is required that implementations be valid `@ApplicationScoped` CDI beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装は有効な `@ApplicationScoped` CDI Beanであることが要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a simple example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単な例を挙げてみます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we decided here to return both the username and the password.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、ユーザー名とパスワードの両方を返すことにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This provider may be used in a datasource definition like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロバイダは、次のようなデータソースの定義で使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to pass configuration properties to the provider using standard MicroProfile Config injection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準的なMicroProfile Configインジェクションを使用して、設定プロパティーをプロバイダに渡すことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And in the provider implementation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、プロバイダの実装では</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Credentials Provider extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいクレデンシャルプロバイダーエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating a custom credentials provider in a new extension, there are a few additional considerations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションでカスタムクレデンシャルプロバイダーを作成する際には、いくつかの追加考慮事項があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to name it to avoid collisions in case multiple credentials providers are available in the project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、プロジェクト内で複数のクレデンシャルプロバイダーが利用可能な場合の衝突を避けるために、名前を付ける必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is the responsibility of the consumer to allow a `credentials-provider-name` property:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`credentials-provider-name` のプロパティを許可するのはコンシューマーの責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension should allow runtime config, such as the `CredentialsProviderConfig` from the `vault` extension to configure any custom property in the provider. For an AWS Secrets Manager extension, this could be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションでは、 `vault` エクステンションの `CredentialsProviderConfig` のように、ランタイム設定でプロバイダー内の任意のカスタムプロパティーを設定できるようにしておく必要があります。AWS Secrets Managerエクステンションの場合は、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`region`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`region`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`credentials-type`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`credentials-type`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`secrets-id`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`secrets-id`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note also that some consumers such as `agroal` will add to their connection configuration any properties returned by the credentials provider, not just the username and password. So when you design the new credentials provider limit the properties to what would be understood by consumers, or provide appropriate configuration options to support different modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `agroal` のようなコンシューマーの中には、ユーザー名とパスワードだけでなく、クレデンシャル・プロバイダが返すプロパティーを接続設定に追加するものがあることにも注意してください。したがって、新しいクレデンシャル・プロバイダーを設計する際には、プロパティーをコンシューマーが理解できるものに限定するか、または異なるモードをサポートするための適切な設定オプションを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are quickly moving to an SSL-everywhere world so being able to use SSL is crucial.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>常時SSL接続の時代へと急速に移行しているので、SSLを利用できることは非常に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native executables to support SSL, as native executables don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブの実行ファイルは標準ではSSLをサポートしていないので、このガイドではネイティブの実行ファイルでSSLをサポートする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't plan on using native executables, you can pass your way as in JDK mode, SSL is supported without further manipulations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK モードでは特に変更しなくても SSL がサポートされているので、ネイティブの実行ファイルを使用する予定がない場合はパスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM (Java 11) installed with `JAVA_HOME` and `GRAALVM_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM (Java 11) をインストールし、 `JAVA_HOME` と `GRAALVM_HOME` を適切に設定しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is based on the REST client guide so you should get this Maven project first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドはRESTクライアントガイドに基づいているので、最初にこのMavenプロジェクトを取得する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is located in the `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトは `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks like it works out of the box?!?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>修正不要にみえる?!?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you open the application's configuration file (`src/main/resources/application.properties`), you can see the following line:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの設定ファイル ( `src/main/resources/application.properties` ) を開くと、以下の行が存在します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which configures our REST client to connect to an SSL REST service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、REST クライアントが SSL REST サービスに接続するように設定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's build the application as a native executable and run the tests:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、アプリケーションをネイティブ実行ファイルとしてビルドし、テストを実行してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we obtain the following result:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、次のような結果が得られます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, yes, it appears it works out of the box and this guide is pretty useless.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、修正不要で動作し、このガイドはかなり役立たずであるように見えますね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not. The magic happens when building the native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実際は、そうではありません。マジックはネイティブ実行ファイルをビルドするときに起こります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Agroal connection pooling extension (`quarkus-agroal`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Agroalコネクションプールエクステンション ( `quarkus-agroal` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Infinispan Client extension (`quarkus-infinispan-client`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan クライアントエクステンション ( `quarkus-infinispan-client` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Jaeger extension (`quarkus-jaeger`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jaeger エクステンション ( `quarkus-jaeger` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the JGit extension (`quarkus-jgit`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JGit エクステンション ( `quarkus-jgit` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Kubernetes client extension (`quarkus-kubernetes-client`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes クライアントエクステンション ( `quarkus-kubernetes-client` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Mailer extension (`quarkus-mailer`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mailer エクステンション ( `quarkus-mailer` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Neo4j extension (`quarkus-neo4j`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4j エクステンション ( `quarkus-neo4j` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Reactive client for PostgreSQL extension (`quarkus-reactive-pg-client`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQLエクステンションのReactiveクライアント ( `quarkus-reactive-pg-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Reactive client for MySQL extension (`quarkus-reactive-mysql-client`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MySQL エクステンションの Reactive クライアント ( `quarkus-reactive-mysql-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Reactive client for DB2 extension (`quarkus-reactive-db2-client`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DB2 エクステンションの Reactive クライアント ( `quarkus-reactive-db2-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Redis client extension (`quarkus-redis-client`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Redis クライアントエクステンション ( `quarkus-redis-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Cassandra client extensions (`cassandra-quarkus-client`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cassandraクライアントエクステンション ( `cassandra-quarkus-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's just check the size of our native executable as it will be useful later:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、あとで役立つので、ネイティブ実行ファイルのサイズを確認してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's disable SSL and see how it goes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、SSLを無効にしてどうなるか見てみましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has an option to disable the SSL support entirely.  Why? Because it comes at a certain cost.  So if you are sure you don't need it, you can disable it entirely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、SSLのサポートを完全に無効にするオプションがあります。なぜでしょうか?それは、一定のコストがかかるからです。ですから、必要ないと確信している場合は、完全に無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's disable it without changing the REST service URL and see how it goes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは、RESTサービスのURLを変えずに無効化して様子を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `src/main/resources/application.properties` and add the following line:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/resources/application.properties` を開いて、以下の行を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And let's try to build again:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、またビルドしてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable tests will fail with the following error:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのテストは、以下のエラーで失敗します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This error is the one you obtain when trying to use SSL while it was not explicitly enabled in your native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエラーは、ネイティブ実行ファイルで明示的に有効にしない状態でSSLを使用しようとしたときに発生するエラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's change the REST service URL to **not** use SSL in `src/main/resources/application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、 `src/main/resources/application.properties` でRESTサービスのURLを変更して、SSLを使用し *ない* ように変更してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And build again:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、再びビルドしましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you check carefully the native executable build options, you can see that the SSL related options are gone:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのビルドオプションをよく確認してみると、SSL関連のオプションがなくなっているのがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we end up with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You remember we checked the size of the native executable with SSL enabled? Let's check again with SSL support entirely disabled:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SSLを有効にしたネイティブ実行ファイルのサイズを確認したのを覚えていますか?SSLサポートを完全に無効にした状態でもう一度確認してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, it is now **35 MB** whereas it used to be **46 MB**. SSL comes with a 11 MB overhead in native executable size.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、以前は *46MB* だったのが *35MB* になりました。SSLはネイティブの実行可能サイズで11MBのオーバーヘッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And there's more to it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、それだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start again with a clean slate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クリーンな状態でもう一回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revert the changes we made to the configuration file and go back to SSL with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定ファイルに変更した内容を元に戻し、以下のコマンドでSSLを有効に戻してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And let's build the native executable again:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、もう一度ネイティブの実行ファイルをビルドしてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior is new to GraalVM 19.3+.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作はGraalVM 19.3+のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating a native binary, GraalVM embraces the principle of "immutable security" for the root certificates.  This essentially means that the root certificates are fixed at image build time, based on the certificate configuration used at that build time (which for Quarkus means when you perform a build having `quarkus.package.type=native` set).  This avoids shipping a `cacerts` file or requiring a system property be set in order to set up root certificates that are provided by the OS where the binary runs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブバイナリーを作成する際、GraalVMはルート証明書の「不変のセキュリティー」の原則を採用しています。これは本質的に、ルート証明書がイメージのビルド時に、そのビルド時に使用される証明書の設定に基づいて固定されることを意味します(Quarkusでは、 `quarkus.package.type=native` を設定してビルドを実行することを意味します)。これにより、 `cacerts` ファイルを出荷したり、バイナリーが実行されるOSによって提供されるルート証明書を設定するためにシステムプロパティーを設定する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, system properties such as `javax.net.ssl.trustStore` do not have an effect at run time, so when the defaults need to be changed, these system properties must be provided at image build time.  The easiest way to do so is by setting `quarkus.native.additional-build-args`. For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その結果、 `javax.net.ssl.trustStore` のようなシステムプロパティーは実行時には影響を及ぼさないため、デフォルトを変更する必要がある場合は、イメージのビルド時にこれらのシステムプロパティーを提供する必要があります。最も簡単な方法は `quarkus.native.additional-build-args` を設定することです。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will ensure that the certificates of `/tmp/mycerts` are baked into the native binary and used *in addition* to the default cacerts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記は `/tmp/mycerts` の証明書がネイティブバイナリーに焼き込まれ、デフォルトの cacerts に *加えて* 使用されることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file containing the custom TrustStore does *not* have to be present at runtime as its content has been baked into the native binary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムTrustStoreを含むファイルは、その内容がネイティブバイナリーに焼き込まれているため、実行時に存在する必要は *ありません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with containers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーへの対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No special action needs to be taken when running the native binary in a container. If the native binary was properly built with the custom TrustStore as described in the previous section, it will work properly in container as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナー内でネイティブバイナリーを実行する際に特別な対応を取る必要はありません。前のセクションで説明したように、ネイティブバイナリーがカスタムTrustStoreを使って適切にビルドされていれば、コンテナー内でも正常に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We make building native executable easy and, even if the SSL support in GraalVM is still requiring some serious thinking, it should be mostly transparent when using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのビルドを簡単にしています。GraalVMでのSSLサポートはまだ真剣に考える必要があるとしても、Quarkusを使用する場合はほとんど透過的になるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We track GraalVM progress on a regular basis so we will promptly integrate in Quarkus any improvement with respect to SSL support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMの進捗状況を定期的に追跡していますので、SSLサポートに関する改善点があれば、速やかにQuarkusに統合していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qute is a templating engine designed specifically to meet the Quarkus needs.  The usage of reflection is minimized to reduce the size of native images.  The API combines both the imperative and the non-blocking reactive style of coding.  In the development mode, all files located in the `src/main/resources/templates` folder are watched for changes and modifications are immediately visible in your application.  Furthermore, Qute attempts to detect most of the template problems at build time and fail fast.  In this guide, you will find an &lt;&lt;hello_world_example,introductory example&gt;&gt;, the description of the &lt;&lt;core_features,core features&gt;&gt; and &lt;&lt;quarkus_integration,Quarkus integration&gt;&gt; details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quteは、Quarkusのニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブイメージのサイズを小さくするために、リフレクションの使用は最小限に抑えられています。APIは、命令型と非ブロッキング反応型のコーディングの両方のスタイルを組み合わせています。開発モードでは、 `src/main/resources/templates` フォルダーにあるすべてのファイルが変更されているかどうかが監視され、変更があった場合はすぐにアプリケーションに反映されます。さらに、Quteはビルド時にテンプレートの問題のほとんどを検出しようとし、早期に失敗します。このガイドでは、 link:#hello_world_example[導入例] 、 link:#core_features[コア機能] の説明、 link:#quarkus_integration[Quarkusの統合] の詳細について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hello World Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ハローワールドの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we'd like to demonstrate the basic workflow when working with Qute templates.  Let's start with a simple hello world example.  We will always need some *template contents*:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、Quteのテンプレートを扱う際の基本的なワークフローをデモしたいと思います。まず、簡単なhello worldの例から始めましょう。 *テンプレートのコンテンツ* は必ず必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hello.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>hello.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{name}` is a value expression that is evaluated when the template is rendered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{name}` は、テンプレートがレンダリングされたときに評価される値の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we will need to parse the contents into a *template definition* Java object.  A template definition is an instance of `io.quarkus.qute.Template`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、その内容を *テンプレート定義* Javaオブジェクトにパースする必要があります。テンプレート定義は、 `io.quarkus.qute.Template` のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Qute "standalone" you'll need to create an instance of `io.quarkus.qute.Engine` first.  The `Engine` represents a central point for template management with dedicated configuration.  Let's use the convenient builder:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quteを"スタンドアロン"で使用する場合は、まず `io.quarkus.qute.Engine` のインスタンスを作成する必要があります。 `Engine` は、専用の設定でテンプレートを管理するための中心点を表しています。便利なビルダーを使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, there is a preconfigured `Engine` available for injection - see &lt;&lt;quarkus_integration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、あらかじめ設定された `Engine` がインジェクション用に利用可能です - link:#quarkus_integration[quarkus_integration] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have an `Engine` instance we could parse the template contents:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Engine` のインスタンスがあれば、テンプレートの内容を解析することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, you can simply inject the template definition. The template is automatically parsed and cached - see &lt;&lt;quarkus_integration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、テンプレートの定義を単純に注入することができます。テンプレートは自動的に解析され、キャッシュされます - link:#quarkus_integration[quarkus_integration] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, we will create a *template instance*, set the data and render the output:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に *テンプレートインスタンス* を作成し、データをセットして出力をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Template.data(String, Object)` is a convenient method that creates a template instance and sets the data in one step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Template.data(String, Object)` は、ワンステップでテンプレートのインスタンスを作成してデータを設定する便利なメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`TemplateInstance.render()` triggers a synchronous rendering, i.e. the current thread is blocked until the rendering is finished. However, there are also asynchronous ways to trigger the rendering and consume the results. For example there is the `TemplateInstance.renderAsync()` method that returns `CompletionStage&lt;String&gt;` or `TemplateInstance.createMulti()` that returns Mutiny's `Multi&lt;String&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TemplateInstance.render()` は同期レンダリングをトリガーします。つまり、レンダリングが終了するまで現在のスレッドはブロックされます。しかし、レンダリングをトリガーして結果を消費する非同期のメソッドもあります。 例えば、 `CompletionStage&lt;String&gt;` を返す `TemplateInstance.renderAsync()` メソッドや、Mutiny の `Multi&lt;String&gt;` を返す `TemplateInstance.createMulti()` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So the workflow is simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なので、ワークフローはシンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create template contents (`hello.html`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートコンテンツを作成する ( `hello.html` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse template definition (`io.quarkus.qute.Template`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートの定義を解析する ( `io.quarkus.qute.Template` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create template instance (`io.quarkus.qute.TemplateInstance`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートインスタンスを作成する ( `io.quarkus.qute.TemplateInstance` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出力をレンダリングする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Engine` is able to cache the definitions so that it's not necessary to parse the contents again and again. In Quarkus, the caching is done automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Engine` は定義をキャッシュすることができるので、何度も内容をパースする必要がありません。Quarkusでは、キャッシュは自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コア機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Building Blocks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本的なビルディングブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The dynamic parts of a template include comments, expressions, sections and unparsed character data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートの動的な部分には、コメント、式、セクション、パースされていない文字データなどがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comment starts with `{!` and ends with `!}`, e.g. `{! This is a comment !}`.  It could be multi-line and may contain expressions and sections: `{! {#if true} !}`.  Of course, the content of a comment is completely ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コメントは `{!` で始まり `!}` で終わります。例： `{! This is a comment !}` 。コメントは複数行で、式やセクションを含むことができます: `{! {#if true} !}` 。もちろん、コメントの内容は完全に無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An &lt;&lt;expressions,expression&gt;&gt; outputs an evaluated value.  It consists of one or more parts.  A part may represent simple properties: `{foo}`, `{item.name}` or virtual methods: `{item.get(name)}`, `{name ?: 'John'}`.  An expression may start with a namespace: `{inject:colors}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#expressions[式] は評価された値を出力します。式は 1 つ以上のパーツから構成されています。パーツは単純なプロパティー: `{foo}` , `{item.name}` や、仮想メソッドを表すことがあります: `{item.get(name)}` , `{name ?: 'John'}` 。式は、名前空間で始まることがあります: `{inject:colors}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sections</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A &lt;&lt;sections,section&gt;&gt; may contain text, expressions and nested sections: `{#if foo}{foo.name}{/if}`.  The name in the closing tag is optional: `{#if active}ACTIVE!{/}`.  It can be empty: `{#myTag image=true /}`.  A section may declare nested section blocks: `{#if item.valid} Valid. {#else} Invalid. {/if}` and decide which block to render.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1 つの link:#sections[セ ク シ ョン] はテキス ト ・ 式 ・ 入れ子に し たセ ク シ ョ ン を含む こ と がで き ます : `{#if foo}{foo.name}{/if}` 。クロージングタグの名前はオプションです: `{#if active}ACTIVE!{/}` 。空にすることもできます: `{#myTag image=true /}` 。セクションは、入れ子になったセクションブロックを宣言することができます: `{#if item.valid} Valid. {#else} Invalid. {/if}` そして、どのブロックをレンダリングするかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unparsed Character Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パース対象外文字データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is used to mark the content that should be rendered but not parsed.  It starts with `{|` and ends with `|}`: `{| &lt;script&gt;if(true){alert('Qute is cute!')};&lt;/script&gt; |}`, and could be multi-line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、レンダリングされるべきだがパースされないコンテンツをマークするために使用されます。 `{|` で始まり `|}` で終わります : `{| &lt;script&gt;if(true){alert('Qute is cute!')};&lt;/script&gt; |}` 、複数行も可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previously, unparsed character data had to start with `{[` and end with `]}`. This syntax is still supported but we encourage users to switch to the new syntax to avoid some common collisions with constructs from other languages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以前は、パース対象外文字データは `{[` で始まり `]}` で終わる必要がありました。この構文はまだサポートされていますが、他の言語の構文とのよくある衝突を避けるために、新しい構文に切り替えることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifiers and Tags</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>識別子とタグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifiers are used in expressions and section tags.  A valid identifier is a sequence of non-whitespace characters.  However, users are encouraged to only use valid Java identifiers in expressions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>識別子は、式やセクションタグで使用されます。有効な識別子は、空白文字以外の文字列です。ただし、式の中では有効な Java 識別子のみを使用することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use bracket notation if you need to specify an identifier that contains a dot, e.g. `{map['my.key']}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドットを含む識別子を指定する必要がある場合は、大括弧表記を使用することができます。例：`{map['my.key']}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When parsing a template document the parser identifies all _tags_.  A tag starts and ends with a curly bracket, e.g. `{foo}`.  The content of a tag must start with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート文書を解析する際、パーサはすべての _タグ_ を識別します。タグは中括弧で始まり、中括弧で終わります。例: `{foo}` タグの内容は次から始まる必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a built-in command: `#`, `!`, `@`, `/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>組み込みコマンド: `#` , `!` , `@` , `/` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it does not start with any of the above it is ignored by the parser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のいずれかで始まらない場合は、パーサによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tag Examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タグの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parsed: an expression that starts with underscore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パース対象: アンダースコアで始まる式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parsed: a comment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パース対象: コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignored: starts with whitespace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>無視対象: 空白で開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignored: starts with `{`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>無視対象: `{` で開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignored: starts with `"`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>無視対象: `"` で開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to use escape sequences `\{` and `\}` to insert delimiters in the text. In fact, an escape sequence is usually only needed for the start delimiter, ie. `\\{foo}` will be rendered as `{foo}` (no parsing/evaluation will happen).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エスケープシーケンス `\{` や `\}` を使ってテキストにデリミタを挿入することも可能です。 実際には、エスケープシーケンスは通常、開始デリミタのためにのみ必要とされます。すなわち、 `\\{foo}` は `{foo}` として描画されます（パース、評価は行われません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removing Standalone Lines From the Template</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートから独立した行を削除する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the parser removes standalone lines from the template output.  A *standalone line* is a line that contains at least one section tag (e.g. `{#each}` and `{/each}`), parameter declaration (e.g. `{@org.acme.Foo foo}`) or comment but no expression and no non-whitespace character.  In other words, a line that contains no section tag or a parameter declaration is *not* a standalone line.  Likewise, a line that contains an _expression_ or a _non-whitespace character_ is *not* a standalone line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、パーサはテンプレート出力からスタンドアロン行を削除します。スタンドアロン *行* とは、少なくとも1つのセクションタグ(例: `{#each}` や `{/each}` )、パラメーター宣言(例: `{@org.acme.Foo foo}` )、コメントを含むが、式を含まず、空白以外の文字を含まない行のことです。言い換えれば、セクションタグやパラメーター宣言を含まない行は、独立した行ではあり *ません* 。同様に、 _式_ や _空白以外の文字_ を含む行もスタンドアロン行ではあり *ません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a standalone line and will be removed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはスタンドアロン行なので削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not a standalone line - contains an expression and non-whitespace characters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタンドアロン行ではない - 式と非空白文字を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not a standalone line - contains no section tag/parameter declaration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタンドアロン行ではない - セクションタグ/パラメーター宣言を含まない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a standalone line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはスタンドアロン行です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Output</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルト出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default behavior can be disabled by setting the property `quarkus.qute.remove-standalone-lines` to `false`.  In this case, all whitespace characters from a standalone line will be printed to the output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、プロパティー( `quarkus.qute.remove-standalone-lines` )を `false` に設定することで、デフォルトの動作を無効にすることができます。この場合、スタンドアロン行のすべての空白文字が出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Output with `quarkus.qute.remove-standalone-lines=false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.qute.remove-standalone-lines=false` での出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An expression outputs a value.  It consists of one or more parts separated by dot (dot notation) or square brackets (bracket notation).  In the `object.property` (dot notation) syntax, the `property` must be a &lt;&lt;identifiers,valid identifier&gt;&gt;.  In the `object[property_name]` (bracket notation) syntax, the `property_name` has to be a non-null &lt;&lt;literals, literal&gt;&gt; value.  An expression could start with an optional namespace followed by a colon (`:`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式は値を出力します。これは、ドット(ドット表記)または角括弧(カッコ表記)で区切られた1つ以上のパーツから構成されています。 `object.property` (ドット表記) 構文では、 `property` は link:#identifiers[有効な識別子] である必要があります。 `object[property_name]` (括弧表記) 構文では、 `property_name` は非 null link:#literals[リテラル] 値である必要があります。式は、コロン ( `:` )が後ろについた名前空間で始まることができます（オプション）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>no namespace, two parts: `item`, `name`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間なし、2つのパーツ: `item` . `name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>equivalent to `{item.name}` but using the bracket notation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{item.name}` と同等ですが、括弧表記を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>namespace `global`, one part: `colors`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>namespace `global` , 1つのパーツ: `colors`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A part of an expression could be a _virtual method_ in which case the name can be followed by a list of comma-separated parameters in parentheses.  A parameter of a virtual method can be either a nested expression or a &lt;&lt;literals, literal&gt;&gt; value.  We call it "virtual" because it does not have to be backed by a real Java method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式のパーツは _仮想メソッド_ である可能性があり、その場合は名前の後に括弧内のコンマで区切られたパラメーターのリストを付けることができます。仮想メソッドのパラメーターは、入れ子になった式か link:#literals[リテラル] 値のどちらかになります。これを「仮想」と呼ぶのは、実際のJavaメソッドに裏打ちされている必要がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual Methods Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>仮想メソッドの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>no namespace, two parts - `item`, `getLabels(1)`, the second part is a virtual method with name `getLabels` and params `1`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間なし、2つのパーツ - `item` , `getLabels(1)` 、2番目のパーツは、名前 `getLabels` と パラメーター `1` を持つ仮想メソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>infix notation that can be used for virtual methods with single parameter, translated to `name.or('John')`; no namespace, two parts - `name`, `or('John')`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`name.or('John')` に翻訳される、単一のパラメーターを持つ仮想メソッドに使用できる 中置 (infix) 記法。名前空間なし、2 つのパーツ - `name` . `or('John')`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Literals</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Literal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>boolean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>boolean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true`, `false`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`true`, `false`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>null</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>null</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`null`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`null`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>string</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>string</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`'value'`, `"string"`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`'value'`, `"string"`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>integer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>long</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>long</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`1l`, `-5L`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`1l`, `-5L`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>double</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>double</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`1D`, `-5d`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`1D`, `-5d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>float</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>float</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`1f`, `-5F`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`1f`, `-5F`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resolution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first part of the expression is always resolved against the &lt;&lt;current_context_object, current context object&gt;&gt;.  If no result is found for the first part it's resolved against the parent context object (if available).  For an expression that starts with a namespace the current context object is found using all the available ``NamespaceResolver``s.  For an expression that does not start with a namespace the current context object is *derived from the position* of the tag.  All other parts of an expression are resolved using all ``ValueResolver``s against the result of the previous resolution.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式の最初のパーツは、常に link:#current_context_object[カレントコンテキストオブジェクト] に対して解決されます。最初のパーツの結果が見つからない場合は、(利用可能な場合) 親コンテキストオブジェクトに対して解決されます。名前空間で始まる式の場合、カレントコンテキストオブジェクトは、利用可能なすべての `NamespaceResolver` を使用して検出されます。名前空間で始まらない式の場合、現在のコンテキストオブジェクトはタグの *位置から派生し* ます。式の他のすべてのパーツは、前の解決結果に対してすべての `ValueResolver` を使用して解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, expression `{name}` has no namespace and single part - `name`.  The "name" will be resolved using all available value resolvers against the current context object.  However, the expression `{global:colors}` has the namespace `global` and single part - `colors`.  First, all available ``NamespaceResolver``s will be used to find the current context object.  And afterwards value resolvers will be used to resolve "colors" against the context object found.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、式 `{name}` には名前空間がなく、単一のパーツ - `name` です。"name"は、カレントコンテキストオブジェクトに対して利用可能なすべての値リゾルバを使用して解決されます。しかし、式 `{global:colors}` には、名前空間 `global` と単一パーツ - `colors` があります。まず、現在のコンテキストオブジェクトを見つけるために、利用可能なすべての `NamespaceResolver` s が使用されます。その後、見つかったコンテキストオブジェクトに対して"colors"を解決するために値リゾルバが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data passed to the template instance are always accessible using the `data` namespace.  This could be useful to access data for which the key is overridden:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート・インスタンスに渡されたデータは、常に `data` 名前空間を使用してアクセスできます。これは、キーがオーバーライドされているデータにアクセスするのに便利かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item` is passed to the template instance as a data object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item` はデータオブジェクトとしてテンプレートインスタンスに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Iterate over the list of derived items.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>派生アイテムのリストを繰り返し処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item` is an alias for the iterated element.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item` は反復要素のエイリアスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `data` namespace to access the `item` data object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`data` 名前空間を使用して、 `item` データ・オブジェクトにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Current Context</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カレントコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an expression does not specify a namespace the _current context object_ is derived from the position of the tag.  By default, the current context object represents the data passed to the template instance.  However, sections may change the current context object.  A typical example is the `with` section that could be used to set the current context object in order to simplify the template structure:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式で名前空間が指定されていない場合、_カレントコンテキストオブジェクト_ はタグの位置から派生します。デフォルトでは、カレントコンテキストオブジェクトはテンプレート・インスタンスに渡されたデータを表します。しかし、セクションは現在のコンテキストオブジェクトを変更することができます。典型的な例は `with` セクションで、テンプレート構造を単純化するためにカレントコンテキストオブジェクトを設定するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`name` is resolved against the `item`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`name` は `item` に対して解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another built-in section that modifies the current context object is `let`/`set`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のコンテキストオブジェクトを変更する別の組み込みセクションは、 `let` / `set` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current context object inside the section is the map of resolved parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクション内の現在のコンテキストオブジェクトは、解決されたパラメーターのマップです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current context can be accessed via the implicit binding `this`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カレントコンテキストは、暗黙のバインディング `this` を通してアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Resolvers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>組込Resolver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs the default value if the previous part cannot be resolved or resolves to `null`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のパーツが解決できなかったり、 `null` に解決された場合のデフォルト値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{person.name ?: 'John'}`, `{person.name or 'John'}`, `{person.name.or('John')}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{person.name ?: 'John'}`, `{person.name or 'John'}`, `{person.name.or('John')}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>orEmpty</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>orEmpty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs an empty list if the previous part cannot be resolved or resolves to `null`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のパーツが解決できなかったり、 `null` に解決された場合に空のリストを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#for pet in pets.orEmpty}{pet.name}{/for}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#for pet in pets.orEmpty}{pet.name}{/for}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shorthand for if-then-else statement. Unlike in &lt;&lt;if_section&gt;&gt; nested operators are not supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>if-then-else文の省略形。 &lt;&lt;if_section&gt;&gt; とは異なり、入れ子になった演算子はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{item.isActive ? item.name : 'Inactive item'}` outputs the value of `item.name` if `item.isActive` resolves to `true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{item.isActive ? item.name : 'Inactive item'}` は、 `item.isActive` が `true` に解決した場合に `item.name` の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logical AND Operator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>論理 AND 演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs `true` if both parts are not `falsy` as described in the &lt;&lt;if_section&gt;&gt;. The parameter is only evaluated if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;if_section&gt;&gt; で説明したように、両方のパーツが `falsy` でない場合に `true` を出力します。このパラメーターは必要な場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{person.isActive &amp;&amp; person.hasStyle}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{person.isActive &amp;&amp; person.hasStyle}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logical OR Operator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>論理 OR 演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs `true` if any of the parts is not `falsy` as described in the &lt;&lt;if_section&gt;&gt;. The parameter is only evaluated if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;if_section&gt;&gt; で説明したように、いずれかのパーツが `falsy` でない場合に `true` を出力します。このパラメーターは必要な場合のみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{person.isActive \</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{person.isActive \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>person.hasStyle}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>person.hasStyle}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The condition in a ternary operator evaluates to `true` if the value is not considered `falsy` as described in the &lt;&lt;if_section&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>三項演算子の条件は、 &lt;&lt;if_section&gt;&gt; で説明したように、値が `falsy` とみなされない場合は `true` と評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In fact, the operators are implemented as "virtual methods" that consume one parameter and can be used with infix notation. For example `{person.name or 'John'}` is translated to `{person.name.or('John')}` and `{item.isActive ? item.name : 'Inactive item'}` is translated to `{item.isActive.ifTruthy(item.name).or('Inactive item')}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実際には、演算子は1つのパラメーターを消費する「仮想メソッド」として実装されており、中置記法で使用することができます。例えば、`{person.name or 'John'}` は `{person.name.or('John')}` に翻訳され、`{item.isActive ? item.name : 'Inactive item'}` は `{item.isActive.ifTruthy(item.name).or('Inactive item')}` に翻訳されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arrays</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can iterate over elements of an array with the &lt;&lt;loop_section&gt;&gt;. Moreover, it's also possible to get the length of the specified array and access the elements directly via an index value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;loop_section&gt;&gt; で配列の要素を反復処理することができます。更に、指定した配列の長さを取得し、インデックス値を介して直接要素にアクセスすることも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Array Examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配列の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs the length of the array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配列の長さを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs the first element of the array.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配列の最初の要素を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs the second element of the array using the bracket notation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>括弧表記で配列の2つ目の要素を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outputs the third element of the array via the virtual method `get()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>配列の 3 番目の要素を仮想メソッド `get()` で出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Character Escapes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>文字エスケープ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTML and XML templates the `'`, `"`, `&lt;`, `&gt;`, `&amp;` characters are escaped by default if a template variant is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTML と XML テンプレートの場合、 `'` , `"` , `&lt;` , `&gt;` , `&amp;` の文字は、テンプレートバリアントが設定されている場合はデフォルトでエスケープされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, a variant is set automatically for templates located in the `src/main/resources/templates`. By default, the `java.net.URLConnection#getFileNameMap()` is used to determine the content type of a template file. The additional map of suffixes to content types can be set via `quarkus.qute.content-types`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `src/main/resources/templates` にあるテンプレートに対してバリアントが自動的に設定されます。デフォルトでは、テンプレートファイルのコンテンツタイプを決定するために `java.net.URLConnection#getFileNameMap()` が使用されます。コンテンツタイプへのサフィックスの追加マップは、 `quarkus.qute.content-types` を通じて設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to render the unescaped value:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エスケープされていない値をレンダリングする必要がある場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `raw` or `safe` properties implemented as extension methods of the `java.lang.Object`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.lang.Object` の拡張メソッドとして実装されている `raw` または `safe` プロパティーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrap the `String` value in a `io.quarkus.qute.RawString`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`String` の値を `io.quarkus.qute.RawString` でラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`title` that resolves to `Expressions &amp; Escapes` will be rendered as `Expressions &amp;amp;amp; Escapes`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`title` が `Expressions &amp; Escapes` に解決した場合は、 `Expressions &amp;amp; Escapes` としてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`paragraph` that resolves to `&lt;p&gt;My text!&lt;/p&gt;` will be rendered as `&lt;p&gt;My text!&lt;/p&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`paragraph` が `&lt;p&gt;My text!&lt;/p&gt;` に解決された場合は、 `&lt;p&gt;My text!&lt;/p&gt;` としてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>仮想メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A virtual method is a *part of an expression* that looks like a regular Java method invocation.  It's called "virtual" because it does not have to match the actual method of a Java class.  In fact, like normal properties a virtual method is also handled by a value resolver.  The only difference is that for virtual methods a value resolver consumes parameters that are also expressions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>仮想メソッドとは、通常のJavaメソッド呼び出しのように見える *式のパーツ* です。Javaクラスの実際のメソッドと一致する必要がないため、「仮想」と呼ばれています。実際には、通常のプロパティーと同様に、仮想メソッドも値リゾルバによって処理されます。唯一の違いは、仮想メソッドの場合、値リゾルバが式でもあるパラメーターを消費することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual Method Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>仮想メソッドの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`buildName(item.name,5)` represents a virtual method with name `buildName` and two parameters: `item.name` and `5` . The virtual method could be evaluated by a value resolver generated for the following Java class:   
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`buildName(item.name,5)` は、名前 `buildName` と 2 つのパラメーター `item.name` と `5` を持つ仮想メソッドを表します。この仮想メソッドは、以下の Java クラスに対して生成された値リゾルバによって評価されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual methods are usually evaluated by value resolvers generated for &lt;&lt;template_extension_methods,@TemplateExtension methods&gt;&gt;, &lt;&lt;template_data,@TemplateData&gt;&gt; or classes used in &lt;&lt;typesafe_expressions,parameter declarations&gt;&gt;. However, a custom value resolver that is not backed by any Java class/method can be registered as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>仮想メソッドは通常、 &lt;&lt;template_extension_methods,@TemplateExtension methods&gt;&gt; 、 &lt;&lt;template_data,@TemplateData&gt;&gt; 、または &lt;&lt;typesafe_expressions,parameter declarations&gt;&gt; で使用されるクラスのために生成された値リゾルバによって評価されます。しかし、Javaのクラス/メソッドに基づかないカスタムの値リゾルバも登録できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A virtual method with single parameter can be called using the infix notation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単一のパラメーターを持つ仮想メソッドは 中置記法を使用して呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infix Notation Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>中置表記例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item.price or 5` is translated to `item.price.or(5)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item.price or 5` は `item.price.or(5)` に翻訳されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual method parameters can be "nested" virtual method invocations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>仮想メソッドのパラメーターは、「入れ子」仮想メソッドの呼び出しにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nested Virtual Method Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入れ子になった仮想メソッドの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item.calculateDiscount(10)` is evaluated first and then passed as an argument to `item.subtractPrice()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item.calculateDiscount(10)` が最初に評価され、その後 `item.subtractPrice()` への引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Evaluation of `CompletionStage` and `Uni` Objects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CompletionStage` と `Uni` オブジェクトの評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects that implement `java.util.concurrent.CompletionStage` and `io.smallrye.mutiny.Uni` are evaluated in a special way.  If a part of an expression resolves to a `CompletionStage`, the resolution continues once this stage is completed and the next part of the expression (if any) is evaluated against the result of the completed stage.  For example, if there is an expression `{foo.size}` and `foo` resolves to `CompletionStage&lt;List&lt;String&gt;&gt;` then `size` is resolved against the completed result, i.e. `List&lt;String&gt;`.  If a part of an expression resolves to a `Uni`, a `CompletionStage` is first created from `Uni` using `Uni#subscribeAsCompletionStage()` and then evaluated as described above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.util.concurrent.CompletionStage` および `io.smallrye.mutiny.Uni` を実装したオブジェクトは、特別な方法で評価されます。式の一部が `CompletionStage` に解決された場合、このステージが完了すると解決が継続され、式の次の部分(もしあれば)が完了したステージの結果に対して評価されます。たとえば、式 `{foo.size}` があり、 `foo` が `CompletionStage&lt;List&lt;String&gt;&gt;` に解決された場合、 `size` は完了した結果、すなわち `List&lt;String&gt;` に対して解決されます。式の一部が `Uni` に解決される場合、 `CompletionStage` が `Uni#subscribeAsCompletionStage()` を使用して `Uni` から最初に作成され、その後上記のように評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Missing Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不明なプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can happen that an expression may not be evaluated at runtime.  For example, if there is an expression `{person.age}` and there is no property `age` declared on the `Person` class.  Qute outputs the special constant `NOT_FOUND` in this case by default.  However, it's possible to change the default strategy via the `quarkus.qute.property-not-found-strategy` as described in the &lt;&lt;configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式が実行時に評価されないことがあります。たとえば、 `{person.age}` という式があり、 `Person` クラスに `age` というプロパティが宣言されていない場合です。Qute はこの場合、デフォルトで特殊定数 `NOT_FOUND` を出力します。ただし、 &lt;&lt;configuration-reference&gt;&gt; で説明されているように、 `quarkus.qute.property-not-found-strategy` を介してデフォルトの戦略を変更することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar errors are detected at build time if &lt;&lt;typesafe_expressions&gt;&gt; and &lt;&lt;typesafe_templates&gt;&gt; are used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;typesafe_expressions&gt;&gt; や &lt;&lt;typesafe_templates&gt;&gt; を使用すると、ビルド時に同様のエラーが検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, the _elvis operator_ can be used to output the default value in case the property cannot be resolved or resolves to `null`: `{person.age ?: 10}` would output `10`. And for the loop section, the `orEmpty` resolver can be used. See also &lt;&lt;built-in-resolvers&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 _elvis 演算子_ を使用すると、プロパティが解決できない場合や `null` に解決される場合に、デフォルト値を出力することができます。 `{person.age ?: 10}` は `10` を出力します。また、ループセクションでは、 `orEmpty` リゾルバを使用することができます。 &lt;&lt;built-in-resolvers&gt;&gt; も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A section:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクションは:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>starts with `#`, followed by the name of the section such as `{#if}` and `{#each}`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`#` で始まり、 `{#if}` や `{#each}` などのセクションの名前が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tag ends with `/`, ie. `{#emptySection /}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タグは `/` で終わります。例: `{#emptySection /}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>may contain other expression, sections, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他の表現、セクションなどを含む場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the end tag starts with `/` and contains the name of the section (optional): `{#if foo}Foo!{/if}` or `{#if foo}Foo!{/}`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>終了タグは `/` で始まり、セクションの名前(オプション)を含みます: `{#if foo}Foo!{/if}` または `{#if foo}Foo!{/}` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The start tag can also define parameters.  The parameters have optional names.  A section may contain several content *blocks*.  The "main" block is always present.  Additional/nested blocks also start with `#` and can have parameters too - `{#else if item.isActive}`.  A section helper that defines the logic of a section can "execute" any of the blocks and evaluate the parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>startタグはパラメーターを定義することもできます。パラメーターにはオプションの名前を付けます。1つのセクションには、いくつかのコンテンツ *ブロック* を含めることができます。"main" ブロックは常に存在します。追加/入れ子になったブロックも `#` で始まり、パラメーターを持つことができます - `{#else if item.isActive}` 。セクションのロジックを定義するセクションヘルパーは、任意のブロックを「実行」し、パラメーターを評価することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Loop Section</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ループセクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The loop section makes it possible to iterate over an instance of `Iterable`, `Map` 's entry set, `Stream` and an `Integer`.  It has two flavors.  The first one is using the `each` name alias.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ループセクションでは、 `Iterable` , `Map` のエントリーセット、 `Stream` と整数のインスタンスを反復処理することができます。ループには2つのフレーバーがあります。1つ目は `each` という名前エイリアスを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`it` is an implicit alias. `name` is resolved against the current iteration element.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`it` は暗黙のエイリアスです。 `name` は現在の反復要素に対して解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other form is using the `for` name alias and can specify the alias used to reference the iteration element:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つの形式は、 `for` 名前エイリアスを使用しており、反復要素を参照するために使用されるエイリアスを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's also possible to access the iteration metadata inside the loop:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ループ内の反復メタデータにアクセスすることも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`count` represents one-based index. Metadata also include zero-based `index`, `hasNext`, `odd` and `even`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`count` は1から始まるインデックスを表しています。メタデータには、0から始まる `index` 、 `hasNext` 、 `odd` 、 `even` も含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `for` statement also works with integers, starting from 1. In the example below, considering that `total = 3`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`for` 文は、1 から始まる整数でも動作します。 以下の例では、 `total = 3` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output will be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出力は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `if` section represents a basic control flow section.  The simplest possible version accepts a single parameter and renders the content if the condition is evaluated to `true`.  A condition without an operator evaluates to `true` if the value is not considered `falsy`, i.e. if the value is not `null`, `false`, an empty collection, an empty map, an empty array, an empty string/char sequence or a number equal to zero.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`if` セクションは、基本的な制御フローセクションを表しています。最も単純なバージョンでは、単一のパラメーターを受け取り、条件が `true` と評価された場合にコンテンツをレンダリングします。演算子なしの条件は値が `falsy` (つまり、`null` 、 `false` 、空のコレクション、空のマップ、空の配列、空の文字列/文字列シーケンス、またはゼロに等しい数) ではない場合、 `true` と評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use the following operators in a condition:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>条件では、以下の演算子を使うこともできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Operator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オペレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aliases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Precedence (higher wins)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>優先順位 (大優先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>logical complement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>logical complement</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>greater than</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>greater than</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`gt`, `&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`gt`, `&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>greater than or equal to</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>greater than or equal to</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ge`, `&gt;=`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ge`, `&gt;=`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>less than</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>less than</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`lt`, `&lt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`lt`, `&lt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>less than or equal to</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>less than or equal to</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`le`, `\&lt;=`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`le`, `\&lt;=`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>equals</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>equals</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`eq`, `==`, `is`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`eq`, `==`, `is`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>not equals</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>not equals</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ne`, `!=`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ne`, `!=`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>logical AND (short-circuiting)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>logical AND (short-circuiting)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`&amp;&amp;`, `and`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&amp;&amp;`, `and`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>logical OR (short-circuiting)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>logical OR (short-circuiting)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`, `or`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`, `or`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simple operator example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単な演算子の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple conditions are also supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の条件にも対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple conditions example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数条件の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Precedence rules can be overridden by parentheses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>優先順位の規則は、カッコで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parentheses example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>括弧の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also add any number of `else` blocks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `else` ブロックを何個でも追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section is similar to Java's `switch` or Kotlin's `when` constructs.  It matches a _tested value_ against all blocks sequentially until a condition is satisfied.  The first matching block is executed.  All other blocks are ignored (this behavior differs to the Java `switch` where a `break` statement is necessary).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションは、Java の `switch` や Kotlin の `when` に似ています。条件が満たされるまで、 _テストされた値_ をすべてのブロックに対して順次マッチさせます。最初にマッチしたブロックが実行されます。他のすべてのブロックは無視されます(この動作は、 `break` 文が必要な Java `switch` とは異なります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example using the `when`/`is` name aliases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`when` / `is` の名前のエイリアスを使用した例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is exactly one parameter it's tested for equality.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パラメーターが1つだけの場合、それは等価かがテストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's possible to use &lt;&lt;when_operators,an operator&gt;&gt; to specify the matching logic. Unlike in the &lt;&lt;if_section&gt;&gt; nested operators are not supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#when_operators[演算子] を使ってマッチングロジックを指定することができます。 &lt;&lt;if_section&gt;&gt; とは異なり、入れ子になった演算子はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`else` is block is executed if no other block matches the value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`else` は、他のブロックが値に一致しない場合に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example using the `switch`/`case` name aliases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`switch` / `case` の名前エイリアスを使用した例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`case` is an alias for `is`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`case` は `is` の別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A tested value that resolves to an enum is handled specifically.  The parameters of an `is`/`case` block are not evaluated as expressions but compared with the result of `toString()` invocation upon the tested value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>enum に解決されるテスト値は特別な扱いを受けます。 `is` / `case` ブロックのパラメーターは式として評価されるのではなく、テストされた値に対して `toString()` を呼び出した結果と比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This block is executed if `machine.status.toString().equals("ON")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このブロックは `machine.status.toString().equals("ON")` の場合に実行されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This block is executed if `machine.status.toString().equals("OFF")` or `machine.status.toString().equals("BROKEN")`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このブロックは、 `machine.status.toString().equals("OFF")` または `machine.status.toString().equals("BROKEN")` の場合に実行されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An enum constant is validated if the tested value has a type information available and resolves to an enum type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>列挙型定数は、テストされた値が利用可能な型情報を持ち、列挙型に解決された場合に検証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following operators are supported in `is`/`case` block conditions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`is` / `case` ブロック条件では、以下の演算子がサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>not equal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>not equal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`!=`, `not`, `ne`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`!=`, `not`, `ne`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#is not 10}`,`{#case != 10}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#is not 10}`,`{#case != 10}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#case le 10}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#case le 10}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#is &gt;= 10}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#is &gt;= 10}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#is &lt; 10}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#is &lt; 10}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>in</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`in`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`in`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#is in 'foo' 'bar' 'baz'}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#is in 'foo' 'bar' 'baz'}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>not in</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>not in</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ni`,`!in`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ni`,`!in`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#is !in 1 2 3}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#is !in 1 2 3}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section can be used to set the current context object.  This could be useful to simplify the template structure:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションは、現在のコンテキストオブジェクトを設定するために使用することができます。これはテンプレート構造を単純化するのに便利かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `name` will be resolved against the `item.parent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`name` は `item.parent` に対して解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `description` will be also resolved against the `item.parent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`description` も `item.parent` に対して解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section might also come in handy when we'd like to avoid multiple expensive invocations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションは、複数の高価な呼び出しを避けたいときにも便利かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`this` is the result of `item.callExpensiveLogicToGetTheValue(1,'foo',bazinga)`. The method is only invoked once even though the result may be used in multiple expressions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`this` は `item.callExpensiveLogicToGetTheValue(1,'foo',bazinga)` の結果です。結果が複数の式で使用されても、このメソッドは一度しか呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section allows you to define named local variables:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、名前付きローカル変数を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The local variable is initialized with an expression that can also represent a &lt;&lt;literals,literal&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカル変数は、 link:#literals[リテラル]を表すこともできる式で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The section tag is also registered under the `set` alias:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクションタグも `set` のエイリアスで登録されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section can be used to include another template and possibly override some parts of the template (template inheritance).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、別のテンプレートをインクルードしたり、テンプレートの一部をオーバーライドすることができます(テンプレートの継承)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単な例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Include a template with id `foo`. The included template can reference data from the current context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>id `foo` でテンプレートをインクルードします。インクルードされたテンプレートは、現在のコンテキストからデータを参照することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's also possible to define optional parameters that can be used in the included template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、インクルードされたテンプレートで使用できるオプションのパラメーターを定義することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template inheritance makes it possible to reuse template layouts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート継承により、テンプレートレイアウトの再利用が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template "base"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート「ベース」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`insert` sections are used to specify parts that could be overridden by a template that includes the given template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`insert` セクションは、指定されたテンプレートをインクルードするテンプレートでオーバーライドできる部分を指定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template "detail"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート「詳細」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`include` section is used to specify the extended template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`include` セクションは、拡張テンプレートを指定するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nested blocks are used to specify the parts that should be overridden.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入れ子になったブロックは、オーバーライドする部分を指定するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Section blocks can also define an optional end tag - `{/title}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクションブロックはオプションのエンドタグを定義することもできます - `{/title}` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User-defined Tags</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー定義タグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User-defined tags can be used to include a template and optionally pass some parameters.  Let's suppose we have a template called `itemDetail.html`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー定義タグは、テンプレートをインクルードし、オプションでいくつかのパラメーターを渡すために使用することができます。 `itemDetail.html` というテンプレートがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`showImage` is a named parameter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`showImage` は名前付きパラメーターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`it` is a special key that is replaced with the first unnamed param of the tag.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`it` は、タグの最初の名前のないパラメーターに置き換えられる特別なキーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(optional) `nested-content` is a special key that will be replaced by the content of the tag.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(オプション) `nested-content` は、タグの内容に置き換えられる特別なキーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now if we register this template under the name `itemDetail.html` and if we add a `UserTagSectionHelper` to the engine:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、このテンプレートを `itemDetail.html` という名前で登録し、エンジンに `UserTagSectionHelper` を追加した場合: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, all files from the `src/main/resources/templates/tags` are registered and monitored automatically!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `src/main/resources/templates/tags` からのファイルはすべて登録され、自動的に監視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can include the tag like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようにタグをインクルードすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item` is resolved to an iteration element and can be referenced using the `it` key in the tag template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item` は反復要素に解決され、タグテンプレートで `it` キーを使用して参照することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tag content injected using the `nested-content` key in the tag template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タグテンプレートで `nested-content` キーを使用して注入されたタグコンテンツ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rendering Output</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レンダリング出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`TemplateInstance` provides several ways to trigger the rendering and consume the result.  The most straightforward approach is represented by `TemplateInstance.render()`.  This method triggers a synchronous rendering, i.e. the current thread is blocked until the rendering is finished, and returns the output.  By contrast, `TemplateInstance.renderAsync()` returns a `CompletionStage&lt;String&gt;` which is completed when the rendering is finished.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TemplateInstance` は、レンダリングをトリガーして結果を消費するためのいくつかの方法を提供しています。最も簡単な方法は `TemplateInstance.render()` です。このメソッドは同期レンダリングをトリガーし、レンダリングが終了するまで現在のスレッドをブロックして出力を返します。対照的に、 `TemplateInstance.renderAsync()` は `CompletionStage&lt;String&gt;` を返し、レンダリングが終了すると完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register a callback that is executed once the rendering is finished.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レンダリング終了後に実行されるコールバックを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are also two methods that return https://smallrye.io/smallrye-mutiny/[Mutiny] types.  `TemplateInstance.createUni()` returns a new `Uni&lt;String&gt;` object.  If you call `createUni()` the template is not rendered right away.  Instead, every time `Uni.subscribe()` is called a new rendering of the template is triggered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 link:https://smallrye.io/smallrye-mutiny/[Mutiny] 型を返す2つのメソッドがあります。 `TemplateInstance.createUni()` は新しい `Uni&lt;String&gt;` オブジェクトを返します。 `createUni()` を呼び出しても、テンプレートはすぐにレンダリングされません。その代わり、 `Uni.subscribe()` が呼び出されるたびに、テンプレートの新しいレンダリングがトリガーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`TemplateInstance.createMulti()` returns a new `Multi&lt;String&gt;` object.  Each item represents a part/chunk of the rendered template.  Again, `createMulti()` does not trigger rendering.  Instead, every time a computation is triggered by a subscriber the template is rendered again.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TemplateInstance.createMulti()` は新しい `Multi&lt;String&gt;` オブジェクトを返します。各アイテムはレンダリングされたテンプレートの一部/チャンクを表します。繰り返しになりますが、 `createMulti()` はレンダリングをトリガしません。代わりに、サブスクライバによって実行がトリガされるたびに、テンプレートが再びレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The template rendering is divided in two phases. During the first phase, which is asynchronous, all expressions in the template are resolved and a _result tree_ is built. In the second phase, which is synchronous, the result tree is _materialized_, i.e. one by one the result nodes emit chunks that are consumed/buffered by the specific consumer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートのレンダリングは2つのフェーズに分かれています。最初のフェーズ(非同期)では、テンプレート内のすべての式が解決され、 _結果ツリー_ が構築されます。同期的な第2フェーズでは、結果ツリーが _マテリアライズされ_ 、結果ノードが1つずつ、特定のコンシューマによって消費/バッファリングされるチャンクを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Engine Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンジン設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value Resolvers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値リゾルバ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value resolvers are used when evaluating expressions.  A custom `io.quarkus.qute.ValueResolver` can be registered programmatically via `EngineBuilder.addValueResolver()`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>式を評価する際に値リゾルバを使用します。カスタム `io.quarkus.qute.ValueResolver` は `EngineBuilder.addValueResolver()` からプログラムで登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Locator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートロケーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manual registration is sometimes handy but it's also possible to register a template locator using `EngineBuilder.addLocator(Function&lt;String, Optional&lt;Reader&gt;&gt;)`.  This locator is used whenever the `Engine.getTemplate()` method is called and the engine has no template for a given id stored in the cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>手動登録が便利な場合もありますが、 `EngineBuilder.addLocator(Function&lt;String, Optional&lt;Reader&gt;&gt;)` を使用してテンプレートロケータを登録することも可能です。このロケータは、 `Engine.getTemplate()` メソッドが呼び出され、エンジンがキャッシュに保存されている指定された id のテンプレートを持っていない場合に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, all templates from the `src/main/resources/templates` are located automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `src/main/resources/templates` のテンプレートはすべて自動的に配置されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Content Filters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテンツフィルタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Content filters can be used to modify the template contents before parsing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテンツフィルタを使用して、解析前にテンプレートコンテンツを変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Content Filter Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテンツフィルター例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Escape all occurences of `${`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての `${` との一致をエスケープします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Qute in your Quarkus application add the following dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusアプリケーションでQuteを使用する場合は、以下の依存関係をプロジェクトに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, a preconfigured engine instance is provided and available for injection - a bean with scope `@ApplicationScoped`, bean type `io.quarkus.qute.Engine` and qualifier `@Default` is registered automatically.  Moreover, all templates located in the `src/main/resources/templates` directory are validated and can be easily injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、事前に設定されたエンジンインスタンスが提供され、インジェクションに利用できます。`@ApplicationScoped` スコープのBean、 `io.quarkus.qute.Engine` 型のBean、 `@Default` 修飾子が自動的に登録されます。さらに、 `src/main/resources/templates` ディレクトリーにあるすべてのテンプレートが検証され、簡単にインジェクションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no `Location` qualifier provided, the field name is used to locate the template. In this particular case, the container will attempt to locate a template with path `src/main/resources/templates/items.html`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Location` 修飾子が与えられていない場合は、フィールド名がテンプレートを特定するために使われます。この特定のケースでは、コンテナーはパス `src/main/resources/templates/items.html` でテンプレートを見つけようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Location` qualifier instructs the container to inject a template from a path relative from `src/main/resources/templates`. In this case, the full path is `src/main/resources/templates/detail/items2_v1.html`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Location` 修飾子は、 `src/main/resources/templates` からの相対パスからテンプレートを注入するようにコンテナーに指示します。この場合のフルパスは `src/main/resources/templates/detail/items2_v1.html` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the configured `Engine` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定された `Engine` インスタンスを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's also possible to contribute to the engine configuration via a CDI observer method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI observerメソッドを通じてエンジン設定に貢献することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Variants</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートバリアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it's useful to render a specific variant of the template based on the content negotiation.  This can be done by setting a special attribute via `TemplateInstance.setAttribute()`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテンツネゴシエーションに基づいてテンプレートの特定のバリアントをレンダリングすることが有用な場合があります。これは `TemplateInstance.setAttribute()` を通じて特別な属性を設定することで行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `quarkus-resteasy-qute` the content negotiation is performed automatically. See &lt;&lt;resteasy_integration&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy-qute` を使用している場合、コンテンツネゴシエーションは自動的に行われます。 &lt;&lt;resteasy_integration&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting Beans Directly In Templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートに直接Beansを注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A CDI bean annotated with `@Named` can be referenced in any template through the `inject` namespace:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Named` でアノテーションされた CDI Beanは、 `inject` 名前空間を通して、どのテンプレートでも参照することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, a bean with name `foo` is found and then used as the base object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、 `foo` という名前のBeanを見つけ、それをベースオブジェクトとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All expressions using the `inject` namespace are validated during build.  For the expression `inject:foo.price` the implementation class of the injected bean must either have the `price` property (e.g. a `getPrice()` method) or a matching &lt;&lt;template_extension_methods,template extension method&gt;&gt; must exist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`inject` 名前空間を使用するすべての式は、ビルド時に検証されます。式 `inject:foo.price` については、注入されたBeanの実装クラスに `price` プロパティー ( `getPrice()` メソッドなど) があるか、一致する link:#template_extension_methods[テンプレート拡張メソッド] が存在していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `ValueResolver` is also generated for all beans annotated with `@Named` so that it's possible to access its properties without reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Named` でアノテーションされたすべてのBeanに対して `ValueResolver` も生成され、そのプロパティーにリフレクションなしでアクセスできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>型安全な式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template expressions can be optionally type-safe.  Which means that an expression is validated against the existing Java types and template extension methods.  If an invalid/incorrect expression is found then the build fails.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート式は、オプションでタイプセーフにすることができます。これは、式が既存のJavaの型とテンプレート拡張メソッドに対して検証されることを意味します。無効な/不正確な式が見つかった場合、ビルドは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if there is an expression `item.name` where `item` maps to `org.acme.Item` then `Item` must have a property `name` or a matching template extension method must exist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `item.name` という式があり、 `item` が `org.acme.Item` にマップされている場合、 `Item` には `name` というプロパティーがあるか、一致するテンプレート拡張メソッドが存在しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An optional _parameter declaration_ is used to bind a Java type to expressions whose first part matches the parameter name.  Parameter declarations are specified directly in a template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションの _パラメーター宣言_ は、最初のパートがパラメーター名と一致する式に Java 型をバインドするために使用されます。パラメーター宣言はテンプレートで直接指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parameter Declaration Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パラメーター宣言の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parameter declaration - maps `foo` to `org.acme.Foo`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パラメーター宣言 - `foo` を `org.acme.Foo` にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not validated - not matching a param declaration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証されていません - パラメーター宣言にマッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is validated. `org.acme.Foo` must have a property `message` or a matching template extension method must exist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この式は検証されています。`org.acme.Foo` はプロパティー `message` を持つか、一致するテンプレート拡張メソッドが存在しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Likewise, the Java type of the object resolved from `foo.message` must have a property `toLowerCase` or a matching template extension method must exist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、 `foo.message` から解決されたオブジェクトの Java 型は、プロパティー `toLowerCase` を持つか、一致するテンプレート拡張メソッドが存在しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A value resolver is automatically generated for all types used in parameter declarations so that it's possible to access its properties without reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パラメーター宣言で使用されるすべての型に対して値リゾルバが自動的に生成され、そのプロパティーにリフレクションなしでアクセスできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method parameters of &lt;&lt;typesafe_templates,type-safe templates&gt;&gt; are automatically turned into parameter declarations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;typesafe_templates,type-safe templates&gt;&gt; のメソッドパラメーターは、自動的にパラメーター宣言に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that sections can override names that would otherwise match a parameter declaration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セクションは、パラメーター宣言にマッチする名前をオーバーライドできることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validated against `org.acme.Foo`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.Foo` に対して検証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not validated - `foo` is overridden in the loop section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証されていません - `foo` はループセクションでオーバーライドされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe Templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Organise your template files in the `/src/main/resources/templates` directory, by grouping them into one directory per resource class. So, if your `ItemResource` class references two templates `hello` and `goodbye`, place them at `/src/main/resources/templates/ItemResource/hello.txt` and `/src/main/resources/templates/ItemResource/goodbye.txt`. Grouping templates per resource class makes it easier to navigate to them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートファイルを `/src/main/resources/templates` ディレクトリーに整理し、リソースクラスごとに 1 つのディレクトリーにグループ化します。つまり、 `ItemResource` クラスが `hello` と `goodbye` の 2 つのテンプレートを参照している場合は、 `/src/main/resources/templates/ItemResource/hello.txt` と `/src/main/resources/templates/ItemResource/goodbye.txt` に配置します。リソースクラスごとにテンプレートをグループ化することで、テンプレートへのナビゲートが容易になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In each of your resource class, declare a `@CheckedTemplate static class Template {}` class within your resource class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各リソースクラスで、`@CheckedTemplate static class Template {}` クラスを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare one `public static native TemplateInstance method();` per template file for your resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リ ソ ース のテ ン プ レー ト フ ァ イ ルごとに `public static native TemplateInstance method();` を 1 つずつ宣言 し ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use those static methods to build your template instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートインスタンスを構築するには、これらの静的メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ItemResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a method that gives us a `TemplateInstance` for `templates/ItemResource/item.html` and declare its `Item item` parameter so we can validate the template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートを検証する為に、`templates/ItemResource/item.html` の `TemplateInstance` を用意するメソッドと、その `Item item` パラメーターを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `item` parameter is automatically turned into a &lt;&lt;typesafe_expressions,parameter declaration&gt;&gt; and so all expressions that reference this name will be validated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item` パラメーターは自動的に &lt;&lt;typesafe_expressions,parameter declaration&gt;&gt; に変換されるので、この名前を参照するすべての式が検証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make the `Item` object accessible in the template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート内で `Item` オブジェクトにアクセスできるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also declare a top-level Java class annotated with `@CheckedTemplate`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `@CheckedTemplate` でアノテーションされたトップレベルの Java クラスを宣言することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Top-level checked templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トップレベルチェック済テンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/hello.txt`. The `name` parameter is automatically turned into a &lt;&lt;typesafe_expressions,parameter declaration&gt;&gt; and so all expressions that reference this name will be validated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、パス `templates/hello.txt` を持つテンプレートを宣言します。 `name` パラメーターは自動的に link:#typesafe_expressions[パラメーター宣言] に変換されるので、この名前を参照するすべての式が検証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then declare one `public static native TemplateInstance method();` per template file.  Use those static methods to build your template instances:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、テンプレートファイルごとに `public static native TemplateInstance method();` を宣言します。これらの静的メソッドを使用してテンプレートインスタンスを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HelloResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Extension Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート拡張メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension methods can be used to extend the data classes with new functionality (to extend the set of accessible properties and methods) or to resolve expressions for a specific &lt;&lt;namespace_extension_methods,namespace&gt;&gt;.  For example, it is possible to add _computed properties_ and _virtual methods_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張メソッドは、データクラスを新しい機能で拡張するため(アクセス可能なプロパティーとメソッドのセットを拡張するため)、または特定の link:#namespace_extension_methods[名前空間] のための式を解決するために使用することができます。例えば、 _計算されたプロパティー_ や _仮想メソッド_ を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A value resolver is automatically generated for a method annotated with `@TemplateExtension`.  If a class is annotated with `@TemplateExtension` then a value resolver is generated for every _non-private static method_ declared on the class.  Method-level annotations override the behavior defined on the class.  Methods that do not meet the following requirements are ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値リゾルバは、 `@TemplateExtension` でアノテーションされたメソッドに対して自動的に生成されます。クラスが `@TemplateExtension` でアノテーションされている場合、そのクラスで宣言されている _プライベートではないスタティック・メソッド_ ごとに値リゾルバが生成されます。メソッドレベルのアノテーションは、クラスで定義された動作をオーバーライドします。以下の要件を満たさないメソッドは無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A template extension method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート拡張メソッドは:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>must not be `private`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`private` であってはなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>must be static,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`static` でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>must not return `void`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`void` を返してはいけません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no namespace defined the class of the first parameter that is not annotated with `@TemplateAttribute` is used to match the base object. Otherwise the namespace is used to match an expression.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間が定義されていない限り、`@TemplateAttribute` でアノテーションされた最初のパラメーターのクラスがベース・オブジェクトにマッチするように使用されます。そうでなければ、名前空間が式をマッチするのに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method name is used to match the property name by default.  However, it is possible to specify the matching name with `TemplateExtension#matchName()`.  A special constant - `TemplateExtension#ANY` - may be used to specify that the extension method matches any name.  It is also possible to match the name against a regular expression specified in `TemplateExtension#matchRegex()`.  In both cases, an additional string method parameter must be used to pass the property name.  If both `matchName()` and `matchRegex()` are set the regular expression is used for matching.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッド名は、デフォルトではプロパティー名とのマッチングに使用されます。ただし、マッチする名前を `TemplateExtension#matchName()` で指定することは可能です。特別な定数 `TemplateExtension#ANY` を使用して、拡張メソッドが任意の名前にマッチすることを指定することができます。また、 `TemplateExtension#matchRegex()` で指定された正規表現に対して名前を一致させることも可能です。どちらの場合も、文字列メソッド・パラメーターを使用してプロパティー名を渡します。 `matchName()` と `matchRegex()` の両方が設定されている場合は、正規表現がマッチングに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Method Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張メソッドの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method matches an expression with base object of the type `Item.class` and the `discountedPrice` property name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、 `Item.class` 型のベース・オブジェクトと `discountedPrice` プロパティー名を持つ式にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This template extension method makes it possible to render the following template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このテンプレート拡張メソッドを使うと、以下のテンプレートをレンダリングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item` is resolved to an instance of `org.acme.Item`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item` は `org.acme.Item` のインスタンスに解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method Parameters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドパラメーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An extension method may declare parameters.  If no namespace is specified then the first parameter that is not annotated with `@TemplateAttribute` is used to pass the base object, i.e. `org.acme.Item` in the first example.  If matching any name or using a regular expression then a string method parameter needs to be used to pass the property name.  Parameters annotated with `@TemplateAttribute` are obtained via `TemplateInstance#getAttribute()`.  All other parameters are resolved when rendering the template and passed to the extension method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張メソッドはパラメーターを宣言することができます。名前空間が指定されていない場合、`@TemplateAttribute` でアノテーションされていない最初のパラメーターが基底オブジェクトを渡すために使用されます。例：最初の例における `org.acme.Item` 。任意の名前に一致する場合、または正規表現を使用する場合は、文字列メソッドパラメータを使用してプロパティ名を渡す必要があります。`@ TemplateAttribute` でアノテーションされたパラメーターは、`TemplateInstance#getAttribute()` を介して取得されます。 他のすべてのパラメーターは、テンプレートをレンダリングするときに解決され、拡張メソッドに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Parameters Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のパラメーターの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method matches an expression with base object of the type `BigDecimal.class`, with the `scale` virtual method name and two virtual method parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、 `BigDecimal.class` 型の基底オブジェクトと、 `scale` の仮想メソッド名と 2 つの仮想メソッドパラメーターを持つ式にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`item.discountedPrice` is resolved to an instance of `BigDecimal`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`item.discountedPrice` は `BigDecimal` のインスタンスに解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Namespace Extension Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間拡張メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `TemplateExtension#namespace()` is specified then the extension method is used to resolve expressions with the given &lt;&lt;expressions,namespace&gt;&gt;.  Template extension methods that share the same namespace are grouped in one resolver ordered by `TemplateExtension#priority()`.  The first matching extension method is used to resolve an expression.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TemplateExtension#namespace()` が指定された場合、拡張メソッドが、指定された &lt;&lt;expressions,namespace&gt;&gt; を持つ式を解決するために使用されます。同じ名前空間を共有するテンプレート拡張メソッドは、 `TemplateExtension#priority()` で順に 1 つのリゾルバにグループ化されます。最初にマッチする拡張メソッドが式の解決に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Namespace Extension Method Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間拡張メソッド例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These extension methods can be used as follows.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの拡張メソッドは、以下のように使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output is `Hello world!`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出力は `Hello world!` です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output is `olleh`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出力は `olleh` です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a set of built-in extension methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、組み込みの拡張メソッドのセットを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`keys` or `keySet`: Returns a Set view of the keys contained in a map</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`keys` または `keySet` : マップに含まれるキーのセットビューを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#for key in map.keySet}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#for key in map.keySet}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`values`: Returns a Collection view of the values contained in a map</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`values` : マップに含まれる値のコレクションビューを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#for value in map.values}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#for value in map.values}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`size`: Returns the number of key-value mappings in a map</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`size` : マップ内のキーと値の対応付けの個数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{map.size}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{map.size}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`isEmpty`: Returns true if a map contains no key-value mappings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`isEmpty` : マップにキーと値のマッピングが含まれていない場合に true を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#if map.isEmpty}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#if map.isEmpty}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`get(key)`: Returns the value to which the specified key is mapped</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`get(key)` : 指定したキーがマッピングされた値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{map.get('foo')}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{map.get('foo')}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A map value can be also accessed directly: `{map.myKey}`. Use the bracket notation for keys that are not legal identifiers: `{map['my key']}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マップ値は、直接アクセスすることもできます : `{map.myKey}` 。正規の識別子ではないキーには大括弧表記を使用します: `{map['my key']}` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`get(index)`: Returns the element at the specified position in a list</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`get(index)` : リストの指定した位置の要素を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{list.get(0)}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{list.get(0)}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list element can be accessed directly: `{list.10}` or `{list[10]}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>list 要素に直接アクセスすることができます: `{list.10}` または `{list[10]}` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mod`: Modulo operation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mod` : モデューロ演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{#if counter.mod(5) == 0}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{#if counter.mod(5) == 0}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`config:&lt;name&gt;` or `config:[&lt;name&gt;]`: Returns the config value for the given property name</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`config:&lt;name&gt;` 又は `config:[&lt;name&gt;]` : 指定したプロパティー名の設定値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`config:property(name)`: Returns the config value for the given property name; the name can be obtained dynamically by an expression</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`config:property(name)` : 指定したプロパティー名の設定値を返します。名前は式で動的に取得することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`format(pattern)`: Formats temporal objects from the `java.time` package</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`format(pattern)` : `java.time` パッケージの一時オブジェクトをフォーマットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{dateTime.format('d MMM uuuu')}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{dateTime.format('d MMM uuuu')}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`format(pattern,locale)`: Formats temporal objects from the `java.time` package</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`format(pattern,locale)` : `java.time` パッケージの一時オブジェクトをフォーマットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{dateTime.format('d MMM uuuu',myLocale)}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{dateTime.format('d MMM uuuu',myLocale)}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`format(pattern,locale,timeZone)`: Formats temporal objects from the `java.time` package</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`format(pattern,locale,timeZone)` : `java.time` パッケージの一時オブジェクトをフォーマットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{dateTime.format('d MMM uuuu',myLocale,myTimeZoneId)}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{dateTime.format('d MMM uuuu',myLocale,myTimeZoneId)}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`time:format(dateTime,pattern)`: Formats temporal objects from the `java.time` package, `java.util.Date`, `java.util.Calendar` and `java.lang.Number`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`time:format(dateTime,pattern)` : `java.time` パッケージ、 `java.util.Date` 、 `java.util.Calendar` 、 `java.lang.Number` の一時オブジェクトをフォーマットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{time:format(myDate,'d MMM uuuu')}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{time:format(myDate,'d MMM uuuu')}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`time:format(dateTime,pattern,locale)`: Formats temporal objects from the `java.time` package, `java.util.Date`, `java.util.Calendar` and `java.lang.Number`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`time:format(dateTime,pattern,locale)` : `java.time` パッケージ、 `java.util.Date` 、 `java.util.Calendar` 、 `java.lang.Number` の一時オブジェクトをフォーマットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{time:format(myDate,'d MMM uuuu', myLocale)}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{time:format(myDate,'d MMM uuuu', myLocale)}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`time:format(dateTime,pattern,locale,timeZone)`: Formats temporal objects from the `java.time` package, `java.util.Date`, `java.util.Calendar` and `java.lang.Number`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`time:format(dateTime,pattern,locale,timeZone)` : `java.time` パッケージ、 `java.util.Date` 、 `java.util.Calendar` 、 `java.lang.Number` の一時オブジェクトをフォーマットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{time:format(myDate,'d MMM uuuu',myTimeZoneId)}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{time:format(myDate,'d MMM uuuu',myTimeZoneId)}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@TemplateData</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@TemplateData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A value resolver is automatically generated for a type annotated with `@TemplateData`.  This allows Quarkus to avoid using reflection to access the data at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値リゾルバは、 `@TemplateData` でアノテーションされた型に対して自動的に生成されます。これにより、Quarkusでは、実行時にデータにアクセスするためのリフレクションの使用を避けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-public members, constructors, static initializers, static, synthetic and void methods are always ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非publicのメンバー、コンストラクタ、静的イニシャライザ、静的メソッド、合成メソッド、ボイドメソッドは常に無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any instance of `Item` can be used directly in the template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Item` の任意のインスタンスをテンプレート内で直接使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`items` is resolved to a list of `org.acme.Item` instances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`items` は `org.acme.Item` インスタンスのリストに解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, `@TemplateData.properties()` and `@TemplateData.ignore()` can be used to fine-tune the generated resolver.  Finally, it is also possible to specify the "target" of the annotation - this could be useful for third-party classes not controlled by the application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、 `@TemplateData.properties()` と `@TemplateData.ignore()` を使用して、生成されるリゾルバを微調整することができます。最後に、アノテーションの「ターゲット」を指定することも可能です。これは、アプリケーションによって管理されないサードパーティーのクラスに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated value resolver knows how to invoke the `BigDecimal.setScale()` method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された値リゾルバは、 `BigDecimal.setScale()` メソッドを呼び出す方法を知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Qute in your JAX-RS application, then depending on which JAX-RS stack you are using, you'll need to register the proper extension first.  If you are using the traditional `quakus-resteasy` extension, then in your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSアプリケーションでQuteを使用したい場合、使用しているJAX-RSスタックによっては、まず適切なエクステンションを登録する必要があります。トラディショナルな `quakus-resteasy` のエクステンションを使用している場合は、 以下を `pom.xml` ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If instead you are using RESTEasy Reactive via the `quarkus-resteasy-reactive` extension, then in your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりに `quarkus-resteasy-reactive` エクステンションを介して RESTEasy Reactive を使用している場合は、 次を `pom.xml` ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both of these extensions register a special `ContainerResponseFilter` implementation which enables resource methods to return a `TemplateInstance`, thus freeing users of having to take care of all necessary internal steps.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのエクステンションはどちらも、リソースメソッドが `TemplateInstance` を返すことを可能にする特別な `ContainerResponseFilter` 実装を登録しています。そのため、ユーザーは必要なすべての内部ステップを処理する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The end result is that a using Qute within a JAX-RS resource may look as simple as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最終的には、JAX-RSリソース内でQuteを使用すると、次のようにシンプルに見えるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no `@Location` qualifier provided, the field name is used to locate the template. In this particular case, we're injecting a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Location` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この特定のケースでは、パスが `templates/hello.txt` であるテンプレートを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Template.data()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Template.data()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、nameの値をキー `name` にセットします。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we don't trigger the rendering - this is done automatically by a special `ContainerResponseFilter` implementation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レンダリングをトリガーしないことに注意してください - これは特別な `ContainerResponseFilter` の実装によって自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users are encouraged to use &lt;&lt;typesafe_templates,Type-safe templates&gt;&gt; that help to organize the templates for a specific JAX-RS resource and enable &lt;&lt;typesafe_expressions,type-safe expressions&gt;&gt; automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーは、特定のJAX-RSリソースのテンプレートを整理し、自動的に &lt;&lt;typesafe_expressions,タイプセーフ表現&gt;&gt; を有効にするのに役立つ &lt;&lt;typesafe_templates,タイプセーフテンプレート&gt;&gt; を使用することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The content negotiation is performed automatically.  The resulting output depends on the `Accept` header received from the client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテンツネゴシエーションは自動的に実行されます。結果の出力はクライアントから受け取った `Accept` ヘッダーに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a variant template with base path derived from the injected field - `src/main/resources/templates/item`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入されたフィールドから派生したベースパスを持つバリアントテンプレートを注入します - `src/main/resources/templates/item`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For `text/plain` the `src/main/resources/templates/item.txt` template is used. For `text/html` the `META-INF/resources/templates/item.html` template is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`text/plain` では `src/main/resources/templates/item.txt` のテンプレートが使用されます。 `text/html` では `META-INF/resources/templates/item.html` のテンプレートが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `RestTemplate` util class can be used to obtain a template instance from a body of a JAX-RS resource method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`RestTemplate` utilクラスは、JAX-RSリソースメソッドのボディからテンプレートインスタンスを取得するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the template is derived from the resource class and method name; `DetailResource/item` in this particular case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートの名前は、リソースクラスとメソッド名から派生しています。このケースでは、`DetailResource/item` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike with `@Inject` the templates obtained via `RestTemplate` are not validated, i.e. the build does not fail if a template does not exist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Inject` とは異なり、 `RestTemplate` 経由で取得したテンプレートは検証されません。即ち、テンプレートが存在しなくてもビルドは失敗しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでは、 `src/main/resources/templates` にあるすべてのファイルの変更が監視され、変更はすぐに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe Message Bundles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプセーフメッセージバンドル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic idea is that every message is potentially a very simple template.  In order to prevent type errors a message is defined as an annotated method of a *message bundle interface*.  Quarkus generates the *message bundle implementation* at build time.  Subsequently, the bundles can be used at runtime:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本的な考え方は、すべてのメッセージは潜在的に非常にシンプルなテンプレートであるということです。型エラーを防ぐために、メッセージは *メッセージバンドルインターフェース* のアノテーションメソッドとして定義されます。Quarkusは、ビルド時に *メッセージバンドルの実装を* 生成します。そのため、実行時にバンドルを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Directly in your code via `io.quarkus.qute.i18n.MessageBundles#get()`; e.g. `MessageBundles.get(AppMessages.class).hello_name("Lucie")`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.qute.i18n.MessageBundles#get()` を経由し、直接コードの中で使用。例: `MessageBundles.get(AppMessages.class).hello_name("Lucie")`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injected in your beans via `@Inject`; e.g. `@Inject AppMessages`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Inject` であなたのBeanに注入。 例: `@Inject AppMessages`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Referenced in the templates via the message bundle namespace:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージ・バンドル名前空間を介してテンプレート内で参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`msg` is the default namespace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`msg` がデフォルトの名前空間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`hello_name` is the message key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`hello_name` がメッセージキーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Lucie` is the parameter of the message bundle interface method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Lucie` はメッセージバンドルインターフェースメソッドのパラメーターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to obtain a localized message for a key resolved at runtime using a reserved key `message`. The validation is skipped in this case though.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、予約されたキー `message` を使用して、実行時に解決されたキーのローカライズされたメッセージを取得することも可能である。この場合、検証はスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Denotes a message bundle interface. The bundle name is defaulted to `msg` and is used as a namespace in templates expressions, e.g. `{msg:hello_name}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージバンドルインターフェイスを表します。 バンドル名のデフォルトは `msg` で、テンプレート式の名前空間として使用されます。例: `{msg:hello_name}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each method must be annotated with `@Message`. The value is a qute template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各メソッドは `@Message` でアノテーションする必要があります。値は qute テンプレートです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameters can be used in the template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドのパラメーターはテンプレートで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bundle Name and Message Keys</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バンドル名とメッセージキー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keys are used directly in templates.  The bundle name is used as a namespace in template expressions.  The `@MessageBundle` can be used to define the default strategy used to generate message keys from method names.  However, the `@Message` can override this strategy and even define a custom key.  By default, the annotated element's name is used as-is.  Other possibilities are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーはテンプレート内で直接使用されます。バンドル名はテンプレート式の名前空間として使用されます。 `@MessageBundle` は、メソッド名からメッセージキーを生成するために使用されるデフォルトのストラテジーを定義するために使用することができます。しかし、 `@Message` はこのストラテジーをオーバーライドし、カスタム・キーを定義することもできます。デフォルトでは、アノテーションされた要素の名前がそのまま使用されます。他の可能性としては、以下のようなものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>De-camel-cased and hyphenated; e.g. `helloName()` -&gt; `hello-name`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャメルケースを止め、ハイフン化したもの。 例: `helloName()` -&gt; `hello-name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>De-camel-cased and parts separated by underscores; e.g. `helloName()` -&gt; `hello_name`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャメルケースを止め、パーツをアンダースコア区切りとしたもの。例: `helloName()` -&gt; `hello_name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All message bundle templates are validated:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのメッセージバンドルテンプレートは検証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All expressions without a namespace must map to a parameter; e.g. `Hello {foo}` -&gt; the method must have a param of name `foo`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間を持たない全ての式はパラメーターにマッピングする必要があります。例: `Hello {foo}` の場合、メソッドは `foo` という名前のパラメータを持つ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All expressions are validated against the types of the parameters; e.g. `Hello {foo.bar}` where the parameter `foo` is of type `org.acme.Foo` -&gt; `org.acme.Foo` must have a property of name `bar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての式はパラメーターの型に対して検証されます。例: `Hello {foo.bar}` で、パラメーター `foo` の型が `org.acme.Foo` の場合、 `org.acme.Foo` は `bar` という名前のプロパティーを持つ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A warning message is logged for each _unused_ parameter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_未使用の_ パラメーターごとに警告メッセージが記録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions that reference a message bundle method, such as `{msg:hello(item.name)}`, are validated too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{msg:hello(item.name)}` のようなメッセージバンドルメソッドを参照する式も検証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Localization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカライゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default locale of the Java Virtual Machine used to *build the application* is used for the `@MessageBundle` interface by default.  However, the `io.quarkus.qute.i18n.MessageBundle#locale()` can be used to specify a custom locale.  Additionally, there are two ways to define a localized bundle:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*アプリケーションのビルド* に使用する Java 仮想マシンのデフォルトのロケールは、デフォルトでは `@MessageBundle` インターフェイスに使用されます。ただし、 `io.quarkus.qute.i18n.MessageBundle#locale()` を使用してカスタムロケールを指定することができます。さらに、ローカライズされたバンドルを定義するには、2 つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an interface that extends the default interface that is annotated with `@Localized`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Localized` でアノテーションされたデフォルトのインターフェイスを拡張するインターフェイスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an UTF-8 encoded file located in `src/main/resources/messages`; e.g. `msg_de.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/resources/messages` に UTF-8 エンコードされたファイルを作成します。例: `msg_de.properties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A localized interface is the preferred solution mainly due to the possibility of easy refactoring.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカライズされたインターフェイスは、主にリファクタリングの容易性から、好ましい解決策です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Localized Interface Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカライズされたインターフェースの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value is the locale tag string (IETF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値はロケールタグ文字列(IETF)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value is the localized template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値はローカライズされたテンプレートです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message bundle files must be encoded in UTF-8.  The file name consists of the relevant bundle name (e.g. `msg`) and underscore followed by the locate tag (IETF).  The file format is very simple: each line represents either a key/value pair with the equals sign used as a separator or a comment (line starts with `#`).  Keys are mapped to method names from the corresponding message bundle interface.  Values represent the templates normally defined by `io.quarkus.qute.i18n.Message#value()`.  We use `.properties` suffix in our example because most IDEs and text editors support syntax highlighting of `.properties` files.  But in fact, the suffix could be anything.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージバンドルファイルはUTF-8でエンコードされている必要があります。ファイル名は、関連するバンドル名(例: `msg` )とアンダースコア、続くロケートタグ(IETF)から構成されます。フ ァ イ ル形式は非常に単純です。各行は、キーと値のペアを表すもので、等号をセパレータとして使用するか、コメント(行頭が `#` で始まる)を使用します。キーは、対応するメッセージ・バンドル・インターフェースのメソッド名にマッピングされています。値は、通常 `io.quarkus.qute.i18n.Message#value()` で定義されているテンプレートを表します。この例では `.properties` サフィックスを使用しています。これは、ほとんどの IDE やテキスト・エディタが `.properties` ファイルのシンタックス・ハイライトをサポートしているからです。しかし、実際には、サフィックスは何でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Localized File Example - `msg_de.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカライズされたファイルの例 - `msg_de.properties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each line in a localized file represents a message template.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカライズされたファイルの各行は、メッセージテンプレートを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keys and values are separated by the equals sign.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーと値は等号で区切られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have the localized bundles defined we need a way to _select_ a correct bundle.  If you use a message bundle expression in a template you'll have to specify the `locale` attribute of a template instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカライズされたバンドルを定義したら、正しいバンドルを _選択する_ 方法が必要です。テンプレートでメッセージバンドル式を使用する場合は、テンプレートインスタンスの `locale` 属性を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can set a `Locale` instance or a locale tag string (IETF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Locale` インスタンスかロケールタグ文字列 (IETF) をセットすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using &lt;&lt;resteasy_integration,quarkus-resteasy-qute&gt;&gt; the `locale` attribute is derived from the the `Accept-Language` header if not set by a user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;resteasy_integration,quarkus-resteasy-qute&gt;&gt; を使用する場合、 `locale` 属性は、ユーザが設定していない場合は `Accept-Language` ヘッダから派生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Localized` qualifier can be used to inject a localized message bundle interface.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Localized` 修飾子を使用して、ローカライズされたMessage Bundleインタフェースを注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injected Localized Message Bundle Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入されたローカライズされた Message Bundle例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The annotation value is a locale tag string (IETF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーションの値はロケールタグ文字列(IETF)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can expose its API description through an OpenAPI specification and how you can test it via a user-friendly UI named Swagger UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがOpenAPI仕様でAPIの説明を公開する方法と、Swagger UIというユーザーフレンドリーなUIを介してテストする方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate how fast you can expose your API specification and benefit from a user interface to test it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、API の仕様をいかに早く公開し、ユーザーインターフェイスから利益を得てテストできるかを実証するために、簡単な REST アプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `openapi-swaggerui-quickstart` {quickstarts-tree-url}/openapi-swaggerui-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `openapi-swaggerui-quickstart` {quickstarts-tree-url}/openapi-swaggerui-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a `/fruits` REST endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、 `/fruits` RESTエンドポイントを持つMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create a `Fruit` bean and a `FruitResouce` REST resource (feel free to take a look to the link:rest-json[Writing JSON REST services guide] if your want more details on how to build a REST API with Quarkus).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Fruit` Beanと `FruitResouce` RESTリソースを作成します(QuarkusでREST APIを構築する方法の詳細については、 link:rest-json[Writing JSON REST servicesガイド] を参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we changed the API, we also need to update the test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>APIを変更したので、テストの更新も必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the https://github.com/smallrye/smallrye-open-api/[Smallrye OpenAPI] extension compliant with the https://github.com/eclipse/microprofile-open-api/[MicroProfile OpenAPI] specification in order to generate your API https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md[OpenAPI v3 specification].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、API link:https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md[OpenAPI v3仕様] を生成するために、 link:https://github.com/eclipse/microprofile-open-api/[Eclipse MicroProfile OpenAPI] 仕様に準拠した `smallrye-openapi` エクステンションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You just need to add the `openapi` extension to your Quarkus application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションに `openapi` のエクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we are ready to run our application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、アプリケーションを実行する準備が整いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is started, you can make a request to the default `/q/openapi` endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを起動すると、デフォルトの `/q/openapi` エンドポイントにリクエストを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not like the default endpoint location `/q/openapi`, you can change it by adding the following configuration to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたがデフォルトのエンドポイントの場所 `/q/openapi` を好きではない場合 , あなたの `application.properties` に次の設定を追加することで、場所を変更することができます .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing Application Level OpenAPI Annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションレベルのOpenAPIアノテーションの提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some MicroProfile OpenAPI annotations which describe global API information, such as the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のようなグローバルAPI情報を記述するMicroProfile OpenAPIアノテーションがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contact Information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>連絡先情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>License</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライセンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Loading OpenAPI Schema From Static Files</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>静的ファイルからの OpenAPI スキーマのロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of dynamically creating OpenAPI schemas from annotation scanning, Quarkus also supports serving static OpenAPI documents.  The static file to serve must be a valid document conforming to the https://swagger.io/docs/specification[OpenAPI specification].  An OpenAPI document that conforms to the OpenAPI Specification is itself a valid JSON object, that can be represented in `yaml` or `json` formats.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、アノテーションスキャンからOpenAPIスキーマを動的に作成する代わりに、静的なOpenAPIドキュメントの配信もサポートしています。サーブする静的ファイルは、 link:https://swagger.io/docs/specification[OpenAPI仕様] に準拠した有効なドキュメントである必要があります。OpenAPI仕様に準拠したOpenAPIドキュメントは、それ自体が有効なJSONオブジェクトであり、 `yaml` または `json` 形式で表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see this in action, we'll put OpenAPI documentation under `META-INF/openapi.yaml` for our `/fruits` endpoints.  Quarkus also supports alternative &lt;&lt;open-document-paths, OpenAPI document paths&gt;&gt; if you prefer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを実際に確認するために、  `META-INF/openapi.yaml` のOpenAPIドキュメントを `/fruits` エンドポイントで公開します。Quarkusでは、必要に応じて代替の link:#open-document-paths[OpenAPIドキュメントパス] もサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a request to `/q/openapi` will serve the combined OpenAPI document from the static file and the model generated from application endpoints code.  We can however change this to only serve the static OpenAPI document by adding `mp.openapi.scan.disable=true` configuration into `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `/q/openapi` へのリクエストは、静的ファイルとアプリケーション エンドポイント コードから生成されたモデルを組み合わせた OpenAPI ドキュメントを提供します。しかし、 `application.properties` に `mp.openapi.scan.disable=true` 設定を追加することで、静的な OpenAPI ドキュメントのみを提供するように変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, a request to `/q/openapi` endpoint will serve the static OpenAPI document instead of the generated one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、 `/q/openapi` エンドポイントへのリクエストは、生成されたものではなく静的な OpenAPI ドキュメントを提供するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports various paths to store your OpenAPI document under. We recommend you place it under `META-INF/openapi.yml`.  Alternative paths are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、OpenAPIドキュメントを保存するためのさまざまなパスをサポートしています。 `META-INF/openapi.yml` 以下に配置することをお勧めします。代替パスは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`META-INF/openapi.yaml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`META-INF/openapi.yaml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`META-INF/openapi.yml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`META-INF/openapi.yml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`META-INF/openapi.json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`META-INF/openapi.json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WEB-INF/classes/META-INF/openapi.yml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`WEB-INF/classes/META-INF/openapi.yml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WEB-INF/classes/META-INF/openapi.yaml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`WEB-INF/classes/META-INF/openapi.yaml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WEB-INF/classes/META-INF/openapi.json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`WEB-INF/classes/META-INF/openapi.json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live reload of static OpenAPI document is supported during development. A modification to your OpenAPI document will be picked up on fly by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発中は、静的なOpenAPIドキュメントのライブリロードがサポートされています。OpenAPIドキュメントへの変更は、Quarkusによって起動中にピックアップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when the document is generated, the OpenAPI version used will be `3.0.3`. If you use a static file as mentioned above, the version in the file will be used. You can also define the version in SmallRye using the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、ドキュメント生成時に使用されるOpenAPIのバージョンは `3.0.3` です。上記のように静的ファイルを使用する場合は、そのファイルのバージョンが使用されます。また、以下の設定でSmallRyeでバージョンを定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Auto-generation of Operation Id</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>操作IDの自動生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The strategies available for generating the Operation Id</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>操作Idを生成するために利用可能な戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the method name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッド名を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the class name (without the package) plus the method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(パッケージを含まない)クラス名とメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the class name plus the method name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラス名とメソッド名を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Swagger UI for development</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発にSwagger UIを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building APIs, developers want to test them quickly. https://swagger.io/tools/swagger-ui/[Swagger UI] is a great tool permitting to visualize and interact with your APIs.  The UI is automatically generated from your OpenAPI specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>APIを構築する際、開発者は素早くテストしたいと考えています。 link:https://swagger.io/tools/swagger-ui/[Swagger UI] は、APIを視覚化して対話するための素晴らしいツールです。UIはOpenAPI仕様から自動的に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Swagger UI is only available when Quarkus is started in dev or test mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Swagger UIは、Quarkusをdevモードまたはtestモードで起動したときにのみ使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to make it available in production too, you can include the following configuration in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番環境でも利用できるようにしたい場合は、以下の設定を `application.properties` に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a build time property, it cannot be changed at runtime after your application is built.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはビルド時プロパティーで、アプリケーションがビルドされた後、ランタイムに変更することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Swagger UI is accessible at `/q/swagger-ui`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Swagger UIは `/q/swagger-ui` でアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the `/swagger-ui` sub path by setting the `quarkus.swagger-ui.path` property in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` の `quarkus.swagger-ui.path` プロパティーを設定することで、 `/swagger-ui` サブパスを更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can check the Swagger UI path in your application's log:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのログでSwaggerのUIパスを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is started, you can go to http://localhost:8080/q/swagger-ui and play with your API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが起動したら、 http://localhost:8080/q/swagger-ui にアクセスしてAPIで遊ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can visualize your API's operations and schemas.  image:openapi-swaggerui-guide-screenshot01.png[alt=Visualize your API]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>APIの操作やスキーマを可視化することができます。 image:openapi-swaggerui-guide-screenshot01.png[alt="Visualize your API"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also interact with your API in order to quickly test it.  image:openapi-swaggerui-guide-screenshot02.png[alt=Interact with your API]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、APIを素早くテストするためにAPIと対話することもできます。 image:openapi-swaggerui-guide-screenshot02.png[alt="Interact with your API"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenAPI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>用語集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントやウェブサイトで好まれる用語を集めたものです。一貫性を保つために、これらの用語の範囲内にとどめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>* ライブコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Maven, you can scaffold a new project with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mavenを使えば、新しいプロジェクトをスキャフォールド(足場の作成)できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`platformGroupId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`platformGroupId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The group id of the target platform. Given that all the existing platforms are coming from `io.quarkus` this one won't practically be used explicitly. But it's still an option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>対象となるプラットフォームのグループID。既存のすべてのプラットフォームが `io.quarkus` から来ていることを考えると、実際にはこれは明示的には使われないでしょう。しかし、これはまだオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`platformArtifactId`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`platformArtifactId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-universe-bom`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-universe-bom`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The artifact id of the target platform BOM. It should be `quarkus-bom` in order to use the locally built Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ターゲットプラットフォームBOMのアーティファクトID。ローカルでビルドされたQuarkusを使用するためには、 `quarkus-bom` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`platformVersion`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`platformVersion`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's not specified, the latest one will be resolved.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指定されていない場合は、最新のものに解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of the platform you want the project to use. It can also accept a version range, in which case the latest from the specified range will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトで使用したいプラットフォームのバージョンを指定します。バージョンの範囲を指定することもでき、その場合は指定した範囲の最新のものが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the command will target the latest version of `quarkus-universe-bom` (unless specific coordinates have been specified). If you run offline however, it will look for the latest locally available and if `quarkus-universe-bom` (satisfying the default version range which is currently up to 2.0) is not available locally, it will fallback to the bundled platform based on `quarkus-bom` (the version will match the version of the plugin).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、このコマンドは `quarkus-universe-bom`  の最新バージョンをターゲットにします (特定の coordinates が指定されていない限り)。しかし、オフラインで実行した場合、ローカルで利用可能な最新のものを探し、 `quarkus-universe-bom`  (現在 2.0 までのデフォルトのバージョン範囲を満たしている) がローカルで利用できない場合は、 `quarkus-bom`  をベースにしたバンドルされたプラットフォームにフォールバックします (バージョンはプラグインのバージョンと一致します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is generated in a directory named after the passed artifactId.  If the directory already exists, the generation fails.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトは、渡された artifactId にちなんだ名前のディレクトリーに生成されます。ディレクトリーが既に存在する場合は、生成に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グロブパターンに一致するすべてのエクステンションをインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a built-in development mode.  Run your application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには開発モードが組み込まれています。以下でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus:dev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティーファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkus:dev` sets the debug host to `localhost` (for security reasons). If you need to change this, for example to enable debugging on all hosts, you can use the `-DdebugHost` option like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `quarkus:dev` はデバッグホストを `localhost` に設定します (セキュリティー上の理由から)。これを変更する必要がある場合、例えばすべてのホストでデバッグを有効にしたい場合は、 `-DdebugHost` オプションを次のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production application in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app. This is done via a HTTP based long polling transport, that will synchronize your local workspace and the remote application via HTTP calls.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、ブラウザを更新するたびに、ローカルで行った変更がリモート アプリに即座に表示されるようになりました。これは、HTTPベースのロングポーリングトランスポートを介して行われ、HTTPコールを介してローカルのワークスペースとリモートアプリケーションを同期させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want to use the HTTP feature then you can simply run the `remote-dev` command without specifying the URL.  In this mode the command will continuously rebuild the local application, so you can use an external tool such as odo or rsync to sync to the remote application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP 機能を使用したくない場合は、URL を指定せずに `remote-dev`  コマンドを実行するだけです。このモードでは、コマンドはローカルアプリケーションを継続的に再構築するので、 odo や rsync のような外部ツールを使ってリモートアプリケーションに同期することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended you use SSL when using remote dev mode, however even if you are using an unencrypted connection your password is never sent directly over the wire. For the initial connection request the password is hashed with the initial state data, and subsequent requests hash it with a random session id generated by the server and any body contents for POST requests, and the path for DELETE requests, as well as an incrementing counter to prevent replay attacks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモート開発モードを使用する際には SSL を使用することを推奨しますが、たとえ暗号化されていない接続を使用していても、パスワードが直接ネットワーク上で送信されることはありません。最初の接続リクエストでは、パスワードは初期状態のデータでハッシュ化され、それ以降のリクエストでは、サーバーによって生成されたランダムなセッションIDと、POSTリクエストのためのボディコンテンツ、DELETEリクエストのためのパス、そしてリプレイ攻撃を防ぐためのインクリメントカウンタでハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Development Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Maven plugin picks up compiler flags to pass to `javac` from `maven-compiler-plugin`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Maven プラグインは `maven-compiler-plugin`  から `javac`  に渡すコンパイラフラグをピックアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used in development mode, add a `configuration` section to the `plugin` block and set the `compilerArgs` property just as you would when configuring `maven-compiler-plugin`.  You can also set `source`, `target`, and `jvmArgs`.  For example, to pass `--enable-preview` to both the JVM and `javac`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードで使用するコンパイラ・フラグをカスタマイズする必要がある場合は、 `plugin`  ブロックに `configuration`  セクションを追加し、 `maven-compiler-plugin`  を設定するときと同じように `compilerArgs`  プロパティーを設定します。また、 `source`  、 `target`  、および `jvmArgs`  を設定することもできます。例えば、 `--enable-preview`  を JVM と `javac`  の両方に渡すには、 を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./mvnw compile quarkus:dev -Dsuspend` which is a shorthand for `./mvnw compile quarkus:dev -Dsuspend=true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw compile quarkus:dev -Dsuspend` を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます( `./mvnw compile quarkus:dev -Dsuspend=true` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./mvnw compile quarkus:dev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離された端末で `./mvnw compile quarkus:dev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルまたは組み込みのターミナルで、 `./mvnw compile quarkus:dev`  を実行してください。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./mvnw compile quarkus:dev`  を実行します。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).  Verify that your `pom.xml` has the proper `native` profile (see &lt;&lt;build-tool-maven&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(GraalVMのJava 11バージョンを使用していることを確認してください)。あなたの `pom.xml`  が適切な `native`  プロファイルを持っていることを確認してください( link:#build-tool-maven[[build-tool-maven]を]参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.  A native executable will be present in `target/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw package -Pnative` を使用してネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `target/` に出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run Integration Tests on the native executable, make sure to have the proper Maven plugin configured (see &lt;&lt;build-tool-maven&gt;&gt;) and launch the `verify` goal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルで統合テストを実行するには、適切なMavenプラグインが設定されていることを確認し( link:#build-tool-maven[[build-tools-maven]を]参照)、 `verify`  ゴールを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can follow the link:building-native-image[Build a native executable guide] as well as link:deploying-to-kubernetes[Deploying Application to Kubernetes and OpenShift] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:building-native-image[ネイティブ実行ファイルのビルドガイド]と同様に、 link:deploying-to-kubernetes[アプリケーションをKubernetesとOpenShiftにデプロイ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have not used &lt;&lt;project-creation,project scaffolding&gt;&gt;, add the following elements in your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;&lt;project-creation,プロジェクトのスキャフォールド&gt;&gt;を使用していない場合は、以下の要素を `pom.xml` に追加してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally use a BOM file to omit the version of the different Quarkus dependencies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションで、BOMファイルを使用して、異なるQuarkus依存関係のバージョンを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus Maven plugin that will hook into the build process.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドプロセスにフックするQuarkus Mavenプラグインを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add system properties to `maven-surefire-plugin`. + `maven.home` is only required if you have custom configuration in `${maven.home}/conf/settings.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>システムのプロパティーを `maven-surefire-plugin`  に追加します。+ `maven.home`  は、 `${maven.home}/conf/settings.xml`  にカスタム設定がある場合にのみ必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a specific `native` profile for native executable building.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行可能ファイルのビルドには、特定の `native`  プロファイルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the `native` package type. The build will therefore produce a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`native`  パッケージタイプを有効にします。そのため、ビルドはネイティブ実行可能ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to test your native executable with Integration Tests, add the following plugin configuration. Test names `*IT` and annotated `@NativeImageTest` will be run against the native executable. See the link:building-native-image[Native executable guide] for more info.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Integration Testsでネイティブ実行可能ファイルをテストしたい場合は、以下のプラグイン設定を追加してください。テスト名 `*IT`  と注釈付き `@NativeImageTest`  は、ネイティブ実行ファイルに対して実行されます。詳細は link:building-native-image[ネイティブ実行ファイルガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fast-jar` is now the default quarkus package type. The result of `./mvnw package` command is a new directory under `target` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fast-jar`が現在デフォルトのQuarkusのパッケージタイプです。 `./mvnw package` コマンドを実行した結果、 `target` の下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Maven plugin supports the generation of Uber-Jars by specifying a `quarkus.package.type=uber-jar` configuration option in your `application.properties` (or `&lt;quarkus.package.type&gt;uber-jar&lt;/quarkus.package.type&gt;` in your `pom.xml`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Mavenプラグインは、 `application.properties` .Quarkus Mavenプラグインで `quarkus.package.type=uber-jar`  設定オプションを指定することで、UberJar の生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The original jar will still be present in the `target` directory but it will be renamed to contain the `.original` suffix.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>元の jar は `target`  ディレクトリーに残っていますが、 `.original`  の接尾辞を含むように名前が変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `quarkus.package.ignored-entries` configuration option, this takes a comma separated list of entries to ignore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Uber-jar をビルドする際に、 `quarkus.package.ignored-entries`  設定オプションを使用して生成された jar から除外したいエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar creation by default excludes link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[signature files] that might be present in the dependencies of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Uber-Jar の作成は、アプリケーションの依存関係に存在する可能性のある link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[署名ファイル]を除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar's final name is configurable via a Maven's build settings `finalName` option.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Uber-Jarの最終的な名前は、Mavenのビルド設定 `finalName`  オプションで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include the `jandex-maven-plugin`, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチモジュールプロジェクト内のモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されていない限り、`jandex-maven-plugin`  をインクルードすることです。モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されている場合は自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Project Output</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト出力の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a several configuration options that will define what the output of your project build will be.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのビルドの出力を定義するための設定オプションがいくつかあります。これらは他の設定プロパティーと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Maven Surefire and Maven Failsafe configurations shown below. This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ただし、以下に示すMaven SurefireおよびMaven Failsafe構成で、テストにカスタム構成プロファイルを使用することは可能です。これは、例えば、デフォルトのテストデータベースではない特定のデータベースを使用してテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security provides the architecture, multiple authentication and authorization mechanisms, and other tools for the developers to build a production-quality security for their Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Securityでは、開発者がQuarkusアプリケーションの商用品質のセキュリティーを構築するためのアーキテクチャ、複数の認証および認可メカニズム、その他のツールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document provides a brief overview of Quarkus Security and links to the individual guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、Quarkus Securityの簡単な概要と、各ガイドへのリンクについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`HttpAuthenticationMechanism` is the main entry into Quarkus HTTP Security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`HttpAuthenticationMechanism`  は、Quarkus HTTP Securityのメインエントリーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security Manager uses `HttpAuthenticationMechanism` to extract the authentication credentials from the HTTP request and delegates to `IdentityProvider` to complete the conversion of these credentials to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Security Managerは、 `HttpAuthenticationMechanism`  を使用してHTTPリクエストから認証資格情報を抽出し、 `IdentityProvider`  に委任して、これらの資格情報の `SecurityIdentity`  への変換を完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the credentials may be coming with the HTTP `Authorization` header, client HTTPS certificates or cookies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、資格情報は、HTTP `Authorization`  ヘッダー、クライアントの HTTPS 証明書、またはクッキーを使用している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` verifies the authentication credentials and maps them to `SecurityIdentity` which contains the username, roles, the original authentication credentials, and other attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`IdentityProvider`  は認証資格情報を検証し、ユーザー名、ロール、元の認証資格情報、およびその他の属性を含む `SecurityIdentity`  にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every authenticated resource, you can inject a `SecurityIdentity` instance to get the authenticated identity information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証済みリソースごとに、 `SecurityIdentity`  インスタンスを注入して、認証済みの ID 情報を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some other contexts you may have other parallel representations of the same information (or parts of it) such as `SecurityContext` for JAX-RS or `JsonWebToken` for JWT.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他の文脈では、JAX-RSであれば `SecurityContext`  、JWTであれば `JsonWebToken`  のように、同じ情報(またはその一部)を他の別の表現で表現している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports several sources to load authentication information from.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、認証情報をロードするためのいくつかのソースをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本認証とフォーム認証の仕組み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form HTTP-based authentication mechanisms are the core authentication mechanisms supported in Quarkus.  Please see link:security-built-in-authentication#basic-auth[Basic HTTP Authentication] and link:security-built-in-authentication#form-auth[Form HTTP Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Basic HTTPベースの認証メカニズムとForm HTTPベースの認証メカニズムは、Quarkusでサポートされている主要な認証メカニズムです。詳細については、 link:security-built-in-authentication#basic-auth[基本HTTP認証]と link:security-built-in-authentication#form-auth[フォームHTTP認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutual TLS Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相互TLS認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides Mutual TLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは相互TLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security-built-in-authentication#mutual-tls[Mutual TLS Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳しくは link:security-built-in-authentication#mutual-tls[相互TLS認証] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenId Connect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenId Connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` extension provides a reactive, interoperable, multi-tenant enabled OpenId Connect adapter which supports `Bearer Token` and `Authorization Code Flow` authentication mechanisms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc`  エクステンションは、 `Bearer Token`  および `Authorization Code Flow`  認証メカニズムをサポートする、リアクティブで相互運用可能なマルチテナント対応の OpenId Connect アダプターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bearer Token` mechanism extracts the token from HTTP `Authorization` header.  `Authorization Code Flow` mechanism uses OpenId Connect Authorization Code flow. It redirects the user to IDP to authenticate and completes the authentication process after the user has been redirected back to Quarkus by exchanging the provided code grant for ID, access and refresh tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Bearer Token`  メカニズムは、HTTP `Authorization`  ヘッダーからトークンを抽出します。 `Authorization Code Flow`  メカニズムは、OpenId Connect Authorization Code Flowを使用します。ユーザーをIDPにリダイレクトして認証を行い、提供されたCode GrantをID、アクセストークン、リフレッシュトークンと交換することで、ユーザーがQuarkusにリダイレクトされた後に認証プロセスを完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ID and access `JWT` tokens are verified with the refreshable `JWK` key set but both JWT and opaque (binary) tokens can be introspected remotely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ID とアクセス `JWT` トークンは、リフレッシュ可能な `JWK` キーセットで検証されますが、JWT と不透明な (バイナリーの) トークンの両方をリモートで検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application] guide for more information about `Authorization Code Flow` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Authorization Code Flow`  認証メカニズムの詳細については、 link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `quarkus-oidc` `Bearer` and `Authorization Code Flow` Authentication mechanisms use &lt;&lt;smallrye-jwt, SmallRye JWT&gt;&gt; to represent JWT tokens as Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` の`Bearer` と `Authorization Code Flow`  認証メカニズムはいずれも link:#smallrye-jwt[SmallRye JWT ]を使用して、JWT トークンを Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken` として表現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] for more information about multiple tenants which can support `Bearer` or `Authorization Code Flow` authentication mechanism and configured statically or dynamically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Bearer`  または `Authorization Code Flow`  認証メカニズムをサポートし、静的または動的に設定できる複数のテナントの詳細については、 link:security-openid-connect-multitenancy[OpenID Connect マルチテナントの使用]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would like to have Quarkus OIDC extension enabled at runtime then set `quarkus.oidc.tenant-enabled=false` at build time and re-enable it at runtime using a system property.  See also link:security-openid-connect-multitenancy#disable-tenant[Disabling Tenant Configurations] for more information about managing the individual tenant configurations in the multi-tenant OIDC deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時にQuarkus OIDCエクステンションを有効にしたい場合は、ビルド時に `quarkus.oidc.tenant-enabled=false` を設定し、システムプロパティーを使用して実行時に再度有効にします。マルチテナントOIDCデプロイメントでの個々のテナント設定の管理の詳細については、テナント link:security-openid-connect-multitenancy#disable-tenant[設定の無効化]も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to configure Keycloak programmatically then consider using https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API] with the help of the `quarkus-keycloak-admin-client` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloakをプログラムで設定する必要がある場合は、 `quarkus-keycloak-admin-client` エクステンションの助けを借りて、 link:https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API]の使用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-client` extension provides `OidcClient` for acquiring and refreshing access tokens from OpenId Connect and OAuth2 providers which support `client-credentials`, `password` and `refresh_token` token grants.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client` エクステンションは、 `client-credentials` , `password` , `refresh_token` トークングラントをサポートする OpenId Connect および OAuth2 プロバイダからアクセストークンを取得したり、更新したりするための `OidcClient` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-client-filter` extension depends on the `quarkus-oidc-client` extension and provides JAX-RS `OidcClientRequestFilter` which sets the access token acquired by `OidcClient` as an HTTP `Authorization` header's `Bearer` scheme value. This filter can be registered with MP RestClient implementations injected into the current Quarkus endpoint but it is not related to the authentication requirements of this service endpoint. For example, it can be a public endpoint or it can be protected with MTLS - the important point is that this Quarkus endpoint does not have to be protected itself with the Quarkus OpenId Connect adapter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client-filter` エクステンションは `quarkus-oidc-client` エクステンションに依存し、 `OidcClient` で取得したアクセストークンを HTTP `Authorization` ヘッダーの `Bearer` スキーム値として設定する JAX-RS `OidcClientRequestFilter` を提供します。このフィルターは、現在のQuarkusエンドポイントに注入されたMP RestClient実装で登録することができますが、このサービスエンドポイントの認証要件には関係ありません。例えば、パブリックエンドポイントにすることもできますし、MTLSで保護することもできます - 重要な点は、このQuarkusエンドポイントは、Quarkus OpenId Connectアダプターでそれ自体を保護する必要がないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-token-propagation` extension depends on the `quarkus-oidc` extension and provides JAX-RS `TokenCredentialRequestFilter` which sets the OpenId Connect Bearer or Authorization Code Flow access token as an HTTP `Authorization` header's `Bearer` scheme value. This filter can be registered with MP RestClient implementations injected into the current Quarkus endpoint and the Quarkus endpoint must be protected itself with the Quarkus OpenId Connect adapter. This filter can be used to propagate the access token to the downstream services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-token-propagation` エクステンションは `quarkus-oidc` エクステンションに依存し、OpenId Connect ベアラーまたは Authorization Code Flow アクセストークンを HTTP `Authorization` ヘッダーの `Bearer` スキーム値として設定する JAX-RS `TokenCredentialRequestFilter` を提供します。このフィルターは、現在のQuarkusエンドポイントに注入されたMP RestClient実装で登録することができ、QuarkusエンドポイントはQuarkus OpenId Connectアダプターでそれ自体を保護する必要があります。このフィルターは、アクセストークンを下流のサービスに伝播させるために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect-client[Using OpenID Connect and OAuth2 Client] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:security-openid-connect-client[OpenID Connect と OAuth2 クライアントの使用] ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` provides Microprofile JWT 1.1.1 implementation and many more options to verify signed and encrypted `JWT` tokens and represent them as `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` はMicroprofile JWT 1.1.1.1 の実装と、署名・暗号化された `JWT` トークンを検証し、 `org.eclipse.microprofile.jwt.JsonWebToken` として表現するための多くのオプションを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It can currently verify only `JWT` tokens using the PEM keys or refreshable `JWK` key set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それは `quarkus-oidc` ベアラートークン認証メカニズムに代わるものを提供します。現在、PEM 鍵または更新可能な `JWK` 鍵セットを使用して `JWT` トークンのみを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally it provides `JWT Generation API` for creating `signed`, `inner-signed` and/or `encrypted` `JWT` tokens with ease.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、 `JWT Generation API` を提供して、 `signed` , `inner-signed` , および/または `encrypted` `JWT`トークンを簡単に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-jwt[Using SmallRye JWT] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:security-jwt[Using SmallRye JWT]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It is based on `Elytron` and is primarily meant for introspecting the opaque tokens remotely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-elytron-security-oauth2`  は `quarkus-oidc`  Bearer Token 認証メカニズムの代替手段を提供します。これは `Elytron` をベースにしており、主に不透明なトークンをリモートでイントロスペクトするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-oauth2[Using OAuth2] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:security-oauth2[OAuth2 の使用]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` extension requires an OpenId Connect provider such as Keycloak which can be used to verify the Bearer tokens or authenticate the end users with the Authorization Code flow. In both cases `quarkus-oidc` requires a connection to this OpenId Connect provider.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` エクステンションには、Keycloak のような OpenId Connect プロバイダーが必要で、これは Bearer トークンの検証や Authorization Code フローによるエンドユーザーの認証に使用することができます。どちらの場合も、 `quarkus-oidc` は、この OpenId Connect プロバイダーへの接続を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` is the only option when the user authentication via Authorization Code flow or supporting multiple tenants is required. It can also request a UserInfo using both Authorization Code Flow and Bearer access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` は、Authorization Code フローによるユーザー認証や、複数のテナントへの対応が必要な場合の唯一の選択肢です。また、Authorization Code FlowとBearerアクセストークンの両方を使ってUserInfoを要求することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the Bearer tokens have to be verified then `quarkus-oidc`, `quarkus-smallrye-jwt` and `quarkus-elytron-security-oauth2` can be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラートークンを検証する必要がある場合は、 `quarkus-oidc` 、 `quarkus-smallrye-jwt` 、 `quarkus-elytron-security-oauth2` を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have Bearer tokens in a JWT format then all these 3 extensions can be used. Both `quarkus-oidc` and `quarkus-smallrye-jwt` support refreshing the JsonWebKey (JWK) set when the OpenId Connect provider rotates the keys, therefore `quarkus-oidc` or `quarkus-smallrye-jwt` should be used for verifying JWT tokens if the remote token introspection has to be avoided or not supported by the providers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JWT形式のBearerトークンを持っている場合は、これら3つのエクステンションをすべて使用することができます。 `quarkus-oidc` と `quarkus-smallrye-jwt` は、OpenId Connect プロバイダーがキーをローテーションする際の JsonWebKey (JWK) セットのリフレッシュをサポートしています。したがって、リモートトークンのイントロスペクションを回避しなければならない場合や、プロバイダーがサポートしていない場合は、JWT トークンの検証に `quarkus-oidc` または `quarkus-smallrye-jwt` を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` does not support the remote introspection of the opaque tokens or even JWT tokens - it always relies on the locally available keys - possibly fetched from the OpenId Connect provider. So if you need to introspect the JWT tokens remotely then both `quarkus-oidc` and `quarkus-elytron-security-oauth2` will work. Both extensions also support the verification of the opaque/binary tokens via the remote introspection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` は、不透明なトークンや JWT トークンのリモートイントロスペクションをサポートしていません。これは常に、ローカルで利用可能なキー（おそらく OpenId Connect プロバイダーから取得されたもの）に依存します。したがって、JWTトークンをリモートでイントロスペクションする必要がある場合は、 `quarkus-oidc` と `quarkus-elytron-security-oauth2` の両方が機能します。どちらのエクステンションも、リモートイントロスペクションによる不透明/バイナリトークンの検証もサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` and `quarkus-smallrye-jwt` can have both JWT and opaque tokens injected into the endpoint code - the injected JWT tokens may offer a richer information about the user. All extensions can have the tokens injected as `Principal`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc` と `quarkus-smallrye-jwt` は、JWT トークンと不透明なトークンの両方をエンドポイントコードに注入することができます。注入された JWT トークンは、ユーザーに関するより豊富な情報を提供することができます。すべてのエクステンションは、 `Principal` として、トークンを注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` supports more key formats than `quarkus-oidc`. The latter will only use the JWK-formatted keys which are part of a JWK set. The former - can also work with PEM keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` は `quarkus-oidc` よりも多くのキーフォーマットをサポートしています。後者は、JWKセットの一部であるJWKフォーマットの鍵のみを使用します。前者では、PEMキーも使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` can handle locally not only signed but also inner-signed-and-encrypted or only encrypted tokens. In fact `quarkus-oidc` and `quarkus-elytron-security-oauth2` can verify such tokens too but only by treating them as opaque tokens and verifying them via the remote introspection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-jwt` は、署名されたトークンだけでなく、内部署名と暗号化されたトークン、または暗号化されたトークンをローカルに扱うことができます。実際、 `quarkus-oidc` と `quarkus-elytron-security-oauth2` はそのようなトークンも検証できますが、それらを不透明なトークンとして扱い、リモートイントロスペクションを介して検証することによってのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` is the best choice if you need a light weight library for the remote introspection of either opaque or JWT tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-elytron-security-oauth2` は、不透明なトークンやJWTトークンをリモートでイントロスペクションするための軽量なライブラリが必要な場合に最適な選択肢です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a choice of using the opaque versus JWT token format is often driven by the architectural considerations. Opaque tokens are usually much shorter than JWT tokens but they require maintaining most of the token associated state in the provider database - the opaque tokens are effectively the database pointers. JWT tokens are significantly longer than the opaque tokens - but the providers are effectively delegating storing most of the token associated state to the client by storing it as the token claims and either signing and/or encrypting them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不透明なトークンとJWTトークンのどちらを使用するかは、多くの場合、アーキテクチャ上の考慮事項によって決定されることに注意してください。不透明なトークンは、通常、JWT トークンよりもはるかに短いですが、トークンに関連する状態のほとんどをプロバイダのデータベースで維持する必要があります。JWT トークンは、不透明なトークンよりもかなり長いですが、プロバイダは、トークンに関連する状態のほとんどを、トークン・クレームとして保存し、それらに署名や暗号を施すことで、事実上、クライアントに保存を委ねています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a summary of the options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下、選択肢の概要をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-oidc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-oidc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-smallrye-jwt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-smallrye-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-elytron-security-oauth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-elytron-security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bearer JWT verification is required</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラー JWTの検証が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local Verification or Introspection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカル検証またはイントロスペクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Local Verification</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカル検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introspection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イントロスペクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bearer Opaque Token verification is required</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアラー不透明 Tokenの検証が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>No</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Yes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Represent token as Principal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トークンをプリンシパルとして表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization Code Flow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認可コードフロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multi-tenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチテナンシー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Token Verificition</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムトークン検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Injected JWTParser</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションされたJWTParserで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see the link:security-ldap[Authenticate with LDAP] guide for more information about LDAP authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>LDAP認証メカニズムの詳細については、 link:security-ldap[Authenticate with LDAP]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity Providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アイデンティティ・プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`IdentityProvider`  は、 `HttpAuthenticationMechanism`  が提供する認証資格情報を `SecurityIdentity`  に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions such as `OIDC`, `OAuth2`, `SmallRye JWT`, `LDAP` have the inlined `IdentityProvider` implementations which are specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`OIDC` , `OAuth2` , `SmallRye JWT` , `LDAP`  などのエクステンションには、サポートされている認証フローに固有の `IdentityProvider` のインライン実装があります。例えば、 `quarkus-oidc` は独自の `IdentityProvider` を使用してトークンを `SecurityIdentity` に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use `Basic` or `Form` HTTP-based authentication then you have to add an `IdentityProvider` which can convert a user name and password to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Basic` または `Form` HTTP ベースの認証を使用している場合は、ユーザー名とパスワードを `SecurityIdentity` に変換できる `IdentityProvider` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-jpa[JPA IdentityProvider] and link:security-jdbc[JDBC IdentityProvider] for more information.  You can also use link:security-testing#configuring-user-information[User Properties IdentityProvider] for testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は、 link:security-jpa[JPA IdentityProvider]および link:security-jdbc[JDBC IdentityProvider]を参照してください。また、テストに link:security-testing#configuring-user-information[User Properties IdentityProvider を]使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証メカニズムの組み合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can combine multiple authentication mechanisms if they get the authentication credentials from the different sources.  For example, combining built-in `Basic` and `quarkus-oidc` `Bearer` authentication mechanisms is allowed, but combining `quarkus-oidc` `Bearer` and `smallrye-jwt` authentication mechanisms is not allowed because both will attempt to verify the token extracted from the HTTP `Authorization Bearer` scheme.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>異なるソースから認証証明書を取得する場合、複数の認証メカニズムを組み合わせることができます。例えば、組み込みの `Basic`  と `Bearer`   `quarkus-oidc`  認証機構を組み合わせることはできますが、 `quarkus-oidc`   `Bearer`  と `smallrye-jwt`  認証機構を組み合わせることはできません。なぜなら、両方とも HTTP `Authorization Bearer`  スキームから抽出されたトークンを検証しようとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます(ターゲットページが認証を必要としない場合でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-built-in-authentication#proactive-authentication[Proactive Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:security-built-in-authentication#proactive-authentication[プロアクティブ認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認可</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-authorization[Security Authorization] for more information about Role Based Access Control and other authorization options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>役割ベースのアクセス制御およびその他の認可オプションの詳細については、 link:security-authorization[セキュリティー認可]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customization and other useful tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタマイズやその他の便利なヒント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security is highly customizable. One can register custom ``HttpAuthenticationMechanism``s, ``IdentityProvider``s and ``SecurityidentityAugmentor``s.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Securityは、高度なカスタマイズが可能です。カスタム `HttpAuthenticationMechanism` 、 `IdentityProvider` 、 `SecurityidentityAugmentor` を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-customization[Security Customization] for more information about customizing Quarkus Security and other useful tips about the reactive security, registering the security providers, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Securityのカスタマイズの詳細や、リアクティブセキュリティー、セキュリティープロバイダーの登録などの便利なヒントについては、セキュリティーの link:security-customization[カスタマイズ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:http-reference#ssl[Supporting secure connections with SSL] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:http-reference#ssl[SSL による安全な接続のサポート]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-Origin Resource Sharing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クロスオリジンリソース共有</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to make your Quarkus application accessible to another application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the link:http-reference#cors-filter[HTTP CORS documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションを別のドメインで実行している別のアプリケーションにアクセスできるようにする場合は、CORS(Cross-Origin Resource Sharing)を設定する必要があります。詳細については、 link:http-reference#cors-filter[HTTP CORSのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:vertx#same-site-cookie[SameSite cookies] for information about adding a https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie property to any of the cookies set by a Quarkus endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエンドポイントによって設定されたCookieに link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] Cookieプロパティーを追加する方法については、 link:vertx#same-site-cookie[SameSite Cookie] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-testing[Security Testing] for more information about testing Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Securityのテストの詳細については、 link:security-testing[セキュリティーのテスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret Engines</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シークレットエンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a very comprehensive HashiCorp Vault support, please see the link:vault[Quarkus and HashiCorp Vault] documentation for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは非常に包括的な HashiCorp Vault のサポートを提供しています。詳しくは link:vault[Quarkus and HashiCorp Vault] のドキュメントを参照下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>National Vulnerability Database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>National Vulnerability Database</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of Quarkus tags have been registered in link:https://nvd.nist.gov[National Vulnerability Database] (NVD) using a Common Platform Enumeration (CPE) name format.  All registered Quarkus CPE names can be found using link:https://nvd.nist.gov/products/cpe/search/results?namingFormat=2.3&amp;keyword=quarkus[this search query].  If a Quarkus tag represented by the given CPE name entry is affected by some CVE then you'll be able to follow a provided link to that CVE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどのQuarkusタグは、Common Platform Enumeration (CPE)名の形式で link:https://nvd.nist.gov[National Vulnerability Database](NVD)に登録されています。登録されているすべてのQuarkusのCPE名は、 link:https://nvd.nist.gov/products/cpe/search/results?namingFormat=2.3&amp;amp;keyword=quarkus[この検索クエリ]を使用して見つけることができます。指定されたCPE名のエントリで表されるQuarkusタグが何らかのCVEの影響を受けている場合、そのCVEへのリンクを辿ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application. In addition there are plugins and extensions to all major IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus には、開発者がライブリロードから Kubernetes アプリケーションのデプロイまでを可能にするツールチェーンが付属しています。加えて、全ての主要なIDEに対するプラグインも存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、以下をみていきます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDE でアプリケーションを開発する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドツールの選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus には、すべての開発段階で役立つツールチェーンが付属しています。ビルドツールとして Maven や Gradle を使うことができます。また、使い勝手の良いネイティブ CLI も提供しています (近日公開予定)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide contains various tips and tricks for getting around problems that might arise when attempting to run Java applications as native executables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドには、Java アプリケーションをネイティブ実行ファイルとして実行しようとしたときに発生する可能性のある問題を回避するためのさまざまなヒントやコツが記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we differentiate two contexts where the solution applied might be different:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>適用されるソリューションが異なる可能性のある 2 つの文脈を区別していることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an application, you will rely on configuring the `native-image` configuration by tweaking your `pom.xml`;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのコンテキストでは、`pom.xml` を変更した `native-image` 設定に依存することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the context of an extension, Quarkus offers a lot of infrastructure to simplify all of this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのコンテキストでは、Quarkus はこれらすべてを簡素化するための多くのインフラストラクチャーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the appropriate section depending on your context.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキストに応じて適切なセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in your application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションでのネイティブのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM imposes a number of constraints and making your application a native executable might require a few tweaks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM は多くの制約を課しており、アプリケーションをネイティブ実行可能なものにするには、いくつかの調整が必要になるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースを含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when building a native executable, GraalVM will not include any of the resources that are on the classpath into the native executable it creates.  Resources that are meant to be part of the native executable need to be configured explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、ネイティブ実行ファイルをビルドする際に、GraalVM はクラスパス上にあるリソースを、作成するネイティブ実行ファイルには含めません。ネイティブ実行ファイルの一部となるリソースは、明示的に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically includes the resources present in `META-INF/resources` (the web resources) but, outside of this directory, you are on your own.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、`META-INF/resources` (Web リソース) にあるリソースが自動的に含まれていますが、このディレクトリー以外の場所では自己責任でお願いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you need to be extremely careful here as anything in `META-INF/resources` will be exposed as static web resources.  So this directory is not a shortcut for "let's automatically include these resources in the native executable" and should only be used for static web resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`META-INF/resources` にあるものはすべて、静的な Web リソースとして公開されるので、ここでは非常に注意が必要です。このディレクトリーは、「これらのリソースを自動的にネイティブの実行ファイルに含める」ためのショートカットではなく、静的な Web リソースのためにのみ使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other resources should be declared explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のリソースは明示的に宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include more resources in the native executable, the easiest way is to use the `quarkus.native.resources.includes` configuration property, and its counterpart to exclude resources `quarkus.native.resources.excludes`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より多くのリソースをネイティブの実行ファイルに含めるには、`quarkus.native.resources.includes` という設定プロパティーと、`quarkus.native.resources.excludes` リソースを除外するための `quarkus.native.resources.excludes` を使用するのが最も簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both configuration properties support glob patterns.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらの構成プロパティーもグロブパターンに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, having the following properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、`application.properties` で以下のプロパティーを使用すると</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.native.resources.includes=foo/**,bar/**/*.txt
quarkus.native.resources.excludes=foo/private/**
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.native.resources.includes=foo/**,bar/**/*.txt
quarkus.native.resources.excludes=foo/private/**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will include:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files in the `foo/` directory and its subdirectories except for files in `foo/private/` and its subdirectories,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`foo/` ディレクトリーとそのサブディレクトリーにあるすべてのファイルのうち、`foo/private/` とそのサブディレクトリーにあるファイルを除く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all text files in the `bar/` directory and its subdirectories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`bar/` ディレクトリーとそのサブディレクトリーにあるすべてのテキストファイル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If globs are not sufficiently precise for your use case and you need to rely on regular expressions or if you prefer relying on the GraalVM infrastructure, you can also create a `resources-config.json` (the most common location is within `src/main/resources`) JSON file defining which resources should be included:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グロブが不十分で正規表現に頼る必要がある場合や、GraalVM インフラストラクチャーを使用することを好む場合は、どのリソースを含めるべきかを定義する JSON ファイル `resources-config.json` (最も一般的な場所は `src/main/resources` 内) を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{
  "resources": [
    {
      "pattern": ".*\\.xml$"
    },
    {
      "pattern": ".*\\.json$"
    }
  ]
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{
  "resources": [
    {
      "pattern": ".*\\.xml$"
    },
    {
      "pattern": ".*\\.json$"
    }
  ]
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patterns are valid Java regexps.  Here we include all the XML files and JSON files into the native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このパターンは有効な Java 正規表現です。ここでは、すべての XML ファイルと JSONファイル をネイティブ実行ファイルに含めています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this topic in https://github.com/oracle/graal/blob/master/substratevm/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このトピックの詳細については、https://github.com/oracle/graal/blob/master/substratevm/Resources.md[GraalVM ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final order of business is to make the configuration file known to the `native-image` executable by adding the proper configuration to `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後にやるべきことは、`application.properties` に適切な設定を追加して、設定ファイルを `native-image` 実行ファイルに知らせることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.native.additional-build-args =-H:ResourceConfigurationFiles=resources-config.json
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.native.additional-build-args =-H:ResourceConfigurationFiles=resources-config.json
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `resources-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のスニペットでは、`src/main/resources` に追加されたため、ファイルのパス全体を指定するのではなく、単に `resources-config.json` を使用することができました。ファイルが別のディレクトリーに追加されていた場合は、適切なファイルパスを手動で指定する必要がありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple options may be separated by a comma. For example, one could use:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のオプションはカンマで区切ることができます。例えば、次のように使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.native.additional-build-args =\
    -H:ResourceConfigurationFiles=resources-config.json,\
    -H:ReflectionConfigurationFiles=reflection-config.json
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.native.additional-build-args =\
    -H:ResourceConfigurationFiles=resources-config.json,\
    -H:ReflectionConfigurationFiles=reflection-config.json
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to ensure that various resources are included and additional reflection is registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さまざまなリソースが含まれており、追加のリフレクションが登録されていることを確認するため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for some reason adding the aforementioned configuration to `application.properties` is not desirable, it is possible to configure the build tool to effectively perform the same operation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何らかの理由で `application.properties` に前述の構成を追加することが望ましくない場合には、ビルドツールで効果的に同様の操作を行うように構成することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Maven, we could use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven を使用する場合は、以下のような構成にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;native&lt;/id&gt;
        &lt;properties&gt;
            &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;
            &lt;quarkus.native.additional-build-args&gt;-H:ResourceConfigurationFiles=resources-config.json&lt;/quarkus.native.additional-build-args&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;native&lt;/id&gt;
        &lt;properties&gt;
            &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;
            &lt;quarkus.native.additional-build-args&gt;-H:ResourceConfigurationFiles=resources-config.json&lt;/quarkus.native.additional-build-args&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering for reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクションのための登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building a native executable, GraalVM operates with a closed world assumption.  It analyzes the call tree and removes all the classes/methods/fields that are not used directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルを構築する際、GraalVM はクローズな環境を想定して動作します。これは、コールツリーを解析し、直接使用しないクラス/メソッド/フィールドをすべて削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).  To include these elements in your native executable, you need to register them for reflection explicitly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクションで使用される要素はコールツリーの一部ではないので、デッドコードとして排除されます (他のケースでは直接呼び出されない場合)。ネイティブ実行ファイルにこれらの要素を含めるには、リフレクションに明示的に登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very common case as JSON libraries typically use reflection to serialize the objects to JSON:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、JSONライブラリがリフレクションを使用してオブジェクトをJSONにシリアライズするのが一般的なので、非常によくあるケースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public class Person {
        private String first;
        private String last;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    public class Person {
        private String first;
        private String last;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        public String getFirst() {
            return first;
        }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        public String getFirst() {
            return first;
        }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        public void setFirst(String first) {
            this.first = first;
        }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        public void setFirst(String first) {
            this.first = first;
        }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        public String getLast() {
            return last;
        }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        public String getLast() {
            return last;
        }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        public void setValue(String last) {
            this.last = last;
        }
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        public void setValue(String last) {
            this.last = last;
        }
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Path("/person")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public class PersonResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Path("/person")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public class PersonResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        private final Jsonb jsonb;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        private final Jsonb jsonb;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        public PersonResource() {
            jsonb = JsonbBuilder.create(new JsonbConfig());
        }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        public PersonResource() {
            jsonb = JsonbBuilder.create(new JsonbConfig());
        }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        @GET
        public Response list() {
            return Response.ok(jsonb.fromJson("{\"first\":  \"foo\", \"last\":  \"bar\"}", Person.class)).build();
        }
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        @GET
        public Response list() {
            return Response.ok(jsonb.fromJson("{\"first\":  \"foo\", \"last\":  \"bar\"}", Person.class)).build();
        }
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we were to use the code above, we would get an exception like the following when using the native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のコードを使用した場合、ネイティブ実行ファイルを使用すると以下のような例外が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception handling request to /person: org.jboss.resteasy.spi.UnhandledException: javax.json.bind.JsonbException: Can't create instance of a class: class org.acme.jsonb.Person, No default constructor found
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Exception handling request to /person: org.jboss.resteasy.spi.UnhandledException: javax.json.bind.JsonbException: Can't create instance of a class: class org.acme.jsonb.Person, No default constructor found
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using Jackson:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または Jackson を使用している場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.acme.jsonb.Person and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.acme.jsonb.Person and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An even nastier possible outcome could be for no exception to be thrown, but instead the JSON result would be completely empty.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに厄介なのは、例外がスローされずに JSON の結果が完全に空になってしまうことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different ways to fix this type of issues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このタイプの問題を解決するには、2 つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the @RegisterForReflection annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterForReflection アノテーションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to register a class for reflection is to use the `@RegisterForReflection` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクション用のクラスを登録する最も簡単な方法は、`@RegisterForReflection` アノテーションを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterForReflection
public class MyClass {
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RegisterForReflection
public class MyClass {
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your class is in a third-party jar, you can do it by using an empty class that will host the `@RegisterForReflection` for it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスがサードパーティの jar にある場合は、そのクラスの `@RegisterForReflection` をホストする空のクラスを使用することで行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定ファイルの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a configuration file to register classes for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、設定ファイルを使用してリフレクション用のクラスを登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, in order to register all methods of class `com.acme.MyClass` for reflection, we create `reflection-config.json` (the most common location is within `src/main/resources`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、クラス `com.acme.MyClass` のすべてのメソッドをリフレクションのために登録するには、`reflection-config.json` を作成します (最も一般的な場所は `src/main/resources` の中です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[
  {
    "name" : "com.acme.MyClass",
    "allDeclaredConstructors" : true,
    "allPublicConstructors" : true,
    "allDeclaredMethods" : true,
    "allPublicMethods" : true,
    "allDeclaredFields" : true,
    "allPublicFields" : true
  }
]
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[
  {
    "name" : "com.acme.MyClass",
    "allDeclaredConstructors" : true,
    "allPublicConstructors" : true,
    "allDeclaredMethods" : true,
    "allPublicMethods" : true,
    "allDeclaredFields" : true,
    "allPublicFields" : true
  }
]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details on the format of this file, please refer to https://github.com/oracle/graal/blob/master/substratevm/Reflection.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このファイルのフォーマットの詳細については、https://github.com/oracle/graal/blob/master/substratevm/Reflection.md[GraalVMドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.native.additional-build-args =-H:ReflectionConfigurationFiles=reflection-config.json
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.native.additional-build-args =-H:ReflectionConfigurationFiles=reflection-config.json
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous snippet we were able to simply use `reflection-config.json` instead of specifying the entire path of the file simply because it was added to `src/main/resources`.  If the file had been added to another directory, the proper file path would have had to be specified manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のスニペットでは、`src/main/resources` に追加されたため、ファイルのパス全体を指定するのではなく、単に `reflection-config.json` を使用することができました。ファイルが別のディレクトリーに追加されていた場合は、適切なファイルパスを手動で指定する必要がありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;native&lt;/id&gt;
        &lt;properties&gt;
            &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;
            &lt;quarkus.native.additional-build-args&gt;-H:ReflectionConfigurationFiles=reflection-config.json&lt;/quarkus.native.additional-build-args&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;native&lt;/id&gt;
        &lt;properties&gt;
            &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;
            &lt;quarkus.native.additional-build-args&gt;-H:ReflectionConfigurationFiles=reflection-config.json&lt;/quarkus.native.additional-build-args&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delaying class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスの初期化を遅らせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus initializes all classes at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkus はビルド時にすべてのクラスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases where the initialization of certain classes is done in a static block needs to be postponed to runtime.  Typically omitting such configuration would result in a runtime exception like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定のクラスの初期化が静的ブロックで行われる場合、実行時に延期する必要がある場合があります。通常、このような設定を省略すると、以下のような実行時例外が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error: No instances are allowed in the image heap for a class that is initialized or reinitialized at image runtime: sun.security.provider.NativePRNG
Trace: object java.security.SecureRandom
method com.amazonaws.services.s3.model.CryptoConfiguration.&lt;init&gt;(CryptoMode)
Call path from entry point to com.amazonaws.services.s3.model.CryptoConfiguration.&lt;init&gt;(CryptoMode):
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Error: No instances are allowed in the image heap for a class that is initialized or reinitialized at image runtime: sun.security.provider.NativePRNG
Trace: object java.security.SecureRandom
method com.amazonaws.services.s3.model.CryptoConfiguration.&lt;init&gt;(CryptoMode)
Call path from entry point to com.amazonaws.services.s3.model.CryptoConfiguration.&lt;init&gt;(CryptoMode):
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to delay the initialization of a class, you can use the `--initialize-at-run-time=&lt;package or class&gt;` configuration knob.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスの初期化を遅らせる必要がある場合は、`--initialize-at-run-time=&lt;package or class&gt;` 設定ノブを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should be added to the `native-image` configuration using the `quarkus.native.additional-build-args` configuration property as shown in the examples above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の例のように、`quarkus.native.additional-build-args` 設定プロパティーを使用して `native-image` 設定に追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about all this in https://github.com/oracle/graal/blob/master/substratevm/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらすべてについての詳細な情報は、https://github.com/oracle/graal/blob/master/substratevm/ClassInitialization.md[GraalVMのドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes or packages need to be specified via the `quarkus.native.additional-build-args` configuration property, the `,` symbol needs to be escaped.  An example of this is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.native.additional-build-args` 設定プロパティーを介して複数のクラスやパッケージを指定する必要がある場合は、`,` シンボルをエスケープする必要があります。その例を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.native.additional-build-args=--initialize-at-run-time=com.example.SomeClass\\,org.acme.SomeOtherClass
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.native.additional-build-args=--initialize-at-run-time=com.example.SomeClass\\,org.acme.SomeOtherClass
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and in the case of using the Maven configuration instead of `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` の代わりに Maven 設定を使用する場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;quarkus.native.additional-build-args&gt;--initialize-at-run-time=com.example.SomeClass\,org.acme.SomeOtherClass&lt;/quarkus.native.additional-build-args&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;quarkus.native.additional-build-args&gt;--initialize-at-run-time=com.example.SomeClass\,org.acme.SomeOtherClass&lt;/quarkus.native.additional-build-args&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing Proxy Classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロキシークラスの管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While writing native application you'll need to define proxy classes at image build time by specifying the list of interfaces that they implement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブアプリケーションを書く際には、実装するインターフェースのリストを指定して、イメージのビルド時にプロキシークラスを定義する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In such a situation, the error you might encounter is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような状況では、以下のようなエラーが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface org.apache.http.conn.HttpClientConnectionManager, interface org.apache.http.pool.ConnPoolControl, interface com.amazonaws.http.conn.Wrapped] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles=&lt;comma-separated-config-files&gt; and -H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt; options.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface org.apache.http.conn.HttpClientConnectionManager, interface org.apache.http.pool.ConnPoolControl, interface com.amazonaws.http.conn.Wrapped] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles=&lt;comma-separated-config-files&gt; and -H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt; options.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solving this issue requires adding the `-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` option and to provide a dynamic proxy configuration file.  You can find all the information about the format of this file in https://github.com/oracle/graal/blob/master/substratevm/DynamicProxy.md#manual-configuration[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この問題を解決するには、`-H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt;` オプションを追加し、ダイナミックプロキシー設定ファイルを提供する必要があります。このファイルのフォーマットについては、https://github.com/oracle/graal/blob/master/substratevm/DynamicProxy.md#manual-configuration[GraalVMのドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting native in a Quarkus extension is even easier as Quarkus provides a lot of tools to simplify all this.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus のエクステンションでのネイティブのサポートは、Quarkus がこれらすべてを単純化するための多くのツールを提供しているため、さらに簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything described here will only work in the context of Quarkus extensions, it won't work in an application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで説明したことはすべて、Quarkus エクステンションのコンテキストでのみ機能し、アプリケーションでは機能しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register reflection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクションの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus makes registration of reflection in an extension a breeze by using `ReflectiveClassBuildItem`, thus eliminating the need for a JSON configuration file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、`ReflectiveClassBuildItem` を使用することで、エクステンションへのリフレクションの登録が簡単になり、JSON 設定ファイルが不要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To register a class for reflection, one would need to create a Quarkus processor class and add a build step that registers reflection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクション用のクラスを登録するには、Quarkus プロセッサークラスを作成し、リフレクションを登録するビルドステップを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class SaxParserProcessor {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class SaxParserProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep
    ReflectiveClassBuildItem reflection() {
        // since we only need reflection to the constructor of the class, we can specify `false` for both the methods and the fields arguments.
        return new ReflectiveClassBuildItem(false, false, "com.sun.org.apache.xerces.internal.parsers.SAXParser");
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep
    ReflectiveClassBuildItem reflection() {
        // since we only need reflection to the constructor of the class, we can specify `false` for both the methods and the fields arguments.
        return new ReflectiveClassBuildItem(false, false, "com.sun.org.apache.xerces.internal.parsers.SAXParser");
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about reflection in GraalVM can be found https://github.com/oracle/graal/blob/master/substratevm/Reflection.md[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM でのリフレクションの詳細は、https://github.com/oracle/graal/blob/master/substratevm/Reflection.md[こちら] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the context of an extension, Quarkus eliminates the need for a JSON configuration file by allowing extension authors to specify a `NativeImageResourceBuildItem`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのコンテキストでは、Quarkus は、エクステンションの作成者が `NativeImageResourceBuildItem` .NET Frameworkを指定できるようにすることで、JSON 設定ファイルの必要性を排除しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class ResourcesProcessor {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class ResourcesProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep
    NativeImageResourceBuildItem nativeImageResourceBuildItem() {
        return new NativeImageResourceBuildItem("META-INF/extra.properties");
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep
    NativeImageResourceBuildItem nativeImageResourceBuildItem() {
        return new NativeImageResourceBuildItem("META-INF/extra.properties");
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about GraalVM resource handling in native executables please refer to https://github.com/oracle/graal/blob/master/substratevm/Resources.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルでのGraalVMリソースの取り扱いについての詳細は、https://github.com/oracle/graal/blob/master/substratevm/Resources.md[GraalVM ドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delay class initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスの初期化を遅らせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus simplifies things by allowing extensions authors to simply register a `RuntimeInitializedClassBuildItem`. A simple example of doing so could be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、エクステンションの作成者が簡単に `RuntimeInitializedClassBuildItem` を登録できるようにすることで、物事を簡素化しています。簡単な例としては、次のようなものが考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class S3Processor {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class S3Processor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep
    RuntimeInitializedClassBuildItem cryptoConfiguration() {
        return new RuntimeInitializedClassBuildItem(CryptoConfiguration.class.getCanonicalName());
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep
    RuntimeInitializedClassBuildItem cryptoConfiguration() {
        return new RuntimeInitializedClassBuildItem(CryptoConfiguration.class.getCanonicalName());
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `--initialize-at-run-time` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような構文を使用すると、 `--initialize-at-run-time` オプションが自動的に `native-image` コマンドラインに追加されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about `--initialize-at-run-time`, please read https://github.com/oracle/graal/blob/master/substratevm/ClassInitialization.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--initialize-at-run-time` の詳細は、https://github.com/oracle/graal/blob/master/substratevm/ClassInitialization.md[GraalVM のドキュメント] をお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very similarly, Quarkus allows extensions authors to register a `NativeImageProxyDefinitionBuildItem`. An example of doing so is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、Quarkus では、エクステンションの作成者が `NativeImageProxyDefinitionBuildItem` を登録することができます。その例としては、以下のようなものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @BuildStep
    NativeImageProxyDefinitionBuildItem httpProxies() {
        return new NativeImageProxyDefinitionBuildItem("org.apache.http.conn.HttpClientConnectionManager",
                "org.apache.http.pool.ConnPoolControl", "com.amazonaws.http.conn.Wrapped");
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @BuildStep
    NativeImageProxyDefinitionBuildItem httpProxies() {
        return new NativeImageProxyDefinitionBuildItem("org.apache.http.conn.HttpClientConnectionManager",
                "org.apache.http.pool.ConnPoolControl", "com.amazonaws.http.conn.Wrapped");
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using such a construct means that a `-H:DynamicProxyConfigurationResources` option will automatically be added to the `native-image` command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このような構文を使用すると、`-H:DynamicProxyConfigurationResources` オプションが自動的に `native-image` コマンドラインに追加されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about Proxy Classes you can read https://github.com/oracle/graal/blob/master/substratevm/DynamicProxy.md[the GraalVM documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロキシークラスの詳細は、https://github.com/oracle/graal/blob/master/substratevm/DynamicProxy.md[GraalVMのドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging with Native Image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージでのロギング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using dependencies that require logging components such as Apache Commons Logging or Log4j and are experiencing a `ClassNotFoundException` when building the native executable, you can resolve this by excluding the logging library and adding the corresponding JBoss Logging adapter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Commons Logging や Log4j などのロギングコンポーネントを必要とする依存関係を使用していて、ネイティブ実行ファイルをビルドする際に `ClassNotFoundException` が発生する場合、ロギングライブラリーを除外し、対応する JBoss Logging アダプターを追加することで解決できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details please refer to the link:logging#logging-adapters[Logging guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は、link:logging#logging-adapters[ロギングガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can find a list of Build Items and the extension that provides them:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、ビルドアイテムとそれを提供するエクステンションの一覧を見ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can send your logs to a centralized log management system like Graylog, Logstash (inside the Elastic Stack or ELK - Elasticsearch, Logstash, Kibana) or Fluentd (inside EFK - Elasticsearch, Fluentd, Kibana).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Graylog、Logstash(Elastic StackやELK - Elasticsearch、Logstash、Kibanaの内部)、Fluentd(EFK - Elasticsearch、Fluentd、Kibanaの内部)のような集中型ログ管理システムにログを送信する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different ways to centralize your logs (if you are using Kubernetes, the simplest way is to log to the console and ask you cluster administrator to integrate a central log manager inside your cluster).  In this guide, we will expose how to send them to an external tool using the `quarkus-logging-gelf` extension that can use TCP or UDP to send logs in the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログを一元化する方法はたくさんあります(Kubernetesを使用している場合、最も簡単な方法はコンソールにログインして、クラスター管理者にクラスター内に一元化されたログマネージャーを統合するように依頼することです)。このガイドでは、TCPまたはUDPを使用してGraylog Extended Log Format (GELF)でログを送信できる `quarkus-logging-gelf` エクステンションを使用して外部ツールに送信する方法を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-logging-gelf` extension will add a GELF log handler to the underlying logging backend that Quarkus uses (jboss-logmanager).  By default, it is disabled, if you enable it but still use another handler (by default the console handler is enabled), your logs will be sent to both handlers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-logging-gelf` エクステンションは、Quarkusが使用する基礎となるロギングバックエンド(jboss-logmanager)にGELFログハンドラーを追加します。デフォルトでは無効になっており、有効にした場合も別のハンドラーも使用している場合(デフォルトではコンソールハンドラーが有効になっています)、ログは両方のハンドラーに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following examples will all be based on the same example application that you can create with the following steps.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例はすべて、以下の手順で作成できる同じアプリケーションの例を基にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an application with the `quarkus-logging-gelf` extension. You can use the following Maven command to create it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-logging-gelf` のエクステンションを持つアプリケーションを作成します。以下のMavenコマンドを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `logging-gelf` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `logging-gelf` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For demonstration purposes, we create an endpoint that does nothing but log a sentence. You don't need to do this inside your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デモのために、文をログに記録するだけのエンドポイントを作成します。これをアプリケーション内で行う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the GELF log handler to send logs to an external UDP endpoint on the port 12201:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GELF ログハンドラーを構成して、ポート 12201 の外部 UDP エンドポイントにログを送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send logs to Graylog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログをGraylogに送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send logs to Graylog, you first need to launch the components that compose the Graylog stack:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログをGraylogに送信するには、まずGraylogスタックを構成するコンポーネントを起動する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Graylog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Graylog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this via the following docker-compose file that you can launch via `docker-compose run -d`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、 `docker-compose run -d` から起動できる以下の docker-compose ファイルを使って行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you need to create a UDP input in Graylog.  You can do it from the Graylog web console (System -&gt; Input -&gt; Select GELF UDP) available at http://localhost:9000 or via the API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、GraylogでUDP入力を作成する必要があります。これは、http://localhost:9000 の GraylogのWebコンソール(System → Input → Select GELF UDP)から、 またはAPI経由で行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This curl example will create a new Input of type GELF UDP, it uses the default login from Graylog (admin/admin).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この curl の例では、Graylog (admin/admin) からのデフォルトのログインを使用し、GELF UDP タイプの新しい入力を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch your application, you should see your logs arriving inside Graylog.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを起動すると、Graylog内にログが届くのがわかるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logstash comes by default with an Input plugin that can understand the GELF format, we will first create a pipeline that enables this plugin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>LogstashにはGELF形式を理解できるInputプラグインがデフォルトで付属しているので、まずこのプラグインを有効にするパイプラインを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the following file in `$HOME/pipelines/gelf.conf`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`$HOME/pipelines/gelf.conf` に以下のファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, launch the components that compose the Elastic Stack:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、Elastic Stackを構成するコンポーネントを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logstash</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Logstash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kibana</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kibana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch your application, you should see your logs arriving inside the Elastic Stack; you can use Kibana available at http://localhost:5601/ to access them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを起動すると、Elastic Stack内にログが到着しているのが確認できるはずです。 http://localhost:5601/ で入手できるKibanaを使ってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to create a Fluentd image with the needed plugins: elasticsearch and input-gelf.  You can use the following Dockerfile that should be created inside a `fluentd` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、必要なプラグインである elasticsearch と input-elf を使って Fluentd イメージを作成します。 以下の Dockerfile を使用することができます。このファイルは `fluentd` ディレクトリー内に作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the image or let docker-compose build it for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イメージをビルドするか、docker-composeにビルドを任せることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to create a fluentd configuration file inside `$HOME/fluentd/fluent.conf`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それから、fluentd 設定ファイルを `$HOME/fluentd/fluent.conf` に作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, launch the components that compose the EFK Stack:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、EFKスタックを構成するコンポーネントを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fluentd</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Fluentd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch your application, you should see your logs arriving inside EFK: you can use Kibana available at http://localhost:5601/ to access them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを起動すると、EFK内にログが到着しているのが確認できるはずです: それらにアクセスするには、 http://localhost:5601/ で利用可能な Kibana を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GELF alternative: use Syslog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GELFの代替:Syslogの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also send your logs to Fluentd using a Syslog input.  As opposed to the GELF input, the Syslog input will not render multiline logs in one event, that's why we advise to use the GELF input that we implement in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Syslog入力を使ってFluentdにログを送ることもできます。GELF入力とは対照的に、Syslog入力は1つのイベントで複数行のログをレンダリングすることができないため、Quarkusで実装されているGELF入力を使用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to create a Fluentd image with the elasticsearch plugin.  You can use the following Dockerfile that should be created inside a `fluentd` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、elasticsearchプラグインでFluentdイメージを作成する必要があります。 以下の Dockerfile を使用することができます。このファイルは `fluentd` ディレクトリー内に作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you need to create a fluentd configuration file inside `$HOME/fluentd/fluent.conf`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、fluentd設定ファイルを `$HOME/fluentd/fluent.conf` 内に作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, launch the components that compose the EFK Stack:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、EFKスタックを構成するコンポーネントを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your application to send logs to EFK using Syslog:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、Syslogを使用してEFKにログを送信するようにアプリケーションを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration is done through the usual `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定は通常の `application.properties` ファイルから行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension uses the `logstash-gelf` library that allow more configuration options via system properties, you can access its documentation here: https://logging.paluch.biz/ .</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、システムプロパティーを介してより多くの設定オプションを提供する `logstash-gelf` ライブラリを使用しています。ドキュメントにはこちら: https://logging.paluch.biz/ からアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding extension(s)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{project-name}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use an LDAP server to authenticate and authorize your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがLDAPサーバーを使用してユーザーアイデンティティを認証・認可する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/public` endpoint can be accessed anonymously.  The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `adminRole` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.  The `/api/users/me` endpoint is also protected with RBAC (Role-Based Access Control) where only users granted with the `standardRole` role can access. As a response, it returns a JSON document with details about the user.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/public` エンドポイントは匿名でアクセスできます。 `/api/admin` エンドポイントは RBAC (Role-Based Access Control) で保護されており、 `adminRole` ロールで許可されたユーザーのみがアクセスできます。このエンドポイントでは、 `@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。 `/api/users/me` エンドポイントも RBAC (Role-Based Access Control) で保護されており、 `standardRole` ロールで付与されたユーザーのみがアクセスできます。レスポンスとして、ユーザーに関する詳細を含むJSONドキュメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-ldap-quickstart` {quickstarts-tree-url}/security-ldap-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-ldap-quickstart` {quickstarts-tree-url}/security-ldap-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `elytron-security-ldap` extension which is a `wildfly-elytron-realm-ldap` adapter for Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、 `elytron-security-ldap` のエクステンションをインポートして Maven プロジェクトを生成します。 link:https://docs.wildfly.org/19/WildFly_Elytron_Security.html#ldap-security-realm[`wildfly-elytron-realm-ldap`] のQuarkusアプリケーション用のアダプターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `elytron-security-ldap` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `elytron-security-ldap` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple. The main difference here is that we are using a `@RolesAllowed` annotation to make sure that only users granted with the `adminRole` role can access the endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/api/admin` エンドポイントのソースコードも非常にシンプルです。ここでの主な違いは、 `adminRole` ロールで付与されたユーザーだけがエンドポイントにアクセスできるように `@RolesAllowed` アノテーションを使用していることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's consider the `/api/users/me` endpoint. As you can see from the source code below, we are trusting only users with the `standardRole` role.  We are using `SecurityContext` to get access to the current authenticated Principal and we return the user's name. This information is loaded from the LDAP server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、 `/api/users/me` エンドポイントを考えてみましょう。下のソースコードを見ればわかるように、私たちは `standardRole` の役割を持つユーザのみを信頼しています。現在認証されているプリンシパルへのアクセスを得るために `SecurityContext` を使用しており、ユーザー名を返します。この情報は LDAP サーバーから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{0}` is substituted by the `uid`, whereas `{1}` will be substituted by the `dn` of the user entry.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`{0}` は `uid` で置換され、 `{1}` はユーザーエントリーの `dn` で置換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-ldap` extension requires a dir-context and an identity-mapping with at least one attribute-mapping to authenticate the user and its identity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`elytron-security-ldap` エクステンションでは、ユーザーとそのアイデンティティを認証するために、 dir-context と、少なくとも一つの属性マッピングを持つ アイデンティティマッピング が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is now protected and the identities are provided by our LDAP server.  The very first thing to check is to ensure the anonymous access works.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは保護され、アイデンティティはLDAPサーバーによって提供されるようになりました。まず最初に確認すべきことは、匿名アクセスが機能することを確認することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By providing the `adminUser:adminUserPassword` credentials, the extension authenticated the user and loaded their roles.  The `adminUser` user is authorized to access to the protected resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`adminUser:adminUserPassword` 資格情報を提供することで、エクステンションはユーザーを認証し、そのロールをロードしました。 `adminUser` ユーザーは、保護されたリソースへのアクセスを許可されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user `adminUser` should be forbidden to access a resource protected with `@RolesAllowed("standardRole")` because it doesn't have this role.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `adminUser` は、この役割を持っていないので、 `@RolesAllowed("standardRole")` で保護されたリソースへのアクセスを禁止する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, using the user `standardUser` works and the security context contains the principal details (username for instance).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、ユーザー `standardUser` を使用すると動作し、セキュリティーコンテキストには主要な詳細(例えばユーザー名)が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[LDAP]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[LDAP]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC, the CDI container, is bootstrapped at build time.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI コンテナーである ArC はビルド時にブートストラップされます。このアプローチの欠点は、CDI Portable Extensionsをサポートできないことです。それにもかかわらず、Quarkus固有のエクステンションAPIを使用して機能を実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container is bootstrapped in multiple phases.  From a high level perspective these phases go as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーは複数のフェーズでブートストラップされます。高レベルの視点から見ると、これらのフェーズは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registration of synthetic components</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合成コンポーネントの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.  _Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.  Subsequently, the extensions can register _synthetic components_.  Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.  Finally, the _deployment is validated_.  For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_初期化_ フェーズでは、準備作業が行われ、カスタムコンテキストが登録されます。その後、コンテナーがすべてのアプリケーションクラスを分析し、Beanを識別し、提供されたメタデータに基づいてそれらをすべて繋ぎ合わせるプロセスがBean _ディスカバリ_ です。その後、エクステンションは _合成コンポーネント_ を登録することができます。これらのコンポーネントの属性はエクステンションによって完全に制御されます。最後に、 _デプロイメントが検証されます_ 。例えば、コンテナーはアプリケーション内のすべての注入ポイントを検証し、与えられた必要な型と修飾子を満たすBeanがない場合はビルドを失敗させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the &lt;&lt;cdi-reference.adoc#dev-mode,development mode&gt;&gt;, you can use `quarkus.log.category."io.quarkus.arc.processor".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のロギングを有効にすることで、ブートストラップに関するより多くの情報を見ることができます。 `-X` または `--debug` で Maven ビルドを実行し、 `io.quarkus.arc` を含む行を grep するだけです。 link:cdi-reference.html#dev-mode[開発モード] では、 `quarkus.log.category."io.quarkus.arc.processor".level=DEBUG` を使用することができ、2つの特別なエンドポイントも自動的に登録され、JSON形式でいくつかの基本的なデバッグ情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus build steps can produce and consume various build items and hook into each phase.  In the following sections we will describe all the relevant build items and common scenarios.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのビルドステップでは、さまざまなビルドアイテムを生成したり消費したりして、各フェーズにフックすることができます。以下のセクションでは、関連するすべてのビルド項目と一般的なシナリオについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metadata Sources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メタデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window="_blank"] which is built from various sources during &lt;&lt;cdi-reference.adoc#bean_discovery,bean discovery&gt;&gt;.  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register &lt;&lt;synthetic_beans,synthetic components&gt;&gt;.  This is an important aspect to realize when integrating CDI components in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスとアノテーションは、Beanレベルのメタデータの主要なソースです。初期のメタデータは、Beanの link:cdi-reference.html#bean_discovery[ディスカバリ] 時に様々なソースから構築される不変の link:https://github.com/wildfly/jandex[Jandexインデックス, window="_blank"] である _Beanアーカイブインデックス_ から読み込まれます。しかし、エクステンションは、ブートストラップの特定の段階でメタデータを追加、削除、変換することができます。さらに、エクステンションは link:#synthetic_beans[合成コンポーネント] を登録することもできます。これは、CDIコンポーネントをQuarkusに統合する際に実現すべき重要な側面です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.  For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようにして、エクステンションは、そうでなければ無視されていたクラスをBeanに変えたり、その逆を行ったりすることができます。例えば、 `@Scheduled` メソッドを宣言するクラスは、たとえそれがBean定義アノテーションでアノテーションされておらず、通常は無視されるようなクラスであっても、常にBeanとして登録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Case - My Class Is Not Recognized as a Bean</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユースケース - クラスがBeanとして認識されません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An `UnsatisfiedResolutionException` indicates a problem during &lt;&lt;cdi.adoc#typesafe_resolution,typesafe resolution&gt;&gt;.  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`UnsatisfiedResolutionException` は、 link:cdi.html#typesafe_resolution[タイプセーフ解決] 時に問題があることを示しています。クラスパス上にインジェクションが可能なクラスがあっても、インジェクションポイントを満たすことができないことがあります。クラスが認識されない理由はいくつかありますが、それを解決する方法もいくつかあります。最初のステップでは、その _理由_ を特定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Reason 1_: Class Is Not discovered </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_理由1_ :クラスが発見されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a &lt;&lt;cdi-reference.adoc#bean_discovery,simplified discovery&gt;&gt;.  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには link:cdi-reference.html#bean_discovery[簡易ディスカバリー] があります。クラスがアプリケーションのインデックスに含まれていないことが起こるかもしれません。例えば、Quarkusエクステンションの _実行時モジュール_ のクラスは自動的にインデックス化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Solution_: Use the `AdditionalBeanBuildItem`.  This build item can be used to specify one or more additional classes to be analyzed during the discovery.  Additional bean classes are transparently added to the application index processed by the container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_解決策_ 。 `AdditionalBeanBuildItem` .このビルド項目は、ディスカバリー中に解析する1つ以上の追加クラスを指定するために使用することができます。追加のBean・クラスは、コンテナーによって処理されるアプリケーション・インデックスに透過的に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AdditionalBeanBuildItem.Builder` can be used for more complex use cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AdditionalBeanBuildItem.Builder` は、より複雑なユースケースに使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them &lt;&lt;cdi-reference.adoc#remove_unused_beans,unused&gt;&gt;, they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also &lt;&lt;cdi-reference.adoc#remove_unused_beans,Removing Unused Beans&gt;&gt; and &lt;&lt;unremovable_builditem&gt;&gt; for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AdditionalBeanBuildItem` 経由で追加された Bean クラスは、デフォルトでは _取り外し可能です_ 。コンテナーがそれらを link:cdi-reference.html#remove_unused_beans[未使用] とみなした場合、それらはただ無視されます。しかし、 `AdditionalBeanBuildItem.Builder.setUnremovable()` メソッドを使用して、このビルド項目を介して登録されたBeanクラスを絶対に削除しないようにコンテナーに指示することができます。詳細は、未使用のBeanの link:cdi-reference.html#remove_unused_beans[削除] と link:#unremovable_builditem[[unremovable_builditem]] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.  The default scope is only used if there is no scope declared on the bean class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AdditionalBeanBuildItem.Builder#setDefaultScope()` からデフォルトのスコープを設定することも可能です。デフォルトのスコープは、Beanクラスにスコープが宣言されていない場合にのみ使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no default scope is specified the `@Dependent` pseudo-scope is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトスコープが指定されていない場合は `@Dependent` 擬似スコープが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_理由2_ : クラスは発見されたが、Beanを定義するアノテーションがない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_解決策1_ : `AutoAddScopeBuildItem` の使用。このビルドアイテムを使用すると、特定の条件を満たすクラスにスコープを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Find all classes annotated with `@Scheduled`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled` でアノテーションされたすべてのクラスを検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのスコープとして `@Singleton` を追加。既にスコープでアノテーションされているクラスは自動的にスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make all classes annotated with `@Startup` unremovable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Startup` でアノテーションされたすべてのクラスを削除できないようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Case - I Need To Transform Metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユースケース - メタデータを変換する必要があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transformer is only applied to classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランスフォーマーはクラスにのみ適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーショントランスフォーマーは、Beanディスカバリが始まる _前に_ 生成されなければならないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Case - Inspect Beans, Observers and Injection Points</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用例 - Bean、オブザーバー、インジェクションポイントの検査</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Solution 1_: `BeanDiscoveryFinishedBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_解決策1._ `BeanDiscoveryFinishedBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Solution 2_: `SynthesisFinishedBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_解決策2_ : `SynthesisFinishedBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Case - Register a Custom CDI Context</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユースケース - カスタム CDI コンテキストの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes extensions need to extend the set of built-in CDI contexts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時々、エクステンションは組み込みCDI コンテキストのセットを拡張する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Case - Additional Qualifiers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用例 - 追加の修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it might be useful to register an existing annotation that is not annotated with `@javax.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時には、 `@javax.inject.Qualifier` でアノテーションされていない既存のアノテーションをCDI修飾子として登録しておくと便利かもしれません。これは CDI が `BeforeBeanDiscovery#addQualifier()` を通して実現していることに似ています。ここでは `QualifierRegistrarBuildItem` を使ってそれを実現しようとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available Build Time Metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能なビルド時メタデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.  The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`BuildExtension.BuildContext` で動作する上記のエクステンションはいずれも、ビルド時に生成される特定のビルド時メタデータを利用することができます。 `io.quarkus.arc.processor.BuildExtension.Key` にある組込キーは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Collection&lt;BeanInfo&gt;` containing all the removed beans; see &lt;&lt;cdi-reference.adoc#remove_unused_beans,Removing unused beans&gt;&gt; for more information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Collection&lt;BeanInfo&gt;` 削除されたすべての link:cdi-reference.html#remove_unused_beans[Bean] を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Map&lt;DotName, ClassInfo&gt;` containing all qualifiers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Map&lt;DotName, ClassInfo&gt;` すべての修飾子を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get hold of these, simply query the extension context object for given key.  Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.  If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.  Here is a summary of which extensions can access which metadata:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのメタデータを取得するには、そのキーのエクステンションコンテキストオブジェクトをクエリするだけ可能です。これらのメタデータはビルドが進むにつれて利用可能になることに注意してください。エクステンションがまだ生成されていないメタデータを取得しようとすると、 `null` が返されます。どのエクステンションがどのメタデータにアクセスできるかをまとめてみました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AnnotationsTransformer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AnnotationsTransformer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブートストラップのどのフェーズでもいつでも使えるので、メタデータに頼るべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ContextRegistrar</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ContextRegistrar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` . `STEREOTYPES` にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>InjectionPointsTransformer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>InjectionPointsTransformer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ObserverTransformer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ObserverTransformer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BeanRegistrar</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BeanRegistrar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS` にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ObserverRegistrar</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ObserverRegistrar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` , `OBSERVERS` (クラスベースのオブザーバーのみ), `INJECTION_POINTS` にアクセス可能です。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BeanDeploymentValidator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BeanDeploymentValidator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Has access to all build metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのビルドメタデータにアクセスできます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a scheduled job</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジュールされたジョブの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method allows retrieving the current value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`get()` メソッドでは、現在の値を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression `cron.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` で設定可能な`cron.expr` で cron のような式でジョブを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the application configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション設定ファイルの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the resource and the test</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースとテストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `CountResource` class, and update the content to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CountResource` クラスを編集して、内容を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CounterBean`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CounterBean` の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send back the current counter value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のカウンターの値の返却</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `CountResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストも更新する必要があります。`CountResourceTest` クラスを一致するように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the response contains `count`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスに `count` が含まれていることを確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  In another terminal, run `curl localhost:8080/count` to check the counter value.  After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行してください。別のターミナルで `curl localhost:8080/count` を実行して、カウンターの値を確認します。数秒後に `curl localhost:8080/count` を再実行して、カウンターがインクリメントされていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Property Expressions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティー式の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic clustered tasks using the http://www.quartz-scheduler.org/[Quartz] extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があることがよくあります。このガイドでは、 link:http://www.quartz-scheduler.org/[Quartz] エクステンションを使用して定期的にクラスター化されたタスクをスケジュールする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you only need to run in-memory scheduler use the link:scheduler[Scheduler] extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インメモリースケジューラーを実行する必要がある場合は、 link:scheduler[Scheduler] エクステンションを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose one Rest API `tasks` to visualise the list of tasks created by a Quartz job running every 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、10秒ごとに実行されるQuartzジョブによって作成されたタスクのリストを可視化するために、1つのRest API `tasks` を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `quartz-quickstart` {quickstarts-tree-url}/quartz-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `quartz-quickstart` {quickstarts-tree-url}/quartz-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.quartz.TaskResource` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.quartz.TaskResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Maven project also imports the Quarkus Quartz extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MavenプロジェクトはQuarkus Quartzエクステンションもインポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `quartz` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `quartz` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use a JDBC store, the `quarkus-agroal` extension, which provides the datasource support, is also required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBCストアを使用するには、データソースのサポートを提供する `quarkus-agroal` エクステンションも必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Task Entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タスクエンティティーの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.quartz` package, create the `Task` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.quartz` パッケージで、以下の内容の `Task` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the entity using link:hibernate-orm-panache[Panache]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:hibernate-orm-panache[Panache] を使用してエンティティーを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.quartz` package, create the `TaskBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.quartz` パッケージで、以下の内容の `TaskBean` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the bean in the _application_ scope</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_アプリケーション_ スコープでBeanを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds and set the unique identifier for this job.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled` アノテーションを使用し、このメソッドを10秒ごとに実行し、識別子を付与するようにQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new `Task` with the current start time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在の開始時刻で新しい `Task` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Persist the task in database using link:hibernate-orm-panache[Panache].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:hibernate-orm-panache[Panache] を使用してデータベースにタスクを永続化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Jobs Programmatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラムによるジョブのスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to leverage the Quartz API directly.  You can inject the underlying `org.quartz.Scheduler` in any bean:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quartz APIを直接利用することも可能です。どのBeanにも、基礎となる `org.quartz.Scheduler` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the underlying `org.quartz.Scheduler` instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基礎となる `org.quartz.Scheduler` インスタンスを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schedule a new job using the Quartz API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quartz APIを使用して新しいジョブをスケジュールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoke the `TaskBean#performTask()` method from the job. Jobs are also link:cdi[container-managed] beans if they belong to a link:cdi-reference[bean archive].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ジョブから `TaskBean#performTask()` メソッドを呼び出します。ジョブは、 link:cdi-reference[Beanアーカイブ] に属している場合、 link:cdi[コンテナー管理された] Beanでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the scheduler is not started unless a `@Scheduled` business method is found. You may need to force the start of the scheduler for "pure" programmatic scheduling. See also &lt;&lt;quartz-configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `@Scheduled` ビジネスメソッドが見つからない限り、スケジューラーは起動されません。純粋なプログラムによるスケジューリングを行うには、スケジューラーを強制的に起動させる必要があるかもしれません。 link:#quartz-configuration-reference[Quartz-configuration-reference] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the below configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` ファイルを編集し、以下の設定を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that the scheduler will be run in clustered mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラーがクラスターモードで実行されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the database store to persist job related information so that they can be shared between nodes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースストアを使用してジョブ関連情報を永続化し、ノード間で共有できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `TaskResource` class, and update the content to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TaskResource` クラスを編集して、内容を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the list of created tasks from the database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>作成されたタスクのリストをデータベースから取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `TaskResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストも更新する必要があります。 `TaskResourceTest` クラスを一致するように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that we have a `200` response and at least one task created</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`200` のレスポンスが返却されていることと、少なくとも 1 つのタスクが作成されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration file named `src/main/resources/db/migration/V2.0.0\__QuarkusQuartzTasks.sql` with the content copied from file with the content from link:{quickstarts-blob-url}/quartz-quickstart/src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql[V2.0.0__QuarkusQuartzTasks.sql].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:{quickstarts-blob-url}/quartz-quickstart/src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql[V2.0.0.0__QuarkusQuartzTasks.sql] からコピーした内容でファイルからコピーした内容で `src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql` という名前のSQLマイグレーションファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the load balancer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロードバランサーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the root directory, create a `nginx.conf` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルートディレクトリーに、以下の内容の `nginx.conf` ファイルを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Route all traffic to our tasks application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのトラフィックをタスクアプリケーションにルーティング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting Application Deployment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションデプロイメントの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the root directory, create a `docker-compose.yml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルートディレクトリーに、以下の内容の `docker-compose.yml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the tasks service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タスクサービスの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the nginx load balancer to route incoming traffic to an appropriate node</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受信トラフィックを適切なノードにルーティングするための nginx ロードバランサーを定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the configuration to run the database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースを実行するための設定を定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separate terminal, run the below command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルで以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start the database instance using the configuration options supplied in the `docker-compose.yml` file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`docker-compose.yml` ファイルで提供されている設定オプションを使用してデータベースインスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application in Dev Mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを開発モードで実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw quarkus:dev`.  After a few seconds, open another terminal and run `curl localhost:8080/tasks` to verify that we have at least one task created.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw quarkus:dev` でアプリケーションを実行します。数秒後、別のターミナルを開き、 `curl localhost:8080/tasks` を実行して、少なくとも 1 つのタスクが作成されていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application and run several instances</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのパッケージ化と複数のインスタンスの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can be packaged using `./mvnw clean package`. Once the build is successful, run the below command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは `./mvnw clean package` を使用してパッケージ化することができます。ビルドが成功したら、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start two instances of the application and a load balancer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションとロードバランサーの2つのインスタンスを起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After a few seconds, in another terminal, run `curl localhost:8080/tasks` to verify that tasks were only created at different instants and in an interval of 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数秒後、別のターミナルで `curl localhost:8080/tasks` を実行し、タスクが異なるタイミングで、10秒の間隔でのみ作成されていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's the reponsibility of the deployer to clear/remove the previous state, i.e. stale jobs and triggers. Moreover, the applications that form the "Quartz cluster" should be identical, otherwise an unpredictable result may occur.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前の状態、つまり古いジョブやトリガーをクリア/削除するのはデプロイ側の責任です。さらに、"Quartzクラスター"を形成するアプリケーションは同一でなければならず、そうでなければ予測不可能な結果が発生する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering Plugin and Listeners</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラグインとリスナーの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can register `plugins`, `job-listeners` and `trigger-listeners` through Quarkus configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの設定から、 `plugins` 、 `job-listeners` 、 `trigger-listeners` を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example below registers the plugin `org.quartz.plugins.history.LoggingJobHistoryPlugin` named as `jobHistory` with the property `jobSuccessMessage` defined as `Job [{1}.{0}] execution complete and reports: {8}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例では、 `org.quartz.plugins.history.LoggingJobHistoryPlugin` という名前のプラグインを `jobHistory` として登録し、プロパティー `jobSuccessMessage` を `Job [{1}.{0}] execution complete and reports: {8}` として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also register a listener programmatically with an injected `org.quartz.Scheduler`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入された `org.quartz.Scheduler` でリスナーをプログラムで登録することも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has an integrated pluggable web security layer. If security is enabled all HTTP requests will have a permission check performed to make sure they are allowed to continue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、プラグイン可能なウェブセキュリティーレイヤーが統合されています。セキュリティーが有効になっている場合、すべてのHTTPリクエストは、処理の継続が許可されているかどうかを確認するためのパーミッションチェックが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration authorization checks are executed before any annotation-based authorization check is done, so both checks have to pass for a request to be allowed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定認可チェックは、アノテーションベースの認可チェックが行われる前に実行されるので、リクエストが許可されるためには両方のチェックを通過しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization using Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定を利用した認可</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default implementation allows you to define permissions using config in `application.properties`. An example config is shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの実装では、 `application.properties` の 設定を使用してパーミッションを定義することができます。以下に config の例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines a role based policy that allows users with the `user` and `admin` roles. This is referenced by later rules.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、 `user` と `admin` のロールを持つユーザーを許可するロールベースのポリシーを定義します。これは後のルールで参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a permission set that references the previously defined policy. `roles1` is an arbitrary name, you can call the permission sets whatever you want.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは以前に定義されたポリシーを参照するパーミッションセットです。 `roles1` は任意の名前ですので、好きなようにパーミッションセットを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This permission references the default `permit` built-in policy to allow `GET` methods to `/public`. This is actually a no-op in this example, as this request would have been allowed anyway.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このパーミッションはデフォルトの `permit` ビルトインポリシーを参照して、 `/public` への `GET` メソッドを許可します。この例では、このリクエストはいずれにせよ許可されているはずなので、これは実際には no-op です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching on paths, methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パス、メソッドのマッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Permission sets can also specify paths and methods as a comma separated list. If a path ends with `*` then it is considered to be a wildcard match and will match all sub paths, otherwise it is an exact match and will only match that specific path:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パーミッションセットでは、パスとメソッドをカンマ区切りのリストで指定することもできます。パスの末尾が `*` である場合はワイルドカードマッチとみなされ、すべてのサブパスにマッチしますが、そうでない場合は完全一致となり、特定のパスにのみマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching path but not method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パスはマッチするがメソッドはマッチしない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a request would match one or more permission sets based on the path, but does not match any due to method requirements then the request is rejected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストがパスに基づいて1つ以上のパーミッションセットにマッチするが、 メソッドの要件によりマッチしない場合、そのリクエストは拒否されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matching multiple paths: longest path wins</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のパスのマッチング:一番長いパスが勝ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the above permission set, `GET /api/foo` would match both permission sets' paths, so would require both the `user` and `admin` roles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のパーミッションセットを考えると、 `GET /api/foo` は両方のパーミッションセットのパスにマッチするので、 `user` と `admin` の両方のロールが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Properties to Deny access</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アクセスを拒否する設定プロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two configuration settings that alter the RBAC Deny behavior:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RBAC Denyの動作を変更する2つの設定があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.security.jaxrs.deny-unannotated-endpoints=true|false` - if set to true, the access will be denied for all JAX-RS endpoints by default.  That is if the security annotations do not define the access control. Defaults to `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.security.jaxrs.deny-unannotated-endpoints=true|false` - true に設定すると、デフォルトではすべての JAX-RS エンドポイントに対してアクセスが拒否されます。つまり、セキュリティーアノテーションでアクセス制御が定義されていない場合です。デフォルトは `false` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling permissions </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パーミッションの無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization using Annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーションを使った認可</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with built-in security to allow for Role-Based Access Control (link:https://en.wikipedia.org/wiki/Role-based_access_control[RBAC])  based on the common security annotations `@RolesAllowed`, `@DenyAll`, `@PermitAll` on REST endpoints and CDI beans.  An example of an endpoint that makes use of both JAX-RS and Common Security annotations to describe and secure its endpoints is given in &lt;&lt;subject-example&gt;&gt;. Quarkus also provides the `io.quarkus.security.Authenticated` annotation that will permit any authenticated user to access the resource (equivalent to `@RolesAllowed("**")`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、共通のセキュリティーアノテーション( `@RolesAllowed` , `@DenyAll` , `@PermitAll` )に基づいたロールベースのアクセス制御 link:https://en.wikipedia.org/wiki/Role-based_access_control[(RBAC] )をRESTエンドポイントとCDI Bean上で可能にするためのビルトインセキュリティーが搭載されています。JAX-RSとCommon Securityアノテーションの両方を利用してエンドポイントを記述し、セキュリティーを確保するエンドポイントの例は、 link:#subject-example[[subject-example]] に記載されています。Quarkusはまた、認証済みのユーザーがリソースにアクセスすることを許可する `io.quarkus.security.Authenticated` アノテーションも提供しています( `@RolesAllowed("**")` と同等です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `/subject/secured` endpoint requires an authenticated user that has been granted the role "Tester" through the use of the `@RolesAllowed("Tester")` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この `/subject/secured` エンドポイントは、 `@RolesAllowed("Tester")` アノテーションを使用して"Tester"というロールを付与された認証済みユーザーが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The endpoint obtains the user principal from the JAX-RS `SecurityContext`. This will be non-null for a secured endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントは、JAX-RS `SecurityContext` からユーザー・プリンシパルを取得します。これは、保護されたエンドポイントの場合は非 null になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/subject/unsecured` endpoint allows for unauthenticated access by specifying the `@PermitAll` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/subject/unsecured` エンドポイントでは、 `@PermitAll` アノテーションを指定することで、認証されていないアクセスが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This call to obtain the user principal will return null if the caller is unauthenticated, non-null if the caller is authenticated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザープリンシパルを取得するためのこの呼び出しは、呼び出し元が認証されていない場合はnullを返し、呼び出し元が認証されている場合は非nullを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/subject/denied` endpoint disallows any access regardless of whether the call is authenticated by specifying the `@DenyAll` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/subject/denied` エンドポイントは、 `@DenyAll` アノテーションを指定することで、呼出が認証されているかどうかにかかわらず、あらゆるアクセスを禁止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC and Mutual TLS authentication as well as the proactive authentication.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、HTTPベースのFORM認証、BASIC認証、相互TLS認証、およびプロアクティブ認証のためのQuarkusの組み込み認証メカニズムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベーシック認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable basic authentication set `quarkus.http.auth.basic=true`. You must also have at least one extension installed that provides a username/password based `IdentityProvider`, such as link:security-jdbc[Elytron JDBC].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベーシック認証を有効にするには、 `quarkus.http.auth.basic=true` を設定します。また、ユーザー名/パスワードベースの `IdentityProvider` を提供するエクステンションを少なくとも 1 つインストールしておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security#identity-providers[Security Identity Providers] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:security#identity-providers[セキュリティー ID プロバイダ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see link:security-testing#configuring-user-information[Configuring User Information in application.properties] section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:security-testing#configuring-user-information[application.propertiesでユーザー情報の設定]セクションも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Form Based Authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォームベース認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、従来のサーブレットのフォームベースの認証と同様の方法で動作するフォームベースの認証を提供します。従来のフォーム認証とは異なり、Quarkusはクラスター化されたHTTPセッションをサポートしていないため、認証されたユーザーはHTTPセッションに保存されません。代わりに、認証情報は暗号化されたCookieに保存され、クラスターのすべてのメンバーが読み取ることができます(すべてのメンバーが同じ暗号化キーを共有している場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>暗号化キーは `quarkus.http.auth.session.encryption-key` プロパティーを使って設定でき、少なくとも 16 文字の長さでなければなりません。このキーは SHA-256 を使ってハッシュ化され、その結果のダイジェストがクッキー値の AES-256 暗号化のキーとして使用されます。このクッキーは暗号化された値の一部として有効期限を含んでいますので、クラスター内のすべての ノードはクロックを同期させなければなりません。1 分間隔で、セッションが使用中であれば、更新された有効期限時間を持つ新しいクッキーが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to configure form based auth:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のプロパティーを使用して、フォームベース認証を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはmTLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this authentication method, you should first enable SSL for your application. For more details, check the link:http-reference#ssl[Supporting secure connections with SSL] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この認証方法を利用するには、まずアプリケーションでSSLを有効にする必要があります。詳細については、 link:http-reference#ssl[SSLによるセキュアな接続のサポート]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが安全な接続を受け入れたら、次のステップは、アプリケーションが信頼すべきすべての証明書を保持する `quarkus.http.ssl.certificate.trust-store-file` を設定し、クライアント(例: ブラウザや他のサービス)が保護されたリソースにアクセスしようとしたときに、アプリケーションがどのように証明書を要求するかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a key store where the server's private key is located.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーの秘密鍵が置かれている鍵ストアを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a trust store from where the trusted certificates are going to be loaded from.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>信頼された証明書がロードされるトラストストアを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーが *常に*クライアントからの証明書を要求することを定義します。 `REQUEST` を使用することで、この動作を緩和することができます。mTLS 以外の認証方法もサポートしている場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines a policy where only authenticated users should have access to resources from your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認証されたユーザーのみがアプリケーションからリソースにアクセスできるようにするポリシーを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受信したリクエストがトラストストアの有効な証明書と一致したら、アプリケーションは以下のように `SecurityIdentity` を注入するだけでサブジェクトを取得できるようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the subject</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>subjectの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should also be able to get the certificate as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、以下のように証明書を取得できるようにしておきましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the certificate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>証明書の取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, etc.  Please see the link:security-customization#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアント証明書からの情報は、Quarkus `SecurityIdentity` を強化するために使用することができます 。たとえば、クライアント証明書のサブジェクト名などを確認した後に、新しいロールを追加することができます。Quarkus `SecurityIdentity` のカスタマイズの詳細については、 link:security-customization#security-identity-customization[SecurityIdentity]のカスタマイズのセクションを参照してください 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます(ターゲットページが認証を必要としない場合でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、公開ページであっても、無効なクレデンシャルを持つリクエストは常に拒否されることを意味します。この動作を変更して、 `quarkus.http.auth.proactive=false` を設定することで必要な場合のみ認証を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you disable proactive authentication then the authentication process will only be run when an identity is requested, either because there are security rules that requires the user to be authenticated, or due to programatic access to the current identity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロアクティブ認証を無効にすると、認証プロセスは ID が要求されたときにのみ実行されます。これは、ユーザーの認証を必要とするセキュリティー ルールがある場合、または現在の ID へのプログラム的なアクセスがある場合のいずれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that if proactive authentication is in use accessing the `SecurityIdentity` is a blocking operation. This is because authentication may not have happened yet, and accessing it may require calls to external systems such as databases that may block. For blocking applications this is no problem, however if you are have disabled authentication in a reactive application this will fail (as you cannot do blocking operations on the IO thread). To work around this you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation`, and call the `Uni&lt;SecurityIdentity&gt; getDeferredIdentity();` method. You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロアクティブ認証を使用している場合、 `SecurityIdentity` へのアクセスはブロック操作になることに注意してください。これは、認証がまだ行われていない可能性があるためで、アクセスする際にデータベースなどの外部システムへの呼び出しが必要となり、ブロックされる可能性があるからです。ブロッキングアプリケーションの場合は問題ありませんが、リアクティブアプリケーションで認証を無効にしている場合は失敗します (IO スレッドでブロッキング操作を行うことができないため)。これを回避するには、 `io.quarkus.security.identity.CurrentIdentityAssociation` のインスタンスを `@Inject` し、 `Uni&lt;SecurityIdentity&gt; getDeferredIdentity();` メソッドを呼び出す必要があります。そして、結果として得られる `Uni` を購読し、認証が完了して ID が利用可能になったときに通知を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the authentication security constraints are enforced before the JAX-RS chain starts.  Disabling the proactive authentication effectively shifts this process to the moment when the JAX-RS chain starts running thus making it possible to use JAX-RS `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException` if required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、認証セキュリティー制約は、JAX-RSチェーンが開始される前に適用されます。プロアクティブ認証を無効にすると、このプロセスがJAX-RSチェーンの実行開始時に効果的に移行するため、必要に応じてJAX-RS `ExceptionMapper` を使用して、 `io.quarkus.security.AuthenticationFailedException` などのQuarkus Security認証例外をキャプチャすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - SmallRye GraphQL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - SmallRye GraphQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use https://github.com/smallrye/smallrye-graphql/[SmallRye GraphQL], an implementation of the https://github.com/eclipse/microprofile-graphql/[MicroProfile GraphQL] specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:https://github.com/eclipse/microprofile-graphql/[MicroProfile GraphQL] 仕様の実装である link:https://github.com/smallrye/smallrye-graphql/[SmallRye GraphQL] をQuarkusアプリケーションで使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the https://www.graphql.org/[GraphQL] specification website states:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.graphql.org/[GraphQL] の仕様のWebサイトにも記載されているように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data.  GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQLは、APIのためのクエリ言語であり、既存のデータを使ってそのクエリを実行するためのランタイムです。  GraphQLは、API内のデータを完全かつ理解しやすい形で提供し、クライアントが必要なものだけを要求する力を与え、時間をかけてAPIを進化させることを容易にし、強力な開発ツールを実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**GraphQL** was originally developed by **Facebook** in 2012 and has been
an open standard since 2015.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**GraphQL** はもともと2012年に **Facebook** が開発したもので、2015年からはオープンスタンダードとなっています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphQL is not a replacement for REST API specification but merely an alternative. Unlike REST, GraphQL API's have the ability to benefit the client by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQLはREST APIの仕様を置き換えるものではなく、単なる別の手段です。RESTとは異なり、GraphQL APIは以下のようにクライアントに利益をもたらす機能を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preventing Over-fetching and Under-fetching</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オーバーフェッチとアンダーフェッチの防止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST API's are server-driven fixed data responses that cannot be determined by the client. Although the client does not require all the fields the client must retrieve all the data hence `Over-fetching`. A client may also require multiple REST API calls according to the first call (HATEOAS) to retrieve all the data that is required thereby `Under-fetching`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST API は、クライアントが決定できないサーバー主導の固定データレスポンスです。クライアントはすべてのフィールドを必要としなくても、クライアントはすべてのデータを取得しなければならないため、 `Over-fetching` です。クライアントはまた、必要とされるすべてのデータを取得するために、最初の呼び出し(HATEOAS)に応じて複数のREST API呼び出しを必要とする場合があり、 `Under-fetching` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since GraphQL API's returns data that are requested by the client adding additional fields and capabilities to existing API will not create breaking changes to existing clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQL APIはクライアントから要求されたデータを返すので、既存のAPIにフィールドや機能を追加しても、既存のクライアントに大きな変更を加えることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we build a simple GraphQL application that exposes a GraphQL API at `/graphql`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 `/graphql` で GraphQL API を公開するシンプルな GraphQL アプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example was inspired by a popular GraphQL API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例は、人気のある GraphQL API にインスパイアされたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `microprofile-graphql-quickstart` {quickstarts-tree-url}/microprofile-graphql-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `microprofile-graphql-quickstart` {quickstarts-tree-url}/microprofile-graphql-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-graphql` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、 `smallrye-graphql` エクステンションをインポートした Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-graphql` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-graphql` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preparing an Application: GraphQL API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの準備: GraphQL API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section we will start creating the GraphQL API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このセクションでは、GraphQL APIの作成を開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create the following entities representing a film from a galaxy far far away:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、はるか彼方の銀河系から来た映画を表す以下のエンティティを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The classes we have just created describe the GraphQL schema which is a set of possible data (objects, fields, relationships) that a client can access.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほど作成したクラスは、クライアントがアクセス可能なデータ（オブジェクト、フィールド、リレーションシップ）のセットであるGraphQLスキーマを記述しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's continue with an example CDI bean, that would work as a repository:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引き続き、リポジトリとして動作するCDI Beanの例を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our first GraphQL API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、最初のGraphQL APIを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.microprofile.graphql.FilmResource` class as following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.microprofile.graphql.FilmResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@GraphQLApi` annotation indicates that the CDI bean will be a GraphQL endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@GraphQLApi` アノテーションは、CDI BeanがGraphQLのエンドポイントになることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Query` annotation defines that this method will be queryable with the name `allFilms`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Query` アノテーションは、このメソッドが `allFilms` という名前でクエリー可能であることを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation of the queryable method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリー可能なメソッドのドキュメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value of the `@Query` annotation is optional and would implicitly be defaulted to the method name if absent.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーション `@Query` の値はオプションで、これがない場合は暗黙のうちにメソッド名がデフォルトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This way we have created our first queryable API which we will later expand.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようにして、最初のクエリー可能なAPIが作成されましたが、これは後に拡張されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch the quarkus app:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkusアプリを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introspect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イントロスペクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full schema of the GraphQL API can be retrieved by calling the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQL APIの完全なスキーマは、以下を呼び出すことで取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The server will return the complete schema of the GraphQL API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーは、GraphQL APIの完全なスキーマを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphiQL UI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphiQL UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphiQL UI is a great tool permitting easy interaction with your GraphQL APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphiQL UIは、GraphQL APIとの簡単なやり取りを可能にする素晴らしいツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus `smallrye-graphql` extension ships with `GraphiQL` and enables it by default in `dev` and `test` modes, but it can also be explicitly configured for `production` mode as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの `smallrye-graphql` エクステンションは、 `GraphiQL` と一緒に出荷され、 `dev` と `test` モードでデフォルトで有効になりますが、 `production` モードでも明示的に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:graphql-ui-screenshot01.png[alt=GraphQL UI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:graphql-ui-screenshot01.png[alt=GraphQL UI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a look at the link:security-authorization[Authorization of Web Endpoints] Guide on how to add/remove security for the GraphQL UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQL UIのセキュリティを追加/削除する方法については link:security-authorization[Webエンドポイントの認可] のガイドをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now visit the GraphiQL page that has been deployed in `dev` mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、 `dev` モードで展開されたGraphiQLページにアクセスしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following query to GraphiQL and press the `play` button:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のクエリをGraphiQLに入力し、 `play` ボタンを押します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since our query contains all the fields in the `Film` class we will retrieve all the fields in our response. Since GraphQL API responses are client determined, the client can choose which fields it will require.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリには `Film` クラスのすべてのフィールドが含まれているので、レスポンスではすべてのフィールドを取得します。GraphQL APIのレスポンスはクライアントが決めるものなので、クライアントはどのフィールドを必要とするかを選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's assume that our client only requires `title` and `releaseDate` making the previous call to the API `Over-fetching` of unnecessary data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントが必要としているのは `title` と `releaseDate` だけで、先ほどの API 呼び出しでは不要なデータを `Over-fetching` していたと仮定しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following query into GraphiQL and hit the `play` button:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のクエリをGraphiQLに入力し、 `play` ボタンを押します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice in the response we have only retrieved the required fields.  Therefore, we have prevented `Over-fetching`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスでは、必要なフィールドのみを取得していることに注意してください。そのため、 `Over-fetching` を防ぐことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's continue to expand our GraphQL API by adding the following to the `FilmResource` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引き続き、 `FilmResource` クラスに以下を追加して、GraphQL API を拡張してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice how we have excluded the value in the `@Query` annotation.  Therefore, the name of the query is implicitly set as the method name excluding the `get`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Query` のアノテーションで値を除外していることに注目してください。したがって、クエリの名前は、 `get` を除いたメソッド名が暗黙的に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following into `GraphiQL` and make a request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GraphiQL` に以下の内容を入力してリクエストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `film` query method requested fields can be determined as such in our previous example. This way we can retrieve individual film information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどの例では、 `film` というクエリメソッドの要求フィールドがそのように決定できます。このようにして、個々の映画の情報を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, say our client requires both films with filmId `0` and `1`.  In a REST API the client would have to make two calls to the API.  Therefore, the client would be `Under-fetching`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、クライアントが filmId `0` と `1` の両方の映画を必要とするとします。REST APIでは、クライアントはAPIに2回コールする必要があります。したがって、クライアントは `Under-fetching` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In GraphQL it is possible to make multiple queries at once.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQLでは、一度に複数のクエリを実行することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following into GraphiQL to retrieve two films:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下をGraphiQLに入力して、2つの映画を検索します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This enabled the client to fetch the required data in a single request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、クライアントは1回のリクエストで必要なデータを取得できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, we have created a GraphQL API to retrieve film data.  We now want to enable the clients to retrieve the `Hero` data of the `Film`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、映画のデータを取得するための GraphQL API を作成していました。今度は、クライアントが `Film` の `Hero` データを取得できるようにしたいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following to our `FilmResource` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`FilmResource` のクラスに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable `List&lt;Hero&gt;` data to be added to queries that respond with `Film`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Film` で応答するクエリに `List&lt;Hero&gt;` データを追加できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding this method we have effectively changed the schema of the GraphQL API.  Although the schema has changed the previous queries will still work.  Since we only expanded the API to be able to retrieve the `Hero` data of the `Film`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを追加することで、GraphQL APIのスキーマが事実上変更されました。  スキーマが変更されたにもかかわらず、以前のクエリはそのまま動作します。  今回は、 `Film` の `Hero` のデータを取得できるようにAPIを拡張しただけですから。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following into GraphiQL to retrieve the film and hero data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphiQLに以下のように入力して、フィルムとヒーローのデータを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response now includes the heroes of the film.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今や、レスポンスには映画のヒーローたちも含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Batching</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バッチ処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are exposing a `Collection` return like our `getAllFilms`, you might want to use the batch form of the above, to more efficiently fetch the heroes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回の `getAllFilms` のように `Collection` の戻り値を公開している場合は、より効率的にヒーローを取得するために、上記のバッチ形式を使用するとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here receive the films as a batch, allowing you to fetch the corresponding heroes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、映画を一括して受け取ることで、対応するヒーローを取り出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Queries can be made reactive by using `Uni`, or `CompletionStage` as a return type, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリは、例えば `Uni` や `CompletionStage` をリターンタイプとして使用することでリアクティブにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the underlying library, graphql-java, `Uni` is creating a `CompletionStage` under the hood.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>graphql-javaというライブラリを使用しているため、 `Uni` はボンネット内で `CompletionStage` を作成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or you can use `CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、 `CompletionStage` を使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `Uni` or `CompletionStage` means that when a request contains more than one query, they will be executed concurrently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni` または `CompletionStage` を使用すると、リクエストに複数のクエリが含まれている場合、それらが同時に実行されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, the query below will fetch `film0` and `film1` concurrently:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、以下のクエリでは、 `film0` と `film1` を同時に取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ミューテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutations are used when data is created, updated or deleted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ミューテーションは、データの作成、更新、削除の際に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now add the ability to add and delete heroes to our GraphQL API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、GraphQL APIにヒーローの追加と削除の機能を追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following into `GraphiQL` to insert a `Hero`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GraphiQL` に次のように入力すると、 `Hero` が挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using this mutation we have created a `Hero` entity in our service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このミューテーションを利用することで、私たちのサービスに `Hero` エンティティを作成しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice how in the response we have retrieved the `name` and `surname` of the created Hero. This is because we selected to retrieve these fields in the response within the `{ }` in the mutation query.  This can easily be a server side generated field that the client may require.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスの中で、作成したヒーローの `name` と `surname` を取得していることに注目してください。これは mutation クエリの `{ }` の中で、これらのフィールドをレスポンスで取得することを選択したためです。これは、クライアントが必要とするサーバー側で生成されたフィールドである可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now try deleting an entry:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、エントリーを削除してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to the `createHero` mutation method we also retrieve the `name` and `surname` of the hero we have deleted which is defined in `{ }`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`createHero` の mutation 法と同様に、 `{ }` で定義されている削除したヒーローの `name` と `surname` も取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Queries by fields</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィールド別のクエリの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Queries can also be done on individual fields. For example, let's create a method to query heroes by their last name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリは個々のフィールドに対して行うこともできます。例えば、ヒーローの名字を照会するメソッドを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `@DefaultValue` annotation we have determined that the surname value will be `Skywalker` when the parameter is not provided.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@DefaultValue` のアノテーションを使用して、パラメータが提供されていない場合、姓の値は `Skywalker` になることを決定しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test the following queries with GraphiQL:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のクエリをGraphiQLでテストしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get information about the GraphQL request anywhere in your code, using this experimental, SmallRye specific feature:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この実験的なSmallRye固有の機能を使えば、コードのどこにいてもGraphQLリクエストの情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The context object allows you to get:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキストオブジェクトによって、以下を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to optimize the downstream queries to the datastore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、データストアへのダウンストリームクエリを最適化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the https://javadoc.io/doc/io.smallrye/smallrye-graphql-api/latest/io/smallrye/graphql/api/Context.html[JavaDoc] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は link:https://javadoc.io/doc/io.smallrye/smallrye-graphql-api/latest/io/smallrye/graphql/api/Context.html[JavaDoc] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphQL-Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQL-Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This context object also allows you to fall down to the underlying https://www.graphql-java.com/[graphql-java] features by using the leaky abstraction:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、このコンテキストオブジェクトは、リーキーな抽象化を利用することで、基礎となる https://www.graphql-java.com/[graphql-java] の機能にフォールダウンすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also get access to the underlying `graphql-java` during schema generation, to add your own features directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、スキーマ生成時に基盤となる `graphql-java` にアクセスして、独自の機能を直接追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `@Observer` you can add anything to the Schema builder.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Observer` を使用することで、スキーマビルダーに何かを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Map to Scalar</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スカラーへのマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another SmallRye specific experimental feature, allows you to map an existing scalar (that is mapped by the implementation to a certain Java type) to another type, or to map complex object, that would typically create a `Type` or `Input` in GraphQL, to an existing scalar.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、SmallRye特有の実験的な機能として、既存のスカラー（実装によって特定のJava型にマッピングされている）を別の型にマッピングしたり、GraphQLで通常 `Type` や `Input` を作成するような複雑なオブジェクトを既存のスカラーにマッピングしたりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping an existing Scalar to another type:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のスカラーを別のタイプにマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Above will map the `Long` java type to an `Int` Scalar type, rather than the https://download.eclipse.org/microprofile/microprofile-graphql-1.0/microprofile-graphql.html#scalars[default] `BigInteger`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記では、 `Long` java型を、 link:https://download.eclipse.org/microprofile/microprofile-graphql-1.0/microprofile-graphql.html#scalars[デフォルト] の `BigInteger` ではなく、 `Int` スカラー型にマッピングしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping a complex object to a Scalar type:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複雑なオブジェクトをスカラー型にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will, rather than creating a `Type` or `Input` in GraphQL, map to a String scalar.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、GraphQLで `Type` や `Input` を作成するのではなく、Stringのスカラーにマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to do the above, the `Phone` object needs to have a constructor that takes a String (or `Int` / `Date` / etc.), or have a setter method for the String (or `Int` / `Date` / etc.), or have a `fromString` (or `fromInt` / `fromDate` - depending on the Scalar type) static method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の操作を行うためには、 `Phone` オブジェクトは、文字列（または `Int` / `Date` など）を受け取るコンストラクタを持つか、文字列（または `Int` / `Date` など）のセッターメソッドを持つか、 `fromString` (または `fromInt` / `fromDate` - スカラーの型に依存）のスタティックメソッドを持つ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See more about the `@ToScalar` feature in the https://javadoc.io/static/io.smallrye/smallrye-graphql-api/1.0.6/index.html?io/smallrye/graphql/api/ToScalar.html[JavaDoc].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ToScalar` の機能については、 link:https://javadoc.io/static/io.smallrye/smallrye-graphql-api/1.0.6/index.html?io/smallrye/graphql/api/ToScalar.html[JavaDoc] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エラーコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add an error code on the error output in the GraphQL response by using the (SmallRye specific) `@ErrorCode`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(SmallRye特有の) `@ErrorCode` を使用することで、GraphQLレスポンスのエラー出力にエラーコードを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `SomeBusinessException` occurs, the error output will contain the Error code:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`SomeBusinessException` が発生した場合、エラー出力にはエラーコードが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The error code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エラーコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Notes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の注意事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `smallrye-graphql` extension and the `micrometer` metrics extension is present and metrics are enabled, you may encounter a `java.lang.NoClassDefFoundError` as some versions of the `smallrye-graphql` extension have runtime requirements on the Microprofile Metrics API.  Add the following Microprofile Metrics API dependency to resolve the issue:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`smallrye-graphql` エクステンションを使用していて、 `micrometer` メトリクスエクステンションが存在し、メトリクスが有効になっている場合、 `smallrye-graphql` エクステンションの一部のバージョンには Microprofile Metrics API のランタイム要件があるため、 `java.lang.NoClassDefFoundError` が発生する可能性があります。この問題を解決するには、次の Microprofile Metrics API の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye GraphQL enables clients to retrieve the exact data that is required preventing `Over-fetching` and `Under-fetching`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye GraphQL は、クライアントが `Over-fetching` や `Under-fetching` を防ぐために必要なデータを正確に取得することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The GraphQL API can be expanded without breaking previous queries enabling easy API `evolution`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphQL APIは、以前のクエリを壊すことなく拡張することができ、API `evolution` を容易にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `kubernetes-config` extension which allows developers to use Kubernetes https://cloud.google.com/kubernetes-engine/docs/concepts/configmap[ConfigMaps] and https://cloud.google.com/kubernetes-engine/docs/concepts/secret[Secrets] as a configuration source, without having to mount them into the https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pod] running the Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、 `kubernetes-config` エクステンションが含まれており、開発者はQuarkusアプリケーションを実行している link:https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pod] にマウントしなくても、Kubernetes link:https://cloud.google.com/kubernetes-engine/docs/concepts/configmap[ConfigMaps] と link:https://cloud.google.com/kubernetes-engine/docs/concepts/secret[Secrets] を設定ソースとして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `kubernetes-config` extension by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで以下のコマンドを実行して、 `kubernetes-config` エクステンションを追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension works by reading ConfigMaps and Secrets directly from the Kubernetes API server using the link:kubernetes-client[Kubernetes Client].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、Kubernet link:kubernetes-client[Kubernates クライアント] を使用してKubernetes APIサーバーから直接ConfigMapsとSecretsを読み込むことで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension understands the following types of ConfigMaps and Secrets as input sources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは、以下のタイプの ConfigMaps と Secrets を入力ソースとして理解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMaps and Secrets that contain literal data (see https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values[this] for an example on how to create one)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リテラルデータを含む ConfigMaps と Secrets (作成方法の例は link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values[こちら] を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMaps and Secrets created from files named `application.properties`, `application.yaml` or `application.yml` (see https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files[this] for an example on how to create one).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ConfigMapsとSecretsは、 `application.properties` 、 `application.yaml` 、または `application.yml` という名前のファイルから作成されます(作成方法の例は link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files[こちら] を参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to explicitly enable the retrieval of ConfigMaps and Secrets by setting `quarkus.kubernetes-config.enabled=true`.  The default is `false` in order to make it easy to test the application locally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ConfigMaps と Secrets の取得を明示的に有効にするには、 `quarkus.kubernetes-config.enabled=true` を設定する必要があります。デフォルトは `false` で、ローカルでのアプリケーションのテストを容易にするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Afterwards, set the `quarkus.kubernetes-config.config-maps` property to configure which ConfigMaps should be used.  Set the `quarkus.kubernetes-config.secrets` property to configure which Secrets should be used.  To access ConfigMaps and Secrets from a specific namespace, you can set the `quarkus.kubernetes-config.namespace` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、 `quarkus.kubernetes-config.config-maps` プロパティーを設定して、どの ConfigMaps を使用するかを設定します。 `quarkus.kubernetes-config.secrets` プロパティーを設定して、どの Secrets を使用するかを設定します。特定の名前空間の
 ConfigMaps と Secrets にアクセスするには、 `quarkus.kubernetes-config.namespace` プロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Priority of obtained properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>取得したプロパティーの優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties obtained from the ConfigMaps and Secrets have a higher priority than (i.e. they override) any properties of the same name that are found in `application.properties` (or the YAML equivalents), but they have lower priority than properties set via Environment Variables or Java System Properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ConfigMapsとSecretsから取得したプロパティーは、 `application.properties` (またはYAMLの等価物)にある同名のプロパティーよりも高い優先度を持っています(すなわち、それらは上書きされます)が、環境変数やJavaシステムプロパティーを介して設定されたプロパティーよりも優先度は低くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when multiple ConfigMaps (or Secrets) are used, ConfigMaps (or Secrets) defined later in the list have a higher priority that ConfigMaps defined earlier in the list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、複数のConfigMap(またはSecret)を使用している場合、後から定義されたConfigMap(またはSecret)は、先に定義されたConfigMap(またはSecret)よりも優先度が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, when both ConfigMaps and Secrets are used, the latter always a higher priority than the former.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、ConfigMapsとSecretsの両方を使用する場合、常に後者の方が前者よりも優先度が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since reading ConfigMaps involves interacting with the Kubernetes API Server, when https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] is enabled on the cluster, the https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount] that is used to run the application needs to have the proper permissions for such access.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ConfigMapsの読み込みにはKubernetes API Serverとのやりとりが含まれるため、クラスター上で link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] が有効になっている場合、アプリケーションを実行するために使用される link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount] に適切なアクセス権限が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thankfully, when using the `kubernetes-config` extension along with the link:deploying-to-kubernetes[Kubernetes] extension, all the necessary Kubernetes resources to make that happen are automatically generated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ありがたいことに、 link:deploying-to-kubernetes[Kubernetes] エクステンションと一緒に `kubernetes-config` エクステンションを使うと、それを実現するために必要なKubernetesリソースがすべて自動的に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secrets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Secrets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the link:deploying-to-kubernetes[Kubernetes] extension doesn't generate the necessary resources to allow accessing secrets.  Set `quarkus.kubernetes-config.secrets.enabled=true` to generate the necessary role and corresponding role binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 link:deploying-to-kubernetes[Kubernetes] エクステンションは秘密にアクセスできるようにするために必要なリソースを生成しません。 `quarkus.kubernetes-config.secrets.enabled=true` を設定して、必要なロールと対応するロールバインディングを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus:quarkus-security` module contains the core Quarkus security classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus:quarkus-security` モジュールには、Quarkusの中核となるセキュリティクラスが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most cases it does not have to be added directly to your project's `pom.xml` as it is already provided by all of the security extensions.  However if you need to write your own custom security code (for example, register a &lt;&lt;jaxrs-security-context, Custom JAX-RS SecurityContext&gt;&gt;) or use &lt;&lt;bouncy-castle, BouncyCastle&gt;&gt; libraries, then please make sure it is included:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどの場合、すべてのセキュリティエクステンションによってすでに追加されているので、プロジェクトの `pom.xml` に直接追加する必要はありません。しかし、独自のカスタムセキュリティコードを書く必要がある場合（例えば、 link:#jaxrs-security-context[カスタムJAX-RS SecurityContext]の登録など）や、 link:#bouncy-castle[BouncyCastle]ライブラリを使用する場合は、必ず追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can customize `HttpAuthenticationMechanism` by registering a CDI implementation bean.  In the example below the custom authenticator delegates to `JWTAuthMechanism` provided by `quarkus-smallrye-jwt`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI実装Beanを登録することで、 `HttpAuthenticationMechanism` をカスタマイズすることができます。以下の例では、カスタム認証機能は `quarkus-smallrye-jwt` によって提供される `JWTAuthMechanism` にデリゲートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Identity Customization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティー・アイデンティティのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally, the identity providers create and update an instance of the `io.quarkus.security.identity.SecurityIdentity` class which holds the principal, roles, credentials which were used to authenticate the client (user) and other security attributes. An easy option to customize `SecurityIdentity` is to register a custom `SecurityIdentityAugmentor`. For example, the augmentor below adds an addition role:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内部的には、アイデンティティ・プロバイダは、プリンシパル、役割、クライアント(ユーザー)の認証に使用されたクレデンシャル、 およびその他のセキュリティー属性を保持する `io.quarkus.security.identity.SecurityIdentity` クラスのインスタンスを作成して更新します。 `SecurityIdentity` をカスタマイズする簡単なオプションは、カスタム `SecurityIdentityAugmentor` を登録することです。例えば、以下のエクステンションは、追加のロールを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is another example showing how to use the client certificate available in the current link:security-built-in-authentication#mutual-tls[Mutual TLS] request to add more roles:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、現在の link:security-built-in-authentication#mutual-tls[相互TLS] リクエストで利用可能なクライアント証明書を使用して、より多くのロールを追加する方法を示すもう一つの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If more than one custom `SecurityIdentityAugmentor` is registered then they will be considered equal candidates and invoked in random order.  You can enforce the order by implementing a default `SecurityIdentityAugmentor#priority` method. Augmentors with higher priorities will be invoked first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のカスタム `SecurityIdentityAugmentor` が登録されている場合、それらは同等の候補とみなされ、ランダムな順序で呼び出されます。デフォルトの `SecurityIdentityAugmentor#priority` メソッドを実装することで順番を強制することができます。優先度の高いAugmentors が最初に起動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom JAX-RS SecurityContext</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタム JAX-RS SecurityContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use JAX-RS `ContainerRequestFilter` to set a custom JAX-RS `SecurityContext` then make sure `ContainerRequestFilter` runs in the JAX-RS pre-match phase by adding a `@PreMatching` annotation to it for this custom security context to be linked with Quarkus `SecurityIdentity`, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS `ContainerRequestFilter` を使用してカスタム JAX-RS `SecurityContext` を設定する場合は、 `ContainerRequestFilter` が JAX-RS のプレマッチフェーズで実行されていることを確認し、このカスタムセキュリティーコンテキストが Quarkus `SecurityIdentity` とリンクされるように `@PreMatching` アノテーションを追加します。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling Authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認可の無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a good reason to disable the authorization (for example, when testing) then you can register a custom `AuthorizationController`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>認可を無効にする正当な理由がある場合(テスト時など)は、カスタムの `AuthorizationController` を登録してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see link:security-testing#testing-security[TestingSecurity Annotation] section on how to disable the security checks using `TestSecurity` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TestSecurity` アノテーションを使ってセキュリティチェックを無効にする方法については、 link:security-testing#testing-security[TestingSecurity Annotation]の項を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering Security Providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティー プロバイダの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default providers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのプロバイダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in native mode, the default behavior for GraalVM native executable generation is to only include the main "SUN" provider unless you have enabled SSL, in which case all security providers are registered. If you are not using SSL, then you can selectively register security providers by name using the `quarkus.security.security-providers` property. The following example illustrates configuration to register the "SunRsaSign" and "SunJCE" security providers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードで実行している場合、GraalVMネイティブ実行ファイル生成のデフォルトの動作は、SSLを有効にしていない限り、メインの「SUN」プロバイダのみを含めるようになっています。SSLを有効にしている場合は、すべてのセキュリティープロバイダが登録されます。SSLを使用していない場合は、 `quarkus.security.security-providers` プロパティーを使用して、セキュリティープロバイダを名前で選択的に登録することができます。以下の例では、「SunRsaSign」と「SunJCE」のセキュリティープロバイダを登録するための設定を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティー プロバイダの設定例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BouncyCastle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jce.provider.BouncyCastleProvider` JCE provider then please set a `BC` provider name:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.bouncycastle.jce.provider.BouncyCastleProvider` JCE プロバイダを登録する必要がある場合は、 `BC` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティープロバイダの例 BouncyCastleの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the BouncyCastle provider dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、BouncyCastleプロバイダ依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle JSSE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BouncyCastle JSSE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSE provider and use it instead of the default SunJSSE provider then please set a `BCJSSE` provider name:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSE プロバイダを登録して、デフォルトの SunJSSE プロバイダの代わりに使用する必要がある場合は、 `BCJSSE` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle JSSE Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティープロバイダの例 BouncyCastle JSSE設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the BouncyCastle TLS dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、BouncyCastleのTLS依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle FIPS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BouncyCastle FIPS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` JCE provider then please set a `BCFIPS` provider name:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` JCE プロバイダを登録する必要がある場合は、 `BCFIPS` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle FIPS Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティープロバイダの例 BouncyCastleのFIPS設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the BouncyCastle FIPS provider dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、BouncyCastle FIPSプロバイダの依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle JSSE FIPS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BouncyCastle JSSE FIPS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSE provider and use it in combination with `org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` instead of the default SunJSSE provider then please set a `BCFIPSJSSE` provider name:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのSunJSSEプロバイダではなく、 `org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSEプロバイダを登録して、 `org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` と組み合わせて使用する必要がある場合は、 `BCFIPSJSSE` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle FIPS JSSE Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティープロバイダの例 BouncyCastle FIPS JSSE設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the keystore and truststore type and provider are set to `BCFKS` and `BCFIPS`.  One can generate a keystore with this type and provider like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>keystore と truststore のタイプとプロバイダが `BCFKS` と `BCFIPS` に設定されていることに注意してください。このタイプとプロバイダでは、以下のようにキーストアを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are going to use security in a reactive environment, you will likely need SmallRye Context Propagation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな環境でセキュリティーを使用する場合は、SmallRye Context Propagationが必要になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will allow you to propagate the identity throughout the reactive callbacks. You also need to make sure you are using an executor that is capable of propagating the identity (e.g. no `CompletableFuture.supplyAsync`), to make sure that Quarkus can propagate it. For more information see the link:context-propagation[Context Propagation Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、リアクティブコールバック全体にIDを伝播させることができます。また、QuarkusがIDを伝播できるようにするために、IDを伝播できる実行者を使用していることを確認する必要があります(例: `CompletableFuture.supplyAsync` がない)。詳細については、 link:context-propagation[コンテキスト伝搬ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>環境変数 - `AWS_ACCESS_KEY_ID` と `AWS_SECRET_ACCESS_KEY`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての AWS SDK および AWS CLI で共有される、デフォルトの場所( `~/.aws/credentials` )にある資格情報プロファイルのファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials delivered through the Amazon ECS if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` 環境変数が設定されていて、セキュリティーマネージャーがその変数にアクセスする権限を持っている場合に、Amazon ECS を通して配信されるクレデンシャル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging を使用して HTTP メッセージを消費および生成する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM, Docker or Podman installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードで実行したい場合は、GraalVM、Docker、Podman がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will implement a service, namely `CostConverter` that consumes HTTP messages with costs in multiple currencies and converts each cost to its value in Euro.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、複数の通貨のコストを持つ HTTP メッセージを消費し、各コストをユーロの値に変換するサービス、すなわち `CostConverter` を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let a user easily try out the service, we will implement an HTTP resource summing up the costs (`CostCollector`), and a simple web page to add new costs and watch the sum.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーが簡単にサービスを試すことができるように、コストを合計したHTTPリソース( `CostCollector` )と、新しいコストを追加して合計を見るためのシンプルなWebページを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and HTTP connector extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Reactive MessagingとHTTPコネクタエクステンションをインポートしてMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Converter</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/reactivehttp/CostConverter.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/java/org/acme/reactivehttp/CostConverter.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume messages from the `incoming-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`incoming-costs` ストリームからメッセージを消費します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dispatch returned values to the `outgoing-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返された値を `outgoing-costs` ストリームにディスパッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume an event with payload of type `Cost` and produce a `double`.  In the case of consuming an arbitrary object, the reactive-messaging-http extension will attempt to deserialize the request body assuming it is JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Cost` 型のペイロードを持つイベントを消費して `double` を生成します。任意のオブジェクトを消費する場合、reactive-messaging-http エクステンションは、リクエストボディが JSON であると仮定して、リクエストボディをデシリアライズしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define the `Cost` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Cost` クラスを定義してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the next step, we will create configurations for both streams in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のステップでは、 `application.properties` ファイルに両方のストリームの設定を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the HTTP connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP コネクタを設定する必要があります。これは `application.properties` ファイルで行います。キーは以下のように構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.{property}=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CostCollector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コストコレクター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate that converting messages and passing them through works, let's add an endpoint that will receive the outgoing costs and sum them up.  This is a usual JAX-RS endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージを変換して受け渡す様子を説明するために、送信コストを受け取って集計するエンドポイントを追加してみましょう。これは通常のJAX-RSエンドポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To conveniently interact with the application, let's create a simple web page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションと便利にやりとりするために、簡単なWebページを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The page will provide a form to add costs, and an info of the current sum of costs.  The page periodically updates the sum by requesting the current sum from `/cost-collector`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このページでは、コストを追加するためのフォームと、現在のコストの合計の情報を提供します。ページは定期的に `/cost-collector` から現在の合計を要求することによって合計を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/index.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/resources/META-INF/resources/index.html` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/index.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザで `http://localhost:8080/index.html` を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `quarkus-http` connector options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-http` コネクタの全オプション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except of the `quarkus-http` connector, the `quarkus-reactive-messaging-http` extension also brings in `quarkus-websocket` - a connector for exposing and feeding WebSockets.  At the moment only binary data is supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-http` コネクタ以外に、 `quarkus-reactive-messaging-http` エクステンションには `quarkus-websocket` - WebSocket を公開して供給するためのコネクタ - が組み込まれています。現時点ではバイナリーデータのみサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the sink of the HTTP connector checks if the message is consumed by the remote endpoint, the WebSocket sink does not. It may happen that a failure to receive a message is not reported, e.g. if the remote side closes the WebSocket connection in a crucial moment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP コネクタのシンクは、メッセージがリモートエンドポイントによって消費されるかどうかをチェックしますが、WebSocket シンクはチェックしません。例えば、リモート側が肝心な時に WebSocket 接続を閉じた場合など、メッセージの受信に失敗したことが報告されないことがあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-websocket` connector is configured with the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-websocket` コネクタは、以下のプロパティーで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブメッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、MicroProfile Reactive Messaging を利用してデータストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka or AMQP quickstart, you have realized that it's the same code.  The only difference is the connector configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KafkaやAMQPのクイックスタートをした人は、同じコードであることに気づいたはずです。違いはコネクタの設定だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Neo4j</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Neo4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://neo4j.com[Neo4j] is a graph database management system developed by Neo4j, Inc. Neo4j is a native graph database focused not only on the data itself, but especially on the relations between data.  Neo4j stores data as a property graph, which consists of vertices or nodes as we call them, connected with edges or relationships.  Both of them can have properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4 link:https://neo4j.com[jは] 、Neo4jが開発したグラフデータベース管理システムです。Neo4jは、データそのものだけでなく、特にデータ間の関係性に焦点を当てたネイティブグラフデータベースです。Neo4jは、データをプロパティー・グラフとして格納しますが、これは、我々が呼ぶところの頂点やノードをエッジやリレーションシップで接続したものです。どちらもプロパティーを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Neo4j offers Cypher, a declarative query language much like SQL.  Cypher is used to for both querying the graph and creating or updating nodes and relationships.  As a declarative language it used to tell the database what to do and not how to do it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4jは、SQLのような宣言的な問い合わせ言語であるCypherを提供しています。Cypherは、グラフの問い合わせとノードとリレーションシップの作成や更新の両方に使用されます。宣言的な言語として、それはデータベースにどのようにそれをするかではなく、何をすべきかを伝える為に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Cypher in the https://neo4j.com/docs/cypher-manual/current/[Neo4j Cypher manual].
      Cypher is not only available in Neo4j, but for example coming to https://github.com/opencypher/morpheus[Apache Spark].
      A spec called http://www.opencypher.org[OpenCypher] is available, too.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://neo4j.com/docs/cypher-manual/current/[Neo4jのCypherマニュアル] でCypherについて詳しく説明しています。
CypherはNeo4jだけではなく、例えば link:https://github.com/opencypher/morpheus[Apache Spark] にも登場しています。
link:http://www.opencypher.org[OpenCypher] と呼ばれる仕様も利用可能です。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clients communicate over the so called Bolt protocol with the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントは、ボルトと呼ばれるプロトコルを介してデータベースと通信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The driver itself is released under the Apache 2.0 license, while Neo4j itself is available in a GPL3-licensed open-source "community edition", with online backup and high availability extensions licensed under a closed-source commercial license.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドライバー自体はApache 2.0ライセンスでリリースされていますが、Neo4j自体はGPL3ライセンスでオープンソースの「コミュニティ版」として利用可能で、オンラインバックアップと高可用性のエクステンションはクローズドソースの商用ライセンスの下でライセンスされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programming model</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラミングモデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The driver and thus the Quarkus extension support three different programming models:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドライバーとQuarkusエクステンションは、3つの異なるプログラミングモデルをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking database access (much like standard JDBC)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースアクセスのブロック (標準の JDBC によく似ています)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive programming based on http://www.reactive-streams.org[Reactive Streams]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://www.reactive-streams.org[Reactive Streams] に基づくリアクティブプログラミング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide you will learn how to</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、次のことを学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the Neo4j extension to your project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトにNeo4jエクステンションを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the driver</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドライバーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And how to use the driver to access a Neo4j database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、Neo4jデータベースにアクセスするためにドライバーを使用する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The domain</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドメイン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with some of the other guides, the application shall manage fruit entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のガイドのいくつかと同様に、アプリケーションは、果物のエンティティーを管理するものとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional Docker for your system</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションでシステムにDockerがインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start a Neo4j instance is a locally installed Docker environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4jインスタンスを起動する最も簡単な方法は、ローカルにインストールされたDocker環境です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a Neo4j instance, that publishes its Bolt port on `7687` and a web interface on http://localhost:7474.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Neo4jインスタンスを起動し、そのボルトポートを `7687` で公開し、ウェブインタフェースを http://localhost:7474 で公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a look at the https://neo4j.com/download/?ref=product[download page] for other options to get started with the product itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>製品自体を起動するための他のオプションについては、 link:https://neo4j.com/download/?ref=product[ダウンロードページ] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `neo4j-quickstart` {quickstarts-tree-url}/neo4j-quickstart[directory].  It contains a very simple UI to use the JAX-RS resources created here, too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `neo4j-quickstart` {quickstarts-tree-url}/neo4j-quickstart[ディレクトリ] にあります。ここで作成したJAX-RSリソースを利用するための非常にシンプルなUIも含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.datasource.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.datasource.GreetingResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Neo4j extension has been added already to your `pom.xml`.  In addition, we added `resteasy-jackson`, which allows us to expose `Fruit` instances over HTTP in the JSON format via JAX-RS resources.  If you have an already created project, the `neo4j` extension can be added to an existing Quarkus project with the `add-extension` command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4jエクステンションは、すでにあなたの `pom.xml` に追加されています。加えて、 `resteasy-jackson` を追加しました。これにより、JAX-RSリソースを経由して、JSON形式のHTTPで `Fruit` インスタンスを公開することができます。すでに作成したプロジェクトがある場合は、 `neo4j` エクステンションを既存のQuarkusプロジェクトに `add-extension` コマンドで追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Neo4j driver can be configured with standard Quarkus properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Neo4jドライバーは、Quarkusの標準的なプロパティーで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the driver</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドライバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are not any fruits, so let's create some.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>果物がないので、作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating nodes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ノードの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>src/main/java/org/acme/neo4j/ReactiveFruitResource.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/java/org/acme/neo4j/ReactiveFruitResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Spring Security annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているSpring Securityアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Secured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Secured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@PreAuthorize</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@PreAuthorize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table shows how Spring Security annotations can be converted to JAX-RS annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の表は、Spring SecurityアノテーションをJAX-RSアノテーションに変換する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Secured("admin")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Secured("admin")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RolesAllowed("admin")</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@RolesAllowed("admin")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次項の説明に従って、一歩一歩アプリを作成していくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we want to use configuration properties obtained from the Config Server, we will update the `GreetingResource` to inject the `message` property. The updated code will look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Config Serverから取得した設定プロパティーを使用したいので、 `GreetingResource` を更新して `message` プロパティーを注入します。更新したコードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Cloud Config Client Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Cloud Config Client Reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of web applications are monotonous CRUD applications with REST APIs that are tedious to write.  To streamline this task, REST Data with Panache extension can generate the basic CRUD endpoints for your entities and repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くのWebアプリケーションは、REST APIを使った単調なCRUDアプリケーションで、書くのが面倒です。このタスクを合理化するために、REST Data with Panache エクステンションは、エンティティーやリポジトリの基本的なCRUDエンドポイントを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While this extension is still experimental and provides a limited feature set, we hope to get an early feedback for it.  Currently this extension supports Hibernate ORM and MongoDB with Panache and can generate CRUD resources that work with `application/json` and `application/hal+json` content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションはまだ実験的なものであり、限られた機能しか提供していませんが、早期にフィードバックが得られることを期待しています。現在のところ、このエクステンションは Hibernate ORM と MongoDB with Panache をサポートしており、 `application/json` と `application/hal+json` のコンテンツで動作する CRUD リソースを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the required dependencies to your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要な依存関係を `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache extension (`quarkus-hibernate-orm-rest-data-panache`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM REST Data with Panache エクステンション ( `quarkus-hibernate-orm-rest-data-panache` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDBC ドライバーエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the RESTEasy JSON serialization extensions (`quarkus-resteasy-jackson` or `quarkus-resteasy-jsonb`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy JSON シリアライゼーションエクステンションのどれか ( `quarkus-resteasy-jackson` または `quarkus-resteasy-jsonb` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the Panache entities and/or repositories as explained in the link:hibernate-orm-panache[Hibernate ORM with Panache guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:hibernate-orm-panache[Panacheを使ったHibernate ORM with Panacheガイド] で説明されているように、Panacheエンティティーおよび/またはリポジトリを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the interfaces for generation as explained in the resource generation section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソース生成の項で説明したように、生成用のインターフェースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB REST Data with Panache extension (`quarkus-mongodb-rest-data-panache`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB REST Data with Panache エクステンション ( `quarkus-mongodb-rest-data-panache` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the Panache entities and/or repositories as explained in the link:mongodb-panache[MongoDB with Panache guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mongodb-panache[MongoDB with Panache ガイド] で説明されているように、Panache エンティティーやリポジトリを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache generates JAX-RS resources based on the interfaces available in your application.  For each entity and repository that you want to generate, provide a resource interface.  _Do not implement these interfaces and don't provide custom methods because they will be ignored._ You can, however, override the methods from the extended interface in order to customize them (see the section at the end).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST Data with Panache は、アプリケーションで利用可能なインターフェイスに基づいて JAX-RS リソースを生成します。生成したい各エンティティーとリポジトリに対して、リソースインターフェイスを提供してください。 _これらのインターフェイスを実装したり、カスタムメソッドを提供したりしないでください。_ ただし、エクステンションインターフェースからメソッドをオーバーライドしてカスタマイズすることは可能です(最後のセクションを参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheEntityResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PanacheEntityResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has an entity (e.g. `Person`) that extends either `PanacheEntity` or `PanacheEntityBase` class, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションに `PanacheEntity` または `PanacheEntityBase` クラスを拡張したエンティティー ( `Person` など) がある場合、REST Data with Panache に、次のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheRepositoryResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PanacheRepositoryResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has a simple entity (e.g. `Person`) and a repository (e.g. `PersonRepository`) that implements either `PanacheRepository` or `PanacheRepositoryBase` interface, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが単純なエンティティー(例: `Person` )と、 `PanacheRepository` または `PanacheRepositoryBase` インターフェイスを実装したリポジトリ(例: `PersonRepository` )を持っている場合、REST Data with Panache に、以下のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheMongoEntityResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PanacheMongoEntityResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has an entity (e.g. `Person`) that extends either `PanacheMongoEntity` or `PanacheMongoEntityBase` class, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションに `PanacheMongoEntity` または `PanacheMongoEntityBase` クラスを拡張したエンティティー ( `Person` など) がある場合、REST Data with Panache に、次のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheMongoRepositoryResource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PanacheMongoRepositoryResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has a simple entity (e.g. `Person`) and a repository (e.g. `PersonRepository`) that implements either `PanacheMongoRepository` or `PanacheMongoRepositoryBase` interface, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが単純なエンティティー(例: `Person` )と、 `PanacheMongoRepository` または `PanacheMongoRepositoryBase` インターフェイスを実装したリポジトリ(例: `PersonRepository` )を持っている場合、REST Data with Panache に、以下のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated resources will be functionally equivalent for both entities and repositories.  The only difference being the particular data access pattern and data storage in use.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されるリソースは、エンティティーとリポジトリの両方で機能的に同等となります。唯一の違いは、利用時の特定のデータアクセスパターンとデータストレージです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have defined one of the `PeopleResource` interfaces mentioned above, this extension will generate its implementation using a particular data access strategy.  The implemented class then will be used by a generated JAX-RS resource, which will look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の `PeopleResource` インターフェイスのいずれかを定義している場合、このエクステンションは特定のデータアクセス戦略を使用してその実装を生成します。実装されたクラスは、生成された JAX-RS リソースによって使用され、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resource customisation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache provides a `@ResourceProperties` and `@MethodProperties` annotations that can be used to customize certain features of the resource.  It can be used in your resource interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST Data with Panache は、リソースの特定の機能をカスタマイズするために使用できる `@ResourceProperties` と `@MethodProperties` のアノテーションを提供します。リソースのインターフェイスで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能なオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ResourceProperties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ResourceProperties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`exposed` - whether resource could be exposed. A global resource property that can be overridden for each method. Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`exposed` - リソースが公開される可能性があるかどうか。各メソッドに対してオーバーライド可能なグローバルリソースプロパティー。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path` - resource base path. Default path is a hyphenated lowercase resource name without a suffix of `resource` or `controller`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`path` - リソースのベースパス。デフォルトのパスは、 `resource` または `controller` のサフィックスを含まないハイフン付きの小文字のリソース名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`paged` - whether collection responses should be paged or not.  First, last, previous and next page URIs are included in the response headers if they exist.  Request page index and size are taken from the `page` and `size` query parameters that default to `0` and `20` respectively.  Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`paged` - コレクションのレスポンスをページングするかどうか。最初、最後、前、次のページの URI が存在する場合は、レスポンスヘッダに含まれます。リクエストページのインデックスとサイズは、 `page` と `size` のクエリパラメーターから取得され、それぞれのデフォルトは `0` と `20` です。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`hal` - in addition to the standard `application/json` responses, generates additional methods that can return `application/hal+json` responses if requested via an `Accept` header.  Default is `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`hal` - 標準の `application/json` レスポンスに加えて、 `Accept` ヘッダでリクエストされた場合に `application/hal+json` レスポンスを返す追加のメソッドを生成します。デフォルトは `false` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`halCollectionName` - name that should be used when generating a hal collection response. Default name is a hyphenated lowercase resource name without a suffix of `resource` or `controller`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`halCollectionName` - HAL コレクションレスポンスを生成する際に使用されるべき名前です。デフォルトの名前は `resource` または `controller` のサフィックスなしのハイフン付き小文字のリソース名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@MethodProperties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@MethodProperties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`exposed` - does not expose a particular HTTP verb when set to `false`. Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`exposed` - `false` に設定されている場合、特定の HTTP Verb を公開しません。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path` - operation path (this is appended to the resource base path). Default is an empty string.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`path` - 操作パス (これはリソースベースのパスに追加されます)。デフォルトは空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query parameters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリパラメーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache supports the following query parameters with the generated resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST Data with Panacheは、生成されたリソースで以下のクエリパラメーターをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`page` - a page number which should be returned by a list operation.  It applies to the paged resources only and is a number starting with 0. Default is 0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`page` - リスト操作で返されるべきページ番号。これはページ化されたリソースにのみ適用され、0 から始まる番号です。 デフォルトは 0 です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`size` - a page size which should be returned by a list operation.  It applies to the paged resources only and is a number starting with 1. Default is 20.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`size` - リスト操作で返されるべきページサイズ。これはページ化されたリソースにのみ適用され、1から始まる数値です。 デフォルトは20です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sort` - a comma separated list of fields which should be used for sorting a result of a list operation.  Fields are sorted in the ascending order unless they're prefixed with a `-`.  E.g. `?sort=name,-age` will sort the result by the name ascending by the age descending.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sort` - リスト操作の結果をソートするために使われるべきフィールドのカンマ区切りのリスト。フィールドの前に `-` を付けない限り、フィールドは昇順でソートされます。例えば `?sort=name,-age` は、名前の昇順、年齢の降順で結果をソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Response body examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスボディの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above REST Data with Panache supports the `application/json` and `application/hal+json` response content types.  Here are a couple of examples of how a response body would look like for the `get` and `list` operations assuming there are five `Person` records in a database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前述の通り、REST Data with Panache は `application/json` と `application/hal+json` のレスポンス コンテンツ タイプをサポートしています。 `Person` ここでは、データベース内に `get` レコードが 5 つあると仮定して、 と `list` 操作を行った場合のレスポンスボディがどのようになるか、いくつかの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GET /people/1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GET /people/1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Accept: application/json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Accept: application/json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Accept: application/hal+json`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Accept: application/hal+json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GET /people?page=0&amp;size=2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GET /people?page=0&amp;size=2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both responses would also contain these headers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>両方のレスポンスには、これらのヘッダも含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link: &lt; http://example.com/people?page=0&amp;size=2 &gt;; rel="first"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Link: &lt; http://example.com/people?page=0&amp;size=2 &gt;; rel="first"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link: &lt; http://example.com/people?page=2&amp;size=2 &gt;; rel="last"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Link: &lt; http://example.com/people?page=2&amp;size=2 &gt;; rel="last"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link: &lt; http://example.com/people?page=1&amp;size=2 &gt;; rel="next"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Link: &lt; http://example.com/people?page=1&amp;size=2 &gt;; rel="next"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `previous` link header (and hal link) would not be included, because the previous page does not exist.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のページが存在しないため、 `previous` リンクヘッダ(および HAL リンク)が含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First: an example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初に:例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining your entity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most useful operations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最も便利な操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `list` methods have equivalent `stream` versions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての `list` メソッドは、同等の `stream` バージョンがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining your repository</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リポジトリの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have written your repository, here are the most common operations you will be able to perform:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リポジトリを書くことで実行可能な最も一般的な操作は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the repository pattern</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リポジトリパターンの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is developed by a third party and is part of the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションはサードパーティによって開発されたもので、Quarkus Platformの一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see our entities remain simple.  There is, however, a slight difference from the Java version.  The Kotlin language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we must use a https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[companion object]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご覧のように、私たちのエンティティーはシンプルなままです。しかし、Java版とは少し違いがあります。Kotlin 言語は Java のように静的メソッドの概念をサポートしていません。その代わり、 link:https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects[コンパニオンオブジェクト] を使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The companion object holds all the methods not related to a specific instance allowing for general management and querying bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンパニオンオブジェクトは、特定のインスタンスに関連しないすべてのメソッドを保持し、特定の型にバインドされた一般的な管理とクエリを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null knowing they will be properly assigned either by the constructor (not shown) or by hibernate loading data from the database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>幾つか選択肢がありますが、ここでは `lateinit` のアプローチを選択しました。これにより、コンストラクタ(表示されていません)やHibernateがデータベースからデータをロードすることで適切に代入されることがわかっているので、これらのフィールドを非 null として宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These types differ from the Java types mentioned in those tutorials.  For Kotlin support, all the Panache types will be found in the `io.quarkus.hibernate.orm.panache.kotlin` package.  This subpackage allows for the distinction between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの型は、それらのチュートリアルで言及されている Java のタイプとは異なります。Kotlin のサポートのために、すべての Panache の型は `io.quarkus.hibernate.orm.panache.kotlin` パッケージにあります。このサブパッケージは、Java と Kotlin の違いを区別し、単一のプロジェクトで両方を明確に使用することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] functionality to the `companion object`.  Apart from this slight change, we can then work with our types in ways that map easily from the Java side of world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kotlin版では、単純に link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`] の機能を `companion object` に追加しました。このわずかな変更を別にすれば、私たちは、世界のJava側から簡単にマップする方法で私たちの型を使用して作業することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the repository pattern, you can define your entities as regular JPA entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リポジトリパターンを使用する場合、エンティティーを通常のJPAエンティティーとして定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository, by making them implement `PanacheRepository`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リポジトリを使用する場合、`PanacheRepository` を実装することでアクティブレコードパターンをリポジトリに注入した場合と全く同じ便利なメソッドを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it is exactly the same as using the active record pattern, except you need to inject it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`PanacheEntityBase` で定義されている操作はすべてリポジトリ上で利用可能なので、これを使用することはアクティブレコードパターンを使用するのと全く同じですが、それを注入する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `stream` methods require a transaction to work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stream` メソッドが動作するにはトランザクションが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more examples, please consult the link:hibernate-orm-panache[Java version] for complete details.  Both APIs are the same and work identically except for some Kotlin-specific tweaks to make things feel more natural to Kotlin developers.  These tweaks include things like better use of nullability and the lack of `Optional` on API methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より多くの例については、 link:hibernate-orm-panache[Java 版] を参照してください。どちらの API も同じで、Kotlin 開発者がより自然に感じられるように Kotlin 固有の調整が行われている点を除いては同じように動作します。これらの調整には、nullability の使用方法の改善や、API メソッドの `Optional` がないことなどが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the addition of `-kotlin` on the end.  Generally you'll only need this version but if your project will be using both Java and Kotlin code, you can safely include both artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に `-kotlin` が追加されていることに注意してください。一般的にはこのバージョンだけが必要ですが、もしあなたのプロジェクトがJavaとKotlinの両方のコードを使うのであれば、両方の成果物を安全に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `elytron-security-jdbc` extension which is an https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-jdbc`] adapter for Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドはMavenプロジェクトを生成し、 `elytron-security-jdbc` エクステンションをインポートします。 link:https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-jdbc`] Quarkusアプリケーション用のアダプターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `elytron-security-jdbc` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `elytron-security-jdbc` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-jdbc` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`elytron-security-jdbc` エクステンションは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store and we initialize the database with users and roles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのコンテキストでは、PostgreSQLをアイデンティティストアとして使用しており、ユーザーとロールでデータベースを初期化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environment ;-).  The `elytron-security-jdbc` offers a built-in bcrypt password mapper.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おそらく無用と思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください ;-)。 `elytron-security-jdbc` は組み込みの bcrypt パスワードマッパーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now configure the Elytron JDBC Realm.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、Elytron JDBC Realmを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-jdbc` extension requires at least one principal query to authenticate the user and its identity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`elytron-security-jdbc` エクステンションは、ユーザーとそのアイデンティティを認証するために、少なくとも一つのプリンシパルのクエリを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We define a parameterized SQL statement (with exactly 1 parameter) which should return the user's password plus any additional information you want to load.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーのパスワードと、ロードしたい追加情報を返却するパラメーター化されたSQL文(単一のパラメーター付)を定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We configure the password mapper with the position of the password field in the `SELECT` fields and other information like salt, hash encoding, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`SELECT` フィールドのパスワードフィールドの位置や、ソルト、ハッシュエンコードなどの情報を使って、パスワードマッパーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `attribute-mappings` to bind the `SELECT` projection fields (ie. `u.role` here) to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`attribute-mappings` を使用して、 `SELECT` の投影フィールド(例:ここでは `u.role` )をターゲットの Principal 表現属性にバインドしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `principal-query` configuration all the `index` properties start at 1 (rather than 0).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`principal-query` の設定では、 `index` のプロパティーはすべて 1 から始まります (0 ではなく)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高度な設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide only covered an easy use case, the extension offers multiple datasources, multiple principal queries configuration as well as a bcrypt password mapper.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、簡単な使用例のみを取り上げていますが、このエクステンションは複数のデータソース、複数のプリンシパルクエリの設定、および bcrypt パスワードマッパーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=postgresql quarkus.datasource.username=quarkus quarkus.datasource.password=quarkus quarkus.datasource.jdbc.url=jdbc:postgresql:multiple-data-sources-users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=postgresql quarkus.datasource.username=quarkus quarkus.datasource.password=quarkus quarkus.datasource.jdbc.url=jdbc:postgresql:multiple-data-sources-users</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.permissions.db-kind=postgresql quarkus.datasource.permissions.username=quarkus quarkus.datasource.permissions.password=quarkus quarkus.datasource.permissions.jdbc.url=jdbc:postgresql:multiple-data-sources-permissions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.permissions.db-kind=postgresql quarkus.datasource.permissions.username=quarkus quarkus.datasource.permissions.password=quarkus quarkus.datasource.permissions.jdbc.url=jdbc:postgresql:multiple-data-sources-permissions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.security.jdbc.enabled=true quarkus.security.jdbc.principal-query.sql=SELECT u.password FROM test_user u WHERE u.username=? quarkus.security.jdbc.principal-query.clear-password-mapper.enabled=true quarkus.security.jdbc.principal-query.clear-password-mapper.password-index=1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.security.jdbc.enabled=true quarkus.security.jdbc.principal-query.sql=SELECT u.password FROM test_user u WHERE u.username=? quarkus.security.jdbc.principal-query.clear-password-mapper.enabled=true quarkus.security.jdbc.principal-query.clear-password-mapper.password-index=1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.security.jdbc.principal-query.roles.sql=SELECT r.role_name FROM test_role r, test_user_role ur WHERE ur.username=? AND ur.role_id = r.id quarkus.security.jdbc.principal-query.roles.datasource=permissions quarkus.security.jdbc.principal-query.roles.attribute-mappings.0.index=1 quarkus.security.jdbc.principal-query.roles.attribute-mappings.0.to=groups</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.security.jdbc.principal-query.roles.sql=SELECT r.role_name FROM test_role r, test_user_role ur WHERE ur.username=? AND ur.role_id = r.id quarkus.security.jdbc.principal-query.roles.datasource=permissions quarkus.security.jdbc.principal-query.roles.attribute-mappings.0.index=1 quarkus.security.jdbc.principal-query.roles.attribute-mappings.0.to=groups</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.  It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used to fan out notifications to end users using mobile push, SMS and email.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Simple Notification Service (SNS)は、高可用性の、フルマネージドのpub/subメッセージングサービスです。高スループットでプッシュベースの多対多のメッセージングのためのトピックを提供します。メッセージは、Amazon SQSキュー、AWS Lambda関数、HTTP/S webhooksなどの並列処理のために、多数のサブスクライバーエンドポイントに送信することができます。さらに、SNSを利用して、モバイルプッシュ、SMS、メールを利用して、エンドユーザーへの通知をファンアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about SNS at https://aws.amazon.com/sns/[the Amazon SNS website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SNSについての詳しい情報は link:https://aws.amazon.com/sns/[Amazon SNSウェブサイト] に載っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SNSエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use SNS locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスを利用してローカルとAWS上でSNSを利用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, Docker for your system to run SNS locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションで、テスト用にローカルでSNSを実行するためにシステムにDockerがインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with SNS is to run a local instance as a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SNSを使い始める最も簡単な方法は、ローカルインスタンスをコンテナーとして実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a SNS instance that is accessible on port `8009`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ポート `8009` でアクセス可能な SNS インスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a SNS topic using AWS CLI and store in `TOPIC_ARN` environment variable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS CLIを使ってSNSトピックを作成し、 `TOPIC_ARN` 環境変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can send emails using an SMTP server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがSMTPサーバーを使用して電子メールを送信する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The SMTP hostname, port and credentials, and an email address</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SMTPホスト名、ポート、資格情報、および電子メール アドレス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 1.8+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to see how you can send emails from a Quarkus application.  It covers simple emails, attachments, inlined attachments, the reactive and imperative APIs...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションからメールを送信する方法を見ていきます。シンプルな電子メール、添付ファイル、インラインの添付ファイル、リアクティブ型と命令型のAPIをカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have an existing project, add the `mailer` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のプロジェクトがある場合は、 `mailer` エクステンションを追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メーラーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus mailer is using SMTP. In the `src/main/resources/application.properties` file, you need to configure the host, port, username, password as well as the other configuration aspect.  Note that the password can also be configured using system properties and environment variables.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのメーラーはSMTPを使用しています。 `src/main/resources/application.properties` ファイルでは、ホスト、ポート、ユーザー名、パスワードだけでなく、他の設定面も設定する必要があります。パスワードは、システムのプロパティーや環境変数を使って設定することもできることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example using _sendgrid_:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは _sendgridを_ 使用した例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about the Mailer extension configuration please refer to the &lt;&lt;configuration-reference, Configuration Reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メーラーエクステンション設定の詳細については、 link:#configuration-reference[設定リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending simple emails</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単なメールの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a JAX-RS resource, or in a bean, you can inject the mailer as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSリソース内、またはBean内では、以下のようにmailerを注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 APIs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>APIは2つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.mailer.Mailer` provides the imperative (blocking and synchronous) API;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mailer.Mailer` は、命令型 (ブロッキングと同期)APIを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.mailer.ReactiveMailer` provides the reactive (non-blocking and asynchronous) API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mailer.ReactiveMailer` はリアクティブ型 (ノンブロッキングで非同期の) API を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The two APIs are equivalent feature-wise. Actually the `Mailer` implementation is built on top of the `ReactiveMailer` implementation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つのAPIは機能的には同等です。実際には `Mailer` の実装は `ReactiveMailer` の実装の上に構築されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send a simple email, proceed as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単なメールを送信するには、以下のように進めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can use the `Mailer` in a JAX-RS endpoint as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、JAX-RS のエンドポイントでは `Mailer` を以下のように使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With such a JAX-RS resource, you can check that everything is working with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなJAX-RSリソースがあれば、すべてが動作していることを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can create new `io.quarkus.mailer.Mail` instances from the constructor or from the `Mail.withText` and `Mail.withHtml` helper methods. The `Mail` instance lets you add recipients (to, cc, or bcc), set the subject, headers, sender (from) address...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンストラクタ、または `Mail.withText` と `Mail.withHtml` ヘルパーメソッドから、新しい `io.quarkus.mailer.Mail` インスタンスを作成できます。 `Mail` インスタンスでは、受信者 (to, cc, bcc) の追加、件名、ヘッダ、送信者 (from) アドレスの設定などを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also send several `Mail` objects in one call:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一度の呼び出しで複数の `Mail` オブジェクトを送信することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending attachments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添付ファイルの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To send attachment, just use the `addAttachment` methods on the `io.quarkus.mailer.Mail` instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添付ファイルを送信するには、 `io.quarkus.mailer.Mail` インスタンスの `addAttachment` メソッドを使用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attachments can be created from raw bytes (as shown in the snippet) or files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>添付ファイルは、(スニペットに示すように)生のバイトから作成することも、ファイルから作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending HTML emails with inlined attachments</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インラインの添付ファイル付きのHTMLメールの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending HTML email, you can add inlined attachments.  For example, you can send an image with your email, and this image will be displayed in the mail content. If you put the image file into resources folder, you should specify the full path to the file. "e.g." "META-INF/resources/quarkus-logo.png" otherwise quarkus will lookup in the root folder of the project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTMLメールを送信する際に、インラインの添付ファイルを追加することができます。例えば、メールに画像を添付して送信すると、この画像がメールの内容に表示されます。画像ファイルをリソースフォルダーに入れる場合は、ファイルのフルパスを指定する必要があります。"例" "META-INF/resources/quarkus-logo.png" 層ではない場合は、quarkusはプロジェクトのルートフォルダーを検索します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the _content-id_ format and reference.  By spec, when you create the inline attachment, the content-id must be structured as follows: `&lt;id@domain&gt;`.  If you don't wrap your content-id between `&lt;&gt;`, it is automatically wrapped for you.  When you want to reference your attachment, for instance in the `src` attribute, use `cid:id@domain` (without the `&lt;` and `&gt;`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_content-id の_ 形式と参照に注意してください。仕様上、インライン添付ファイルを作成する際には、content-idは以下のように構成する必要があります。 `&lt;id@domain&gt;` . `&lt;&gt;` の間に content-id を挟まない場合は、自動的にラップされます。添付ファイルを参照したい場合、例えば `src` 属性で参照したい場合は `cid:id@domain` を使用してください( `&lt;` と `&gt;` は使用しないでください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing email sending</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メール送信のテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because it is very inconvenient to send emails during development and testing, you can set the `quarkus.mailer.mock` boolean configuration to `true` to not actually send emails but print them on stdout and collect them in a `MockMailbox` bean instead.  This is the default if you are running Quarkus in `DEV` or `TEST` mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発中やテスト中にメールを送信するのは非常に不便なので、 `quarkus.mailer.mock` のブール設定を `true` に設定して、実際にはメールを送信せずに標準出力に印刷して、代わりに `MockMailbox` Beanに収集することができます。これは、 `DEV` または `TEST` モードでQuarkusを実行している場合のデフォルトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then write tests to verify that your emails were sent, for example, by a REST endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、テストを書いて、例えばRESTエンドポイントでメールが送信されたかどうかを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the Gmail SMTP server, first create a dedicated password in `Google Account &gt; Security &gt; App passwords` or go to https://myaccount.google.com/apppasswords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GmailのSMTPサーバーを利用する場合は、まず、 `Google Account &gt; Security &gt; App passwords` で専用のパスワードを作成するか、 https://myaccount.google.com/apppasswords に行きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When done, you can configure your Quarkus application by adding the following properties to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完了したら、 `application.properties` .Quarkusアプリケーションに以下のプロパティーを追加して、Quarkusアプリケーションを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With TLS:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TLSを利用する場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or with SSL:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SSLを利用する場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL with native executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルでSSLを使用する場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that if you enable SSL for the mailer and you want to build a native executable, you will need to enable the SSL support.  Please refer to the native-and-ssl-guide.html[Using SSL With Native Executables] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メーラーのSSLを有効にして、ネイティブ実行ファイルをビルドしたい場合は、SSLサポートを有効にする必要がありますのでご注意ください。詳しくは、native-and-ssl-guide.html[Using SSL With Native Executables]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the underlying Vert.x Mail Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基盤となる Vert.x メールクライアントの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Mailer is implemented on top of the https://vertx.io/docs/vertx-mail-client/java/[Vert.x Mail Client], providing an asynchronous and non-blocking way to send emails.  If you need fine control on how the mail is sent, for instance if you need to retrieve the message ids, you can inject the underlying client, and use it directly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Mailerは、 link:https://vertx.io/docs/vertx-mail-client/java/[Vert.xメールクライアント] の上に実装されており、非同期でノンブロッキングな方法でメールを送信することができます。メールの送信方法を細かく制御する必要がある場合、例えばメッセージのIDを取得する必要がある場合などの場合は、基礎となるクライアントを注入して直接使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Three API flavors are exposed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>3つのAPIフレーバーが公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Axle client (`io.vertx.axle.ext.mail.MailClient`), using `CompletionStage` and Reactive Streams `Publisher`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CompletionStage` と Reactive Streams を使用する `Publisher`Axle クライアント ( `io.vertx.axle.ext.mail.MailClient` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the RX Java 2 client (`io.vertx.reactivex.ext.mail.MailClient`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RX Java 2 クライアント ( `io.vertx.reactivex.ext.mail.MailClient` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the bare client (`io.vertx.ext.mail.MailClient`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアクライアント ( `io.vertx.ext.mail.MailClient` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the link:using-vertx.html[Using Vert.x guide] for further details about these different APIs and how to select the most suitable for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの異なる API の詳細と、あなたに最も適した API を選択する方法については、 link:using-vertx.html[Using Vert.x ガイド] を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The retrieved `MailClient` is configured using the configuration key presented above.  You can also create your own instance, and pass your own configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>取得した `MailClient` は、上記で提示した設定キーを使用して設定します。また、独自のインスタンスを作成し、独自の設定を渡すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can send emails from a Quarkus application.  The _mailer_ extension works in JVM and native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションからメールを送信する方法を紹介しました。 _mailer_ エクステンションは、JVMとネイティブモードで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mailer Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メーラー設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Identity and Access Management (IAM) enables users to manage access to AWS services and resources securely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Identity and Access Management(IAM)は、ユーザーがAWSのサービスやリソースへのアクセスを安全に管理できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about IAM at https://aws.amazon.com/iam/[the Amazon IAM website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://aws.amazon.com/iam/[アマゾンのIAMのサイト]を見てみると、IAMについての詳しい情報が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The IAM extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IAMエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x]をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to allow HTTP clients to invoke your Funqy functions on Google Cloud Functions, Quarkus allows you to expose multiple Funqy functions through HTTP deployed as one Google Cloud Function.  This approach does add overhead over the regular Funqy Google Cloud Function integration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP クライアントが Google Cloud Function 上で Funqy 関数を呼び出すことができるようにする場合、Quarkus では、1 つの Google Cloud Function としてデプロイされた HTTP を通じて複数の Funqy 関数を公開することができます。なお、このアプローチは、通常の Funqy Google Cloud Function の統合よりもオーバーヘッドが増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the link:gcp-functions-http[Google Cloud Functions Http Guide].  It walks through using a variety of HTTP frameworks on Google Cloud Functions, including Funqy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:gcp-functions-http[Google Cloud Functions Http Guide] に従ってください。これは、Google Cloud Functions 上で、Funqy を含むさまざまな HTTP フレームワークを使用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + Google Cloud Functions binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Route link:gcp-functions-http[support] instead.  They also work with Quarkus and Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy HTTP + Google Cloud Functions バインディングは HTTP 上の REST の代わりではありません。Funqy は多くの異なるプロトコルや関数プロバイダーを横断してポータブルである必要があるため、HTTP バインディングは非常にミニマムであり、リンクのような REST 機能やキャッシュコントロールや条件付きGETのような HTTP 機能を活用する機能を失うことになります。代わりに、Quarkus の JAX-RS、Spring MVC、または Vert.x Web Reactive Route の link:gcp-functions-http[サポート] を使用することを検討するとよいでしょう。また、Quarkus や Google Cloud Functions とも連携しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond generating a Google Cloud Functions project that is covered in the link:gcp-functions-http[Google Cloud Functions HTTP Guide], there's also a quickstart for running Funqy HTTP on Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions link:gcp-functions-http[HTTP ガイド] で紹介されている Google Cloud Functions プロジェクトを生成するものだけでなく、Google Cloud Functions 上で Funqy HTTP を実行するためのクイックスタートもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-google-cloud-functions-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-google-cloud-functions-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このソリューションは `funqy-google-cloud-functions-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-google-cloud-functions-http-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the code and more importantly nothing Google Cloud specific.  Funqy functions can be deployed to many different environments and Google Cloud Functions is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードには何も特別なものはありませんし、もっと重要なのは Google Cloud に特化したものは何もありません。Funqy 関数はさまざまな環境にデプロイすることができ、Google Cloud Functions もその一つです。Java のコードは、実は {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]と  全く同じコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The steps to get this quickstart running are exactly the same as defined in the link:gcp-functions-http[Google Cloud Functions HTTP Guide].  This differences are that you are running from a quickstart and the Maven dependencies are slightly different.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクイックスタートを実行するための手順は、link:gcp-functions-http[Google Cloud Functions HTTP Guide] で定義されているものと全く同じです。この違いは、クイックスタートから実行していることと、Maven の依存関係が若干異なることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-funqy-http&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-google-cloud-functions-http&lt;/artifactId&gt;
        &lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-funqy-http&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-google-cloud-functions-http&lt;/artifactId&gt;
        &lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable fails on macOS with `error: unknown type name 'uint8_t'`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>macOS でのネイティブ実行ファイルが `error: unknown type name 'uint8_t'` で失敗する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your macOS has the wrong `*.h` files compared to the OS and no gcc compilation will work.  This can happen when you migrate from versions of the OS.  See https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お使いの macOS には、その OS とは異なる `*.h` ファイルがあるため、gcc コンパイルが動作しません。この問題は、その OS の別のバージョンから移行したときに起こる可能性があります。 https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is to</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>解決策は、以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reinstall XCode for good measure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>念のため Xcode を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>generally reinstall your brew dependencies with native compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常は、ネイティブコンパイルで brew の依存関係を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable should work now.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、実行ファイルが動作するようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.liquibase.org/[Liquibase] is an open source tool for database schema change management.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.liquibase.org/[Liquibase] はデータベーススキーマ変更管理のためのオープンソースツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Liquibase as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、このガイドで説明するように、Liquibaseを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start using Liquibase with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase をプロジェクトで使い始めるためには、以下のことを行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your changeLog to the `{change-log}` file as you usually do with Liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase で通常行うように、変更ログを `{change-log}` ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Liquibase` object and run your migration as you normally do.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`migrate-at-start` オプションを有効にしてスキーマを自動的に移行するか、 `Liquibase` オブジェクトをインジェクトして通常通りにマイグレーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Liquibase extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibaseエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Liquibase to manage the schema.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibaseのサポートは、Quarkusのデータソース設定に依存しています。この設定は、デフォルトのデータソースだけでなく、すべての link:#multiple-datasources[名前付きデータソース] 用にカスタマイズすることができます。まず、Liquibaseがスキーマを管理できるようにするために、 `{config-file}` ファイルにデータソース設定を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a changeLog file to the default folder following the Liquibase naming conventions: `{change-log}` The yaml, json, xml and sql changeLog file formats are also supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase の命名規則に従って、デフォルトのフォルダーに changeLog ファイルを追加します: `{change-log}` yaml, json, xml, sql changeLog ファイル形式もサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Liquibase's update method according to your config:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでアプリケーションを起動することが出来るようになり、Quarkusはあなたの設定に従ってLiquibaseの更新メソッドを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension provides a factory to initialize a Liquibase instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエクステンションは、Liquibaseインスタンスを初期化するためのファクトリーを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Quarkus liquibase factory if you want to use the liquibase methods directly</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibaseメソッドを直接使用したい場合は、QuarkusのLiquibaseファクトリーをインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase can be configured for multiple datasources.  The Liquibase properties are prefixed exactly the same way as the named datasources, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liquibase は複数のデータソースに対して設定することができます。Liquibase のプロパティーは、例えば、名前のついたデータソースと全く同じように接頭辞が付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.liquibase.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーに余分なビットがあることに注意してください。構文は以下の通りです。 `quarkus.liquibase.[optional name.][datasource property]` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Liquibase is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定をしないと、Liquibaseはデフォルトの設定で各データソースに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Liquibase` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `Liquibase` オブジェクトを直接使いたい場合は、以下のように注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enabled the `quarkus.liquibase.migrate-at-start` property, by the time you use the Liquibase instance, Quarkus will already have run the migrate operation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.liquibase.migrate-at-start` プロパティーを有効にした場合、Liquibase インスタンスを使用する時点で、Quarkus はすでにマイグレーション操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Liquibase for named datasources using the Quarkus `LiquibaseDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus `LiquibaseDataSource` 修飾子を使用して、指定されたデータソースに Liquibase を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Liquibase for named datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指定されたデータソースに Liquibase を注入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List of applied or not applied liquibase ChangeSets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>適用された、または適用されていない liquibase ChangeSets のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Introduction to Contexts and Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - コンテキストと依存性注入(CDI)の紹介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本原理について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OK. Let's start simple. What is a bean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OK、簡単なことから始めましょう。Beanとは何でしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanは _コンテナーで管理された_ オブジェクトです。依存性の注入、ライフサイクルコールバック、インターセプターなどの基本的なサービスのセットをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wait a minute. What does "container-managed" mean?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ちょっと待ってください。「コンテナーで管理された」とはどういう意味ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simply put, you don't control the lifecycle of the object instance directly.  Instead, you can affect the lifecycle through declarative means, such as annotations, configuration, etc.  The container is the _environment_ where your application runs.  It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単に言えば、オブジェクトインスタンスのライフサイクルを直接制御することはできません。その代わりに、アノテーションや設定などの宣言的な手段でライフサイクルに影響を与えることができます。コンテナーはアプリケーションが動作する _環境_ です。コンテナーは、Beanのインスタンスを作成したり破棄したり、指定されたコンテキストにインスタンスを関連付けたり、他のBeanに注入したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is it good for?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何に使うと適切ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An application developer can focus on the business logic rather than finding out "where and how" to obtain a fully initialized component with all of its dependencies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション開発者は、「どこで、どのように」ではなく、ビジネスロジックに集中して、すべての依存関係を持つ完全に初期化されたコンポーネントを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_制御の反転_ (Inversion of Control, IoC )というプログラミングの原理を聞いたことがあると思います。依存性注入はIoCの実装技術の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several kinds of beans.  The most common ones are class-based beans:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanにはいくつかの種類があります。一番多いのは、クラスベースのBeanです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Bean Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなBeanの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all other beans that inject `Translator`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはスコープアノテーションです。これはコンテナーに、Beanのインスタンスをどのコンテキストに関連付けるかを伝えます。この特定のケースでは、 *単一のBeanインスタンス* がアプリケーション用に作成され、 `Translator` の注入を行う他の全てのBeanによって使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはフィールド注入ポイントです。 `Translator` が `Dictionary` Beanに依存していることをコンテナーに伝えます。マッチするBeanがない場合、ビルドは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics. We will talk about &lt;&lt;interceptors,interceptors&gt;&gt; later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはインターセプター結合アノテーションです。この場合、アノテーションは MicroProfile Metrics に由来します。関連するインターセプターは呼び出しをインターセプトし、関連するメトリクスを更新します。 &lt;&lt;interceptors,インターセプター&gt;&gt;については後述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nice. How does the dependency resolution work? I see no names or identifiers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いいですね。依存関係の解決方法はどのように動作しますか?名前も識別子も見当たりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a good question.  In CDI the process of matching a bean to an injection point is *type-safe*.  Each bean declares a set of bean types.  In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.  Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.  We'll talk about qualifiers later.  For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>良い質問ですね。CDIでは、Beanをインジェクションポイントにマッチングするプロセスは *タイプセーフ* です。各Beanは、Beanタイプのセットを宣言します。上の例では、 `Translator` Beanには、 `Translator` と `java.lang.Object` の 2 つのBeanタイプがあります。その後、Beanが _必要な型_ にマッチするBean型を持ち、 _必要な_ すべての _修飾子を_ 持っている場合、Beanはインジェクションポイントに代入可能です。この後、修飾子について説明します。今のところ、上記のBeanが `Translator` と `java.lang.Object` のタイプのインジェクションポイントに代入可能であることを知っていれば十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hm, wait a minute. What happens if multiple beans declare the same type?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ふむ、ちょっと待ってください。複数のBeanが同じ型を宣言した場合はどうなるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.  If none is assignable the build fails with `UnsatisfiedResolutionException`.  If multiple are assignable the build fails with `AmbiguousResolutionException`.  This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなルールがあります: *正確に1つのBeanがインジェクションポイントに割り当て可能でなければならず、そうでなければビルドは失敗します。* 割り当て可能なBeanがない場合、ビルドは `UnsatisfiedResolutionException` で失敗します。複数のBeanが割り当て可能な場合、ビルドは `AmbiguousResolutionException` で失敗します。これは非常に便利です。コンテナーがどのインジェクションポイントに対しても明確な依存関係を見つけることができない場合、アプリケーションは早く失敗するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your can use programmatic lookup via `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.enterprise.inject.Instance` を通じてプログラム的なルックアップを使用して、実行時に曖昧さを解決したり、指定された型を実装しているすべてのBeanを反復処理したりすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このインジェクションポイントは、 `Dictionary`  型を実装した複数のBeanがあっても、曖昧な依存関係にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.inject.Instance` extends `Iterable`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.enterprise.inject.Instance` は `Iterable` を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I use setter and constructor injection?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セッターやコンストラクタのインジェクションは使えますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, you can.  In fact, in CDI the "setter injection" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window="_blank"].  Initializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、できます。実際には、CDIでは「セッターインジェクション」は、より強力な link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[イニシャライザメソッド, window="_blank"] に取って代わられています。イニシャライザは複数のパラメーターを受け入れることができ、JavaBeanの命名規則に従う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initialized and Constructor Injection Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初期化とコンストラクタのインジェクション例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the absence of no-args constructor and "add" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one constructor present.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはコンストラクタのインジェクションです。実際には、このコードは通常のCDI実装では動作しません。通常のスコープを持つBeanは常にno-argsコンストラクタを宣言しなければならず、Beanのコンストラクタは `@Inject`  でアノテーションされなければなりません。しかし、Quarkusでは、no-argsコンストラクタが存在しないことを検出し、バイトコードに直接「追加」します。また、コンストラクタが1つしかない場合は、 `@Inject`  を追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer method must be annotated with `@Inject`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イニシャライザメソッドには `@Inject`  をアノテーションしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer may accept multiple parameters - each one is an injection point.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イニシャライザは複数のパラメーターを受け付けることができ、それぞれがインジェクションポイントとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You talked about some qualifiers?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>修飾子の話をしましたか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window="_blank"] are annotations that help the container to distinguish beans that implement the same type.  As we already said a bean is assignable to an injection point if it has all the required qualifiers.  If you declare no qualifier at an injection point the `@Default` qualifier is assumed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[修飾子, window="_blank"] は、コンテナーが同じ型を実装したBeanを区別するのに役立つアノテーションです。既に述べたように、Beanは必要な修飾子をすべて持っていれば、インジェクションポイントに割り当てることができます。インジェクションポイントで修飾子を宣言しない場合は、 `@Default` の修飾子が想定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@javax.inject.Qualifier` meta-annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Qualifier型は、 `@Retention(RUNTIME)` として定義された Java アノテーションで、 `@javax.inject.Qualifier` メタアノテーションでアノテーションされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>修飾子の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanの修飾子は、Beanクラスやプロデューサのメソッドやフィールドに修飾子タイプをアノテーションすることで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean With Custom Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタム修飾子を持つ Bean の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Superior`  は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[修飾子アノテーション, window=_blank]です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このBeanは `@Inject @Superior Translator`  と `@Inject @Superior SuperiorTranslator`  には割り当てられますが、 `@Inject Translator`  には割り当てられません。その理由は、 `@Inject Translator`  はタイプセーフ解決の際に自動的に `@Inject @Default Translator`  に変換されるからです。また、私たちの `SuperiorTranslator`  は `@Default`  を宣言していないので、元の `Translator`  Beanだけが代入可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks good. What is the bean scope?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>良いですね。Beanスコープとは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanのスコープはインスタンスのライフサイクルを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every bean has exactly one scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのBeanは、正確に1つのスコープを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What scopes can I actually use in my Quarkus application?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実際にQuarkusアプリケーションで使用できるスコープは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.enterprise.context.ConversationScoped` 以外の仕様で言及されているすべてのビルトインスコープを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description   
//----------------------</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>説明   
//----------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.ApplicationScoped`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@javax.enterprise.context.ApplicationScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the &lt;&lt;client_proxies, client proxy&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単一のBeanインスタンスがアプリケーションに使用され、すべてのインジェクションポイント間で共有されます。 link:#client_proxies[インスタンス] は遅延的に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.inject.Singleton`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@javax.inject.Singleton`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like `@ApplicationScoped` except that no client proxy is used. The instance is created when an injection point that resolves to a @Singleton bean is being injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントプロキシーを使用しないことを除いて、 `@ApplicationScoped` と同じです。インスタンスは、@Singleton Beanに解決するインジェクションポイントがインジェクションされたときに生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.RequestScoped`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@javax.enterprise.context.RequestScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean instance is associated with the current _request_ (usually an HTTP request).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanインスタンスは、現在の _リクエスト_ (通常はHTTPリクエスト)に関連付けられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.Dependent`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@javax.enterprise.context.Dependent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a pseudo-scope. The instances are not shared and every injection point spawns a new instance of the dependent bean. The lifecycle of dependent bean is bound to the bean injecting it - it will be created and destroyed along with the bean injecting it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは疑似スコープです。インスタンスは共有されておらず、すべての注入ポイントは依存Beanの新しいインスタンスをスポーンします。依存Beanのライフサイクルは、それを注入するBeanに拘束されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.SessionScoped`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@javax.enterprise.context.SessionScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This scope is backed by a `javax.servlet.http.HttpSession` object. It's only available if the `quarkus-undertow` extension is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このスコープは `javax.servlet.http.HttpSession` オブジェクトによってバックアップされています。 `quarkus-undertow` エクステンションを使用している場合のみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There can be other custom scopes provided by Quarkus extensions. For example, `quarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのエクステンションによって提供される他のカスタムスコープもあります。例えば、 `quarkus-narayana-jta` は `javax.transaction.TransactionScoped` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` and `@Singleton` look very similar. Which one should I choose for my Quarkus application?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ApplicationScoped` と `@Singleton` は非常に似ているように見えます。Quarkusアプリケーションにはどれを選べばいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It depends ;-).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それは場合によりけりです ;-)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `@Singleton` bean has no &lt;&lt;client_proxies,client proxy&gt;&gt; and hence an instance is _created eagerly_ when the bean is injected. By contrast, an instance of an `@ApplicationScoped` bean is _created lazily_, i.e.  when a method is invoked upon an injected instance for the first time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Singleton` Beanは link:#client_proxies[クライアントプロキシー] を持たないので、Beanがインジェクトされるとインスタンスは _熱心に(eagerly)生成され_ ます。対照的に、 `@ApplicationScoped` Beanのインスタンスは _怠惰(lazily)に生成されます。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, client proxies only delegate method invocations and thus you should never read/write fields of an injected `@ApplicationScoped` bean directly.  You can read/write fields of an injected `@Singleton` safely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、クライアントプロキシーはメソッドの呼び出しを委譲するだけなので、注入された `@ApplicationScoped` Bean のフィールドを直接読み書きしてはいけません。注入された `@Singleton` のフィールドは安全に読み書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Singleton` should have a slightly better performance because the is no indirection (no proxy that delegates to the current instance from the context).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Singleton` はインダイレクトがない(コンテキストから現在のインスタンスをデリゲートするプロキシーがない)ため、パフォーマンスが若干向上するはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other hand, you cannot mock `@Singleton` beans using &lt;&lt;getting-started-testing.adoc#quarkus_mock,QuarkusMock&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一方、 link:getting-started-testing.html#quarkus_mock[QuarkusMockを] 使って `@Singleton` Beanをモックすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` beans can be also destroyed and recreated at runtime.  Existing injection points just work because the injected proxy delegates to the current instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ApplicationScoped` Beanは、実行時に破棄して再作成することもできます。既存のインジェクションポイントは、インジェクションされたプロキシーが現在のインスタンスにデリゲートするので、単に機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, we recommend to stick with `@ApplicationScoped` by default unless there's a good reason to use `@Singleton`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>したがって、 `@Singleton` を使用する正当な理由がない限り、デフォルトで `@ApplicationScoped` を使用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I don't understand the concept of client proxies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントプロキシーの概念が理解できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window="_blank"] could be hard to grasp but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実際、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[クライアントプロキシー, window=_blank]は理解するのが難しいかもしれませんが、いくつかの有用な機能を提供します。クライアントプロキシーは基本的に、すべてのメソッド呼び出しをターゲットのBeanインスタンスに委譲するオブジェクトです。これは `io.quarkus.arc.ClientProxy`  を実装し、Bean クラスを拡張したコンテナー構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with non-contextual or stale data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントプロキシーはメソッドの呼び出しをデリゲートするだけです。そのため、通常のスコープされたBeanのフィールドを読み書きしてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generated Client Proxy Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたクライアントプロキシーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[contextual instance, window="_blank"] of the `Translator` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Translator_ClientProxy`  インスタンスは、 `Translator`  Beanの link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[コンテキストインスタンス, window=_blank]への直接参照の代わりに、常に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies allow for:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントプロキシーは、以下のことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy instantiation - the instance is created once a method is invoked upon the proxy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遅延インスタンス化 - メソッドがプロキシーに呼び出されるとインスタンスが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ability to inject a bean with "narrower" scope to a bean with "wider" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>「狭い」スコープのBeanを「広い」スコープのBeanに注入する機能、すなわち、 `@RequestScoped`  Beanを `@ApplicationScoped`  Beanに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes it's inevitable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係グラフの円形の依存関係。循環的な依存関係を持つことは、しばしば再設計を検討すべきであることを示していますが、時には避けられないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まれなケースでは、手動でBeanを破棄するのが現実的です。直接参照を注入すると、古くなったBeanのインスタンスになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OK. You said that there are several kinds of beans?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そうですか。Beanは何種類かあるんですよね?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes. In general, we distinguish:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、一般的には以下に区別しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサーメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer fields</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサーフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>合成Beanは通常、エクステンションによって提供されます。そのため、このガイドではそれらを取り上げません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサ・メソッドとフィールドは、Beanのインスタンス化を追加で制御する必要がある場合に便利です。また、サードパーティのライブラリを統合する際に、クラスソースを制御できず、追加のアノテーションなどを追加できない場合にも便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producers Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーは,フィールドアノテーションを分析して,Beanのメタデータを構築します。 _型_ は,Beanの型の集合を構築するために使用されます。この場合、 `double`  と `java.lang.Object` .スコープアノテーションは宣言されていないので、デフォルトは `@Dependent` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will read this field when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーは、Beanのインスタンスを作成するときにこのフィールドを読みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In this case, it will be `List&lt;String&gt;`, `Collection&lt;String&gt;`, `Iterable&lt;String&gt;` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーは,メソッドのアノテーションを解析して,Beanのメタデータを構築します。戻り値の _型_ は、Bean型のセットを構築するために使用されます。この場合、 `List&lt;String&gt;` と `Collection&lt;String&gt;`、 `Iterable&lt;String&gt;`、 `java.lang.Object` となります。スコープアノテーションは宣言されていないので、デフォルトは `@Dependent`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will call this method when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーは、Beanのインスタンスを作成する際にこのメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサーについては他にもあります。修飾子を宣言したり、プロデューサーメソッドのパラメーターに依存性を注入したりすることができます。プロデューサについては、例えば link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld, window=_blank] のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OK, injection looks cool. What other services are provided?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OK、インジェクションは便利ですね。他にはどんなサービスが提供されていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライフサイクルコールバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanクラスは、ライフサイクル `@PostConstruct`  と `@PreDestroy`  コールバックを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライフサイクルコールバックの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコールバックは、Beanインスタンスがサービスに投入される前に呼び出されます。ここでいくつかの初期化を行うのが安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコールバックは、Beanインスタンスが破棄される前に呼び出されます。ここでいくつかのクリーンアップタスクを実行しても安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a good practice to keep the logic in the callbacks "without side effects", i.e. you should avoid calling other beans inside the callbacks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コールバック内のロジックを「副作用なし」に保つこと、つまり、コールバック内で他のBeanを呼び出すことは避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターは、横断的な問題をビジネス・ロジックから分離するために使用されます。基本的なプログラミングモデルとセマンティクスを定義した Java Interceptors という別の仕様があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Interceptor Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなインターセプターの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、インターセプターをBeanにバインドするために使用されるインターセプターバインディングアノテーションです。Beanクラスに `@Logged`  をアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Priority`  はインターセプターを有効にし、インターセプターの順序に影響を与えます。優先度の値が小さいインターセプターが最初に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Marks an interceptor component.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターコンポーネントをマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interceptor instance may be the target of dependency injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターインスタンスは、依存性注入の対象となる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AroundInvoke` denotes a method that interposes on business methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AroundInvoke`  とは、ビジネスの方法に口出しする方法を指します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターチェーンの次のインターセプターに進むか、インターセプターされたビジネスメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプタのインスタンスは、インターセプトするBeanのインスタンスに依存するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events and Observers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントとオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event payload.  The optional qualifiers act as topic selectors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanは、完全に分離された方法で相互作用するために、イベントを生成したり消費したりすることもできます。任意の Java オブジェクトをイベントのペイロードとして使用できます。オプションの修飾子は、トピックセレクタとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Event Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなイベントの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.event.Event` is used to fire events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.enterprise.event.Event`  は、イベントの火付けに使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fire the event synchronously.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントを同期的に発生させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is notified when a `TaskCompleted` event is fired.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、 `TaskCompleted`  イベントが発生したときに通知されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベント/オブザーバーの詳細については、 link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docsを, window=_blank]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we've covered some of the basic topics of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.  However, a full CDI implementation is not used under the hood.  Quarkus only implements a subset of the CDI features - see also &lt;&lt;cdi-reference.adoc#supported_features,the list of supported features&gt;&gt; and &lt;&lt;cdi-reference.adoc#limitations,the list of limitations&gt;&gt;.  On the other hand, there are quite a few &lt;&lt;cdi-reference#nonstandard_features,non-standard features&gt;&gt; and &lt;&lt;cdi-reference.adoc#build_time_apis,Quarkus-specific APIs&gt;&gt;.  We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本的なトピックをいくつか取り上げました。ただし、CDIの完全な実装が使用されている訳ではありません。QuarkusはCDI link:cdi-reference.html#supported_features[機能]のサブセットのみを実装しています。一方で、 link:cdi-reference.html#nonstandard_features[非標準の機能]や link:cdi-reference.html#build_time_apis[Quarkus固有のAPI]もかなりの数があります。私たちの努力は、将来的にビルド時指向の開発者スタックに向けてCDI仕様の革新を推進するものと信じています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus link:cdi-reference[CDI Reference Guide].  We also recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus固有の機能や制限について詳しく知りたい場合は、Quarkus link:cdi-reference[CDIリファレンスガイド]があります。また、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDIの仕様]や link:https://docs.jboss.org/weld/reference/latest/en-US/html/[Weldのドキュメント](WeldはCDIリファレンスインプリメンテーションです)を読んで、より複雑なトピックに精通することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy (JAX-RS), Undertow (servlet), Vert.x Web, link:funqy-http[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API]または link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST] APIのいずれかを使用して、お気に入りのJava HTTPフレームワークをAmazon Lambdaとしてデプロイできます。つまり、RESTEasy（JAX-RS）、Undertow（サーブレット）、Vert.x Web、 link:funqy-http[Funqy HTTP]、その他のQuarkusのHTTPフレームワークで書かれたマイクロサービスを、AWS Lambdaとしてデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Lambda を純粋な Java jar としてデプロイすることもできますし、プロジェクトをネイティブイメージにコンパイルしてデプロイすることで、より少ないメモリーフットプリントと起動時間を実現することもできます。また、統合により、 https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[AmazonのSAM framework] で使用できるSAMデプロイメントファイルも生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、ゲートウェイAPIごとに異なるエクステンションを用意しています。HTTP Gateway APIは、 `quarkus-amazon-lambda-http` のエクステンションで実装されています。REST Gateway APIは、 `quarkus-amazon-lambda-rest` のエクステンションで実装されています。どのGateway製品を使用すべきか迷っている場合は、Amazonが決断を助ける為に link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[素晴らしいガイド]を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、mavenのアーキタイプを介してJavaプロジェクトのサンプルを生成する方法を説明します。その後、既存のプロジェクトを Amazon Lambda で利用できるようにするために、プロジェクトの構造を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWSのすべてのツールをインストールすることは、おそらくこのガイドでは最も難しいことです。AWS CLIをインストールするためのすべての手順に従っていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Quarkus AWS Lambda maven project using our Maven Archetype.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven Archetypeを使用してQuarkus AWS Lambda Mavenプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the AWS Gateway HTTP API, generate your project with this script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS Gateway HTTP APIを使用する場合は、このスクリプトでプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the AWS Gateway REST API, generate your project with this script:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS Gateway REST APIを使用する場合は、このスクリプトでプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev-mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでコードがコンパイルされ、生成されたプロジェクト内に含まれるユニットテストが実行されます。ユニットテストは他のJavaプロジェクトと同じで、Amazonで実行する必要はありません。Quarkus dev-modeもこのエクステンションで利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build for native too, make sure you have GraalVM installed correctly and just add a `native` property to the build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ用にもビルドしたい場合は、GraalVMが正しくインストールされていることを確認し、 `native` プロパティーをビルドに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your Maven build: `-Dnative-image.docker-build=true`, or for Gradle: `--docker-build=true`.  This requires you to have docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非 Linux システムでビルドしている場合は、Amazon Lambda が linux バイナリーを必要とするため、quarkus に docker ビルドを使用するように指示するプロパティーを渡す必要があります。これは、このプロパティーを Maven ビルドに渡すことで行うことができます: `-Dnative-image.docker-build=true` , または Gradle の場合: `--docker-build=true` .ただし、この場合はローカルに docker がインストールされている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the quarkus lambda extension you are using.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドを実行すると、 quarkus lambda エクステンションで生成されるいくつかの追加ファイルがあります。これらのファイルはビルドディレクトリーにあります: mavenなら `target/` 、gradleなら `build/` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.jvm.yaml` - sam cli deployment script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.jvm.yaml` - SAM CLI デプロイメントスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.native.yaml` - sam cli deployment script for native</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.native.yaml` - ネイティブ用の SAM CLI デプロイメントスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires docker to be installed (see their install docs).  After you have built your maven project, execute this command</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS SAM CLIを使うと、ラップトップ上でLambdaをシミュレートした環境でローカルに実行することができます。このためにはdockerをインストールする必要があります(インストールドキュメントを参照してください)。mavenプロジェクトをビルドした後、以下のコマンドを実行してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start a docker container that mimics Amazon's Lambda's deployment environment.  Once the environment is started you can invoke the example lambda in your browser by going to</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでAmazonのLambdaのデプロイ環境を模したdockerコンテナーが起動します。環境が起動したら、ブラウザで以下を開くとサンプルの Lambda を実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールには、ラムダからの起動メッセージが表示されます。この特定のデプロイメントでは、JVM を起動し、純粋な Java として Lambda をロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての質問に答えると、 Lambda がデプロイされ、API Gatewayへの必要なフックが設定されます。すべてが正常にデプロイされると、マイクロサービスのルート URL がコンソールに出力されます。このような感じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Value` 属性は Lambda のルート URL です。これをブラウザにコピーして、最後に `hello` を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バイナリー型のレスポンスは自動的にbase64でエンコードされます。これは、生のバイトを返す `quarkus:dev` を使用した動作とは異なります。Amazon の API には、base64 エンコーディングを必要とする追加の制限があります。一般的に、クライアントコードは自動的にこのエンコーディングを処理しますが、特定のカスタムな状況では、手動でエンコーディングを管理する必要があるかもしれないことを認識しておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying a native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a native executable, you must build it with Graal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルをデプロイするには、Graalを使ってビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then test the executable locally with sam local</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、ローカルで sam local を使って実行ファイルをテストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy to AWS Lambda:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS Lambda へのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POM には `quarkus-amazon-lambda-http` エクステンション(AWS Gateway HTTP APIでデプロイしている場合) か `quarkus-amazon-lambda-rest` エクステンション( AWS Gateway REST APIでデプロイしている場合)が依存関係として含まれている以外に特別なことは何もありません。これらのエクステンションは Lambda のデプロイに必要なものをすべて自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated maven archetype `pom.xml`, the `quarkus-resteasy`, `quarkus-vertx-web`, and `quarkus-undertow` dependencies are all optional.  Pick which http framework(s) you want to use (JAX-RS, Vertx Web, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、少なくとも生成された maven のアーキタイプ `pom.xml` , `quarkus-resteasy` , `quarkus-vertx-web` , `quarkus-undertow` の依存関係はすべてオプションです。使用したい http フレームワーク (JAX-RS、Vertx Web、および/または Servlet) を選択し、他の依存関係を削除してデプロイを縮小します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine sam.yaml</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>sam.yaml を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.yaml` の構文はこのドキュメントの範囲を超えています。しかし、カスタムの `sam.yaml` デプロイメントファイルを作成しようとしている場合、幾つかの強調しなければならないことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初に注意することは、純粋なJavaラムダデプロイメントには特定のハンドラークラスが必要であるということです。 Lambdaハンドラー名は変更しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (JAX-RS, Servlet, etc.)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このハンドラは、ラムダランタイムと、使用しているQuarkus HTTPフレームワーク（JAX-RS、Servletなど）との間のブリッジとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブを利用する場合は、ネイティブのGraalVMデプロイメント用に設定する必要のある環境変数があります。 `sam.native.yaml` を見ると、次のことがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この環境変数は、QuarkusとAmazon Lambdaカスタムランタイム環境との間のいくつかの非互換性を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、AWS Gateway RESTAPIへのデプロイに固有のことが一つあります。そのAPIは、設定でどのメディアタイプがバイナリーであるかを明示的に指定しない限り、HTTPレスポンスボディはテキストであることを想定しています。より簡単にするために、QuarkusエクステンションはすべてのHTTP応答メッセージのバイナリー(ベース64)エンコーディングを強制します。 `sam.yaml` ファイルでは、すべてのメディアタイプがバイナリーであると仮定するようにAPI Gatewayを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injectable AWS Context Variables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注入可能なAWSコンテキスト変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Resteasy and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ResteasyとJAX-RSを使用している場合、JAX-RS `@Context` アノテーションを使用して、様々なAWS Context変数をJAX-RSリソースクラスに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS HTTP APIでは、AWS変数 `com.amazonaws.services.lambda.runtime.Context` および `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` を注入することができます。以下はその例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS REST APIでは、AWS変数 `com.amazonaws.services.lambda.runtime.Context` と `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext` を注入することができます。以下はその例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージをビルドしていて、Lambda で link:https://aws.amazon.com/xray[AWS X-Ray Tracing] を使いたい場合は、 `quarkus-amazon-lambda-xray` を依存関係として pom に含める必要があります。AWS X-Ray ライブラリは GraalVM との完全な互換性がないため、これを動作させるためにいくつかの統合作業をしなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming a gRPC Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC サービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC services can be injected in your application code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC サービスは、アプリケーションのコードに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC services requires the gRPC classes to be generated.  Place your `proto` files in `src/main/proto` and run `mvn compile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC サービスを消費するには、gRPC クラスを生成する必要があります。 `proto` ファイルを `src/main/proto` に置き、 `mvn compile` を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stubs and Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタブとインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC allows sending and receiving streams:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCでは、ストリームの送受信が可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Mutiny stub, you can interact with these as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyのスタブを使用すると、以下のようにこれらと対話することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアント設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each gRPC service you inject in your application, you can configure the following attributes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションにインジェクトする各gRPCサービスに対して、以下の属性を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable TLS, use the following configuration.  Note that all paths in the configuration may either specify a resource on the classpath (typically from `src/main/resources` or its subfolder) or an external file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TLS を有効にするには、以下の設定を使用します。構成内のすべてのパスは、クラスパス上のリソース (通常は `src/main/resources` またはそのサブフォルダーから) または外部ファイルのいずれかを指定することに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When SSL/TLS is configured, `plain-text` is automatically disabled.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SSL/TLSを設定すると、 `plain-text` は自動的に無効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TLS with Mutual Auth</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相互認証付きTLS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use TLS with mutual authentication, use the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相互認証付きのTLSを使用するには、以下の設定を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client Interceptors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントインターセプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can implement a gRPC client interceptor by implementing an `@ApplicationScoped` bean implementing `io.grpc.ClientInterceptor`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ApplicationScoped` `io.grpc.ClientInterceptor` Beanを実装することで、gRPC クライアントのインターセプターを実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the https://grpc.github.io/grpc-java/javadoc/io/grpc/ClientInterceptor.html[ClientInterceptor JavaDoc] to properly implement your interceptor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://grpc.github.io/grpc-java/javadoc/io/grpc/ClientInterceptor.html[ClientInterceptor JavaDoc] をチェックして、インターセプターを適切に実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have multiple client interceptors, you can order them by implementing the `javax.enterprise.inject.spi.Prioritized` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のクライアント・インターセプターがある場合、 `javax.enterprise.inject.spi.Prioritized` インターフェイスを実装することで、それらのインターセプターを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors with the highest priority are called first.  The default priority, used if the interceptor does not implement the `Prioritized` interface, is `0`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最高の優先度を持つインターセプターが最初に呼び出されます。インターセプターが `Prioritized` インターフェイスを実装していない場合に使用されるデフォルトの優先度は `0` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>having access to an Azure subscription. https://azure.microsoft.com/free/?WT.mc_id=opensource-quarkus-brborges[Get a free one here]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure サブスクリプションにアクセスできること。 link:https://azure.microsoft.com/free/?WT.mc_id=opensource-quarkus-brborges[無料のものを入手するには、ここをクリック] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will take as input a native application developed in the link:building-native-image[building native image guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、 link:building-native-image[ネイティブイメージのビルド] で開発されたネイティブアプリケーションを入力として受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you correctly followed the link:building-native-image[building native image guide], you should have a local container image named `quarkus-quickstart/getting-started`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:building-native-image[ネイティブイメージのビルド] に正しく従っていれば、 `quarkus-quickstart/getting-started` という名前のローカルコンテナーイメージがあるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus by default runs on port 8080, most Azure services expect web applications to be running on port 80. Before we continue, go back to your quickstart code and open the file `src/main/docker/Dockerfile.native`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusはデフォルトではポート 8080 で動作しますが、ほとんどのAzureサービスでは、ウェブアプリケーションがポート 80 で動作することを想定しています。続ける前に、クイックスタートコードに戻り、 `src/main/docker/Dockerfile.native`  を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change the last two commands in the `Dockerfile.native` file and make it read like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Dockerfile.native` ファイルの最後の 2 つのコマンドを変更して、以下のように読み込み可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can rebuild the docker image:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでdockerイメージをリビルドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test, run it by exposing port 80 into port 8080 in your host:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストのときは、自分のホストでポート80を8080に公開して実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your container image is now ready to run on Azure. Remember, the Quarkus application is mapped to run on port 80.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、コンテナーイメージをAzure上で実行する準備が整いました。Quarkusアプリケーションは、ポート80で実行するようにマッピングされていることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ease the user experience throughout this guide, it is better to have the Azure CLI installed and authenticated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイド全体を通してユーザー体験を容易にするために、Azure CLI をインストールして認証を受けた方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visit the https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest?WT.mc_id=opensource-quarkus-brborges[Azure CLI] installation page for instructions specific to your operating system.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お使いのオペレーティングシステムに固有の手順については、 link:https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest?WT.mc_id=opensource-quarkus-brborges[Azure CLI] のインストールページを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once installed, ensure you are authenticated:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インストールしたら、認証されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to deploy images hosted on Docker Hub, but this location by default leaves images accessible to anyone. To better protect your container images, this guide shows how to host your images on a private instance of the Azure Container Registry service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Docker Hub上にホストされたイメージをデプロイすることは可能ですが、この場所はデフォルトでは誰でもイメージにアクセスできる状態になっています。コンテナーイメージをよりよく保護するために、このガイドでは、Azure Container Registry サービスのプライベートインスタンス上でイメージをホストする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create an Azure Resource Group:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、Azure Resource Groupを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can create the ACR:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そうすれば、ACRを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, authenticate your local Docker installation with this container registry by running:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、このコンテナーレジストリーを実行して、ローカルのDockerインストールを認証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you've followed the build native image guide, you should have a local container image named `quarkus-quickstart/getting-started`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドネイティブイメージガイドに従っていれば、 `quarkus-quickstart/getting-started` という名前のローカルコンテナーイメージがあるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To upload this image to your ACR, you must tag and push the image under the ACR login server. To find the login server of the Azure Container Registry, run this command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このイメージをACRにアップロードするには、ACRログインサーバーの下にタグを付けてイメージをプッシュする必要があります。Azure Container Registryのログインサーバーを見つけるには、次のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To upload, now do:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アップロードするには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you should have your Quarkus container image on your Azure Container Registry. To verify, run the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この時点で、Azure Container Registry上にQuarkusコンテナーイメージがあるはずです。確認するには、次のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest way to start this container in the cloud is with the Azure Container Instances service. It simply creates a container on Azure infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコンテナーをクラウド上で起動する最もシンプルな方法は、Azure Container Instancesサービスです。これは、Azureインフラストラクチャ上にコンテナーを作成するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are different approaches for using ACI. Check the documentation for details. The quickest way to get a container up and running goes as it follows.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ACIを使用するためには、さまざまなアプローチがあります。詳細はドキュメントを確認してください。コンテナーを起動して稼働させるための最も手っ取り早い方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First step is to find the username and password for the admin, so that ACI can authenticate into ACR and pull the Docker image:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のステップは、ACIがACRに認証してDockerイメージをプルできるように、管理者のユーザー名とパスワードを見つけることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create the Docker instance on ACI pointing to your image on ACR:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ACR上のイメージを指すACI上にDockerインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command above, if run successfully, will give you the address of your container in the Cloud. Access your Quarkus application in the address displayed as output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記のコマンドの実行が成功すると、クラウド上のコンテナーのアドレスが表示されます。出力として表示されるアドレスでQuarkusアプリケーションにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information and details on ACR authentication and the use of service principals, follow this guide below and remember the Azure Container Registry `loginServer` and the image name of your Quarkus application now hosted on the ACR.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ACR認証とサービスプリンシパルの使用の詳細と詳細については、以下のガイドに従ってください。Azure Container Registry `loginServer` と、現在ACRでホストされているQuarkusアプリケーションのイメージ名を覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that this service does not provide scalability. A container instance is unique and does not scale.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このサービスはスケーラビリティを提供しないことを覚えておいてください。コンテナーインスタンスは単一であり、スケーラビリティを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also deploy the container image as a microservice in a Kubernetes cluster on Azure. To do that, follow this tutorial:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、コンテナーイメージをマイクロサービスとしてAzure上のKubernetesクラスターにデプロイすることもできます。そのためには、このチュートリアルに従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once deployed, the application will be running on whatever port is used to expose the service. By default, Quarkus apps run on port 8080 internally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイされると、アプリケーションは、サービスを公開するために使用されるポートであれば何でも実行されます。デフォルトでは、Quarkusアプリケーションは内部的にポート8080で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This service provides scalability out of the box for web applications. If more instances are required, it will provide a load-balancing automatically, plus monitoring, metrics, logging and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このサービスは、Webアプリケーションのスケーラビリティを提供します。より多くのインスタンスが必要な場合は、自動的に負荷分散を行い、監視、メトリクス、ロギングなどを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy your Quarkus Native container image to this service, follow this tutorial:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Nativeコンテナーイメージをこのサービスにデプロイするには、このチュートリアルに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[[quarkus-blaze-persistence_configuration]]link:#quarkus-blaze-persistence_configuration[Configuration property]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[[quarkus-blaze-persistence_configuration]]link:#quarkus-blaze-persistence_configuration[設定プロパティー]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.template-eager-loading]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.template-eager-loading[quarkus.blaze-persistence.template-eager-loading]`

[.description]
--
A boolean flag to make it possible to prepare all view template caches on startup. By default the eager loading of the view templates is disabled to have a better startup performance. Valid values for this property are `true` or `false`.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.template-eager-loading]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.template-eager-loading[quarkus.blaze-persistence.template-eager-loading]`

[.description]
—
スタートアップですべての表示テンプレートキャッシュを準備できるブールフラグ。デフォルトでは、スタートアップパフォーマンスを向上するため、表示テンプレートの一括読み込みが無効化されています。このプロパティーに使用できる値は、`true` または `false` です。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.default-batch-size]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.default-batch-size[quarkus.blaze-persistence.default-batch-size]`

[.description]
--
An integer value that defines the default batch size for entity view attributes. By default the value is 1 and can be overridden either via `com.blazebit.persistence.view.BatchFetch#size()` or by setting this property via `com.blazebit.persistence.view.EntityViewSetting#setProperty`.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.default-batch-size]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.default-batch-size[quarkus.blaze-persistence.default-batch-size]`

[.description]
—
エンティティー属性のデフォルトバッチサイズを定義する整数値。デフォルトでは、値は 1 で、`com.blazebit.persistence.view.BatchFetch#size()` または、 `com.blazebit.persistence.view.EntityViewSetting#setProperty`  からこのプロパティーを設定することで上書きできます。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.expect-batch-mode]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.expect-batch-mode[quarkus.blaze-persistence.expect-batch-mode]`

[.description]
--
A mode specifying if correlation value, view root or embedded view batching is expected. By default the value is `values` and can be overridden by setting this property via `com.blazebit.persistence.view.EntityViewSetting#setProperty`. Valid values are  
 - `values` 
 - `view_roots` 
 - `embedding_views`
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.expect-batch-mode]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.expect-batch-mode[quarkus.blaze-persistence.expect-batch-mode]`

[.description]
--
A mode specifying if correlation value, view root or embedded view batching is expected. By default the value is `values` and can be overridden by setting this property via `com.blazebit.persistence.view.EntityViewSetting#setProperty`. Valid values are  
 - `values` 
 - `view_roots` 
 - `embedding_views`
--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.eager-loading]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater.eager-loading[quarkus.blaze-persistence.updater.eager-loading]`

[.description]
--
A boolean flag to make it possible to prepare the entity view updater cache on startup. By default the eager loading of entity view updates is disabled to have a better startup performance. Valid values for this property are `true` or `false`.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.eager-loading]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater.eager-loading[quarkus.blaze-persistence.updater.eager-loading]`

[.description]
—
エンティティー表示アップデーターキャッシュをスタートアップで準備することを可能にするブールフラグ。デフォルトでは、スタートアップパフォーマンスを向上するために、エンティティー表示更新の一括読み込みが無効化されています。このプロパティーに使用できる値は、`true` または `false` です。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.disallow-owned-updatable-subview]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater.disallow-owned-updatable-subview[quarkus.blaze-persistence.updater.disallow-owned-updatable-subview]`

[.description]
--
A boolean flag to make it possible to disable the strict validation that disallows the use of an updatable entity view type for owned relationships. By default the use is disallowed i.e. the default value is `true`, but since there might be strange models out there, it possible to allow this. Valid values for this property are `true` or `false`.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.disallow-owned-updatable-subview]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater.disallow-owned-updatable-subview[quarkus.blaze-persistence.updater.disallow-owned-updatable-subview]`

[.description]
—
所有されている関係の更新可能なエンティティー表示タイプを使用できないようにする厳格な検証を無効にできるブール値のフラグ。デフォルトでは、できないように設定されています (`true`)。ただし、特殊な例も考えられるので、許可することも可能です。利用できるプロパティーの値は、`true` または `false` です。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.strict-cascading-check]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater.strict-cascading-check[quarkus.blaze-persistence.updater.strict-cascading-check]`

[.description]
--
A boolean flag to make it possible to disable the strict cascading check that disallows setting updatable or creatable entity views on non-cascading attributes before being associated with a cascading attribute. When disabled, it is possible, like in JPA, that the changes done to an updatable entity view are not flushed when it is not associated with an attribute that cascades updates. By default the use is enabled i.e. the default value is `true`. Valid values for this property are `true` or `false`.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.strict-cascading-check]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater.strict-cascading-check[quarkus.blaze-persistence.updater.strict-cascading-check]`

[.description]
—
カスケード属性に関連する前に、非カスケード属性での設定の更新可能または作成可能なエンティティー表示を許可しない厳格なカスケードチェックを無効化できるブールフラグ。無効化すると、JPA のように、更新をカスケーディング属性に関連していない場合、更新可能なエンティティー表示への変更がフラッシュされません。デフォルトは有効化されています (`true`)。このプロパティーに使用できる値は、 `true` または `false` です。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.create-empty-flat-views]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.create-empty-flat-views[quarkus.blaze-persistence.create-empty-flat-views]`

[.description]
--
A boolean flag that allows to specify if empty flat views should be created by default if not specified via `EmptyFlatViewCreation`. By default the creation of empty flat views is enabled i.e. the default value is `true`. Valid values for this property are `true` or `false`.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.create-empty-flat-views]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.create-empty-flat-views[quarkus.blaze-persistence.create-empty-flat-views]`

[.description]
—
`EmptyFlatViewCreation` で指定されていない場合、空のフラットビューがデフォルトで作成されるべきかどうかを指定できるブールフラグ。デフォルトでは、空のフラットビューの作成が有効化されています (`true`)。このプロパティーに使用できる値は、`true` または `false` です。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.expression-cache-class]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.expression-cache-class[quarkus.blaze-persistence.expression-cache-class]`

[.description]
--
The full qualified expression cache implementation class name.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.expression-cache-class]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.expression-cache-class[quarkus.blaze-persistence.expression-cache-class]`

[.description]
—
完全修飾式キャッシュ実装クラス名
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-persistence.inline-ctes]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.inline-ctes[quarkus.blaze-persistence.inline-ctes]`

[.description]
--
If set to true, the CTE queries are inlined by default. Valid values for this property are `true`, `false` or `auto`. Default is `true` which will always inline non-recursive CTEs. The `auto` configuration will only make use of inlining if the JPA provider and DBMS dialect support/require it. The property can be changed for a criteria builder before constructing a query.
--</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>icon:lock[title=ビルド時に固定] [[quarkus-blaze-persistence_quarkus.blaze-persistence.inline-ctes]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.inline-ctes[quarkus.blaze-persistence.inline-ctes]`

[.description]
—
true に設定すると、CTE クエリーがデフォルトでインライン化されます。このプロパティーに使用できる値は、`true`、`false`、または `auto` です。デフォルトの値は、 `true` で、非再帰 CTE を常にインライン化します。`auto` 設定は、JPA プロバイダーと DBMS ダイアレクトが対応または必要とする場合にのみインライン化を使用できます。このプロパティーは、クエリーを構成する前にクライテリアビルダー (criteria builder) に対して変更できます。
—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS Key Management Service (KMS) is a service that allows you to create and control the keys used to encrypt or digitally sign your data.  Using KMS, you can create and manage cryptographic keys and control their use across a wide range of AWS services and in your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS Key Management Service (KMS)は、データの暗号化や電子署名に使用する鍵の作成と管理を可能にするサービスです。KMSを使用することで、様々なAWSサービスやアプリケーションで暗号鍵を作成・管理し、その使用を制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about KMS at https://aws.amazon.com/kms/[the AWS KMS website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KMSについての詳しい情報は link:https://aws.amazon.com/kms/[AWS KMSのサイト] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The KMS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KMSのエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供し、1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use KMS locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、どのようにしてRESTサービスでローカルやAWS上でKMSを使用することができるかを見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker for your system to run KMS locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テスト目的でローカルでKMSを実行するためにシステムにDockerがインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with KMS is to run a local instance as a container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KMSを使い始める最も簡単な方法は、ローカルインスタンスをコンテナーとして実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a KMS instance that is accessible on port `8011`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ポート `8011` でアクセス可能な KMS インスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a KMS master key queue using AWS CLI and store in `MASTER_KEY_ARN` environment variable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS CLIでKMSマスターキーキューを作成し、 `MASTER_KEY_ARN` 環境変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, if you want to use your AWS account create a key using your default profile</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、AWSアカウントを使用したい場合は、デフォルトのプロファイルを使用してキーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built here allows to encrypt and decrypt text messages using a master key created on AWS KMS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで構築したアプリケーションでは、AWS KMS上で作成したマスターキーを用いてテキストメッセージの暗号化・復号化を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amazon-kms-quickstart` {quickstarts-tree-url}/amazon-kms-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `amazon-kms-quickstart` {quickstarts-tree-url}/amazon-kms-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon KMS Client extensions.  After this, the `amazon-kms` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RS、Mutiny、Amazon KMSクライアントエクステンションをインポートするMavenディレクトリ構造を生成します。この後、 `amazon-kms` エクステンションおよびRESTEasyのMutinyサポートが `pom.xml` に追加されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application that allows to encrypt and decrypt text message provided in the request.  The example application will demonstrate the two programming models supported by the extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、リクエストで提供されたテキストメッセージの暗号化と復号化を可能にするアプリケーションを作成します。この例のアプリケーションでは、エクステンションでサポートされている2つのプログラミングモデルを実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create a `org.acme.kms.QuarkusKmsSyncResource` that will provide an API to encrypt and decrypt message using the synchronous client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同期クライアントを使ってメッセージを暗号化・復号化するAPIを提供する `org.acme.kms.QuarkusKmsSyncResource` を作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An encrypted message is in the form of a bytes array. To return it to the user we need to encode it as Base64 string in the `encrypt` endpoint.  On the `decrypt` endpoint we need to decode from the Base64 string back to the bytes array before sending it out to the KMS client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>暗号化されたメッセージはバイト配列の形をしています。これをユーザーに返すためには、 `encrypt` エンドポイントで Base64 文字列としてエンコードする必要があります。 `decrypt` エンドポイントでは、KMS クライアントに送信する前に Base64 文字列からバイト配列にデコードする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both KMS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.  Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses the URL connection HTTP client, so you need to add a URL connection client dependency to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KMS クライアント (sync と async) は、 `src/main/resources` ディレクトリーにある `application.properties` ファイルで設定できます。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、エクステンションは URL connection HTTP クライアントを使用するので、URL connectionクライアントの依存関係を `pom.xml` ファイルに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're going to use a local KMS instance, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ローカルのKMSインスタンスを使用する場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kms.aws.region` - It's required by the client, but since you're using a local KMS instance use `us-east-1` as it's a default region of localstack's KMS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kms.aws.region` - クライアントによって必須とされていますが、ローカルのKMSインスタンスを使用しているので、ローカルスタックのKMSのデフォルトリージョンである `us-east-1` を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kms.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.ses.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-id` と `secret-access-key` について任意の値で設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work with an AWS account, you can simply remove or comment out all Amazon KMS related properties. By default, the KMS client extension will use the `default` credentials provider chain that looks for credentials in this order:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWSアカウントで作業したい場合は、Amazon KMS関連のプロパティーをすべて削除するかコメントアウトするだけです。デフォルトでは、KMSクライアントエクステンションは、次の順番でクレデンシャルを探す `default` クレデンシャルプロバイダチェーンを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging your application is as simple as `./mvnw clean package`.  It can be run with `java -Dkey.arn=$MASTER_KEY_ARN -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのパッケージ化は `./mvnw clean package` のようにシンプルです。 `java -Dkey.arn=$MASTER_KEY_ARN -jar target/quarkus-app/quarkus-run.jar` で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.kms.QuarkusKmsAsyncResource` REST resource that will be similar to our `QuarkusKmsSyncResource` but using an asynchronous programming model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.kms.QuarkusKmsAsyncResource` RESTリソースを作成します。 `QuarkusKmsSyncResource` と似ていますが、非同期プログラミングモデルを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create `Uni` instances from the `CompletionStage` objects returned by the asynchronous KMS client, and then transform the emitted item.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期のKMSクライアントから返された `CompletionStage` オブジェクトから `Uni` インスタンスを作成し、生成されたアイテムを変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクのスケジュール方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a clustered scheduler use the link:quartz[Quartz extension].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスター化されたスケジューラーが必要な場合は、 link:quartz[Quartzエクステンション] を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application accessible using HTTP to get the current value of a counter.  This counter is periodically (every 10 seconds) incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、カウンタの現在値を取得するために HTTP を使用してアクセスできる簡単なアプリケーションを作成します。このカウンタは定期的に (10 秒ごとに) インクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:scheduling-task-architecture.png[alt=Architecture]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:scheduling-task-architecture.png[alt=Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.scheduler.CountResource` resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.scheduler.CountResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Maven project also imports the Quarkus scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven プロジェクトは、Quarkus scheduler エクステンションもインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `scheduler` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `scheduler` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.scheduler` package, create the `CounterBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.scheduler` パッケージで、以下の内容の `CounterBean` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds provided a worker thread is available (Quarkus is using 10 worker threads for the scheduler). If it is not available the method invocation should be re-scheduled by default i.e it should be invoked as soon as possible. The invocation of the scheduled method does not depend on the status or result of the previous invocation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled` アノテーションを使用して、ワーカースレッドが利用可能であれば 10 秒ごとにこのメソッドを実行するように Quarkus に指示します (Quarkus はスケジューラーに10個のワーカースレッドを使用しています)。ワーカースレッドが利用できない場合は、メソッドの呼び出しをデフォルトで再スケジューリングする必要があります。スケジュールされたメソッドの呼び出しは、前回の呼び出しのステータスや結果には依存しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is pretty straightforward. Every 10 seconds, the counter is incremented.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードはとても簡単です。10 秒ごとにカウンターがインクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression. The annotated method is executed at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cron のような式でジョブを定義します。アノテーションされたメソッドは毎日午前 10 時 15 分に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the `cron.expr` configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` ファイルを編集し、 `cron.expr` の設定を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observe the console to verify that the message `Cron expression configured in application.properties` has been displayed indicating that the cron job using an expression configured in `application.properties` has been triggered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールを見て、 `application.properties` で構成された式を使用する cron ジョブがトリガーされたことを示すメッセージ `Cron expression configured in application.properties` が表示されたことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラー設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Gradle plugin is published to the https://plugins.gradle.org/plugin/io.quarkus[Gradle Plugin Portal].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Gradle プラグインは、Gradle link:https://plugins.gradle.org/plugin/io.quarkus[プラグインポータル] に公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use it, add the following to your `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>使用するには、 `build.gradle` ファイルに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You also need to add the following at the top of your `settings.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、`settings.gradle` ファイルの先頭に以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `plugins{}` method in `settings.gradle` is not supported in Gradle 5.x. In this case make sure to explicitly declare the plugin version in the `build.gradle` file like the example below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`settings.gradle` の `plugins{}` メソッドは Gradle 5.x ではサポートされていません。この場合、以下の例のように `build.gradle` ファイルでプラグインのバージョンを明示的に宣言するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference covers how to write applications that run and then exit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリファレンスでは、実行して終了するアプリケーションの書き方について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Command Mode Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドモードアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different approaches that can be used to implement applications that exit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>終了するアプリケーションを実装するためには、2つの異なるアプローチがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and have Quarkus run this method automatically</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusApplication` を実装し、Quarkusがこのメソッドを自動的に実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and a Java main method, and use the Java main method to launch Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusApplication` とJava mainメソッドを実装し、Java mainメソッドを使用してQuarkusを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this document the `QuarkusApplication` instance is referred to as the application main, and a class with a Java main method is the Java main.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、 `QuarkusApplication` インスタンスをアプリケーション mainと呼び、Java mainメソッドを持つクラスを Java mainと呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;.&gt; The `@QuarkusMain` annotation tells Quarkus that this is the main entry point.  &lt;.&gt; The `run` method is invoked once Quarkus starts, and the application stops when it finishes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;.&gt; `@QuarkusMain` アノテーションは、これがメインのエントリーポイントであることをQuarkusに伝えます。  &lt;.&gt; `run` メソッドは、Quarkusが起動すると呼び出され、終了するとアプリケーションが停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contexts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get access to your application beans and services, be aware that a `@QuarkusMain` instance is an application scoped bean by default. It has access to singletons, application and dependent scoped beans. If you want to interact with beans that requires a request scope put a `@ActivateRequestContext` on your `run()` method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションBeanやサービスにアクセスするために、 `@QuarkusMain` インスタンスはデフォルトでapplicationスコープのBeanであることに注意してください。singleton、application、dependentスコープのBeanへのアクセスを持っています。requestスコープを必要とするBeanと対話したい場合は、 `run()` メソッドに `@ActivateRequestContext` を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This let `run()` have access to methods like `listAll()` and `query*` methods on a Panache Entity. Without it you will eventually get a `ContextNotActiveException` when accessing such classes/beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `run()` は Panache Entity 上の `listAll()` や `query*` のようなメソッドにアクセスできるようになります。これがないと、そのようなクラスやBeanにアクセスするときに、最終的には `ContextNotActiveException` に直面することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Main method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Main method</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is effectively the same as running the `HelloWorldMain` application main directly, but has the advantage it can be run from the IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `HelloWorldMain` アプリケーション mainを直接実行するのと実質的には同じですが、IDE から実行できるという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class that implements `QuarkusApplication` and has a Java main then the Java main will be run.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusApplication` を実装したクラスで Java main がある場合は Java main が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that a Java main perform very little logic, and just launch the application main. In development mode the Java main will run in a different ClassLoader to the main application, so may not behave as you would expect.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java mainはほとんどロジックを実行せず、アプリケーション mainを起動するだけにすることをお勧めします。開発モードでは、Java mainはアプリケーション mainとは異なるClassLoaderで実行されるので、期待通りの動作をしないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Main Methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のmainメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to have multiple main methods in an application, and select between them at build time.  The `@QuarkusMain` annotation takes an optional 'name' parameter, and this can be used to select the main to run using the `quarkus.package.main-class` build time configuration option. If you don't want to use annotations this can also be used to specify the fully qualified name of a main class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション内に複数のmainメソッドを持ち、ビルド時にそれらの間で選択することが可能です。 `@QuarkusMain` アノテーションはオプションの 'name' パラメーターを取り、 `quarkus.package.main-class` ビルド時設定オプションを使用して実行するmainを選択するために使用できます。アノテーションを使用したくない場合は、メインクラスの完全修飾名を指定するために使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the `@QuarkusMain` with no name (i.e. the empty string) will be used, and if it is not present and `quarkus.package.main-class` is not specified then Quarkus will automatically generate a main class that just runs the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、名前のない `@QuarkusMain` (つまり空文字列)が使用され、それが存在せず `quarkus.package.main-class` が指定されていない場合は、Quarkus はアプリケーションを実行するだけのメインクラスを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `name` of `@QuarkusMain` must be unique (including the default of the empty string). If you have multiple `@QuarkusMain` annotations in your application the build will fail if the names are not unique.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusMain` の `name` は一意である必要があります(デフォルトの空文字列を含む)。アプリケーション内に複数の `@QuarkusMain` アノテーションがある場合、名前が一意でないとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command mode lifecycle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドモードのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running a command mode application the basic lifecycle is as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドモードのアプリケーションを実行する場合、基本的なライフサイクルは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the `QuarkusApplication` main method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusApplication` mainメソッドの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shut down Quarkus and exit the JVM after the main method returns</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mainメソッドがreturnされた後にQuarkusをシャットダウンし、JVMを終了する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shutdown is always initiated by the application main thread returning. If you want to run some logic on startup, and then run like a normal application (i.e. not exit) then you should call `Quarkus.waitForExit` from the main thread (A non-command mode application is essentially just running an application that just calls `waitForExit`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シャットダウンは常にアプリケーションのメインスレッドがreturnされることで開始されます。起動時に何らかのロジックを実行して、通常のアプリケーションのように実行したい場合 (つまり終了しない) は、メインスレッドから `Quarkus.waitForExit` を呼び出す必要があります (非コマンドモードのアプリケーションは、基本的に `waitForExit` を呼び出すだけのアプリケーションを実行しているだけです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to shut down a running application and you are not in the main thread then you should call `Quarkus.asyncExit` in order to unblock the main thread and initiate the shutdown process.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行中のアプリケーションをシャットダウンしたい場合、メインスレッドにいない場合は、 `Quarkus.asyncExit` を呼び出してメインスレッドのブロックを解除し、シャットダウン処理を開始する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also for command mode applications the dev mode is supported. When running `mvn compile quarkus:dev`, the command mode application is executed and on press of the Enter key, is restarted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、コマンドモードアプリケーションでは、開発モードにも対応しています。 `mvn compile quarkus:dev` を実行しているときは、コマンドモードアプリケーションを実行し、Enter キーを押すと再起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As command mode applications will often require arguments to be passed on the commandline, this is also possible in dev mode via:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドモードのアプリケーションでは、コマンドラインで引数を渡す必要があることが多く、これは開発モードでも可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, you will learn how to enable application data caching in any CDI managed bean of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションのCDI管理されたBeanでアプリケーションデータのキャッシングを有効にする方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scenario</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シナリオ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for the next three days.  The problem is that you have to rely on an external meteorological service which only accepts requests for one day at a time and takes forever to answer.  Since the weather forecast is updated once every twelve hours, caching the service responses would definitely improve your API performances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションで、ユーザーが今後3日間の天気予報を取得できるREST APIを公開したいとします。問題は、一度に1日分のリクエストしか受け付けず、応答に時間がかかる外部の気象サービスに依存しなければならないことです。天気予報は12時間に一度更新されるので、サービスのレスポンスをキャッシュすればAPIのパフォーマンスは間違いなく向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll do that using a single Quarkus annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これをQuarkusの単一のアノテーションを使用して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create a new Quarkus project using Maven with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、以下のコマンドでMavenを使って新しいQuarkusプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `cache` and `resteasy-jackson` extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `cache` と `resteasy-jackson` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service that will simulate an extremely slow call to the external meteorological service.  Create `src/main/java/org/acme/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは、外部気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is where the slowness comes from.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遅さはここに由来します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class that will contain the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、ユーザーが次の3日間の天気予報を求めたときに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/cache/WeatherForecast.java` をこのように作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we just need to update the generated `WeatherForecastResource` class to use the service and response:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あとは、サービスとレスポンスを使用するようにに生成された `WeatherForecastResource` クラスを更新するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `daysInFuture` query parameter is omitted, the three days weather forecast will start from the current day.  Otherwise, it will start from the current day plus the `daysInFuture` value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`daysInFuture` クエリパラメーターが省略された場合、3 日間の天気予報は現在の日から始まります。それ以外の場合は、現在の日に `daysInFuture` の値を加えたものから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We're all done! Let's check if everything's working.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完了です!うまくいっているか確認してみましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, run the application using `./mvnw compile quarkus:dev` from the project directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、プロジェクトディレクトリーから `./mvnw compile quarkus:dev` を使ってアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, call `http://localhost:8080/weather?city=Raleigh` from a browser.  After six long seconds, the application will answer something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 `http://localhost:8080/weather?city=Raleigh` ブラウザからを呼び出します。6秒ほど長い時間が経過すると、アプリケーションは次のような回答をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response content may vary depending on the day you run the code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードを実行する日によってレスポンスの内容が異なる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can try calling the same URL again and again, it will always take six seconds to answer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何度も同じURLに電話をかけてみても、必ず6秒でレスポンスが返却されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling the cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュの有効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションが動いたので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを次のように修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We only added this annotation (and the associated import of course).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーション(もちろん関連するインポートも)を追加しただけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try to call `http://localhost:8080/weather?city=Raleigh` again.  You're still waiting a long time before receiving an answer.  This is normal since the server just restarted and the cache was empty.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `http://localhost:8080/weather?city=Raleigh` をもう一度実行してみましょう。レスポンスが来るまでにまだ長い時間待たされています。これはサーバーが再起動したばかりでキャッシュが空になっているので正常です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing features for developers called `live coding`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ちょっと待って!? `WeatherForecastService` のアップデート後、サーバーが勝手に再起動した?はい、これは、 `live coding` と呼ばれる開発者のためのQuarkusの驚くべき機能の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the cache was loaded during the previous call, try calling the same URL.  This time, you should get a super fast answer with an `executionTimeInMs` value close to 0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前回の呼び出しでキャッシュが読み込まれたので、同じ URL を呼び出してみてください。今度は、 `executionTimeInMs` の値が 0 に近い超高速な応答が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see what happens if we start from one day in the future using the `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` URL.  You should get an answer two seconds later since two of the requested days were already loaded in the cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` のURLで、未来のある日から始めるとどうなるか見てみましょう。要求された日のうち2つはすでにキャッシュに読み込まれていたので、2秒後に回答が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also try calling the same URL with a different city and see the cache in action again.  The first call will take six seconds and the following ones will be answered immediately.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、同じURLを別の都市で呼び出してみて、再度キャッシュの動作を確認することもできます。最初の呼出には6秒ほどかかり、次の呼出にはすぐに出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations! You just added application data caching to your Quarkus application with a single line of code!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おめでとうございます。たった1行のコードでQuarkusアプリケーションにアプリケーションデータのキャッシングを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do you want to learn more about the Quarkus application data caching abilities? The following sections will show you everything there is to know about it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションのデータキャッシング機能について詳しく知りたいですか?以下のセクションでは、この機能について知っておくべきことをすべて紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュのアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers a set of annotations that can be used in a CDI managed bean to enable caching abilities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、CDI管理されたBeanで使用できる、キャッシング機能を有効にするアノテーションのセットを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching annotations are not allowed on private methods.  They will work fine with any other access modifier including package-private (no explicit modifier).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プライベートメソッドではキャッシュのアノテーションは許可されていません。package-private (明示的な修飾子を持たない) を含む他のアクセス修飾子では問題なく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheResult</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@CacheResult</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Loads a method result from the cache without executing the method body whenever possible.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可能な限り、メソッド本体を実行せずにキャッシュからメソッドの結果を読み込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a method annotated with `@CacheResult` is invoked, Quarkus will compute a cache key and use it to check in the cache whether the method has been already invoked.  If the method has one or more arguments, the key computation is done from all the method arguments if none of them is annotated with `@CacheKey`, or all the arguments annotated with `@CacheKey` otherwise.  Each non-primitive method argument that is part of the key must implement `equals()` and `hashCode()` correctly for the cache to work as expected.  This annotation can also be used on a method with no arguments, a default key derived from the cache name is used in that case.  If a value is found in the cache, it is returned and the annotated method is never actually executed.  If no value is found, the annotated method is invoked and the returned value is stored in the cache using the computed key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CacheResult` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュキーを計算し、それを使用して、そのメソッドがすでに呼び出されているかどうかをキャッシュでチェックします。メソッドに1つ以上の引数がある場合、キーの計算は、 `@CacheKey` でアノテーションされていない場合はすべてのメソッド引数から、そうでない場合は `@CacheKey` でアノテーションされているすべての引数から行われます。キャッシュが期待通りに動作するためには、キーの一部である非プリミティブなメソッドの各引数は `equals()` と `hashCode()` を正しく実装しなければなりません。このアノテーションは引数を持たないメソッドにも使用することができ、その場合はキャッシュ名から派生したデフォルトキーが使用されます。キャッシュ内に値が見つかった場合はそれが返され、アノテーションされたメソッドは実際には実行されません。値が見つからない場合は、アノテーションされたメソッドが呼び出され、返された値は計算されたキーを使用してキャッシュに保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A method annotated with `CacheResult` is protected by a lock on cache miss mechanism.  If several concurrent invocations try to retrieve a cache value from the same missing key, the method will only be invoked once.  The first concurrent invocation will trigger the method invocation while the subsequent concurrent invocations will wait for the end of the method invocation to get the cached result.  The `lockTimeout` parameter can be used to interrupt the lock after a given delay.  The lock timeout is disabled by default, meaning the lock is never interrupted.  See the parameter Javadoc for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CacheResult` でアノテーションされたメソッドは、キャッシュミスのロック機構によって保護されています。複数の同時呼び出しが同じ欠落キーからキャッシュ値を取得しようとした場合、メソッドは一度だけ呼び出されます。最初の同時呼び出しはメソッドの呼び出しをトリガし、その後の同時呼び出しはキャッシュされた結果を取得するためにメソッドの呼び出しの終了を待ちます。 `lockTimeout` パラメーターを使用すると、所定の遅延後にロックを中断することができます。ロックのタイムアウトは既定では無効になっており、ロックが中断されることはありません。詳細は、パラメーター Javadoc を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation cannot be used on a method returning `void`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションは、 `void` を返すメソッドでは使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is able to also cache `null` values unlike the underlying Caffeine provider.  See &lt;&lt;negative-cache,more on this topic below&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、基礎となるCaffeineプロバイダとは異なり、 `null` の値をキャッシュすることもできます。 link:#negative-cache[このトピックの詳細は以下] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheInvalidate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@CacheInvalidate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes an entry from the cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュからエントリーを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a method annotated with `@CacheInvalidate` is invoked, Quarkus will compute a cache key and use it to try to remove an existing entry from the cache.  If the method has one or more arguments, the key computation is done from all the method arguments if none of them is annotated with `@CacheKey`, or all the arguments annotated with `@CacheKey` otherwise.  This annotation can also be used on a method with no arguments, a default key derived from the cache name is used in that case.  If the key does not identify any cache entry, nothing will happen.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CacheInvalidate` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュキーを計算し、それを使用してキャッシュから既存のエントリーを削除しようとします。メソッドに1つ以上の引数がある場合、キーの計算は、 `@CacheKey` でアノテーションされていない場合はすべてのメソッド引数から、そうでない場合は `@CacheKey` でアノテーションされているすべての引数から行われます。このアノテーションは引数を持たないメソッドでも使用でき、その場合はキャッシュ名から派生したデフォルトのキーが使用されます。キーがキャッシュエントリーを識別しない場合は、何も起こりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheInvalidateAll</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@CacheInvalidateAll</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a method annotated with `@CacheInvalidateAll` is invoked, Quarkus will remove all entries from the cache.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CacheInvalidateAll` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュからすべてのエントリーを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheKey</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@CacheKey</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a method argument is annotated with `@CacheKey`, it is identified as a part of the cache key during an invocation of a method annotated with `@CacheResult` or `@CacheInvalidate`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドの引数が `@CacheKey` でアノテーションされている場合、 `@CacheResult` または `@CacheInvalidate` でアノテーションされたメソッドの呼び出し時にキャッシュキーの一部として識別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation is optional and should only be used when some of the method arguments are NOT part of the cache key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションはオプションで、メソッドの引数の一部がキャッシュキーの一部ではない場合にのみ使用されるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Composite cache key building logic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複合キャッシュキー構築ロジック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a cache key is built from several method arguments, whether they are explicitly identified with `@CacheKey` or not, the building logic depends on the order of these arguments in the method signature. On the other hand, the arguments names are not used at all and do not have any effect on the cache key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュキーが複数のメソッド引数から構築される場合、それらが明示的に `@CacheKey` で識別されているかどうかに関わらず、構築ロジックはメソッドシグネチャ内のこれらの引数の順序に依存します。一方、引数名は全く使用されず、キャッシュキーには何の影響も与えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling this method WILL invalidate values cached by the `load` method even if the key elements names have been swapped.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを呼び出すと、キー要素名が入れ替わっていても `load` メソッドでキャッシュされた値が無効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling this method WILL NOT invalidate values cached by the `load` method because the key elements order is different.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを呼び出すと、キー要素の順序が異なるため、 `load` メソッドでキャッシュされた値が無効になることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling this method WILL invalidate values cached by the `load` method because the key elements order is the same.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを呼び出すと、キー要素の順序が同じなので、 `load` メソッドでキャッシュされた値が無効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the underlying caching provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基礎となるキャッシングプロバイダーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension uses https://github.com/ben-manes/caffeine[Caffeine] as its underlying caching provider.  Caffeine is a high performance, near optimal caching library.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、基礎となるキャッシュプロバイダとして link:https://github.com/ben-manes/caffeine[Caffeine] を使用しています。Caffeine は高性能で最適に近いキャッシングライブラリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each of the Caffeine caches backing up the Quarkus application data caching extension can be configured using the following properties in the `application.properties` file. By default caches do not perform any type of eviction if not configured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションのデータキャッシュエクステンションを支える各Caffeineキャッシュは、 `application.properties` ファイルの以下のプロパティーを使用して設定することができます。デフォルトでは、設定されていない場合、キャッシュはどのようなタイプの退避も実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to replace `cache-name` in all of the following properties with the real name of the cache you want to configure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のすべてのプロパティーで `cache-name` を設定したいキャッシュの実名に置き換える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's what your cache configuration could look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュの設定は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `foo` cache is being configured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`foo` キャッシュの設定を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `bar` cache is being configured.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`bar` キャッシュの設定を行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotated beans examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注釈付きBean例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implicit simple cache key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>暗黙の単純キャッシュキー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cache key is implicit since there's no `@CacheKey` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CacheKey` アノテーションがないので、キャッシュキーは暗黙の了解です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explicit composite cache key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>明示的な合成キャッシュキー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cache key is explicitly composed of two elements. The method signature also contains a third argument which is not part of the key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュキーは明示的に 2 つの要素で構成されています。メソッドシグネチャには、キーの一部ではない第三引数も含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default cache key</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのキャッシュキー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A unique default cache key derived from the cache name is used because the method has no arguments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドには引数がないため、キャッシュ名から派生した一意のデフォルトキャッシュキーが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple annotations on a single method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単一のメソッドに複数のアノテーションを付与</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used to force a refresh of the cache entry corresponding to the given key.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドを使用して、指定されたキーに対応するキャッシュエントリーを強制的に更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method will invalidate all entries from the `foo` and `bar` caches with a single call.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、一度の呼び出しで `foo` および `bar` キャッシュからのすべてのエントリーを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Negative caching and nulls</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネガティブキャッシングとnull</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes one wants to cache the result of an (expensive) remote call.  If the remote call fails, one may not want to cache the result or exception, but rather re-try the remote call on the next invocation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(高価な)リモートコールの結果をキャッシュしたい場合があります。リモートコールが失敗した場合、結果や例外をキャッシュするのではなく、 次の呼び出しでリモートコールを再試行したい場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simple approach could be to catch the exception and return `null`, so that the caller can act accordingly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなアプローチとしては、例外をキャッチして `null` を返すことで、呼び出し元がそれに応じて行動できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample code</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Call the method to call the remote</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートを呼び出すためにメソッドを実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do the remote call and return its result</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートコールを行い、その結果を返却</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return in case of exception</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例外が発生時にリターンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach has an unfortunate side effect: as we said before, Quarkus can also cache `null` values. Which means that the next call to `callRemote()` with the same parameter value will be answered out of the cache, returning `null` and no remote call will be done.  This may be desired in some scenarios, but usually one wants to retry the remote call until it returns a result.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプローチには不幸な副作用があります。先に述べたように、Quarkusは `null` の値をキャッシュすることもできます。つまり、同じパラメーター値を持つ `callRemote()` への次の呼び出しは、キャッシュの外で応答され、 `null` が返され、リモートコールは行われないということです。これはシナリオによっては望ましいことかもしれませんが、通常は結果が返ってくるまでリモートコールを再試行したいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let exceptions bubble up</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例外をバブルアップさせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To prevent the cache from caching (marker) results from a remote call, we need to let the exception bubble out of the called method and catch it at the caller side:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートコールの結果をキャッシュ(マーカー)しないようにするには、コールされたメソッドから例外をバブルアップし、呼び出し側でキャッチする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Exception bubbling up</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例外をバブルアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exceptions may bubble up</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例外がバブルアップする場合がある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can throw all kinds of remote exceptions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、あらゆる種類のリモート例外を投げることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the call to the remote throws an exception, the cache does not store the result, so that a subsequent call to `callRemote()` with the same parameter value will not be answered out of the cache.  It will instead result in another attempt to call the remote.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートへの呼び出しが例外をスローした場合、キャッシュは結果を保存しないので、 同じパラメーター値を持つ `callRemote()` への後続の呼び出しがキャッシュから応答されることはありません。その代わりに、リモートへの呼び出しを再度試みることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended, that you have read the {quickstarts-tree-url}/kafka-quickstart[Kafka quickstart] before.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>事前に {quickstarts-tree-url}/kafka-quickstart[Kafka quickstart] を読んでおくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension for Kafka Streams allows for very fast turnaround times during development by supporting the Quarkus Dev Mode (e.g. via `./mvnw compile quarkus:dev`).  After changing the code of your Kafka Streams topology, the application will automatically be reloaded when the next input message arrives.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Streams用のQuarkusエクステンションを使用すると、Quarkus Dev Modeをサポートすることで、開発期間を非常に短縮することができます(例: `./mvnw compile quarkus:dev` を参照)。Kafka Streamsトポロジーのコードを変更した後、次の入力メッセージが到着すると、アプリケーションが自動的にリロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A recommended development set-up is to have some producer which creates test messages on the processed topic(s) in fixed intervals, e.g. every second and observe the streaming application's output topic(s) using a tool such as `kafkacat`.  Using the dev mode, you'll instantly see messages on the output topic(s) as produced by the latest version of your streaming application when saving.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>推奨される開発セットアップは、処理されたトピックに対して一定の間隔 (たとえば毎秒) でテストメッセージを作成するプロデューサを用意し、 `kafkacat` のようなツールを使用してストリーミング アプリケーションの出力トピックを観察することです。開発モードを使用すると、保存時にストリーミングアプリケーションの最新バージョンによって生成された出力トピッ ク上のメッセージを即座に見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the best development experience, we recommend applying the following configuration settings to your Kafka broker:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最高の開発環境を実現するために、以下の設定を Kafka ブローカーに適用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also specify the following settings in your Quarkus `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、以下の設定をQuarkusの `application.properties`で指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Together, these settings will ensure that the application can very quickly reconnect to the broker after being restarted in dev mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの設定を併用することで、アプリケーションを開発モードで再起動した後に、非常に迅速にブローカに再接続できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to generate (random) temperature values in one component (named `generator`).  These values are associated to given weather stations and are written in a Kafka topic (`temperature-values`).  Another topic (`weather-stations`) contains just the main data about the weather stations themselves (id and name).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、(ランダムな)温度値を 1 つのコンポーネント ( `generator` ) で生成します。これらの値は、与えられた気象観測所に関連付けられ、Kafka トピック ( `temperature-values` ) に書き込まれます。別のトピック ( `weather-stations` ) には、気象観測所自体に関するマスターデータ (id と名前) だけが格納されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A second component (`aggregator`) reads from the two Kafka topics and processes them in a streaming pipeline:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2 つ目のコンポーネント ( `aggregator` ) は、2 つの Kafka トピックから読み込み、ストリーミングパイプラインで処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the two topics are joined on weather station id</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ウェザーステーション ID では、この2つのトピックが結合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>per weather station the min, max and average temperature is determined</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各気象台ごとに最低、最高、平均気温が決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this aggregated data is written out to a third topic (`temperatures-aggregated`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この集約されたデータは、第三のトピック ( `temperatures-aggregated` ) に書き出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The data can be examined by inspecting the output topic.  By exposing a Kafka Streams https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html[interactive query], the latest result for each weather station can alternatively be obtained via a simple REST query.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出力トピックを検査することで、データを調べることができます。Kafka Streams の link:https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html[対話型クエリ] を公開することで、各気象観測所の最新の結果を単純な REST クエリで取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The overall architecture looks like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>全体的なアーキテクチャはこんな感じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project with the temperature value producer.  Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、温度値プロデューサを持つ新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Reactive Messaging と Kafka コネクタエクステンションをインポートして Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-reactive-messaging-kafka` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Temperature Value Producer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>温度値プロデューサー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `producer/src/main/java/org/acme/kafka/streams/producer/generator/ValuesGenerator.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `producer/src/main/java/org/acme/kafka/streams/producer/generator/ValuesGenerator.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from the returned `Multi` to `temperature-values`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返却された `Multi` から `temperature-values` にアイテムを発送するように Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a Mutiny _stream_ (`Multi`) emitting a random temperature value every 0.5 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、0.5 秒ごとにランダムな温度値を放出する Mutiny _ストリーム_ ( `Multi` ) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from the returned `Multi` (static list of weather stations) to `weather-stations`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>返された `Multi` (気象観測所の静的リスト) から `weather-stations` にアイテムをディスパッチするように、Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The two methods each return a _reactive stream_ whose items are sent to the streams named `temperature-values` and `weather-stations`, respectively.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この 2 つのメソッドは、それぞれ `temperature-values` と `weather-stations` という名前のストリームにアイテムが送信される _リアクティブストリーム_ を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Topic Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トピック構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The two channels are mapped to Kafka topics using the Quarkus configuration file `application.properties`.  For that, add the following to the file `producer/src/main/resources/application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つのチャンネルは、Quarkus設定ファイル `application.properties` を使用してKafkaトピックにマッピングされます。そのためには、ファイル `producer/src/main/resources/application.properties` に次のように追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configures the Kafka bootstrap server, the two topics and the corresponding (de-)serializers.  More details about the different configuration options are available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Kafka ブートストラップサーバー、2 つのトピック、および対応する (デ)シリアライザを設定します。さまざまな設定オプションの詳細については、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Aggregator Maven Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アグリゲータMavenプロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the producer application in place, it's time to implement the actual aggregator application, which will run the Kafka Streams pipeline.  Create another project like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサアプリケーションを用意したら、Kafka Streams パイプラインを実行するアグリゲータアプリケーションを実装しましょう。このように別のプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This creates the `aggregator` project with the Quarkus extension for Kafka Streams and with RESTEasy support for Jackson.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、Kafka Streams用のQuarkusエクステンションとJackson用のRESTEasyサポートを備えた `aggregator` プロジェクトが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `kafka-streams` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `kafka-streams` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Pipeline Implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パイプラインの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's begin the implementation of the stream processing application by creating a few value objects for representing temperature measurements, weather stations and for keeping track of aggregated values.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ストリーム処理アプリケーションの実装を開始しましょう。温度測定、気象観測所を表現し、集約された値を追跡するためのいくつかの値オブジェクトを作成することから始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStation.java`, representing a weather station, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、次の内容でファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStation.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/TemperatureMeasurement.java`, representing temperature measurements for a given station:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、指定されたステーションの温度測定値を表すファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/TemperatureMeasurement.java` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/Aggregation.java`, which will be used to keep track of the aggregated values while the events are processed in the streaming pipeline:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして最後に `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/Aggregation.java` 、イベントがストリーミング・パイプラインで処理されている間、集約された値を追跡するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, let's create the actual streaming query implementation itself in the `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/TopologyProducer.java` file.  All we need to do for that is to declare a CDI producer method which returns the Kafka Streams `Topology`; the Quarkus extension will take care of configuring, starting and stopping the actual Kafka Streams engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、実際のストリーミングクエリの実装自体を `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/TopologyProducer.java` ファイルで作成してみましょう。そのために必要なのは、Kafka Streams `Topology` を返す CDI プロデューサメソッドを宣言することだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `weather-stations` table is read into a `GlobalKTable`, representing the current state of each weather station</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`weather-stations` テーブルは、各気象台の現在の状態を表す `GlobalKTable` に読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `temperature-values` topic is read into a `KStream`; whenever a new message arrives to this topic, the pipeline will be processed for this measurement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`temperature-values` トピックは `KStream` に読み込まれます。このトピックに新しいメッセージが到着するたびに、パイプラインはこの測定のために処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The message from the `temperature-values` topic is joined with the corresponding weather station, using the topic's key (weather station id); the join result contains the data from the measurement and associated weather station message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`temperature-values` トピックからのメッセージは、トピックのキー (ウェザーステーション ID) を使用して、対応するウェザーステーションと結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values are grouped by message key (the weather station id)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値はメッセージキー(ウェザーステーションID)によってグループ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Within each group, all the measurements of that station are aggregated, by keeping track of minimum and maximum values and calculating the average value of all measurements of that station (see the `Aggregation` type)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各グループ内では、最小値と最大値を追跡し、そのステーションのすべての測定値の平均値を計算することで、そのステーションのすべての測定値が集約されます( `Aggregation` タイプを参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The results of the pipeline are written out to the `temperatures-aggregated` topic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パイプラインの結果は `temperatures-aggregated` トピックに書き出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka Streams extension is configured via the Quarkus configuration file `application.properties`.  Create the file `aggregator/src/main/resources/application.properties` with the following contents:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Streams エクステンションは、Quarkusの設定ファイル `application.properties` で設定します。ファイル `aggregator/src/main/resources/application.properties` を以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The options with the `quarkus.kafka-streams` prefix can be changed dynamically at application startup, e.g. via environment variables or system properties.  `bootstrap-servers` and `application-server` are mapped to the Kafka Streams properties `bootstrap.servers` and `application.server`, respectively.  `topics` is specific to Quarkus: the application will wait for all the given topics to exist before launching the Kafka Streams engine.  This is to done to gracefully await the creation of topics that don't yet exist at application startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kafka-streams` `bootstrap-servers` と は、それぞれ Kafka Streams プロパティー と にマップされます。 `application-server` `bootstrap.servers` `application.server` `topics` は Quarkus に固有のもので、アプリケーションは Kafka Streams エンジンを起動する前に、指定したすべてのトピックが存在するのを待ちます。これは、アプリケーションの起動時にまだ存在しないトピックの作成をグレースフルに待つために行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can use `kafka.bootstrap.servers` instead of `quarkus.kafka-streams.bootstrap-servers` as you did in the _generator_ project above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、上記の _ジェネレーター_ プロジェクトで行ったように、 `quarkus.kafka-streams.bootstrap-servers` の代わりに `kafka.bootstrap.servers` を使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the properties within the `kafka-streams` namespace are passed through as-is to the Kafka Streams engine.  Changing their values requires a rebuild of the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kafka-streams` ネームスペース内のすべてのプロパティーは、そのまま Kafka Streams エンジンに渡されます。プロパティーの値を変更するには、アプリケーションの再構築が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building and Running the Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのビルドと実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now can build the `producer` and `aggregator` applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`producer` と `aggregator` のアプリケーションをビルドできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of running them directly on the host machine using the Quarkus dev mode, we're going to package them into container images and launch them via Docker Compose.  This is done in order to demonstrate scaling the `aggregator` aggregation to multiple nodes later on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのdevモードを使ってホストマシン上で直接実行するのではなく、コンテナーイメージにパッケージ化してDocker Compose経由で起動します。これは、後で `aggregator` のアグリゲーションを複数のノードにスケーリングすることを実証するために行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Dockerfile` created by Quarkus by default needs one adjustment for the `aggregator` application in order to run the Kafka Streams pipeline.  To do so, edit the file `aggregator/src/main/docker/Dockerfile.jvm` and replace the line `FROM fabric8/java-alpine-openjdk8-jre` with `FROM fabric8/java-centos-openjdk8-jdk`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusがデフォルトで作成した `Dockerfile` は、Kafka Streamsパイプラインを実行するために、 `aggregator` アプリケーションに1つの調整が必要です。そのためには、 `aggregator/src/main/docker/Dockerfile.jvm` ファイルを編集して、 `FROM fabric8/java-alpine-openjdk8-jre` の行を `FROM fabric8/java-centos-openjdk8-jdk` に置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next create a Docker Compose file (`docker-compose.yaml`) for spinning up the two applications as well as Apache Kafka and ZooKeeper like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、2 つのアプリケーションを起動するための Docker Compose ファイル ( `docker-compose.yaml` ) を作成し、Apache Kafka と ZooKeeper と同様に以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To launch all the containers, building the `producer` and `aggregator` container images, run `docker-compose up --build`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`producer` と `aggregator` のコンテナーイメージをビルドして、すべてのコンテナーを起動するには、 `docker-compose up --build` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of `QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS`, you can use `KAFKA_BOOTSTRAP_SERVERS`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS` の代わりに、 `KAFKA_BOOTSTRAP_SERVERS` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see log statements from the `producer` application about messages being sent to the "temperature-values" topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`producer` アプリケーションから、"temperature-values" トピックに送信されたメッセージに関するログステートメントが表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now run an instance of the _debezium/tooling_ image, attaching to the same network all the other containers run in.  This image provides several useful tools such as _kafkacat_ and _httpie_:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで _debezium/tooling_ イメージのインスタンスを実行し、他のすべてのコンテナーが実行しているのと同じネットワークにアタッチします。このイメージは、 _kafkacat_ や _httpie_ などの便利なツールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Within the tooling container, run _kafkacat_ to examine the results of the streaming pipeline:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ツールコンテナー内で、 _kafkacatを_ 実行して、ストリーミングパイプラインの結果を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see new values arrive as the producer continues to emit temperature measurements, each value on the outbound topic showing the minimum, maximum and average temperature values of the represented weather station.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロデューサが温度測定値を出力し続けると、新しい値が表示され、送信トピックの各値は、表現された気象観測所の最小、最大、および平均温度値を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interactive Queries</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インタラクティブクエリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscribing to the `temperatures-aggregated` topic is a great way to react to any new temperature values.  It's a bit wasteful though if you're just interested in the latest aggregated value for a given weather station.  This is where Kafka Streams interactive queries shine: they let you directly query the underlying state store of the pipeline for the value associated to a given key.  By exposing a simple REST endpoint which queries the state store, the latest aggregation result can be retrieved without having to subscribe to any Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`temperatures-aggregated` のトピックを購読することは、新しい気温の値に反応するための素晴らしい方法です。しかし、特定の気象観測所の最新の集計値だけに興味があるのであれば、少しもったいないです。そこで、Kafka Streams の対話型クエリが威力を発揮します。ステートストアをクエリするシンプルな REST エンドポイントを公開することで、Kafka トピックを購読しなくても最新の集計結果を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's begin by creating a new class `InteractiveQueries` in the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/InteractiveQueries.java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、ファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/InteractiveQueries.java` 内に `InteractiveQueries` を作成することから始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>one more method to the `KafkaStreamsPipeline` class which obtains the current state for a given key:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`KafkaStreamsPipeline` クラスに、与えられたキーの現在の状態を取得するメソッドをもう一つ追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A value for the given station id was found, so that value will be returned</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指定されたステーションIDの値が見つかったので、その値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No value was found, either because a non-existing station was queried or no measurement exists yet for the given station</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>存在しないステーションがクエリされたか、指定されたステーションに測定がまだ存在しないため、値が見つかりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also create the method's return type in the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、メソッドの戻り値の型もファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java` に作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also create `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStationData.java`, which represents the actual aggregation result for a weather station:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、気象台の実際の集計結果を表す `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStationData.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now can add a simple REST endpoint (`aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/WeatherStationEndpoint.java`), which invokes `getWeatherStationData()` and returns the data to the client:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、 `getWeatherStationData()` を呼び出してクライアントにデータを返すシンプルな REST エンドポイント ( `aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/WeatherStationEndpoint.java` ) を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on whether a value was obtained, either return that value or a 404 response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値が取得されたかどうかに応じて、その値を返すか、404 レスポンスを返すかのどちらかを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this code in place, it's time to rebuild the application and the `aggregator` service in Docker Compose:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコードを用意して、Docker Composeでアプリケーションと `aggregator` サービスをリビルドしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will rebuild the `aggregator` container and restart its service.  Once that's done, you can invoke the service's REST API to obtain the temperature data for one of the existing stations.  To do so, you can use `httpie` in the tooling container launched before:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `aggregator` コンテナーが再構築され、サービスが再起動されます。これが完了したら、サービスの REST API を呼び出して、既存のステーションの 1 つの温度データを取得することができます。そのためには、前に起動したツーリングコンテナで `httpie` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scaling Out</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケールアウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very interesting trait of Kafka Streams applications is that they can be scaled out, i.e. the load and state can be distributed amongst multiple application instances running the same pipeline.  Each node will then contain a subset of the aggregation results, but Kafka Streams provides you with https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html#querying-remote-state-stores-for-the-entire-app[an API] to obtain the information which node is hosting a given key.  The application can then either fetch the data directly from the other instance, or simply point the client to the location of that other node.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Streams の非常に興味深い特性は、それらがスケールアウト可能であるということです。つまり、同じパイプラインを実行している複数のアプリケーションインスタンス間で負荷や状態を分散させることができます。各ノードには集約結果のサブセットが含まれますが、Kafka Streams は与えられたキーをホストしているノードの情報を取得するための link:https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html#querying-remote-state-stores-for-the-entire-app[API] を提供しています。アプリケーションは、他のインスタンスから直接データを取得するか、クライアントにその他のノードの場所を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launching multiple instances of the `aggregator` application will make look the overall architecture like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`aggregator` アプリケーションの複数のインスタンスを起動すると、全体のアーキテクチャがこのようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `InteractiveQueries` class must be adjusted slightly for this distributed architecture:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`InteractiveQueries` クラスは、この分散型アーキテクチャ用に少し調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The streams metadata for the given weather station id is obtained</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与えられたウェザーステーションIDのストリームメタデータが取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The given key (weather station id) is maintained by the local application node, i.e. it can answer the query itself</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与えられたキー(ウェザーステーションID)はローカルのアプリケーションノードによって管理されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The given key is maintained by another application node; in this case the information about that node (host and port) will be returned</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与えられたキーは別のアプリケーションノードによって管理されています; この場合、そのノードに関する情報(ホストとポート)が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `getMetaData()` method is added to provide callers with a list of all the nodes in the application cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getMetaData()` メソッドが追加され、アプリケーション・クラスター内の全ノードのリストを呼び出し元に提供するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GetWeatherStationDataResult` type must be adjusted accordingly:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GetWeatherStationDataResult` のタイプは、それに合わせて調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also the return type for `getMetaData()` must be defined (`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `getMetaData()` のリターンタイプも定義しなければなりません ( `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the REST endpoint class must be updated:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、RESTエンドポイントクラスを更新する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The data was found locally, so return it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データはローカルで見つかったので、それを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The data is maintained by another node, so reply with a redirect (HTTP status code 303) if the data for the given key is stored on one of the other nodes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データは他のノードで管理されているので、指定されたキーのデータが他のノードに保存されている場合は、リダイレクト(HTTPステータスコード303)で返信する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No data was found for the given weather station id</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指定されたウェザーステーションIDに対するデータが見つからなかった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exposes information about all the hosts forming the application cluster</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションクラスターを形成しているすべてのホストの情報を表示する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now stop the `aggregator` service again and rebuild it.  Then let's spin up three instances of it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで再び `aggregator` サービスを停止してリビルドします。そして、3つのインスタンスを起動してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When invoking the REST API on any of the three instances, it might either be that the aggregation for the requested weather station id is stored locally on the node receiving the query, or it could be stored on one of the other two nodes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>3つのインスタンスのいずれかでREST APIを呼び出す場合、要求されたウェザーステーションIDの集約は、クエリを受信したノードにローカルに格納されるか、他の2つのノードのいずれかに格納されるかのどちらかであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the load balancer of Docker Compose will distribute requests to the `aggregator` service in a round-robin fashion, we'll invoke the actual nodes directly.  The application exposes information about all the host names via REST:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Docker Composeのロードバランサーがラウンドロビン方式で `aggregator` サービスにリクエストを配信するので、実際のノードを直接呼び出すことにします。アプリケーションはREST経由ですべてのホスト名の情報を公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the data from one of the three hosts shown in the response (your actual host names will differ):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レスポンスに表示されている 3 つのホストのうちの 1 つからデータを取得します (実際のホスト名は異なります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If that node holds the data for key "1", you'll get a response like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのノードがキー「1」のデータを保持している場合は、このようなレスポンスが得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, the service will send a redirect:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そうでない場合、サービスはリダイレクトを送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also have _httpie_ automatically follow the redirect by passing the `--follow option`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `--follow option` を渡すことで _httpie_ が自動的にリダイレクトに従うようにすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Natively</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension for Kafka Streams enables the execution of stream processing applications natively via GraalVM without further configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Streams用のQuarkusエクステンションを使用すると、GraalVMを介してストリーム処理アプリケーションをネイティブ実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run both the `producer` and `aggregator` applications in native mode, the Maven builds can be executed using the `native` profile:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`producer` と `aggregator` アプリケーションをネイティブモードで実行するには、 `native` プロファイルを使用して Maven ビルドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create an environment variable named `QUARKUS_MODE` and with value set to "native":</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `QUARKUS_MODE` という名前の環境変数を作成し、値を"native"に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is used by the Docker Compose file to use the correct `Dockerfile` when building the `producer` and `aggregator` images.  The Kafka Streams application can work with less than 50 MB RSS in native mode.  To do so, add the `Xmx` option to the program invocation in `aggregator/src/main/docker/Dockerfile.native`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、 `producer` と `aggregator` のイメージをビルドする際に正しい `Dockerfile` を使用するために Docker Compose ファイルで使用されます。Kafka Streams アプリケーションは、ネイティブモードでは 50 MB 未満の RSS で動作します。そのためには、 `aggregator/src/main/docker/Dockerfile.native` のプログラム呼び出しに `Xmx` オプションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now start Docker Compose as described above (don't forget to rebuild the container images).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、上記のようにDocker Composeを起動します(コンテナーイメージのリビルドを忘れずに)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka-streams` will automatically add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` のエクステンションを使用している場合は、 `quarkus-kafka-streams` が自動的に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a readiness health check to validate that all topics declared in the `quarkus.kafka-streams.topics` property are created,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kafka-streams.topics` プロパティーで宣言されたすべてのトピックが作成されているかどうかを検証するための Readiness ヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a liveness health check based on the Kafka Streams state.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Streams の状態に基づく Liveness ヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health` endpoint of your application you will have information about the state of the Kafka Streams and the available and/or missing topics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、アプリケーションの `/q/health` エンドポイントにアクセスすると、Kafka Streams の状態や、利用可能なトピックや不足しているトピックについての情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example of when the status is `DOWN`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ステータスが `DOWN` になった場合の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liveness health check. Also available at `/q/health/live` endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liveness ヘルスチェック。 `/q/health/live` エンドポイントでも利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Readiness health check. Also available at `/q/health/ready` endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Rediness ヘルスチェック。 `/q/health/ready` エンドポイントでも利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So as you can see, the status is `DOWN` as soon as one of the `quarkus.kafka-streams.topics` is missing or the Kafka Streams `state` is not `RUNNING`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、ご覧のように `quarkus.kafka-streams.topics` のいずれかが欠けているか、Kafka Streams の `state` が `RUNNING` でないとすぐにステータスが `DOWN` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no topics are available, the `available_topics` key will not be present in the `data` field of the `Kafka Streams topics health check`.  As well as if no topics are missing, the `missing_topics` key will not be present in the `data` field of the `Kafka Streams topics health check`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トピックがない場合、 `Kafka Streams topics health check` .の `data` フィールドに `available_topics` キーは表示されません。また、トピックがない場合は、 `Kafka Streams topics health check` の `data` フィールドに `missing_topics` キーは表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can of course disable the health check of the `quarkus-kafka-streams` extension by setting the `quarkus.kafka-streams.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もちろん、 `quarkus-kafka-streams` エクステンションのヘルスチェックを無効にすることもできます。`application.properties` の中で `quarkus.kafka-streams.health.enabled` を `false` にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously you can create your liveness and readiness probes based on the respective endpoints `/q/health/live` and `/q/health/ready`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>言うまでもなく、それぞれのエンドポイント `/q/health/live` と `/q/health/ready` に対して自前の Liveness および Rediness プローブを作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the liveness check:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Liveness チェックの一例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `state` is coming from the `KafkaStreams.State` enum.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`state` は `KafkaStreams.State` Enum から来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the readiness check:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、Rediness チェックの一例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going Further</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can build stream processing applications using Quarkus and the Kafka Streams APIs, both in JVM and native modes.  For running your KStreams application in production, you could also add health checks and metrics for the data pipeline.  Refer to the Quarkus guides on link:micrometer[Micrometer], link:smallrye-metrics[SmallRye Metrics], and link:smallrye-health[SmallRye Health] to learn more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusとKafka Streams APIを使用して、JVMとネイティブモードの両方でストリーム処理アプリケーションを構築する方法を紹介しました。KStreamsアプリケーションを本番環境で実行するために、データパイプラインのヘルスチェックやメトリクスを追加することもできます。詳細については、 link:micrometer[Micrometer] 、 link:smallrye-metrics[SmallRye Metrics] 、 link:smallrye-health[SmallRye Health] に関するQuarkusのガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a gRPC Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a gRPC service requires the gRPC classes to be generated.  Place your `proto` files in `src/main/proto` and run `mvn compile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC サービスを実装するには、gRPC クラスを生成する必要があります。 `proto` ファイルを `src/main/proto` に置き、 `mvn compile` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, all the methods from a gRPC service run on the event loop.  As a consequence, you must **not** block.  If your service logic must block, annotate the method with `io.smallrye.common.annotation.Blocking`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、gRPCサービスからのすべてのメソッドはイベントループ上で実行されます。そのため、ブロックしては *いけません* 。サービスロジックをブロックする必要がある場合は、メソッドに `io.smallrye.common.annotation.Blocking` アノテーションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC allows receiving and returning streams:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCでは、ストリームを受信して返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Mutiny, you can implement these as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyを使うと、以下のように実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the implemented services, Quarkus gRPC exposes health information in the following format:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装されたサービスでは、Quarkus gRPCは以下の形式でヘルスチェックを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clients can specify the fully qualified service name to get the health status of a specific service or skip specifying the service name to get the general status of the gRPC server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントは、特定のサービスのヘルス状態を取得するために完全修飾されたサービス名を指定したり、gRPCサーバーの一般的な状態を取得するためにサービス名の指定を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details, check out the https://github.com/grpc/grpc/blob/v1.28.1/doc/health-checking.md[gRPC documentation]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:https://github.com/grpc/grpc/blob/v1.28.1/doc/health-checking.md[gRPCのドキュメント] を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, if Quarkus SmallRye Health is added to the application, a readiness check for the state of the gRPC services will be added to the MicroProfile Health endpoint response, that is `/q/health`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、Quarkus SmallRye Healthがアプリケーションに追加された場合、gRPCサービスの状態に関するレディネスチェックがMicroProfile Healthエンドポイントレスポンスに追加されます( `/q/health` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reflection Service</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクションサービス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus gRPC Server implements the https://github.com/grpc/grpc/blob/master/doc/server-reflection.md[reflection service].  This service allows tools like https://github.com/fullstorydev/grpcurl[grpcurl] or https://github.com/gusaul/grpcox[grpcox] to interact with your services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus gRPC Serverは、 link:https://github.com/grpc/grpc/blob/master/doc/server-reflection.md[リフレクションサービス] を実装しています。このサービスを使用すると、 link:https://github.com/fullstorydev/grpcurl[grpcurl] や link:https://github.com/gusaul/grpcox[grpcox] などのツールがサービスと対話できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reflection service is enabled by default in _dev_ mode.  In test or production mode, you need to enable it explicitly by setting `quarkus.grpc.server.enable-reflection-service` to `true`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リフレクションサービスは、 _開発_ モードではデフォルトで有効になっています。テストモードやプロダクションモードでは、 `quarkus.grpc.server.enable-reflection-service` を `true` に設定して明示的に有効にする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scaling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケーリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, quarkus-grpc starts a single gRPC server running on a single event loop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、quarkus-grpcは単一のイベントループ上で動作する単一のgRPCサーバーを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to scale your server, you can set the number of server instances by setting `quarkus.grpc.server.instances`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーをスケールさせたい場合は、 `quarkus.grpc.server.instances` を設定することで、サーバーのインスタンス数をセットできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable TLS, use the following configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TLSを有効にするには、以下の設定を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that all paths in the configuration may either specify a resource on the classpath (typically from `src/main/resources` or its subfolder) or an external file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定のすべてのパスは、クラスパス上のリソース (通常は `src/main/resources` やそのサブフォルダーから) か外部ファイルを指定することに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Server Interceptors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーインターセプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can implement a gRPC server interceptor by implementing an `@ApplicationScoped` bean implementing `io.grpc.ServerInterceptor`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.grpc.ServerInterceptor` を実装した `@ApplicationScoped` Beanを実装することで、gRPC サーバーのインターセプターを実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the https://grpc.github.io/grpc-java/javadoc/io/grpc/ServerInterceptor.html[ServerInterceptor JavaDoc] to properly implement your interceptor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://grpc.github.io/grpc-java/javadoc/io/grpc/ServerInterceptor.html[ServerInterceptor JavaDoc] をチェックして、インターセプターを適切に実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have multiple server interceptors, you can order them by implementing the `javax.enterprise.inject.spi.Prioritized` interface:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のサーバーインターセプターがある場合は、 `javax.enterprise.inject.spi.Prioritized` インターフェイスを実装することで、それらを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>source, java]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>source, java]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - JGit</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - JGit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `jgit` extension which enables the use of https://www.eclipse.org/jgit/[Eclipse JGit] in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、ネイティブモードでの link:https://www.eclipse.org/jgit/[Eclipse JGit]の使用を可能にする `jgit` エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `jgit` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで次のコマンドを実行して、 `jgit` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://wiki.eclipse.org/JGit/User_Guide#API[JGit] dependency is resolved transitively when the extension is added to your project.  Here is an example using it in a JAX-RS endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://wiki.eclipse.org/JGit/User_Guide#API[JGit]依存関係は、エクステンションがプロジェクトに追加されたときに推移的に解決されます。ここでは、JAX-RS エンドポイントでの使用例を示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in native mode, make sure that the link:native-and-ssl#the-truststore-path[SSL access is configured correctly].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードで実行する場合は、 link:native-and-ssl#the-truststore-path[SSLアクセスが正しく設定されていること]を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDBは広く使われているNoSQLデータベースとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use the MongoDB database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスでMongoDBデータベースを使用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements are stored in MongoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要素はMongoDBに格納されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, Mutiny, Context Propagation and MongoDB Client extensions.  After this, the quarkus-mongodb-client extension has been added to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、Mutiny、Context Propagation、MongoDBクライアントエクステンションをインポートするMaven構造を生成します。この後、quarkus-mongodb-client エクステンションが `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `mongodb-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `mongodb-client` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.mongodb.FruitService` that will be the business layer of our application and store/load the fruits from the mongoDB database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今、私たちのアプリケーションのビジネス層となる `org.acme.mongodb.FruitService` を作成し、mongoDB データベースからフルーツを保存/ロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.mongodb.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `org.acme.mongodb.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main property to configure is the URL to access to MongoDB, almost all configuration can be included in the connection URI so we advise you to do so, you can find more information in the MongoDB documentation: https://docs.mongodb.com/manual/reference/connection-string/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定する主なプロパティーは MongoDB にアクセスするための URL です。ほとんどすべての設定は接続 URI に含めることができるので、そうすることをお勧めします : https://docs.mongodb.com/manual/reference/connection-string/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need more configuration properties, there is a full list at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の設定プロパティーが必要な場合は、このガイドの最後に完全なリストがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple MongoDB Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のMongoDBクライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDBでは、複数のクライアントを設定することができます。複数のクライアントを使っても、単一のクライアントを持つのと同じように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `users` and `inventory` segments).  The syntax is as follows: `quarkus.mongodb.[optional name.][mongo connection property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キーに余分なビットがあることに注意してください ( `users` と `inventory` のセグメント)。構文は以下の通りです。 `quarkus.mongodb.[optional name.][mongo connection property]` .名前を省略すると、デフォルトのクライアントを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use of multiple MongoDB clients enables multi-tenancy for MongoDB by allowing to connect to multiple MongoDB clusters. + If you want to connect to multiple databases inside the same cluster, multiple clients are **not** necessary as a single client is able to access all databases in the same cluster (like a JDBC connection is able to access to multiple schemas inside the same database).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の MongoDB クライアントを使うことで、複数の MongoDB クラスターに接続できるようになり、MongoDB のマルチテナンシーが可能になります。+ 同じクラスター内の複数のデータベースに接続したい場合は、(JDBC接続が同じデータベース内の複数のスキーマにアクセスできるように) 1つのクライアントで同じクラスター内のすべてのデータベースにアクセスできるので、複数のクライアントは必要あり *ません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Mongo client Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前付きMongoクライアントの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, each `MongoClient`, you can select the client to inject using the `io.quarkus.mongodb.MongoClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のクライアントを使用する場合、各 `MongoClient` は、 `io.quarkus.mongodb.MongoClientName` の修飾子を使用して注入するクライアントを選択できます。上記のプロパティーを使用して、以下のように3つの異なるクライアントを設定し、それぞれに注入することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As by default, `MongoClient` is configured to access a local MongoDB database on port 27017 (the default MongoDB port), if you have a local running database on this port, there is nothing more to do before being able to test it!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `MongoClient` はポート 27017 (デフォルトの MongoDB ポート) でローカルの MongoDB データベースにアクセスするように設定されています。このポートで実行されているローカルのデータベースがある場合は、他に何もする必要はありません!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Docker to run a MongoDB database, you can use the following command to launch one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dockerを使ってMongoDBデータベースを起動したい場合は、以下のコマンドで起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 `FruitResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的なリソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html]ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブな MongoDB クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A reactive MongoDB Client is included in Quarkus.  Using it is as easy as using the classic MongoDB Client.  You can rewrite the previous example to use it like the following.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブなMongoDBクライアントがQuarkusに含まれています。これを使うのは、古典的なMongoDBクライアントを使うのと同じくらい簡単です。先ほどの例を以下のように書き換えて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.mongodb.ReactiveMongoClient` client is deprecated and will be removed in the future.  It is recommended to switch to the `io.quarkus.mongodb.reactive.ReactiveMongoClient` client providing the `Mutiny` API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mongodb.ReactiveMongoClient` クライアントは非推奨であり、将来的には削除される予定です。 `Mutiny` API を提供する `io.quarkus.mongodb.reactive.ReactiveMongoClient` クライアントに切り替えることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MongoDB reactive client uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB のリアクティブクライアントはMunityのリアクティブ型を使っています。 link:getting-started-reactive#mutiny[Reactive入門ガイド]を先にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using a Bson `Codec`, the MongoDB Client will take care of the transformation of your domain object to/from a MongoDB `Document` automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bson `Codec` を使用することで、MongoDB クライアントは自動的に MongoDB `Document` への/からドメインオブジェクトの変換の世話をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you need to create a Bson `Codec` that will tell Bson how to transform your entity to/from a MongoDB `Document`.  Here we use a `CollectibleCodec` as our object is retrievable from the database (it has a MongoDB identifier), if not we would have used a `Codec` instead.  More information in the codec documentation: https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、Bson `Codec` を作成する必要があります。これは、エンティティーを MongoDB `Document` に変換する方法を Bson に伝えます。ここでは `CollectibleCodec` を使用しています。私たちのオブジェクトはデータベースから取得可能なので (MongoDB の識別子を持っています)、そうでなければ `Codec` を使用しています。詳細はコーデックのドキュメントを参照ください: https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to create a `CodecProvider` to link this `Codec` to the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、この `Codec` を `Fruit` クラスにリンクさせるための `CodecProvider` を作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus takes care of registering the `CodecProvider` for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `CodecProvider` の登録を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, when getting the `MongoCollection` from the database you can use directly the `Fruit` class instead of the `Document` one, the codec will automatically map the `Document` to/from your `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、データベースから `MongoCollection` を取得するとき、 `Document` の代わりに `Fruit` クラスを直接使用することができます。コーデックは自動的に `Document` を `Fruit` クラスにマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of using a `MongoCollection` with the `FruitCodec`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これが、 `MongoCollection` を `FruitCodec` と使用する例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO Codec] provides a set of annotations that enable the customization of the way a POJO is mapped to a MongoDB collection and this codec is initialized automatically by Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://mongodb.github.io/mongo-java-driver/3.12/bson/pojos[POJO Codec] は、POJOをMongoDBコレクションにマッピングする方法をカスタマイズできるアノテーションのセットを提供しています。このCodecはQuarkusによって自動的に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of these annotations is the `@BsonDiscriminator` annotation that allows to storage multiple Java types in a single MongoDB collection by adding a discriminator field inside the document. It can be useful when working with abstract types or interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションのひとつに `@BsonDiscriminator` アノテーションがありますが、これは、ドキュメントの中にデリミタフィールドを追加することで、複数の Java 型をひとつの MongoDB コレクションに保存できるようにするものです。抽象的な型やインターフェイスを扱うときに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus will automatically register all the classes annotated with `@BsonDiscriminator` with the POJO codec.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `@BsonDiscriminator` でアノテーションされたすべてのクラスをPOJOコーデックで自動的に登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The POJO Codec have enhanced generic support via `PropertyCodecProvider`, Quarkus will automatically register any `PropertyCodecProvider` with the POJO Codec.  When building native executables and using generic types, you might need to register the type arguments for reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POJOコーデックは、 `PropertyCodecProvider` を介して強化されたジェネリックサポートを持っています。Quarkusは、任意の `PropertyCodecProvider` をPOJOコーデックで自動的に登録します。ネイティブ実行可能ファイルをビルドしてジェネリック型を使用する場合、リフレクションのために型引数を登録する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The link:mongodb-panache[MongoDB with Panache] extension facilitates the usage of MongoDB by providing active record style entities (and repositories) like you have in link:hibernate-orm-panache.html[Hibernate ORM with Panache] and focuses on making your entities trivial and fun to write in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:mongodb-panache[MongoDB with Panache] エクステンションは、 link:hibernate-orm-panache.html[Hibernate ORM with Panacheの] ようなアクティブなレコードスタイルのエンティティー(とリポジトリ)を提供することでMongoDBの使用を容易にし、エンティティーをQuarkusで書くのが簡単で楽しいものにすることに重点を置いています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-mongodb-client` will automatically add a readiness health check to validate the connection to the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、 `quarkus-mongodb-client` はクラスターへの接続を検証するためのReadinessヘルスチェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.mongodb.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、 `application.properties` で `quarkus.mongodb.health.enabled` プロパティーを `false` に設定することで無効にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-mongodb-client` can provide metrics about the connection pools.  This behavior must first be enabled by setting the `quarkus.mongodb.metrics.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-micrometer` または `quarkus-smallrye-metrics` エクステンションを使用している場合、 `quarkus-mongodb-client` は接続プールに関するメトリクスを提供することができます。この動作を有効にするには、まず `application.properties` の `quarkus.mongodb.metrics.enabled` プロパティーを `true` に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トレース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-opentracing` extension, `quarkus-mongodb-client` can register traces about the commands executed.  This behavior must be enabled by setting the `quarkus.mongodb.tracing.enabled` property to `true` in your `application.properties` and adding the dependency `io.opentracing.contrib:opentracing-mongo-common` to your pom.xml (for more info read the link:opentracing#mongodb-client[OpenTracing - MongoDB client] section).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-micrometer` または `quarkus-smallrye-metrics` エクステンションを使用している場合、 `quarkus-mongodb-client` はコネクションプールに関するメトリクスを提供することができます。この動作を有効にするには、まず `application.properties` の `quarkus.mongodb.tracing.enabled` プロパティーを `true` に設定し、pom.xml に `io.opentracing.contrib:opentracing-mongo-common` という依存関係を追加する必要があります（詳しくは link:opentracing#mongodb-client[OpenTracing - MongoDB client] セクションをご覧ください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read the link:opentracing[OpenTracing] guide, for how to configure OpenTracing and how to use the Jaeger tracer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTracingの設定方法やJaegerトレーサーの使用方法については、 link:opentracing[OpenTracing]ガイドをお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The legacy client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レガシークライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't include the legacy MongoDB client by default. It contains the now retired MongoDB Java API (DB, DBCollection,... )  and the `com.mongodb.MongoClient` that is now superseded by `com.mongodb.client.MongoClient`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトではレガシーな MongoDB クライアントは含まれていません。今では引退した MongoDB Java API (DB, DBCollection, ... ) と `com.mongodb.MongoClient` が含まれていますが、今では `com.mongodb.client.MongoClient` に取って代わられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the legacy API, you need to add the following dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レガシー API を使用したい場合は、以下の依存関係を `pom.xml` に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the MongoDB client in a native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDBクライアントをネイティブの実行ファイルで使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use SSL/TLS encryption, you need to add these properties in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SSL/TLS 暗号化を使用したい場合は、これらのプロパティを `application.properties` に追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then build a native executable with the usual command `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、いつものコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/mongodb-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行は `./target/mongodb-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Quarkus doesn't support the `mongodb+srv` protocol in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在、Quarkusはネイティブモードでは `mongodb+srv` プロトコルをサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[Client-Side Field Level Encryption] is also not supported in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.mongodb.com/manual/core/security-client-side-encryption/[クライアントサイドフィールドレベル暗号化] もネイティブモードではサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing a MongoDB database from a MongoDB Client is easy with Quarkus as it provides configuration and native support for it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDBクライアントからMongoDBデータベースにアクセスするのは、設定とネイティブサポートが提供されているのでQuarkusを使えば簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an elastically scalable in-memory data store that you can embed directly in your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanは、アプリケーションに直接埋め込むことができる拡張性の高いインメモリーデータストアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://infinispan.org/documentation/[Infinispan documentation] to find out more about the Infinispan project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispanプロジェクトの詳細については、Infinispanの link:https://infinispan.org/documentation/[ドキュメント] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command adds the following dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、以下の依存関係を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feature Support</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>機能サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension offers core caching functionality that includes clustered caches, off-heap memory, data persistence, and transactions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan Embeddedエクステンションは、クラスター化キャッシュ、オフヒープメモリー、データ永続化、トランザクションを含むコアキャッシング機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension does not currently support indexing capabilities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan Embeddedエクステンションは、現在のところインデックス機能をサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Infinispan caches for transactional operations with a specific `TransactionManagerLookup`, as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan キャッシュを特定の `TransactionManagerLookup` でトランザクション処理用に設定するには、以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, see the Quarkus link:transaction[Transaction Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、Quarkus link:transaction[トランザクションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Limitations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブの制限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running Infinispan in native mode, some limitations apply:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードでInfinispanを実行する場合、いくつかの制限が適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX management is not supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JMX管理には対応していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM does not allow native VM interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMは、ネイティブVMインターフェースを許可していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`UDP`/`Multicast` is not supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`UDP` / `Multicast` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must use `TCP` transport and a non-UDP based membership protocol with JGroups.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JGroupsでは、 `TCP` トランスポートと非UDPベースのメンバーシッププロトコルを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection (CDI)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクション(CDI)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension provides injection capabilities so you do not have to configure and start caches manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Infinispan Embeddedエクステンションはインジェクション機能を提供するので、手動でキャッシュを設定して起動する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional injection functionality will be available in future versions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のインジェクション機能は、将来のバージョンで利用可能になる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the main entry point to configure and obtain caches.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>キャッシュを設定したり取得したりするためのメインのエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX elements are disabled during native runtime so you can use the same configuration file in JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JMX要素はネイティブ実行時には無効化されるので、JVMとネイティブモードで同じ設定ファイルを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Contexts and Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Contexts and Dependency Injection</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution (also called ArC) is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.  However, it is not a full CDI implementation verified by the TCK.  Only a subset of the CDI features is implemented - see also &lt;&lt;supported_features,the list of supported features&gt;&gt; and &lt;&lt;limitations,the list of limitations&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の DI ソリューション (ArC とも呼ばれる) は、link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] 仕様に基づいています。しかし、TCK によって検証された CDI の完全な実装ではありません。CDI 機能のサブセットのみが実装されています。link:#supported_features[サポートされている機能の一覧] と link:#limitations[制限事項の一覧] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're new to CDI then we recommend you to read the link:cdi[Introduction to CDI] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI が初めての方は、最初に link:cdi[CDI の紹介] を読むことが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存の CDI コードのほとんどは問題なく動作するはずですが、Quarkus のアーキテクチャや目標との間には、わずかな相違点がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.  However, Quarkus is using a *simplified bean discovery*.  There is only single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window="_blank"] and no visibility boundaries.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI での Bean 検出は、レガシーなデプロイメント構造と、基礎となるモジュールアーキテクチャーのアクセシビリティ要件を含む複雑なプロセスです。しかし、Quarkusは *簡素化された Bean 検出* を使用しています。link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[Bean 検出モード `annotated`, window="_blank"] と可視性の境界線がない単一の Bean アーカイブのみが存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean archive is synthesized from:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean のアーカイブは、次のものから合成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dependencies that contain a `beans.xml` descriptor (content is ignored),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`beans.xml` 記述子を含む依存関係 (内容は無視される)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dependencies that contain a Jandex index - `META-INF/jandex.idx`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jandex インデックスを含む依存関係 (`META-INF/jandex.idx`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dependencies referenced by `quarkus.index-dependency` in `application.properties`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` の `quarkus.index-dependency` で参照される依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and Quarkus integration code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の統合コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window="_blank"] are not discovered.  This behavior is defined by CDI.  But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).  In fact, the declaring bean classes are considered annotated with `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[Bean 定義アノテーション, window="_blank"] を持たない Bean クラスは検出されない。この動作は CDI で定義されています。しかし、producer  メソッドやフィールド、observer  メソッドは、宣言クラスが Bean 定義アノテーションを持たない場合でも検出されます (この動作は CDI で定義されているものとは異なります)。実際には、宣言 Bean クラスは `@Dependent` でアノテートされていると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus エクステンションは、追加のディスカバリールールを宣言することができます。たとえば、`@Scheduled` ビジネスメソッドは、宣言するクラスが Bean 定義アノテーションでアノテーションされていなくても登録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dependency with a Jandex index is automatically scanned for beans.  To generate the index just add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jandex インデックスを持つ依存関係は、自動的に Bean をスキャンします。インデックスを生成するには、以下を `pom.xml` に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are are using gradle, you can apply the following plugin to your `build.gradle`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gradle を使っている場合は、以下のプラグインを `build.gradle` に適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係を変更できなくても、`quarkus.index-dependency` エントリーを `application.properties` に追加することでインデックスを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.index-dependency.&lt;name&gt;.group-id=
quarkus.index-dependency.&lt;name&gt;.artifact-id=
quarkus.index-dependency.&lt;name&gt;.classifier=(this one is optional)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.index-dependency.&lt;name&gt;.group-id=
quarkus.index-dependency.&lt;name&gt;.artifact-id=
quarkus.index-dependency.&lt;name&gt;.classifier=(this one is optional)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、次のエントリーは、`org.acme:acme-api` 依存関係が確実にインデックス化されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.properties の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.index-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.index-dependency.acme.artifact-id=acme-api &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.index-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.index-dependency.acme.artifact-id=acme-api &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value is a group id for a dependency identified by name `acme`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値 `acme` は、名前で識別される依存関係のグループ ID です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value is an artifact id for a dependency identified by name `acme`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値は、名前 `acme` で識別される依存関係のアーティファクト ID です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How To Exclude Types and Dependencies from Discovery</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ディスカバリーから型と依存関係を除外する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It may happen that some beans from third-party libraries do not work correctly in Quarkus.  A typical example is a bean injecting a portable extension.  In such case, it's possible to exclude types and dependencies from the bean discovery.  The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サードパーティーのライブラリーからのいくつかの Bean が Quarkus で正しく動作しないことがあります。典型的な例は、ポータブル拡張機能を注入する Bean です。このような場合は、型や依存関係を Bean の検出から除外することができます。`quarkus.arc.exclude-types` プロパティーは、除外すべきクラスに一致するために使用される文字列値のリストを受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value Examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.Foo`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.Foo`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the fully qualified name of the class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスの完全修飾名と一致させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.*`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match classes with package `org.acme`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme` パッケージとクラスを一致させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.**`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.**`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match classes where the package starts with `org.acme`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パッケージが `org.acme` で始まるクラスを一致させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Bar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the simple name of the class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスのシンプルな名前に一致する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar &lt;1&gt;&lt;2&gt;&lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar &lt;1&gt;&lt;2&gt;&lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exclude the type `org.acme.Foo`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプ `org.acme.Foo` を除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exclude all types from the `org.acme` package.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme` パッケージからすべてのタイプを除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exclude all types whose simple name is `Bar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルな名前が `Bar` であるすべてのタイプを除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.  For example, because it contains a `beans.xml` descriptor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、除外しなければ Bean をスキャンする、依存関係のあるアーティファクトを除外することも可能です。たとえば、`beans.xml` 記述子を含んでいる場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.exclude-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.arc.exclude-dependency.acme.artifact-id=acme-services &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.arc.exclude-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.arc.exclude-dependency.acme.artifact-id=acme-services &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executables and Private Members</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルとプライベートメンバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is using GraalVM to build a native executable.  One of the limitations of GraalVM is the usage of https://github.com/oracle/graal/blob/master/substratevm/Limitations.md#reflection[Reflection, window="_blank"].  Reflective operations are supported but all relevant members must be registered for reflection explicitly.  Those registrations result in a bigger native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、GraalVM を使用してネイティブ実行ファイルを構築しています。GraalVM の制限事項の 1 つは、link:https://github.com/oracle/graal/blob/master/substratevm/Limitations.md#reflection[リフレクション, window="_blank"] の使用です。リフレクション操作はサポートされていますが、関連するすべてのメンバーを明示的にリフレクション用に登録する必要があります。これらの登録は、より大きなネイティブ実行ファイルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And if Quarkus DI needs to access a private member it *has to use reflection*.  That's why Quarkus users are encouraged __not to use private members__ in their beans.  This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers and interceptor methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Quarkus DI がプライベートメンバーにアクセスする必要がある場合は、**リフレクションを使用しなければなりません**。そのため、Quarkus ユーザーは、プライベートメンバーを Bean で _使用しないこと_ が推奨されています。これには、インジェクションフィールド、コンストラクターとイニシャライザー、observer メソッド、producer メソッドおよび producer フィールド、disposers メソッドおよび interceptor メソッドが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to avoid using private members? You can use package-private modifiers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プライベートメンバーの使用を回避するには、package-private 修飾子を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class CounterBean {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped
public class CounterBean {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    CounterService counterService; &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    CounterService counterService; &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    void onMessage(@Observes Event msg) { &lt;2&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    void onMessage(@Observes Event msg) { &lt;2&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package-private injection field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package-private injection フィールド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package-private observer method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package-private observer メソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or constructor injection:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいはコンストラクターの注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private CounterService service;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    private CounterService service;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    CounterBean(CounterService service) { &lt;1&gt;
      this.service = service;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    CounterBean(CounterService service) { &lt;1&gt;
      this.service = service;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package-private constructor injection. `@Inject` is optional in this particular case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パッケージプライベートコンストラクター挿入。この特定の場合、`@Inject` は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされている機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@PostConstruct` and `@PreDestroy` lifecycle callbacks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライフサイクルコールバック `@PostConstruct` および `@PreDestroy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods and fields, disposers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>producer のメソッドおよびフィールド、ディスポーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualifiers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatives</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代替品</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stereotypes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステレオタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection and lookup</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係の注入とルックアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Field, constructor and initializer/setter injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィールド、コンストラクター、イニシャライザー/セッター挿入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe resolution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプセーフ解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic lookup via `javax.enterprise.inject.Instance`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.Enterprise.inject.instance` を介したプログラムによる検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントのプロキシー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection point metadata</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>挿入点メタデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scopes and contexts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スコープとコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom scopes and contexts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムスコープとコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business method interceptors: `@AroundInvoke`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスメソッドインターセプタ―: `@AroundInvoke`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors for lifecycle event callbacks: `@PostConstruct`, `@PreDestroy`, `@AroundConstruct`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライフサイクルイベントコールバックのためのインターセプター: `@PostConstruct`、`@PreDestroy`、`@AroundConstruct`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events and observer methods, including asynchronous events and transactional observer methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期イベントとトランザクションオブザーバーメソッドを含むイベントとオブザーバーメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ConversationScoped` is not supported</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ConversationScoped` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Portable Extensions are not supported</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ポータブル拡張機能はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`BeanManager` - only the following methods are implemented: `getBeans()`, `createCreationalContext()`, `getReference()`, `getInjectableReference()` , `resolve()`, `getContext()`, `fireEvent()`, `getEvent()` and `createInstance()`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`BeanManager` - メソッドでは、`getBeans()`、`createCreationalContext()`、`getReference()`、`getInjectableReference()`、`resolve()`、`getContext()`、`fireEvent()`、`getEvent()`、および `createInstance()` のみが実装されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specialization is not supported</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>専門性はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`beans.xml` descriptor content is ignored</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`beans.xml` 記述子の内容は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passivation and passivating scopes are not supported</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パッシベーションおよびパッシベーションスコープはサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptor methods on superclasses are not implemented yet</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スーパークラスのインターセプターメソッドは実装されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Interceptors` is not supported</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Interceptors` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-standard Features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準外の機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy By Default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトではレイジー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, CDI beans are created lazily, when needed.  What exactly "needed" means depends on the scope of a bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、CDI Bean は必要なときに作成されます。何を正確に「必要とされる」かは、Bean のスコープに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>挿入されたインスタンス (仕様による文脈参照) からメソッドが呼び出される場合は、*通常のスコープ付き Bean* (`@ApplicationScoped`、`@RequestScoped` など) が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>言い換えれば、通常のスコープ付き Bean を挿入しても、Bean のコンテキストインスタンスの代わりに _クライアントプロキシー_ が挿入されるため、十分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>挿入時に *疑似スコープを持つ Bean* (`@Dependent` および `@Singleton`) が作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy Instantiation Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>遅延インスタンス化の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Singleton // =&gt; pseudo-scope
class AmazingService {
  String ping() {
    return "amazing";
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Singleton // =&gt; pseudo-scope
class AmazingService {
  String ping() {
    return "amazing";
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped // =&gt; normal scope
class CoolService {
  String ping() {
    return "cool";
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped // =&gt; normal scope
class CoolService {
  String ping() {
    return "cool";
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/ping")
public class PingResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/ping")
public class PingResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject
  AmazingService s1; &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Inject
  AmazingService s1; &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject
  CoolService s2; &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Inject
  CoolService s2; &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @GET
  public String ping() {
    return s1.ping() + s2.ping(); &lt;3&gt;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @GET
  public String ping() {
    return s1.ping() + s2.ping(); &lt;3&gt;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection triggers the instantiation of `AmazingService`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>挿入は、`AmazingService` のインスタンス化をトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクション自体は、`CoolService` のインスタンス化にはなりません。クライアントプロキシーが挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first invocation upon the injected proxy triggers the instantiation of `CoolService`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>挿入されたプロキシーに対する最初の呼び出しは、`CoolService` のインスタンス化をトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Startup Event</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタートアップイベント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if you really need to instantiate a bean eagerly you can:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ただし、Bean の性急なインスタンス化が必要な場合は、次のことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`StartupEvent` のオブザーバーを宣言します。この場合、Bean のスコープは重要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
class CoolService {
  void startup(@Observes StartupEvent event) { &lt;1&gt;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped
class CoolService {
  void startup(@Observes StartupEvent event) { &lt;1&gt;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `CoolService` is created during startup to service the observer method invocation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CoolService` は、起動時に作成され、オブザーバーメソッドの呼び出しを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in &lt;&lt;lazy_by_default&gt;&gt;:    
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`StartupEvent` のオブザーバーで Bean を使用します。link:#lazy_by_default[lazy_by_default] の説明に従って、通常のスコープ付き Bean を使用する必要があります。    
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Dependent
class MyBeanStarter {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Dependent
class MyBeanStarter {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { &lt;1&gt;
    cool.toString(); &lt;2&gt;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { &lt;1&gt;
    cool.toString(); &lt;2&gt;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `AmazingService` is created during injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AmazingService` は注入時に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CoolService` is a normal scoped bean so we have to invoke a method upon the injected proxy to force the instantiation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CoolService` は通常のスコープ付き Bean であるため、強制的にインスタンス化するために挿入されたプロキシーにメソッドを呼び出さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotate the bean with `@io.quarkus.runtime.Startup` as described in link:lifecycle#startup_annotation[Startup annotation]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:lifecycle#startup_annotation[スタートアップアノテーション] で説明したように、`@io.quarkus.runtime.Startup` で Bean をアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Startup // &lt;1&gt;
@ApplicationScoped
public class EagerAppBean {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Startup // &lt;1&gt;
@ApplicationScoped
public class EagerAppBean {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the link:lifecycle[Application Initialization and Termination] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus ユーザーは、link:lifecycle[アプリケーションの初期化と終了] のガイドで説明されているように、常に `@Initialized(ApplicationScoped.class)` よりも `@Observes StartupEvent` を選択することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request Context Lifecycle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストコンテキストのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request context is also active:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストコンテキストもアクティブになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>during notification of a synchronous observer method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同期オブザーバメソッドの通知中に</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request context is destroyed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストコンテキストは破棄されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>after the observer notification completes for an event, if it was not already active when the notification started.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通知が開始したときにまだアクティブではなかった場合はイベントのオブザーバー通知が完了した後</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オブザーバー通知のためにリクエストコンテキストが初期化されると、修飾子 `@Initialized(RequestScoped.class)` を持つイベントが発生します。さらに、修飾子 `@BeforeDestroyed(RequestScoped.class)` および `@Destroyed(RequestScoped.class)` を持つイベントは、リクエストコンテキストが破棄されたときに発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualified Injected Fields</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>修飾された注入フィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI では、フィールド注入ポイントを宣言する場合は `@Inject` と任意で修飾子のセットを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject
  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Inject
  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、注入されたフィールドが少なくとも 1 つの修飾子を宣言している場合は、`@Inject` アノテーションを完全にスキップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>後述する特別なケースを除いて、コンストラクターとメソッドの注入には `@Inject` が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Constructor Injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡略化されたコンストラクター注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).  However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI では、通常のスコープ付き Bean は常に no-args コンストラクターを宣言しなければなりません (このコンストラクターは、他のコンストラクターを宣言しない限り、通常はコンパイラーによって生成されます)。しかし、この要件はコンストラクターの注入を複雑にします。CDI で動作させるためにはダミーの no-args コンストラクターを提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class MyCoolService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped
public class MyCoolService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  private SimpleProcessor processor;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  private SimpleProcessor processor;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  MyCoolService() { // dummy constructor needed
  }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  MyCoolService() { // dummy constructor needed
  }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject // constructor injection
  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Inject // constructor injection
  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.  Also if there's only one constructor there is no need for `@Inject`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、通常のスコープ付き Bean のためにダミーのコンストラクターを宣言する必要はありません。自動的に生成されます。また、コンストラクターが 1 つしかない場合は、`@Inject` の必要性はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>no-args コンストラクターを宣言していないクラスを Bean クラスが継承している場合は、no-args コンストラクターは自動的に生成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removing Unused Beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>未使用の Bean の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container attempts to remove all unused beans during build by default.  This optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーは、デフォルトではビルド中に未使用の Bean をすべて削除しようとします。この最適化は、`quarkus.arc.remove-unused-beans` を `none` または `false` に設定することで無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An unused bean:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>未使用の Bean:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not a built-in bean or an interceptor,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルトイン Bean でもインターセプターでもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not eligible for injection to any injection point,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任意の注入点への注入の対象とはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not excluded by any extension,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どのような拡張機能を用いても除外されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>does not have a name,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>does not declare an observer,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オブザーバーを宣言しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>does not declare any producer which is eligible for injection to any injection point,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任意の注入ポイントへの注入対象となるプロデューサーを宣言しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not directly eligible for injection into any `javax.enterprise.inject.Instance` or `javax.inject.Provider` injection point</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.enterprise.inject.Instance` または `javax.inject.Provider` の注入ポイントに直接注入することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This optimization applies to all forms of bean declarations: bean class, producer method, producer field.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この最適化は、Bean クラス、プロデューサーメソッド、プロデューサーフィールドなど、Bean 宣言のすべての形式に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `io.quarkus.arc.Unremovable`.  This annotation can be placed on the types, producer methods, and producer fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーは、コンテナーに `io.quarkus.arc.Unremovable` をアノテーションすることで、(上で指定したルールをすべて満たしていても) 特定の Bean を削除しないように指示することができます。このアノテーションは、型、producer メソッド、producer フィールドに置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since this is not always possible, there is an option to achieve the same via `application.properties`.  The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは常に可能ではないので、`application.properties` を通して同じことを実現するオプションがあります。`quarkus.arc.unremovable-types` プロパティーは、Bean の名前やパッケージに基づいて一致させるための文字列値のリストを受け付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match beans where the package of the bean class is `org.acme`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean クラスのパッケージが `org.acme` である Bean に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match beans where the package of the bean class starts with `org.acme`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean クラスのパッケージが `org.acme` で開始する Bean に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the simple name of the bean class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean クラスのシンプルな名前に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, extensions can eliminate possible false positives by producing `UnremovableBeanBuildItem`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、エクステンションは `UnremovableBeanBuildItem` を生成することで、可能性のある誤検出を排除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, Quarkus provides a middle ground for the bean removal optimization where application beans are never removed whether or not they are unused, while the optimization proceeds normally for non application classes. To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、Quarkus では、アプリケーション Bean が未使用であるかどうかに関わらず削除されることはありませんが、アプリケーション以外のクラスについては通常通り最適化が行われるという、Bean 削除最適化のための妥協点を提供しています。このモードを使用するには、`quarkus.arc.remove-unused-beans` を `fwk` または `framework` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the dev mode (running `./mvnw clean compile quarkus:dev`), you can see more information about which beans are being removed by enabling additional logging via the following line in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードを使用する場合 (`./mvnw clean compile quarkus:dev`) は、`application.properties` の次の行で追加のログを有効にすることで、削除されている Bean に関する詳細情報を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."io.quarkus.arc.processor".level=DEBUG
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.category."io.quarkus.arc.processor".level=DEBUG
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)  This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、CDI が現在サポートしていない機能を追加します。これは、利用可能な手段 (Beanクラス、producer、合成 Bean など) で同等の型と修飾子を持つ他の Bean が宣言されていない場合に、条件付きで Bean を宣言することです。これは、`@io .quarkus.Arc.DefaultBean` アノテーションを使用して行われ、例を挙げて説明するのが最善です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Say there is a Quarkus extension that among other things declares a few CDI beans like the following code does:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコードのようにいくつかの CDI Bean を宣言する Quarkus エクステンションがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The idea is that the extension auto-configures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.  Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.  The only thing that would be needed in our application would be something like the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アイデアは、エクステンションがユーザーのために自動設定を行い、多くのボイラープレートを排除するということです。必要な場所であれば、`@Inject` を `Tracer` にすることができます。私たちのアプリケーションで、設定された `Tracer` を利用しようとする場合は、、カスタムの `Reporter` を提供するなど、少しカスタマイズする必要があります。アプリケーションで必要になるのは、次のようなものだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any way Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@DefaultBean` では、エクステンション (またはそのための他のコード) が Quarkus がサポートする何らかの方法でその型の Bean が提供されている場合、バックオフ中にデフォルトを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time profile is enabled, via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、CDI が現在サポートしていない機能を追加しました。これは、Quarkus のビルド時プロファイルが有効になっているときに条件付きで Bean を有効にするというもので、`@io.quarkus.arc.profile.IfBuildProfile` と `@io.quarkus.arc.profile.UnlessBuildProfile` のアノテーションを使用します。`@io.quarkus.arc.DefaultBean` と合わせて使用すると、これらのアノテーションにより、異なるビルドプロファイルに対して異なる Bean 構成を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine for instance that an application contains a bean named `Tracer`, which needs to be do nothing when in tests or dev-mode, but works in its normal capacity for the production artifact.  An elegant way to create such beans is the following:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、アプリケーションが `Tracer` という名前の Bean を含んでいるとします。この Bean は、テストや開発モードでは何もする必要はありませんが、本番の成果物に対しては通常の能力で動作します。このような Bean を作成する洗練された方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @IfBuildProfile("prod")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @IfBuildProfile("prod")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @DefaultBean
    public Tracer noopTracer() {
        return new NoopTracer();
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @DefaultBean
    public Tracer noopTracer() {
        return new NoopTracer();
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If instead, it is required that the `Tracer` bean also works in dev-mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりに、`Tracer` Bean も dev モードで動作し、デフォルトではテストのために何もしないことが要求される場合は、`@UnlessBuildProfile` が理想的です。コードは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @UnlessBuildProfile("test") // this will be enabled for both prod and dev build time profiles
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @UnlessBuildProfile("test") // this will be enabled for both prod and dev build time profiles
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時プロファイルは、`@IfBuildProfile` および `@UnlessBuildProfile` を使用した Bean 解決には影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has a specific value, via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotation.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, this annotation allow for the creation of different bean configurations for different build properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、CDI が現在サポートしていない機能を追加しました。これは、Quarkus のビルド時プロファイルが有効になっているときに条件付きで Bean を有効にするというもので、`@io.quarkus.arc.profile.IfBuildProfile` および `@io.quarkus.arc.profile.UnlessBuildProfile` のアノテーションを使用します。`@io.quarkus.arc.DefaultBean` と合わせて使用すると、これらのアノテーションにより、異なるビルドプロファイルに対して異なる Bean 構成を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scenario we mentioned above with `Tracer` could also be implemented in the following way:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Tracer` を使用して上で述べたシナリオも、以下のように実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @IfBuildProperty(name = "some.tracer.enabled", stringValue = "true")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @IfBuildProperty(name = "some.tracer.enabled", stringValue = "true")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代わりに、`some.tracer.enabled` プロパティーが `false` でない場合にのみ `RealTracer` Bean が使用されることが要求される場合は、`@UnlessBuildProperty` が理想的です。コードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @UnlessBuildProperty(name = "some.tracer.enabled", stringValue = "false")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Produces
    @UnlessBuildProperty(name = "some.tracer.enabled", stringValue = "false")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時に設定されたプロパティーは、 `@IfBuildProperty` を使用しても Bean の解決に全く影響しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declaring Selected Alternatives</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>選択された代替の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.  Quarkus has a simplified bean discovery and the content of `beans.xml` is ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI では、代替の Bean は、`@Priority` を使用してアプリケーションに対してグローバルに選択することも、`beans.xml` 記述子を使用した Bean アーカイブ用に選択することもできます。Quarkus には単純化された Bean 検出があり、`beans.xml`の内容は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The disadvantage of `@Priority` is that it has `@Target({ TYPE, PARAMETER })` and so it cannot be used for producer methods and fields.  To address this problem and to simplify the code Quarkus provides the `io.quarkus.arc.AlternativePriority` annotation.  It's basically a shortcut for `@Alternative` plus `@Priority`.  Additionally, it can be used for producers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Priority` の欠点は、`@Priority` には、`@Target({ TYPE, PARAMETER })` があるため、producer メソッドや producer  フィールドには使用できないことです。この問題に対処し、コードを単純化するために、Quarkus は `io.quarkus.arc.AlternativePriority` アノテーションを提供します。基本的には、`@Alternative` および `@Priority` のショートカットです。さらに、producer にも使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, it is also possible to select alternatives for an application using the unified configuration.  The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.  If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.  The priority declared via `@Priority` or `@AlternativePriority` is overridden.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ただし、統一された設定を使用して、アプリケーションの代替を選択することもできます。`quarkus.arc.selected-alternatives` プロパティーは、代替 Bean を照合するために使用される文字列値のリストを受け入れます。一致する値がある場合は、関連する Bean に `Integer#MAX_VALUE` の優先順位が使用されます。`@Priority` または `@AlternativePriority` で宣言された優先度は上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the fully qualified name of the bean class or the bean class of the bean that declares the producer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean クラス、または producer を宣言する Bean の Bean クラスの完全修飾名に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the simple name of the bean class or the bean class of the bean that declares the producer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean クラス、または producer を宣言する Bean の Bean クラスの単純名に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Producer Method Declaration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡略化された Producer メソッドの宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, a producer method must be always annotated with `@Produces`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI では、producer メソッドは常に `@Produces` とアノテーションされていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Producers {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>class Producers {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Produces
  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Produces
  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、producer メソッドにスコープ注釈、ステレオタイプ、または修飾子が付いている場合は、`@Produces` アノテーションを完全に省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interception of Static Methods </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>静的メソッドのインターセプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Interceptors specification is clear that _around-invoke_ methods must not be declared static.  However, this restriction was driven mostly by technical limitations.  And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.  It's possible to annotate a non-private static method with an interceptor binding:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターの仕様は、_around-invoke_ メソッドを静的宣言してはならないことは明らかです。しかし、この制限は、主に技術的な制限によって設定されました。Quarkus は追加のクラス変換を可能にするビルド時指向のスタックであるため、この制限は適用されなくなりました。インターセプタ―バインディングで非プライベートの静的メソッドに注釈を付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Services {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>class Services {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Logged &lt;1&gt;
  static BigDecimal computePrice(long amount) { &lt;2&gt;
    BigDecimal price;
    // Perform computations...
    return price;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Logged &lt;1&gt;
  static BigDecimal computePrice(long amount) { &lt;2&gt;
    BigDecimal price;
    // Perform computations...
    return price;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Logged` is an interceptor binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Logged` はインターセプターバインディングです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each method invocation is intercepted if there is an interceptor associated with `Logged`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各メソッドの呼び出しは、`Logged` に関連付けられたインターセプターがある場合に傍受されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>下位互換性の理由から *メソッドレベルのバインディング* のみが考慮されます (そうでないとクラスレベルのバインディングを宣言している Bean クラスの静的メソッドが突然傍受されてしまいます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Private static methods are never intercepted</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プライベートなスタティックメソッドは決して傍受されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore not all existing interceptors may behave correctly when intercepting static methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`InvocationContext#getTarget()` は明白な理由により `null` を返します。したがって、静的メソッドを傍受するときに既存のインターセプターがすべて正しく動作するとは限りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプターは `InvocationContext.getMethod()` を使用して静的メソッドを検出し、それに応じて動作を調整することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ability to handle 'final' classes and methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>final クラスとメソッドを処理する能力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation, which in turn means that interceptors and normal scoped beans don't work properly.  This situation is very common when trying to use CDI with alternative JVM languages like Kotlin where classes and methods are `final` by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常の CDI では、`final` としてマークされているクラス、または `final` メソッドを持つクラスは、プロキシー作成の対象になりません。これは、インターセプターと通常のスコープ Bean が正しく動作しないことを意味します。このような状況は、クラスおよびメソッドがデフォルトで `final`である Kotlin のような代替 JVM 言語で CDI を使用しようとするときに非常に一般的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、Quarkus では、`quarkus.arc.transform-unproxyable-classes` を `true` (デフォルト値) に設定すると、これらの制限を抑制することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container-managed Concurrency</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナー管理型の並行処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no standard concurrency control mechanism for CDI beans.  Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.  In that case it should be thread-safe.  You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.  Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.  Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI Bean の標準的な同時実行制御メカニズムはありません。それにもかかわらず、Bean インスタンスは、複数のスレッドから同時に共有およびアクセスすることができます。その場合は、スレッドセーフでなければなりません。標準の Java コンストラクト (`volatile`、`synchronized`、`ReadWriteLock` など) を使用するか、コンテナーに同時アクセスを制御させることができます。Quarkus は、`@io.quarkus.arc.Lock` と、このインターセプタ―バインディング用の組み込みインターセプターを提供します。傍受された Bean のコンテキストインスタンスに関連付けられた各インターセプターインスタンスは、公平でない順序付けポリシーを持つ `ReadWriteLock` を保持しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for "shared" scopes, e.g. `@Singleton` and `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.arc.Lock` は通常のインターセプターバインディングであるため、任意のスコープを持つ任意の Bean に使用することができます。しかし、特に「共有」スコープ、たとえば `@Singleton` や `@ApplicationScoped` に有益です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container-managed Concurrency Example</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナー管理された並行処理の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.arc.Lock;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.arc.Lock;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Lock &lt;1&gt;
@ApplicationScoped
class SharedService {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Lock &lt;1&gt;
@ApplicationScoped
class SharedService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  void addAmount(BigDecimal amount) {
    // ...changes some internal state of the bean
  }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  void addAmount(BigDecimal amount) {
    // ...changes some internal state of the bean
  }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) &lt;2&gt; &lt;3&gt;
  BigDecimal getAmount() {
    // ...it is safe to read the value concurrently
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) &lt;2&gt; &lt;3&gt;
  BigDecimal getAmount() {
    // ...it is safe to read the value concurrently
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has "exclusive access" and no concurrent invocations will be allowed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスで宣言された (`@Lock (Lock.type.Write)` にマッピングされる) `@Lock` は、任意のビジネスメソッドの呼び出しに対して Bean インスタンスをロックするようにコンテナーに指示します。つまり、クライアントには「排他アクセス」があり、同時呼び出しは許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Lock(Lock.Type.READ)` は、クラスレベルで指定された値を上書きします。これは、Bean のインスタンスが `@Lock(Lock.Type.WRITE)` によってロックされていない限り、任意の数のクライアントが同時にメソッドを呼び出すことができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also specify the "wait time". If it's not possible to acquire the lock in the given time a `LockException` is thrown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、「待ち時間」を指定することもできます。指定した時間内にロックを取得できない場合は `LockException` が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeatable interceptor bindings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>反復可能なインターセプターバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has limited support for `@Repeatable` interceptor binding annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、`@Repeatable` インターセプター結合アノテーションのサポートが制限されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.  Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.  This might be added in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプタ―をコンポーネントにバインドする場合は、メソッドに対して複数の `@Repeatable` アノテーションを宣言できます。インターセプター仕様との相互作用に関する未解決の質問があるため、クラスとステレオタイプで宣言された反復可能なインターセプターバインディングはサポートされていません。これは将来追加される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, suppose we have an interceptor that clears a cache.  The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.  If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、キャッシュをクリアするインターセプタ―があるとします。対応するインターセプタ―バインディングは `@CacheInvalidateAll` と呼ばれ、`@Repeatable` として宣言されます。同時に 2 つのキャッシュをクリアしたい場合は、`@CacheInvalidateAll` を 2 回追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
class CachingService {
  @CacheInvalidateAll(cacheName = "foo")
  @CacheInvalidateAll(cacheName = "bar")
  void heavyComputation() {
    // ...
    // some computation that updates a lot of data
    // and requires 2 caches to be invalidated
    // ...
  }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped
class CachingService {
  @CacheInvalidateAll(cacheName = "foo")
  @CacheInvalidateAll(cacheName = "bar")
  void heavyComputation() {
    // ...
    // some computation that updates a lot of data
    // and requires 2 caches to be invalidated
    // ...
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is how interceptors are used.  What about creating an interceptor?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここまで、インターセプタ―がどのように使用されるかを説明しました。では、インターセプターを作成するにはどうすれば良いでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.  This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インターセプタ―のインターセプタ―バインディングを宣言する場合は、通常どおり、インターセプタ―クラスに複数の `@Repeatable` アノテーションを追加できます。`@Cached` アノテーションの場合と同様に、アノテーションメンバーが `@Nonbinding` の場合は役に立ちませんが、それ以外の場合は重要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, suppose we have an interceptor that can automatically log method invocations to certain targets.  The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.  Our implementation could be restricted to console logging and file logging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、メソッド呼び出しを特定のターゲットに自動的に記録できるインターセプタ―があるとします。インターセプタ―バインディング注釈 `@Logged` には、ログを保存する場所を指定する `target` というメンバーがあります。この実装は、コンソールログとファイルロギングに制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Interceptor
@Logged(target = "console")
@Logged(target = "file")
class NaiveLoggingInterceptor {
  // ...
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Interceptor
@Logged(target = "console")
@Logged(target = "file")
class NaiveLoggingInterceptor {
  // ...
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other interceptors could be provided to log method invocations to different targets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他にも、異なるターゲットへのメソッド呼び出しをログに記録するためのインターセプターを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時間延長</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, most of the functionality can be achieved using Quarkus link:writing-extensions[extensions].  See the link:cdi-integration[integration guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は、インスタント起動と低メモリフットプリントを提供するために、ビルド時間の最適化を取り入れています。このアプローチの欠点は、CDI ポータブル拡張機能をサポートできないことです。それにもかかわらず、ほとんどの機能は、Quarkus link:writing-extensions[エクステンション] を使用して行うことができます。詳細は、link:cdi-integration[統合ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the development mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでは、JSON 形式で基本的なデバッグ情報を提供するために、2 つの特別なエンドポイントが自動的に登録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP GET `/q/arc` - 要約、Bean の数、設定プロパティーなどを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc/beans` - returns the list of all beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP GET `/q/arc/beans` - すべての Bean のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use query params to filter the output:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クエリーパラメーターを使用して出力をフィルタリングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`scope` - 指定した値で終わるスコープを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`beanClass` - 与えられた値で始まる Bean クラスを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kind` - 指定された種類の Bean (`CLASS`、`PRODUCER_FIELD`、`PRODUCER_METHOD`、`INTERCEPTOR`、または `SYNTHETIC`) を含みます (つまり `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP GET `/q/arc/removed-beans` - ビルド中に削除された未使用の Bean のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc/observers` - returns the list of all observer methods</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP GET `/q/arc/observers` - すべてのオブザーバーメソッドのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These endpoints are only available in the development mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのエンドポイントは開発モードでのみ使用できます。つまり `mvn quarkus:dev` (または `./gradlew quarkusDev`) 経由でアプリケーションを実行したときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document explains the Quarkus class loading architecture. It is intended for extension authors and advanced users who want to understand exactly how Quarkus works.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このドキュメントでは、Quarkus のクラスロードアーキテクチャについて説明します。このドキュメントは、Quarkus がどのように動作するかを正確に理解したいエクステンションの作者や上級ユーザーを対象としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus class loading architecture is slightly different depending on the mode that the application is run in. When running a production application everything is loaded in the system ClassLoader, so it is a completely flat class path. This also applies to native image mode which does not really support multiple ClassLoaders, and is based on a normal production Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus のクラスロードアーキテクチャは、アプリケーションを実行するモードによって若干異なります。本番環境のアプリケーションを実行しているときは、すべてがシステム ClassLoader でロードされるため、完全にフラットなクラスパスとなります。これは、複数の ClassLoader をサポートしていないネイティブイメージモードにも当てはまり、通常のプロダクション Quarkus アプリケーションをベースにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For all other use cases (e.g. tests, dev mode, and building the application) Quarkus uses the class loading architecture outlined here.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のすべてのユースケース(テスト、開発モード、アプリケーションのビルドなど)では、Quarkus はここで説明したクラスロードアーキテクチャを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus application. The end result of this process is a `CuratedApplication`, which contains all the class loading information for the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての Quarkus アプリケーションは、 `independent-projects/bootstrap` モジュールの QuarkusBootstrap クラスによって作成されます。このクラスは、Quarkus アプリケーションに必要なすべての関連する依存関係(デプロイメントとランタイムの両方)を解決するために使用されます。このプロセスの最終結果は、 `CuratedApplication` であり、これにはアプリケーションのすべてのクラスロード情報が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 `CuratedApplication` を使用して `AugmentAction` インスタンスを作成し、本番アプリケーションを作成したり、ランタイムのものを起動/再起動したりすることができます。このアプリケーションインスタンスは、分離された ClassLoader 内に存在しています。収集処理によって解決されるため、クラスパスに Quarkus デプロイメントクラスを配置する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このブートストラッププロセスは、Quarkus がどのように起動されても、異なるパラメーターが渡されているだけで、同じであるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Current Run Modes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在の実行モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment we have the following use cases for bootstrapping Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のところ、Quarkus のブートストラップには以下のようなユースケースがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリファクタの目的の一つは、これらの異なる実行モードのすべてが基本的に同じ方法で Quarkus を起動できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A ClassLoader is said to be 'transformer safe' if it is safe to load classes in the class loader before the transformers are ready. Once a class has been loaded it cannot be changed, so if a class is loaded before the transformers have been prepared this will prevent the transformation from working. Loading classes in a transformer safe ClassLoader will not prevent the transformation, as the loaded class is not used at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ClassLoader は、Transformer が準備される前にクラスをロードしても安全であれば、「Transformerセーフ」と言われます。一度ロードされたクラスは変更することができないので、もし Transformer の準備が整う前にロードされた場合、変換が機能しなくなります。Transformer セーフな ClassLoader でクラスをロードした場合は、ロードされたクラスは実行時には使用されないので、変換を妨げることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ClassLoader Implementations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスローダーの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base ClassLoader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベース ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは通常、通常の JVM System ClassLoader です。Maven のような環境では異なる場合があります。この ClassLoader はブートストラップクラスをロードするために使用され、他の ClassLoader インスタンスは JDK クラスのロードをこれに委譲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augment ClassLoader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張 ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader, and it is transformer safe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、すべての `-deployment` アーティファクトとその依存関係、および他のユーザー依存関係をロードします。アプリケーションのルートやホットデプロイされたコードはロードしません。この ClassLoader は永続的に動作し、アプリケーションが再起動してもそれは残ります (ホットデプロイされている可能性のあるアプリケーションクラスをロードできないのはそのためです)。親はベースの ClassLoader であり、Transformerセーフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のところ、これはベース ClassLoader に委譲するように設定することができますが、計画ではこのオプションは廃止され、常に分離された ClassLoader として使用することになっています。これを分離型 ClassLoader にすることは、すべてのビルダクラスが分離されていることを意味するので複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment ClassLoader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメント ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can load all application classes, its parent is the Augment ClassLoader so it can also load all deployment classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはすべてのアプリケーションクラスをロードすることができ、その親は 拡張 ClassLoader なので、すべてのデプロイメントクラスをロードすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader is the context ClassLoader that is used when running the build steps. It is also transformer safe.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この ClassLoader は永続的ではなく、アプリケーションの起動時に再作成され、分離されています。この ClassLoader は、ビルドステップを実行する際に使用されるコンテキスト ClassLoader です。また、Transformerセーフでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base Runtime ClassLoader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベースランタイム ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads all the runtime extension dependencies, as well as other user dependencies (note that this may include duplicate copies of classes also loaded by the Augment ClassLoader). It does not load the application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、他のユーザー依存関係と同様に、すべての実行時エクステンション依存関係をロードします(これには 拡張 ClassLoader によってロードされたクラスの重複コピーも含まれる可能性があることに注意してください)。アプリケーションのルートやホットデプロイされたコードはロードされません。この ClassLoader は永続的なもので、アプリケーションが再起動しても残ります (ホットデプロイされている可能性のあるアプリケーションクラスをロードできないのはそのためです)。親はベース ClassLoader です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this transformation is no longer possible). This means that only transformers registered in the first application start will take effect, however as these transformers are expected to be idempotent this should not cause problems. An example of the sort of transformation that might be required here is a Panache entity packaged in an external jar. This class needs to be transformed to have its static methods implemented, however this transformation only happens once, so restarts use the copy of the class that was created on the first start.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはホットリロードできないコードをロードしますが、変換をサポートしています (ただし、クラスがロードされるとこの変換はできなくなります)。これは、最初のアプリケーション起動時に登録された Transformer のみが有効になることを意味しますが、これらの Transformer は冪等であることが期待されているため、これは問題を引き起こすことはないはずです。ここで必要となる可能性のある変換の例として、外部 jar にパッケージ化された Panache エンティティーがあります。このクラスは静的メソッドを実装するために変換する必要がありますが、この変換は一度しか行われないため、再起動時には最初の起動時に作成されたクラスのコピーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications to behave more like a production application (production applications are isolated in that they run in a whole new JVM).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この ClassLoader は、拡張 ClassLoader とデプロイメント ClassLoader から分離されています。つまり、デプロイメント側の静的フィールドに値を設定して、実行時に読み込まれることを期待することはできません。これにより、開発アプリケーションやテストアプリケーションが本番アプリケーションのように振る舞うことができます(本番アプリケーションは全く新しい JVM で実行されるという点で分離されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、実行時のバージョンは別の依存関係のセットに対してリンクされる可能性があることを意味します。例えば、デプロイ時に使用する Hibernate バージョンには ByteBuddy が含まれていても、実行時に使用するバージョンには含まれていない場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime Class Loader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムクラス ローダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is used to load the application classes and other hot deployable resources. Its parent is the base runtime ClassLoader, and it is recreated when the application is restarted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この ClassLoader は、アプリケーションクラスやその他のホットデプロイ可能なリソースをロードするために使用されます。親はベースランタイム ClassLoader で、アプリケーションの再起動時に再作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Isolated ClassLoaders</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離型クラスローダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime ClassLoader is always isolated. This means that it will have its own copies of almost every class from the resolved dependency list. The exception to this are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムの ClassLoader は常に分離されています。これは、解決された依存関係リストのほとんどすべてのクラスの独自のコピーを持つことを意味します。これには例外があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes from artifacts that extensions have marked as parent first (more on this later).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションが親優先とマークしたアーティファクトからのクラス (これについては後述します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parent First Dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>親優先の依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system ClassLoader (or whatever ClassLoader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about this, however there are a few cases where this is necessary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>分離された方法でロードされるべきではないクラスがいくつかありますが、それは常にシステムの ClassLoader(または Quarkus のブートストラップを担当している ClassLoader )によってロードされなければなりません。ほとんどのエクステンションはこのことを気にする必要はありませんが、必要な場合もあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some logging related classes, as logging must be loaded by the system ClassLoader</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギングはシステム ClassLoader によってロードされなければならないので、いくつかのロギング関連のクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you mark a dependency as parent first then all of its dependencies must also be parent first, or a `LinkageError` can occur.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これが必要な場合は、 `quarkus-bootstrap-maven-plugin` で設定することができます。 依存関係を親優先とマークした場合は、その依存関係もすべて親優先にしなければならないことに注意してください。そうでないと、 `LinkageError` が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Banned Dependencies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>禁止された依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some dependencies that we can be sure we do not want. This generally happens when a dependency has had a name change (e.g. smallrye-config changing groups from `org.smallrye` to `org.smallrye.config`, the `javax` -&gt; `jakarta` rename).  This can cause problems, as if these artifacts end up in the dependency tree out of date classes can be loaded that are not compatible with Quarkus. To deal with this extensions can specify artifacts that should never be loaded. This is done by modifying the `quarkus-bootstrap-maven-plugin` config in the pom (which generates the `quarkus-extension.properties` file). Simply add an `excludedArtifacts` section as shown below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係の中には、必要ないと確信できるものもあります。これは一般的に、依存関係の名前が変更された場合に起こります(例:smallrye-configがグループを `org.smallrye` から `org.smallrye.config` に変更した、 `javax` → `jakarta` のリネームなど)。これは問題を引き起こす可能性があります。これらのアーティファクトが依存関係ツリーで終わると、Quarkusと互換性のない古いクラスがロードされる可能性があるからです。この問題に対処するために、エクステンションでは、決してロードしてはいけないアーティファクトを指定することができます。これは、 `quarkus-extension.properties` ファイルを生成する pom の `quarkus-bootstrap-maven-plugin` 設定を変更することで行います。以下のように `excludedArtifacts` セクションを追加するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This should only be done if the extension depends on a newer version of these artifacts. If the extension does not bring in a replacement artifact as a dependency then classes the application needs might end up missing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、エクステンションがこれらのアーティファクトの新しいバージョンに依存している場合にのみ行うべきです。もしエクステンションが代替アーティファクトを依存関係として持ち込まなかった場合、 アプリケーションが必要とするクラスが見つからなくなってしまうかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Class Loading</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスローディングの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to configure some aspects of class loading in dev and test mode. This can be done using `application.properties`.  Note that class loading config is different to normal config, in that it does not use the standard Quarkus config mechanisms (as it is needed too early), so only supports `application.properties`. The following options are supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードとテストモードでクラスローディングのいくつかの側面を設定することができます。これは、 `application.properties` を使用して行うことができます。クラスローディングの設定は通常の設定とは異なり、標準のQuarkusの設定メカニズムを使用していないため（必要な時期が早すぎるため）、 `application.properties` のみをサポートしていることに注意してください。以下のオプションがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading Class Bytecode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスバイトコードの読み取り</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to use the correct `ClassLoader`. The recommended approach is to get it by calling the `Thread.currentThread().getContextClassLoader()` method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正しい `ClassLoader` を使用することが重要です。推奨される方法は、 `Thread.currentThread().getContextClassLoader()` メソッドを呼び出して取得することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple application which offers a single land page:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、単一のランディングページを提供する非常にシンプルなアプリケーションを構築しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/{tenant}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`/{tenant}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The land page is served by a JAX-RS Resource and shows information obtained from the OpenID Provider about the authenticated user and the current tenant.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランディングページはJAX-RSリソースによって提供され、認証されたユーザーと現在のテナントに関するOpenIDプロバイダから取得した情報を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-openid-connect-multi-tenancy-quickstart` {quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `security-openid-connect-multi-tenancy` {quickstarts-tree-url}/security-openid-connect-multi-tenancy[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, follow the steps below to import the realms for the two tenants:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、以下の手順に従って、2つのテナントのためのレルムをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/tenant-a[http://localhost:8080/tenant-a]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/tenant-a[http://localhost:8080/tenant-a]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically Resolving Tenants Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テナントの設定をプログラムで解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a more dynamic configuration for the different tenants you want to support and don't want to end up with multiple entries in your configuration file, you can use the `io.quarkus.oidc.TenantConfigResolver`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートしたいさまざまなテナントに対して、より動的な設定が必要で、設定ファイルに複数のエントリーを入れたくない場合は、 `io.quarkus.oidc.TenantConfigResolver` が利用出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This interface allows you to dynamically create tenant configurations at runtime:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このインターフェイスを使用すると、実行時にテナント設定を動的に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tenant Resolution for OIDC 'web-app' applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OIDCの "web-app" アプリケーションのためのテナント解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling Tenant Configurations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テナント設定を無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom `TenantResolver` and `TenantConfigResolver` implementations may return `null` if no tenant can be inferred from the current request and a fallback to the default tenant configuration is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムの `TenantResolver` および `TenantConfigResolver` の実装では、現在のリクエストからテナントを推測できず、デフォルトのテナント設定へのフォールバックが必要な場合は `null` を返すことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is expected that the custom resolvers will always infer a tenant then the default tenant configuration is not needed. One can disable it with the `quarkus.oidc.tenant-enabled=false` setting.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムリゾルバが常にテナントを推論することが予想される場合、デフォルトのテナント設定は必要ありません。 `quarkus.oidc.tenant-enabled=false` の設定で無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that tenant specific configurations can also be disabled, for example: `quarkus.oidc.tenant-a.tenant-enabled=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テナント固有の設定を無効にすることもできます。例: `quarkus.oidc.tenant-a.tenant-enabled=false`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://developers.google.com/identity/protocols/OpenIDConnect[Google OpenID Connect]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://developers.google.com/identity/protocols/OpenIDConnect[Google OpenID Connect]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.mailer.reactive.ReactiveMailer` provides the reactive (non-blocking and asynchronous) API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.mailer.reactive.ReactiveMailer` はリアクティブ型 (ノンブロッキングで非同期の) API を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN
quarkus.mailer.from=YOUREMAIL@gmail.com
quarkus.mailer.host=smtp.gmail.com
quarkus.mailer.port=587
quarkus.mailer.start-tls=REQUIRED
quarkus.mailer.username=YOUREMAIL@gmail.com
quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN
quarkus.mailer.from=YOUREMAIL@gmail.com
quarkus.mailer.host=smtp.gmail.com
quarkus.mailer.port=587
quarkus.mailer.start-tls=REQUIRED
quarkus.mailer.username=YOUREMAIL@gmail.com
quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN quarkus.mailer.from=YOUREMAIL@gmail.com quarkus.mailer.host=smtp.gmail.com quarkus.mailer.port=465 quarkus.mailer.ssl=true quarkus.mailer.username=YOUREMAIL@gmail.com quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN quarkus.mailer.from=YOUREMAIL@gmail.com quarkus.mailer.host=smtp.gmail.com quarkus.mailer.port=465 quarkus.mailer.ssl=true quarkus.mailer.username=YOUREMAIL@gmail.com quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject MailClient client;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Inject MailClient client;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While users are encouraged to use link:cache[Quarkus annotations for caching], Quarkus nevertheless provides a compatibility layer for Spring Cache annotations in the form of the `spring-cache` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーは link:cache[キャッシュ用のQuarkusアノテーション] を使用することが推奨されていますが、Quarkusはそれにもかかわらず、 `spring-cache` エクステンションの形でSpring Cacheアノテーションの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how a Quarkus application can leverage the well known Spring Cache annotations to enable application data caching for their Spring beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションがよく知られているSpring Cacheアノテーションを活用して、Spring Beanのアプリケーションデータのキャッシュを可能にする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with a REST endpoint and imports the `spring-cache` and `spring-di` extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `spring-cache` と `spring-di` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `spring-cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service which will simulate an extremely slow call to an external meteorological service.  Create `src/main/java/org/acme/spring/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは、外部の気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/spring/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class which contains the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/spring/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、ユーザーが3日間の天気予報を聞いてきたときに、ユーザーに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/spring/cache/WeatherForecast.java` をこのように作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションが稼働しているので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを以下のように更新します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされている機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Cacheable`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Cacheable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@CachePut`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CachePut`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@CacheEvict`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CacheEvict`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in this first version of the Spring Cache annotations extension, not all features of these annotations are supported (with proper errors being logged when trying to use an unsupported feature).  However, additional features are planned for future releases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この最初のバージョンの Spring Cache アノテーションエクステンションでは、これらのアノテーションのすべての機能がサポートされているわけではないことに注意してください (サポートされていない機能を使用しようとすると、適切なエラーがログに記録されます)。しかし、今後のリリースでは追加機能が計画されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events] builds off of the link:funqy-http[Funqy HTTP] extension to allow you to route and process Knative Events within a Funqy function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events]は 、link:funqy-http[Funqy HTTP] エクステンションをベースに構築されており、Funqy関数内でKnative Eventsをルーティングして処理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions with Knative Events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、クイックスタートコードを使って、Knative Events を使って Funqy 関数をデプロイして呼び出す方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have gone through the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial], specifically link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knativeチュートリアル] 、特に link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[ブローカーとトリガー] を一読していること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  It is advised to follow https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[this] Knative Tutorial put together by Red Hat.  It walks through how to set up Knative on Minikube or OpenShift in a local environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Minikube 環境で Knative をローカルに設定することは、このガイドの範囲を超えています。link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Red HatがまとめたKnativeチュートリアル] に従うことをお勧めします。このチュートリアルでは、ローカル環境でMinikubeやOpenShift上でKnativeをセットアップする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specifically you should run the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers] tutorial as this guide requires that you can invoke on a Broker to trigger the quickstart code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、クイックスタートコードをトリガーするためにブローカーを呼び出す必要があるため、特に link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[ブローカーとトリガー] のチュートリアルを実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event link:https://cloudevents.io/[specification] is a good read to give you an even greater understanding of Knative Events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Knative Events をより深く理解するために、Cloud Events の link:https://cloudevents.io/[仕様] を読んでおくと良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quickstart Flow</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クイックスタートの流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quickstart works by manually sending an HTTP request containing a Cloud Event to the Knative Broker using `curl`.  The Knative Broker receives the request and triggers the startup of the Funqy container built by the quickstart.  The event triggers the invocation of a chain of Funqy functions.  The output of one function triggers the invocation of another Funqy function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クイックスタートは、Cloud Eventを含む HTTP リクエストを `curl` を使用して Knative Broker に手動で送信することで動作します。Knative Broker はリクエストを受信し、クイックスタートによって構築された Funqy コンテナの起動をトリガーします。イベントは、一連の Funqy 関数の呼び出しをトリガーします。1 つの関数の出力は、別の Funqy 関数の呼び出しをトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When living within a Knative Events environment, Funqy functions are triggered by a specific Cloud Event type.  You can have multiple Funqy functions within a single application/deployment, but they must be triggered by a specific Cloud Event Type.  The exception to this rule is if there is only one Funqy function in the application.  In that case, the event is pushed to that function irregardless of the Cloud Event type.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Knative Events環境内で稼働する場合、Funqy関数は特定のタイプの Cloud Event によってトリガーされます。1つのアプリケーション/デプロイメント内に複数のFunqy関数を持つことができますが、それらは特定のタイプの Cloud Event によってトリガーされなければなりません。このルールの例外は、アプリケーション内にFunqy関数が1つしかない場合です。この場合、イベントは Cloud Event タイプに関係なく、その関数にプッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Funqy can only consume JSON-based data.  It supports both Binary and Structured mode of execution, but the data component of the Cloud Event message must be JSON.  This JSON must also be marshallable to and from the Java parameters and return types of your functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在、FunqyはJSONベースのデータしか消費できません。それ自体はバイナリモードと構造化モードの両方をサポートしていますが、Cloud EventメッセージのデータコンポーネントはJSONでなければなりません。このJSONは、関数のJavaパラメータやリターンタイプとの間でマーシャル可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start looking at our quickstart code so that you can understand how Knative Events map to Funqy.  Open up {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Knative イベントがどのように Funqy にマップされるかを理解するために、クイックスタートのコードを見てみましょう。クイックスタートコードは、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java] を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first function we'll look at is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初に見る関数は `defaultChain` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is, a Funqy function has a default Cloud Event mapping.  By default, the Cloud Event type must match the function name for the function to trigger.  If the function returns output, the response is converted into a Cloud Event and returned to the Broker to be routed to other triggers.  The default Cloud Event type for this response is the function name + `.output`.  The default Cloud Event source is the function name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この状態で、Funqy関数はデフォルトの Cloud Event マッピングを持っています。デフォルトでは、 Cloud Event のタイプは、トリガする関数の関数名と一致していなければなりません。関数が出力を返す場合、レスポンスは Cloud Event に変換され、ブローカに返されて他のトリガーにルーティングされます。このレスポンスのデフォルトの Cloud Event  タイプは、関数名 + `.output` です。デフォルトの Cloud Event のソースは、関数名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, for the `defaultChain` function, the Cloud Event type that triggers the function is `defaultChain`.  It generates a response that triggers a new Cloud Event whose type is `defaultChain.output` and the event source is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>したがって、 `defaultChain` 関数の場合、この関数をトリガーする Cloud Event のタイプは `defaultChain` です。これは、タイプが `defaultChain.output` でイベントソースが `defaultChain` である新しい Cloud Event をトリガーするレスポンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the default mapping is simple, it might not always be feasible.  You can change this default mapping through configuration.  Let's look at the next function:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのマッピングはシンプルですが、必ずしもうまくいくとは限りません。このデフォルトのマッピングは設定で変更することができます。次の関数を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `configChain` function has its Cloud Event mapping changed by configuration within {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`configChain` 関数は、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties] 内の設定により、 Cloud Event のマッピングが変更されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the configuration maps the incoming Cloud Event type `defaultChain.output` to the `configChain` function.  The `configChain` function maps its response to the `annotated` Cloud Event type, and the Cloud Event source `configChain`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、この構成では、受信するCloud Eventのタイプ `defaultChain.output` を `configChain` 関数にマッピングします。 `configChain` 関数は、そのレスポンスを `annotated` Cloud Event タイプに、Cloud Event ソース `configChain` にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.trigger` sets the Cloud Event type that triggers a specific function</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.trigger` は、特定の機能をトリガーする Cloud Event タイプを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.response-type` sets the Cloud Event type of the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.response-type` は、レスポンスの Cloud Event タイプを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.resource-source` sets the Cloud Event source of the response</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.resource-source` は、レスポンスの Cloud Event のソースを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy Knative Events extension also has annotations to do this Cloud Event mapping to your functions.  Take a look at the `annotatedChain` method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy Knative Events エクステンションには、この Cloud Event の関数へのマッピングを行うためのアノテーションも用意されています。 `annotatedChain` メソッドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the `@CloudEventMapping` annotation on your function you can map the Cloud Event type trigger and the Cloud Event response.  In this example the `annotatedChain` function will be triggered by the `annotated` Cloud Event type and the response will be mapped to a `lastChainLink` type and `annotated` Cloud Event source.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数に `@CloudEventMapping` アノテーションを使用すると、Cloud Event タイプのトリガーとCloud Event レスポンスをマッピングできます。この例では、 `annotatedChain` 関数は `annotated` Cloud Event タイプによってトリガされ、レスポンスは `lastChainLink` タイプと `annotated` Cloud Eventソースにマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if look at all the functions defined within `SimpleFunctionChain` you'll notice that one function triggers the next.  The last function that is triggered is `lastChainLink`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>つまり、 `SimpleFunctionChain` 内で定義されているすべての関数を見てみると、ある関数が次の関数を引き金にしていることに気づくでしょう。最後にトリガーされる関数は `lastChainLink` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two things to notice about this function.  One, it has no output.  Your functions are not required to return output.  Second, there is an additional `event` parameter to the function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能には2つの注意点があります。一つは、この関数には出力がありません。あなたの関数は出力を返す必要はありません。第二に、この関数には追加の `event` パラメータがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to know additional information about the incoming Cloud Event, you can inject the `CloudEvent` interface using the Funqy `@Context` annotation.  The `CloudEvent` interface exposes information about the triggering event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受信したCloud Eventに関する追加情報を知りたい場合は、Funqy `@Context` アノテーションを使用して `CloudEvent` インターフェイスを注入することができます。 `CloudEvent` インターフェイスは、トリガーとなるイベントに関する情報を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom], you'll see that it is a typical Quarkus pom that pulls in one funqy dependency</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom] を見ると、典型的なQuarkusのpomで、以下のような1つのfunqy依存関係を持っていることがわかるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode and Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードとテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy Knative Events support dev mode and unit testing using RestAssured.  You can invoke on Funqy Knative Events functions using the same invocation model as link:funqy-http[Funqy HTTP] using normal HTTP requests, or Cloud Event Binary mode, or Structured Mode.  All invocation modes are supported at the same time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Funqy Knative Eventsは、RestAssuredを使用したdevモードとユニットテストをサポートしています。通常のHTTPリクエストを使用した link:funqy-http[Funqy HTTP] と同じ呼び出しモデルを使用してFunqy Knative Events関数上で呼び出すか、Cloud Event Binaryモード、またはStructured Modeを使用して呼び出すことができます。すべての呼び出しモードが同時にサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if you open up the unit test code in {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java] you'll see that its simply using RestAssured to make HTTP invocations to test the functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java] のユニットテストコードを開くと、関数をテストするためのHTTP呼び出しを行うために、単にRestAssuredを使用していることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First build the Java artifacts:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、Javaアーティファクトをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, a docker image is required by Knative, so you'll need to build that next:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、Knativeではdockerイメージが必要なので、続いてそれをビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to replace `yourAccountName` with your docker or quay account name when you run `docker build`.  The Dockerfile is a standard Quarkus dockerfile.  No special Knative magic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`docker build` を実行する際には、必ず `yourAccountName` を docker または quay のアカウント名に置き換えてください。Dockerfileは標準のQuarkusのdockerfileです。特別なKnativeマジックはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Push your image to docker hub or quay</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イメージをDocker HubやQuayにプッシュする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, make sure to replace `yourAccountName` with your docker or quay account name when you run `docker push`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>繰り返しになりますが、 `docker push` を実行する際には、 `yourAccountName` を docker または quay のアカウント名に置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `spec:filter:attributes:type` maps a Cloud Event type to the Kubernetes service defined in `spec:subscriber:ref`.  When a Cloud Event is pushed to the Broker, it will trigger the spin up of the service mapped to that event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`spec:filter:attributes:type` は、 `spec:subscriber:ref` で定義されている Kubernetes サービスにCloud Eventのタイプをマッピングします。Cloud EventがBrokerにプッシュされると、そのイベントにマッピングされたサービスのスピンアップがトリガーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the demo</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デモの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You'll need two different terminal windows.  One to do a curl request to the Broker, the other to watch the pod log files so you can see the messages flowing through the Funqy function event chain.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つの異なるターミナルウィンドウが必要です。一つは Broker への curl リクエストを行うためのもので、もう一つはポッドのログファイルを見るためのもので、Funqy 関数のイベントチェーンを流れるメッセージを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have the `stern` tool installed.  See the Knative Tutorial setup for information on that.  Run stern to look for logs outputted by our Funqy deployment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`stern` ツールがインストールされていることを確認してください。それについての情報は Knative チュートリアルのセットアップを参照してください。Funqy デプロイメントが出力したログを探すために stern を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a separate terminal.  You'll first need to learn the URL of the broker.  Execute this command to find it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別の端末を開きます。まずブローカーのURLを知る必要があります。このコマンドを実行して探します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This posts a Knative Event to the broker, which will trigger the `defaultChain` function.  As discussed earlier, the output of `defaultChain` triggers an event that is posted to `configChain` which triggers an event posted to `annotatedChain` then finally to the `lastChainLink` function.  You can see this flow in your `stern` window.  Something like this should be outputted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ブローカーに Knative イベントをポストし、 `defaultChain` 関数をトリガーします。前述したように、 `defaultChain` の出力は、 `configChain` に投稿されたイベントをトリガーにして、 `annotatedChain` に投稿されたイベントをトリガーにして、最後に `lastChainLink` 関数をトリガーにします。この流れは `stern` ウィンドウで見ることができます。以下のようなものが出力されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qute is a templating engine designed specifically to meet the Quarkus needs.  The usage of reflection is minimized to reduce the size of native images.  The API combines both the imperative and the non-blocking reactive style of coding.  In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible.  Furthermore, we try to detect most of the template problems at build time.  In this guide, you will learn how to easily render templates in your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quteは、Quarkus のニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブイメージのサイズを小さくするために、リフレクションの使用は最小限に抑えられています。API は、命令型とノンブロッキングリアクティブ型の両方のスタイルのコーディングを組み合わせています。開発モードでは、 `src/main/resources/templates` にあるすべてのファイルが変更のために監視され、変更はすぐに表示されます。さらに、ビルド時にテンプレートの問題のほとんどを検出するようにしています。このガイドでは、アプリケーションでテンプレートを簡単にレンダリングする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Qute in your JAX-RS application, you need to add the `quarkus-resteasy-qute` extension first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS アプリケーションで Qute を使用する場合は、まず `quarkus-resteasy-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに以下を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll start with a very simple template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずはとてもシンプルなテンプレートから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, all files located in the `src/main/resources/templates` directory and its subdirectories are registered as templates. Templates are validated during startup and watched for changes in the development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `src/main/resources/templates` ディレクトリーとそのサブディレクトリーにあるすべてのファイルがテンプレートとして登録されます。開発モードではテンプレートは起動時に検証され、変更が監視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's inject the "compiled" template in the resource class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、リソースクラスに「コンパイル済み」テンプレートを注入してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application is running, you can request the endpoint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが動作している場合は、エンドポイントを要求することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's an alternate way to declare your templates in your Java code, which relies on the following convention:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java コードでテンプレートを宣言する別の方法もあり、以下の規約に依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's the previous example, rewritten using this style:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどの例を、このスタイルで書き換えてみました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's declare and use those templates in the resource class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、これらのテンプレートをリソースクラスで宣言して使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/HelloResource/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、パス `templates/HelloResource/hello.txt` でテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Templates.hello()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Templates.hello()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have declared a `@CheckedTemplate` class, we will check that all its methods point to existing templates, so if you try to use a template from your Java code and you forgot to add it, we will let you know at build time :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@CheckedTemplate` クラスを宣言したら、すべてのメソッドが既存のテンプレートを指しているかどうかをチェックしますので、もし Java コードからテンプレートを使おうとして追加するのを忘れてしまった場合は、ビルド時にお知らせします :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind this style of declaration allows you to reference templates declared in other resources too:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このスタイルの宣言では、他のリソースで宣言されたテンプレートも参照できることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Top-level type-safe templates</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トップレベルのタイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, if you want to declare templates at the top-level, directly in `/src/main/resources/templates/hello.txt`, for example, you can declare them in a toplevel (non-nested) `Templates` class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当然のことながら、トップレベルでテンプレートを宣言したい場合、例えば `/src/main/resources/templates/hello.txt` で直接宣言したい場合は、トップレベル(非入れ子)の `Templates` クラスで宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、パス `templates/hello.txt` のテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Parameter Declarations </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートパラメーター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you declare a *parameter declaration* in a template then Qute attempts to validate all expressions that reference this parameter and if an incorrect expression is found the build fails.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートで *パラメーター宣言* を宣言した場合、Quteはこのパラメーターを参照するすべての式の検証を試み、間違った式が見つかった場合はビルドが失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose we have a simple class like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなシンプルなクラスがあったとしましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Item.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Item.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we'd like to render a simple HTML page that contains the item name and price.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、商品名と価格が記載されたシンプルな HTML ページをレンダリングしたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start again with the template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>改めてテンプレートから始めてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource/item.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ItemResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is validated. Try to change the expression to `{item.nonSense}` and the build should fail.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この式は検証済みです。式を `{item.nonSense}` に変更するとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is also validated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これも検証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class with type-safe templates:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、タイプセーフなテンプレートを使ってリソースクラスを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template parameter declaration inside the template itself</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート内部のテンプレートパラメーター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can declare your template parameters in the template file itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、テンプレートファイル自体でテンプレートパラメーターを宣言することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional parameter declaration. Qute attempts to validate all expressions that reference the parameter `item`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションのパラメーター宣言。Qute は、パラメーター `item` を参照するすべての式の検証を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、リソースクラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the template with path `templates/item.html`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パスが `templates/item.html` のテンプレートを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Template extension methods* are used to extend the set of accessible properties of data objects.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*テンプレート拡張メソッド* は 、データオブジェクトのアクセス可能なプロパティーのセットを拡張するために使用されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you're not in control of the classes that you want to use in your template, and you cannot add methods to them. Template extension methods allows you to declare new method for those classes that will be available from your templates just as if they belonged to the target class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時には、テンプレートで使用したいクラスをコントロールできず、それらのクラスにメソッドを追加できないことがあります。テンプレート拡張メソッドを使うと、テンプレートから利用できるようになるクラスのメソッドを、あたかもターゲットクラスに属しているかのように宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's keep extending on our simple HTML page that contains the item name, price and add a discounted price.  The discounted price is sometimes called a "computed property".  We will implement a template extension method to render this property easily.  Let's update our template:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アイテム名、価格、値引き価格を含むシンプルな HTML ページを拡張していきましょう。値引き価格は「計算プロパティー」と呼ばれることがあります。このプロパティーを簡単にレンダリングするためのテンプレート拡張メソッドを実装します。テンプレートを更新してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/item.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HelloResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`if` is a basic control flow section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`if` は、基本的な制御フローのセクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is also validated against the `Item` class and obviously there is no such property declared. However, there is a template extension method declared on the `TemplateExtensions` class - see below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この式は `Item` クラスに対しても検証されており、明らかにそのようなプロパティーは宣言されていません。しかし、 `TemplateExtensions` クラスにはテンプレート拡張メソッドが宣言されています - 以下を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a class where we put all our extension methods:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、すべての拡張メソッドを置くクラスを作りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TemplateExtensions.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>TemplateExtensions.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A static template extension method can be used to add "computed properties" to a data class. The class of the first parameter is used to match the base object and the method name is used to match the property name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>静的テンプレート拡張メソッドを使用して、データクラスに「計算プロパティー」を追加することができます。最初のパラメーターのクラスはベースオブジェクトと一致するように使用され、メソッド名はプロパティー名と一致するように使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can place template extension methods in every class if you annotate them with `@TemplateExtension` but we advise to keep them either grouped by target type, or in a single `TemplateExtensions` class by convention.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレート拡張メソッドは、 `@TemplateExtension` でアノテーションを付ければ、すべてのクラスに配置することができますが、規約上、ターゲットタイプでグループ化するか、 `TemplateExtensions` クラスにまとめておくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rendering Periodic Reports</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定期レポートのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating engine could be also very useful when rendering periodic reports.  You'll need to add the `quarkus-scheduler` and `quarkus-qute` extensions first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレーティングエンジンは、定期的なレポートをレンダリングする際にも非常に便利かもしれません。最初に `quarkus-scheduler` と `quarkus-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose the have a `SampleService` bean whose `get()` method returns a list of samples.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`SampleService` Beanがあり、その `get()` メソッドがサンプルのリストを返すとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Sample.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The template is simple:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートはシンプルです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>report.html</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>report.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The loop section makes it possible to iterate over iterables, maps and streams.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ループセクションでは、イテレーション、マップ、ストリームの反復処理が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This value expression is using the https://en.wikipedia.org/wiki/Elvis_operator[elvis operator] - if the name is null the default value is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この値式は link:https://en.wikipedia.org/wiki/Elvis_operator[elvis 演算子] を使用します - nameが NULL の場合はデフォルト値が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ReportGenerator.java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ReportGenerator.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to execute this method on the half hour. For more information see the link:scheduler[Scheduler] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled` アノテーションを使用して、Quarkusにこのメソッドを30分に実行するよう指示します。詳細については、 link:scheduler[スケジューラーガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `TemplateInstance.render()` method triggers rendering. Note that this method blocks the current thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`TemplateInstance.render()` メソッドはレンダリングをトリガします。このメソッドは現在のスレッドをブロックすることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive and Asynchronous APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブと非同期API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates can be rendered as a `CompletionStage&lt;String&gt;` (completed with the rendered output asynchronously) or as `Publisher&lt;String&gt;` containing the rendered chunks:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートは、 `CompletionStage&lt;String&gt;` (非同期にレンダリングされた出力で完了)としてレンダリングすることも、レンダリングされたチャンクを含む `Publisher&lt;String&gt;` としてレンダリングすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of a `Publisher`, the template is rendered chunk by chunk following the requests from the subscriber.  The rendering is not started until a subscriber requests it.  The returned `Publisher` is an instance of `io.smallrye.mutiny.Multi`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Publisher` の場合、テンプレートはサブスクライバーからのリクエストに応じてチャンクごとにレンダリングされます。レンダリングは、サブスクライバーがリクエストするまで開始されません。返された `Publisher` は `io.smallrye.mutiny.Multi` のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create an instance of `io.smallrye.mutiny.Uni` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のように、 `io.smallrye.mutiny.Uni` のインスタンスを作成することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the rendering only starts once the subscriber requests it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、サブスクライバーが要求した場合にのみレンダリングが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about Qute, please refer to the link:qute-reference[Qute reference guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Qute について詳しく知りたい方は、 link:qute-reference[Qute リファレンスガイド] を参考にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://camel.apache.org/[Apache Camel]は、10年以上の歴史とユーザーや開発者の活発なコミュニティを持つ、異種システムを統合するためのスイスアーミーナイフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus上のApache Camelのサポートは、 link:https://github.com/apache/camel-quarkus[Apache Camel Quarkusプロジェクト]によって提供されています。詳細は link:https://camel.apache.org/camel-quarkus/latest/[彼らのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for properties file based authentication that is intended for development and testing purposes. It is not recommended that this be used in production as at present only plaintext and MD5 hashed passwords are used, and properties files are generally too limited to use in production.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、開発とテストを目的としたプロパティーファイルベースの認証をサポートしています。現在のところ、平文とMD5ハッシュ化されたパスワードしか使用されておらず、プロパティーファイルは一般的に本番環境で使用するには制限が多すぎるため、本番環境で使用することはお勧めできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下を `pom.xml` に追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elytron-security-properties-file extension currently supports two different realms for the storage of authentication and authorization information. Both support storage of this information in properties files. The following sections detail the specific configuration properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>elytron-security-properties-file エクステンションは、現在、認証と認可情報の保存のための2つの異なる領域をサポートしています。どちらもこの情報のプロパティーファイルへの保存をサポートしています。以下のセクションでは、特定の設定プロパティーについて詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties Files Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーファイルレルム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties files realm supports mapping of users to password and users to roles with a combination of properties files. They are configured with properties starting with `quarkus.security.users.file`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーファイルのレルムは、プロパティーファイルの組み合わせを使用して、ユーザーをパスワードに、ユーザーをロールにマッピングすることをサポートしています。これらは `quarkus.security.users.file` で始まるプロパティーで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーズプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.security.users.file.users` configuration property specifies a classpath resource which is a properties file with a user to password mapping, one per line. The following &lt;&lt;test-users-example&gt;&gt; illustrates the format:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.security.users.file.users` 設定プロパティーは、クラスパスリソースを指定します。これは、1行に1つずつ、ユーザーとパスワードをマッピングしたプロパティーファイルです。以下の link:#test-users-example[test-users-example] はそのフォーマットを示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password defined as `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `scott` のパスワードは `jb0ss` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has password defined as `p4ssw0rd`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `jdoe` のパスワードは `p4ssw0rd` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このファイルには、ユーザー名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roles.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Roles.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has been assigned the roles `Admin`, `admin`, `Tester` and `user`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester` および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has been assigned the role `NoRolesUser`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `jdoe` に役割が割り当てられています。 `NoRolesUser`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has been assigned the roles `admin` and `user`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `stuart` には `admin` と `user` の役割が割り当てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンベデッドレルムの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The embedded realm also supports mapping of users to password and users to roles. It uses the main `application.properties` Quarkus configuration file to embed this information. They are configured with properties starting with `quarkus.security.users.embedded`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>埋め込まれたレルムは、ユーザーのパスワードへのマッピングやユーザーのロールへのマッピングもサポートしています。この情報を埋め込むには、メインの `application.properties` Quarkus設定ファイルを使用します。これらは、 `quarkus.security.users.embedded` で始まるプロパティーで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example application.properties file section illustrating the embedded realm configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下は、組み込みレルムの設定を示すapplication.propertiesファイルのセクションの例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the first example this file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初の例と同様に、このファイルにはユーザー名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上記の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Users</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>組込ユーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to password mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;`. The following &lt;&lt;password-example&gt;&gt; illustrates the syntax with 4 user to password mappings:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーからパスワードへのマッピングは、 `application.properties` ファイル内で `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;` 形式のプロパティーキーで指定します。以下の link:#password-example[password-example] は]、4 つのユーザーからパスワードへのマッピングの構文を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Passwords</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パスワードの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `scott` はパスワード `jb0ss` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has password `test`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `stuart` はパスワード `test` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Roles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>組込ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to role mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.roles.&lt;user&gt;=role1[,role2[,role3[,...]]]`. The following &lt;&lt;roles-example&gt;&gt; illustrates the syntax with 4 user to role mappings:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーとロールのマッピングは、 `application.properties` ファイルで `quarkus.security.users.embedded.roles.&amp;amp;lt;user&amp;amp;gt;=role1[,role2[,role3[,…​]]]` 形式のプロパティー・キーで指定されます。以下の link:#roles-example[[role-example]]は、4つのユーザーとロールをマッピングした構文を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Roles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロールの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has roles `Admin`, `admin`, `Tester`, and `user`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester`, および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has roles `admin` and `user`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー `stuart` には `admin` と `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Persistence Units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の永続性ユニット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.  Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-amazon-lambda` エクステンションを使うと、Quarkusを使ってAWS Lambda を構築することができます。Lambda では、CDIやSpringからのインジェクションアノテーションや、必要に応じてQuarkusの他の機能を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus lambdas can be deployed using the Amazon Java Runtime, or you can build a native executable and use Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの Lambda は、Amazon Javaランタイムを使用してデプロイすることもできますが、より小さなメモリーフットプリントとより高速なコールドブート起動時間が必要な場合は、ネイティブの実行ファイルをビルドしてAmazonのカスタムランタイムを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle projects please &lt;&lt;gradle,see below&gt;&gt;, or for further reference consult the guide in the link:gradle-tooling[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle プロジェクトに対しては &lt;&lt;gradle,こちらを参照する&gt;&gt; か、さらに詳しい解説が必要な場合には link:gradle-tooling[Gradle セットアップ] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a maven archetype and deploying it to AWS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、mavenのArchetypeを使用してJavaプロジェクトのサンプルを生成し、AWSにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[code.quarkus.io] adding the `quarkus-amazon-lambda` extension as a dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleを使いたい場合は、 link:https://code.quarkus.io/[code.quarkus.io] を使って、 `quarkus-amazon-lambda` エクステンションを依存関係として追加することで、素早く簡単にGradleプロジェクトを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>build.gradle、gradle.properties、settings.gradleを上記の生成されたMavenのアーキタイププロジェクトにコピーして、このガイドに従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execute: gradle wrapper to setup the gradle wrapper (recommended).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Execute: gradle wrapper を実行して gradle wrapper を設定します(推奨)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The dependency for `quarkus-test-amazon-lambda` will also need to be added to your build.gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-test-amazon-lambda` の依存関係も build.gradle に追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For full Gradle details &lt;&lt;gradle, see below&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleの詳細は link:#gradle[こちらを参照してください] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.  It must find a class in your project that implements this interface or it will throw a build time failure.  If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-amazon-lambda` エクステンションは、Amazon `RequestHandler&lt;?, ?&gt;` または `RequestStreamHandler` インターフェイスを直接実装しているクラスをプロジェクト内でスキャンします。このインターフェイスを実装しているクラスがプロジェクト内で見つかるようにしなければならず、そうでない場合にはビルド時に例外がスローされます。複数のハンドラークラスを見つけた場合にも、ビルド時の例外がスローされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、時にはコードを共有するいくつかの関連する Lambda があって、複数の maven モジュールを作成することは、やりたくないオーバーヘッドに過ぎないことがあるかもしれません。 `quarkus-amazon-lambda` エクステンションを使用すると、1 つのプロジェクトに複数のラムダをバンドルし、設定または環境変数を使用してデプロイしたいハンドラーを選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up `src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたプロジェクトは、その中に3つの Lambda を持っています。 `RequestHandler&lt;?, ?&gt;` インターフェイスを実装したものが 2 つ、 `RequestStreamHandler` インターフェイスを実装したものが 1 つ。1つは使用され、2つは未使用です。 `src/main/resources/application.properties` を開くと、このようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.lambda.handler` property tells Quarkus which lambda handler to deploy. This can be overridden with an environment variable too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.lambda.handler` プロパティーは、デプロイする Lambda ハンドラーをQuarkusに伝えます。これは環境変数でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the three generated handler classes in the project, you'll see that they are `@Named` differently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト内で生成された3つのハンドラークラスを見てみると、異なる `@Named` が指定されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ハンドラークラスのCDI名は、 `quarkus.lambda.handler` プロパティー内で指定された値と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Lambda をAWS上で動作させるには、いくつかのステップがあります。生成されたmavenプロジェクトには、pure Java とネイティブデプロイメント用の Lambda を作成、更新、削除、呼び出しするための便利なスクリプトが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or, if using Gradle:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>または、Gradleを使用している場合は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドを実行すると、 `quarkus-amazon-lambda` のエクステンションで生成されるいくつかの追加ファイルがあります。これらのファイルはビルドディレクトリーにあります: mavenなら `target/` 、gradleなら `build/` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`target/manage.sh` スクリプトは、AWS Lambda Java ランタイムを使用して Lambda を管理するためのものです。このスクリプトは利便性のためだけに提供されています。Lambda の作成、削除、更新のためにどのようなawsコマンドが実行されるかを知りたい場合は、 `manage.sh` スクリプトの出力を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Gradle, the path to the binaries in the `manage.sh` must be changed from `target` to `build`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleを使用している場合、 `manage.sh` のバイナリーへのパスを `target` から `build` に変更しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ハンドラースイッチを変更しないでください。これは、 `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest` にハードコードする必要があります。このハンドラは、Quarkusをブートストラップし、インジェクションを実行できるように実際のハンドラをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example lambda takes input passed in via the `--payload` switch which points to a json file in the root directory of the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルの Lambda は、プロジェクトのルートディレクトリーにある json ファイルを指す `--payload` スイッチを介して渡された入力を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lambda can also be invoked locally with the SAM CLI like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Lambda は、以下のようにSAM CLI によってローカルで呼び出すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the `update` command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お好きなように Java コードを更新することができます。リビルドしたら、 `update` コマンドを実行することで、Lambda を再配備できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Lambda のメモリーフットプリントを減らし、初期化時間を短縮したい場合は、Javaコードをネイティブの実行ファイルにコンパイルすることができます。 `-Pnative` スイッチでプロジェクトをリビルドすることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Lambda を作成、削除、更新するためにどのようなawsコマンドが実行されるかを知りたい場合は、 `manage.sh` スクリプトの出力を調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` and `quarkus-test-amazon-lambda` extensions as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POM には、 `quarkus-amazon-lambda` と `quarkus-test-amazon-lambda` エクステンションが依存関係として含まれていること以外に特別なことは何もありません。このエクステンションは、Lambda のデプロイに必要なものをすべて自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In previous versions of this extension you had to set up your pom or gradle to zip up your executable for native deployments, but this is not the case anymore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションの以前のバージョンでは、ネイティブデプロイメントのために実行ファイルを zip 化するように pom や gradle を設定しなければなりませんでしたが、今はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly for Gradle projects, you also just have to add the `quarkus-amazon-lambda` and `quarkus-test-amazon-lambda` dependencies.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle プロジェクトの場合も同様に、 `quarkus-amazon-lambda` と `quarkus-test-amazon-lambda` の依存関係を追加するだけです。このエクステンションは、Lambda のデプロイに必要なすべてのものを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Gradle dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleの依存関係の例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function, via the integration layer that Quarkus provides.  This is true for both JVM and native modes.  It provides similar functionality to the SAM CLI, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのAmazon Lambdaエクステンションには、Quarkusが提供するインテグレーションレイヤーを介して、AWS Lambda関数上で標準的なJUnitテストを実行するための機能を提供するマッチングテストフレームワークがあります。これはJVMモードとネイティブモードの両方に当てはまります。これは、DockerのオーバーヘッドなしでSAM CLIと同様の機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate, the project generated by the Maven archetype, generates a JUnit test for the `RequestHandler&lt;?, ?&gt;` implementation, which is shown below.  The test replicates the execution environment, for the function that is selected for invocation, as described &lt;&lt;choose, above&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>説明のために、Maven のアーキタイプで生成されたプロジェクトは、 `RequestHandler&lt;?, ?&gt;` の実装用の JUnit テストを生成します。このテストは、 link:#choose[上] で説明したように、呼び出しのために選択された関数の実行環境を複製しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the integration tests in your project there is a required property, in `src/test/resources/application.properties`. If not included, the integration tests will be in a constant loop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトで統合テストを使用するには、 `src/test/resources/application.properties` に必須のプロパティーがあります。これが含まれていない場合、統合テストは固定のループになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are following along with the example Maven archetype project for AWS Lambda in this guide, it includes the required property `quarkus.lambda.enable-polling-jvm-mode=true` in the test `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドのAWS Lambda用のMaven archetypeプロジェクトの例に従う場合、テストの `application.properties` に必要なプロパティー `quarkus.lambda.enable-polling-jvm-mode=true` が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, if you are using a `RequestStreamHandler` implementation, you can add a matching JUnit test, like below, which aligns to the generated `StreamLambda` class in the generated project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、 `RequestStreamHandler` の実装を使用している場合は、以下のように一致する JUnit テストを追加することで、生成されたプロジェクトで生成された `StreamLambda` クラスに合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces, whether `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>明らかに、これら2種類のテストは相互に排他的です。 `RequestHandler&lt;?, ?&gt;` と `RequestStreamHandler` のいずれか、実装されているAWS Lambdaインターフェースに対応したテストを用意しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two versions of the Test for `RequestStreamHandler` are presented below.  You can use either, depending on the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下に、 `RequestStreamHandler` 用のテストの 2 つのバージョンを紹介します。ユニットテストの必要性に応じて、どちらを使用しても構いません。前者の方が明らかにシンプルで速いです。Java ストリームを使用すると、より多くのコーディングが必要になることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードが CDI インジェクションを使用している場合、これもモッキング機能とともに実行されます。詳細は link:getting-started-testing[テストガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add JUnit functionality for native tests, add the `@NativeImageTest` annotation to a subclass of your test class, which will execute against your native image, and can be leveraged in an IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブテストに JUnit の機能を追加するには、テストクラスのサブクラスに `@NativeImageTest` アノテーションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] を利用すると、Lambda をシミュレートした環境でラップトップ上のローカルで Lambda を実行することができます。これには link:https://www.docker.com/products/docker-desktop[docker] のインストールが必要です。これは、利用することを選択した場合のオプションのアプローチです。それ以外の場合は、Quarkus JUnitの統合でほとんどのニーズを満たすことができるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.  The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の SAM CLI コマンドを実行して、適切な SAM `template` を渡して Lambda Function をローカルでテストします。 `event` パラメーターには任意の JSON ファイルを指定します。この場合はサンプル `payload.json` を指定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradle を使用している場合、YAML テンプレートのバイナリーへのパスを `target` から `build` に変更しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated by the build.  To do this create a `zip.jvm` or `zip.native` directory within `src/main`.  Create `zip.jvm/` if you are doing a pure Java lambda.  `zip.native/` if you are doing a native deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドによって生成された `function.zip` Lambda デプロイメントにいくつかの追加を加えなければならない場合があります。これを行うには、 `src/main` 内に `zip.jvm` または `zip.native` ディレクトリーを作成します。Pure Java Lambda を実行している場合は `zip.jvm/` を、ネイティブディプロイメントを実行している場合は `zip.native/` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes your native quarkus lambda deployment.  If you include a `bootstrap` script file within `zip.native`, the quarkus extension will automatically rename the executable to `runner` within `function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ラムダがネイティブの quarkus ラムダデプロイメントを起動する際に、特定のシステムプロパティーやその他の引数を設定したい場合があるかもしれません。 `zip.native` 内に `bootstrap` スクリプトファイルを含めると、Quarkus エクステンションは自動的に実行ファイルの名前を `function.zip` 内の `runner` に変更し、 `bootstrap` スクリプトの unix モードを実行ファイルに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、 `manage.sh` の `cmd_create()` 関数で AWS X-Ray tracing パラメーターを有効にすることを忘れないでください。これはAWSマネジメントコンソールでも設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the sam template files, add the following to the YAML function Properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SAM テンプレートファイルの場合は、YAML の Function Properties に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AWS X-Ray はディストリビューションに多くのクラスを追加しますが、最低でも256MBのAWS Lambdaメモリーサイズを使用していることを確認してください。これは `manage.sh` `cmd_create()` で明示的に設定されています。ネイティブイメージは常により低いメモリー設定を使用できる可能性がありますが、特にパフォーマンスを比較するためには同じ設定にしておくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image, as GraalVM will only include the dependencies when explicitly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.  For further information, please consult the link:native-and-ssl[Quarkus SSL guide]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードがマイクロサービス(またはAWSサービス)などの HTTPS 呼び出しを行う場合、GraalVM は明示的に宣言された場合にのみ依存関係を含むため、ネイティブイメージに設定を追加する必要があります。Quarkus は、デフォルトでは、この機能を暗黙的に必要とするエクステンションでこの機能を有効にします。詳細については、 link:native-and-ssl[Quarkus SSLガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open src/main/resources/application.properties and add the following line to enable SSL in your native image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>src/main/resources/application.properties を開き、以下の行を追加してネイティブイメージでSSLを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming). Please check those guides on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusにはDynamoDB、S3、SNS、SQS (他にも追加中) のエクステンションが追加されました。以下のように手動でワイヤリングするのではなく、Quarkusを使って様々なAWSサービスを利用する方法については、それらのガイドを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With minimal integration, it is possible to leverage the AWS Java SDK v2, which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最小限のインテグレーションで、AWSのJava SDK v2を活用し、SQS、SNS、S3、DynamoDBなどのサービスを呼び出すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For native image, however the URL Connection client must be preferred over the Apache HTTP Client when using synchronous mode, due to issues in the GraalVM compilation (at present).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかしながら、ネイティブイメージに対しては、同期モードを使用する場合は、GraalVMのコンパイルの問題のため、Apache HTTPクライアントよりもURL接続クライアントを優先する必要があります(現在のところ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus-jaxb` as a dependency in your Maven `pom.xml`, or Gradle `build.gradle` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jaxb` を依存関係として Maven `pom.xml` または Gradle `build.gradle` ファイルに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also force your AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS, hence the inclusion of the SSL enabled property, as described in the &lt;&lt;https&gt;&gt; section above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、SQS, SNS, S3などのAWSサービスクライアントでは、 link:#https[HTTPS] でAWSサービスに接続するURL Connectionクライアントを強制的に使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Maven, add the following to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mavenの場合は、 `pom.xml` に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM, there is some additional work to bundle the `function.zip`, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もし、 `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` 、または同様のSSLエラーが表示された場合、GraalVMの現状のため、 `function.zip` 、以下のようにバンドルするための追加作業があります。詳しくは、 link:native-and-ssl[Quarkus Native SSLガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional requirements for client SSL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントSSLの追加要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable requires some additional steps to enable client ssl that S3 and other aws libraries need.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルは、S3や他のawsライブラリが必要とするクライアントSSLを有効にするために、いくつかの追加の手順が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A custom `bootstrap` script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタム `bootstrap` スクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`libsunec.so` must be added to `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`function.zip` に `libsunec.so` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`cacerts` must be added to `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`function.zip` に `cacerts` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap` within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを行うには、まず、ビルドでディレクトリー `src/main/zip.native/` を作成します。次に `src/main/zip.native/` 内に `bootstrap` という名前のシェルスクリプトファイルを作成します。サンプル `bootstrap-example.sh` がビルドフォルダー(ターゲットまたはビルド)内に自動的に作成されます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional set `-Djavax.net.ssl.trustStorePassword=changeit` if your `cacerts` file is password protected.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`cacerts` ファイルがパスワードで保護されている場合は、追加で `-Djavax.net.ssl.trustStorePassword=changeit` を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next you must copy some files from your GraalVM distribution into `src/main/zip.native/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、GraalVM ディストリビューションから `src/main/zip.native/` にいくつかのファイルをコピーする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM versions can have different paths for these files, and whether you using the Java 8 or 11 version. Adjust accordingly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 8 か 11 バージョンのいずれか、GraalVM バージョンによって、これらのファイルのパスが異なる場合があります。それに応じて調整してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run the native build all these files will be included within `function.zip`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブビルドを実行すると、これらのファイルはすべて `function.zip` に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a Docker image to build, then you must extract these files from this image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dockerイメージを使ってビルドする場合は、このイメージからこれらのファイルを抽出する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To extract the required ssl, you must start up a Docker container in the background, and attach to that container to copy the artifacts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要な SSL を抽出するには、バックグラウンドでDockerコンテナーを起動し、そのコンテナーにアタッチしてアーティファクトをコピーする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's start the GraalVM container, noting the container id output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、GraalVMコンテナーを起動して、コンテナーIDの出力に注目してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, libsunec.so, the C library used for the SSL implementation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、SSLの実装に使用するC言語のライブラリである libsunec.so です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つ目は、cacerts(証明書ストア)です。また、定期的に更新されたコピーを取得する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your final archive will look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最終的なアーカイブは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Alexa with Quarkus native, please add the following extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Alexa を Quarkus ネイティブで使用するには、以下のエクステンションを追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create your Alexa handler, as normal, by sub-classing the abstract `com.amazon.ask.SkillStreamHandler`, and add your request handler implementation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常通り、抽象クラス `com.amazon.ask.SkillStreamHandler` をサブクラス化して Alexa ハンドラーを作成し、リクエストハンドラーの実装を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それだけだよ!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications.  Because it's the _canonical_ web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがWebSocketを利用してインタラクティブなウェブアプリケーションを作成する方法を説明します。 _定型的な_ WebSocketアプリケーションなので、簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward chat application using web sockets to receive and send messages to the other connected users.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、WebSocketを使用して、接続されている他のユーザーとメッセージを送受信するための簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:websocket-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:websocket-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `websockets-quickstart` {quickstarts-tree-url}/websockets-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `websockets-quickstart` {quickstarts-tree-url}/websockets-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project (without any classes) and import the `websockets` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Mavenプロジェクト(クラスなし)を生成し、 `undertow-websockets` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `websockets` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `undertow-websockets` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling web sockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>WebSocketの取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our application contains a single class that handles the web sockets.  Create the `org.acme.websockets.ChatSocket` class in the `src/main/java` directory.  Copy the following content into the created file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションには、Web ソケットを処理するクラスが一つ含まれます。 `src/main/java` ディレクトリーに `org.acme.websockets.ChatSocket` クラスを作成します。作成したファイルに以下の内容をコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stores the currently opened web sockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在開いているWebSocketを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A slick web frontend</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>洗練されたWebフロントエンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All chat applications need a _nice_ UI, well, this one may not be that nice, but does the work.  Quarkus automatically serves static resources contained in the `META-INF/resources` directory.  Create the `src/main/resources/META-INF/resources` directory and copy this {quickstarts-blob-url}/websockets-quickstart/src/main/resources/META-INF/resources/index.html[index.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのチャットアプリケーションには _素敵な_ UIが必要です。Quarkusは、 `META-INF/resources` ディレクトリーに含まれる静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーを作成し、この {quickstarts-blob-url}/websockets-quickstart/src/main/resources/META-INF/resources/index.html[index.html] ファイルをコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's see our application in action. Run it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、実際にアプリケーションを見てみましょう。以下のように実行してみてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then open your 2 browser windows to http://localhost:8080/:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、ブラウザウィンドウを2つ開いて、 http://localhost:8080/ に移動します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter a name in the top text area (use 2 different names).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上部のテキストエリアに名前を入力します(2種類の名前を使用します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on connect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>connectをクリック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send and receive messages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージの送受信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:websocket-guide-screenshot.png[alt=Application]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:websocket-guide-screenshot.png[alt=Application]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file.  You can also build the native executable using `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `target/quarkus-app/quarkus-run.jar` ファイルを使って実行することができます。また、 `./mvnw package -Pnative` を使用してネイティブの実行ファイルをビルドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also test your web socket applications using the approach detailed {quickstarts-blob-url}/websockets-quickstart/src/test/java/org/acme/websockets/ChatTest.java[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、{quickstarts-blob-url}/websockets-quickstart/src/test/java/org/acme/websockets/ChatTest.java[こちら]で詳細に解説された手法を使用して、Webソケットアプリケーションをテストすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also contains a WebSocket client. You can call `ContainerProvider.getWebSocketContainer().connectToServer` to create a websocket connection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには、WebSocketクライアントも含まれています。 `ContainerProvider.getWebSocketContainer().connectToServer` を呼び出して、Websocket接続を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you connect to the server you can either pass in the Class of the annotated client endpoint you want to use, or an instance of `javax.websocket.Endpoint`. If you are using the annotated endpoint then you can use the exact same annotations as you can on the server, except it must be annotated with `@ClientEndpoint` instead of `@ServerEndpoint`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーに接続する際には、使用するアノテーション付きクライアント・エンドポイントの Class で渡すか、 `javax.websocket.Endpoint` のインスタンスで渡すことができます。アノテーション付きエンドポイントを使用している場合は、サーバー上で使用できるのとまったく同じアノテーションを使用できますが、アノテーションは `@ServerEndpoint` ではなく `@ClientEndpoint` でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example below shows the client being used to test the chat endpoint above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例は、上記のチャットエンドポイントをテストするために使用されるクライアントを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More WebSocket Information</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のWebSocket情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus WebSocket implementation is an implementation of link:https://eclipse-ee4j.github.io/websocket-api/[Jakarta Websockets].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus WebSocketの実装は、 link:https://eclipse-ee4j.github.io/websocket-api/[Jakarta Websocket] の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from https://www.consul.io[Consul].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションが実行時に link:https://www.consul.io[Consul] から設定プロパティーを読み取る方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consul is a versatile system which among other things, provides a distributed Key-Value store that is used in many architectures as a source of configuration for services.  This Key-Value store is what the `quarkus-consul-config` extension interacts with in order to allow Quarkus applications to read runtime configuration properties from Consul.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Consulは、サービスの設定のソースとして多くのアーキテクチャで使用されている分散型のキーバリューストアを提供する多目的システムです。このキーバリューストアは、Quarkus アプリケーションが Consul から実行時の設定プロパティーを読み込めるようにするために、 `quarkus-consul-config` エクステンションがやり取りするものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various ways to start Consul that vary in complexity, but for the purposes of this guide, we elect to start a single Consul server with no persistence via Docker, like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Consul を起動する方法は複雑さによって様々ですが、このガイドの目的のために、Docker を介して永続性のない単一の Consul サーバーを起動することを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please consult the https://www.consul.io/docs/install[documentation] to learn more about the various Consul installation options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>様々なConsulのインストールオプションについては、 link:https://www.consul.io/docs/install[ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with a REST endpoint and imports the `consul-config` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `consul-config` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `consul-config` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `consul-config` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Maven plugin automatically generated a `GreetingResource` JAX-RS resource in the `src/main/java/org/acme/consul/config/client/GreetingResource.java` file that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Mavenプラグインは、 `src/main/java/org/acme/consul/config/client/GreetingResource.java` ファイル内に `GreetingResource` JAX-RSリソースを次のように自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides various configuration knobs under the `quarkus.consul-config` root. For the purposes of this guide, our Quarkus application is going to be configured in `application.properties` as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `quarkus.consul-config` ルートの下に様々な設定ノブを提供しています。このガイドの目的のために、私たちのQuarkusアプリケーションは以下のように `application.properties` で設定されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the previous application configuration to work, we need to add a `config/consul-test` key under Consul's Key Value store. The value of this key will essentially be a properties "file" containing the application configuration.  In this case we want to add the following data to the `config/consul-test` key:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以前のアプリケーション設定を動作させるためには、Consulのキーバリューストアの下に `config/consul-test` キーを追加する必要があります。このキーの値は、基本的にはアプリケーションの設定を含むプロパティー「ファイル」になります。この場合、 `config/consul-test` キーに以下のデータを追加したいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding this configuration from the UI, Consul will automatically convert the data into the necessary base64 encoding. If you instead add the configuration via the Consul's https://www.consul.io/api/kv.html#create-update-key[REST API], make sure to first encode the previous data into base64.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>UI からこの設定を追加すると、Consul は自動的に必要な base64 エンコーディングにデータを変換します。代わりに Consul の link:https://www.consul.io/api/kv.html#create-update-key[REST API ] を介して設定を追加する場合は、まず前のデータを base64 にエンコードするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this use case we made the value of the key as a properties "file", because we used `quarkus.consul-config.properties-value-keys` in the application. The extension also provides the ability to use the raw values of keys when `quarkus.consul-config.raw-value-keys` is used. Furthermore, these two properties can be used simultaneously, while each one also supports setting multiple keys.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このユースケースでは、アプリケーションで `quarkus.consul-config.properties-value-keys` を使用しているため、キーの値をプロパティー「ファイル」にしました。また、このエクステンションでは、 `quarkus.consul-config.raw-value-keys` を使用した場合に、キーの生の値を使用する機能を提供しています。さらに、この2つのプロパティーは同時に使用することができ、それぞれが複数のキーの設定にも対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result should be: `Hello from Consul` as it is the value obtained from the Consul Key Value store.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Consulキーバリューストアから取得した値なので、結果は、 `Hello from Consul` となるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation for:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、以下の場合のHibernate Validator/Bean Validation の使用方法について説明します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the input/output of your REST services;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST サービスの入出力の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the parameters and return values of the methods of your business services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスサービスのメソッドのパラメーターと戻り値の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple. The user fills a form on a web page.  The web page sends the form content to the `BookResource` as JSON (using Ajax). The `BookResource` validates the user input and returns the _result_ as JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで構築されたアプリケーションは非常にシンプルです。ユーザーはウェブページ上でフォームを入力します。Web ページはフォームの内容を JSON として `BookResource` に送信します (Ajax を使用)。 `BookResource` はユーザーの入力を検証し、 _結果_ をJSON として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson and Hibernate Validator/Bean Validation extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、およびHibernate Validator/Bean ValidationエクステンションをインポートするMavenディレクトリー構造を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `hibernate-validator` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `hibernate-validator` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the Validator</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バリデータへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.validation.BookResource` class, and inject the `Validator` object as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.validation.BookResource` クラスを編集し、以下のように `Validator` オブジェクトを注入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Validator` allows checking constraints on a specific object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Validator` では、特定のオブジェクトに対する制約をチェックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this application, we are going to test an elementary object, but we support complicated constraints and can validate graphs of objects.  Create the `org.acme.validation.Book` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のアプリケーションでは、基本のオブジェクトをテストすることになりますが、複雑な制約にも対応しており、オブジェクトのグラフを検証することができます。以下の内容で `org.acme.validation.Book` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints are added on fields, and when an object is validated, the values are checked.  The getter and setter methods are also used for JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィールドに制約を加え、オブジェクトが検証されると値がチェックされます。ゲッターメソッドとセッターメソッドはJSONマッピングにも使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to the `BookResource` class.  Add the following method:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`BookResource` クラスに戻り、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes it does not compile, `Result` is missing, but we will add it very soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、これはコンパイル出来ません。 `Result` がありませんが、私たちはすぐに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter (`book`) is created from the JSON payload automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッドパラメーター( `book` )は、JSONペイロードから自動的に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method uses the `Validator` to check the payload.  It returns a set of violations.  If this set is empty, it means the object is valid.  In case of failures, the messages are concatenated and sent back to the browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは `Validator` を使用してペイロードをチェックします。これは違反のセットを返します。このセットが空の場合は、オブジェクトが有効であることを意味します。失敗した場合は、メッセージを連結してブラウザに送り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create the `Result` class as an inner class:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、 `Result` クラスをインナークラスとして作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class is very simple and only contains 2 fields and the associated getters and setters.  Because we indicate that we produce JSON, the mapping to JSON is made automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクラスは非常にシンプルで、2つのフィールドとそれに関連するゲッターとセッターだけが含まれています。JSONを生成することを示しているので、JSONへのマッピングは自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `Validator` manually might be useful for some advanced usage, if you simply want to validate the parameters or the return value or your REST end point, you can annotate it directly, either with constraints (`@NotNull`, `@Digits`...)  or with `@Valid` (which will cascade the validation to the bean).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Validator` を手動で使用することは、高度な使用法には便利かもしれませんが、単にパラメーターや戻り値、RESTのエンドポイントを検証したい場合は、制約( `@NotNull`, `@Digits`...)や `@Valid` (Beanに検証をカスケードします)を使用して直接アノテーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an end point validating the `Book` provided in the request:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストで提供された `Book` を検証するエンドポイントを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, we don't have to manually validate the provided `Book` anymore as it is automatically validated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご覧のように、提供された `Book` は自動的に検証されるので、もう手動で検証する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a validation error is triggered, a violation report is generated and serialized as JSON as our end point produces a JSON output.  It can be extracted and manipulated to display a proper error message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証エラーが発生した場合、違反レポートが生成され、そしてエンドポイントがJSON出力を生成することによってJSONとしてシリアライズされます。これを抽出して操作することで、適切なエラーメッセージを表示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service method validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスメソッドの検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might not always be handy to have the validation rules declared at the end point level as it could duplicate some business validation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バリデーションルールをエンドポイントレベルで宣言するのは、必ずしも便利とは限りません。ビジネスバリデーションと重複する可能性があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best option is then to annotate a method of your business service with your constraints (or in our particular case with `@Valid`):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最良の選択肢は、ビジネスサービスのメソッドに制約をアノテーションすることです(私たちの場合は `@Valid` ):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling the service in your rest end point triggers the `Book` validation automatically:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTエンドポイントでサービスを呼び出すと、自動的に `Book` の検証が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that, if you want to push the validation errors to the frontend, you have to catch the exception and push the information yourselves as they will not be automatically pushed to the JSON output.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>検証エラーをフロントエンドにプッシュしたい場合は、例外をキャッチして自分で情報をプッシュしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that you usually don't want to expose to the public the internals of your services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたは通常、あなたのサービスの内部を公開したくないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and especially not the validated value contained in the violation object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特に違反オブジェクトに含まれる検証された値は公開したくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A frontend</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フロントエンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add the simple web page to interact with our `BookResource`.  Quarkus automatically serves static resources contained in the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, replace the `index.html` file with the content from this {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、 `BookResource`.Quarkusと対話するためのシンプルなウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーに含まれる静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーで、 `index.html` ファイルをこの {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] ファイルの内容で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open your browser to http://localhost:8080/:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、ブラウザで http://localhost:8080/ を開いてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the book details (valid or invalid)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>書籍の詳細を入力してください(有効または無効)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the _Try me..._ buttons to check if your data is valid using one of the methods we presented above.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_Try me..._ ボタンをクリックして、上記で紹介した方法のいずれかを使用してデータが有効かどうかを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate Validator extension is tightly integrated with CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ValidatorエクステンションはCDIと緊密に統合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you might need to configure the behavior of the `ValidatorFactory`, for instance to use a specific `ParameterNameProvider`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時には、 `ValidatorFactory` の動作を設定する必要があるかもしれません。例えば、特定の `ParameterNameProvider` を使用するためなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the `ValidatorFactory` is instantiated by Quarkus itself, you can very easily tweak it by declaring replacement beans that will be injected in the configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ValidatorFactory` は、Quarkus 自体によってインスタンス化されていますが、設定に注入される代わりのBeanを宣言することで、非常に簡単に微調整することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you create a bean of the following types in your application, it will automatically be injected into the `ValidatorFactory` configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションで以下のタイプのBeanを作成すると、自動的に `ValidatorFactory` の設定に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to wire anything.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何も設定しなくても大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, for each listed type, you can declare only one bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>勿論、リストされた各型に対して、宣言することができるのは1つのBeanだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These beans should be declared as `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのBeanは、 `@ApplicationScoped` として宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can declare your constraint validators as CDI beans:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>制約バリデーターをCDI Beanとして宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When initializing a constraint validator of a given type, Quarkus will check if a bean of this type is available and, if so, it will use it instead of instantiating one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>指定された型の制約バリデーターを初期化する際、Quarkusはこの型のBeanが利用可能かどうかをチェックし、利用可能な場合はインスタンスを作成する代わりにそれを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, as demonstrated in our example, you can fully use injection in your constraint validator beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このように、例で示したように、制約バリデーターBeanでインジェクションを完全に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except in very specific situations, it is recommended to make the said beans `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非常に特定の状況を除いて、このBeanは `@ApplicationScoped` として作ることをお勧めします.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation and localization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バリデーションとローカリゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, constraint violation messages will be returned in the build system locale.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、制約違反のメッセージはビルドシステムのロケールで返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior by adding the following configuration in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、以下の設定を `application.properties` に追加することで変更することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy, in the context of a JAX-RS endpoint, Hibernate Validator will automatically resolve the optimal locale to use from the `Accept-Language` HTTP header, provided the supported locales have been properly specified in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasyを使用している場合、JAX-RSエンドポイントのコンテキストでは、 サポートされるロケールが `application.properties` で適切に指定されている場合、Hibernate Validatorが使用する最適なロケールを `Accept-Language` HTTPヘッダから自動的に解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's sometimes necessary to enable different validation constraints for the same class when it's passed to a different method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同じクラスが別のメソッドに渡されたときに、異なるバリデーション制約を有効にする必要があることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, a `Book` may need to have a `null` identifier when passed to the `put` method (because the identifier will be generated), but a non-`null` identifier when passed to the `post` method (because the method needs the identifier to know what to update).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `Book` は、 `put` メソッドに渡されたときには `null` の識別子が必要ですが（識別子が生成されるため）、 `post` メソッドに渡されたときには `null` 以外の識別子が必要です（何を更新すべきかを知るためにメソッドが識別子を必要とするため）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To address this, you can take advantage of validation groups.  Validation groups are markers that you put on your constraints in order to enable or disable them at will.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これに対処するために、バリデーション・グループを利用することができます。バリデーション・グループは、制約を有効または無効にするために制約に付けるマーカーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, define the `Put` and `Post` groups, which are just Java interfaces.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、 `Put` と `Post` グループを定義します。単なるJavaインタフェースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make the custom groups extend the `Default` group.  This means that whenever these groups are enabled, the `Default` group is also enabled.  This is useful if you have constraints that you want validated in both the `Put` and `Post` method: you can simply use the default group on those constraints, like on the `title` property below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムグループを `Default` グループを拡張するようにします。これは、これらのグループが有効になっているときはいつでも、 `Default` グループも有効になることを意味します。これは、 `Put` と `Post` メソッドの両方で検証したい制約がある場合に便利です。以下の `title` プロパティのように、それらの制約に対してデフォルトのグループを使用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then add the relevant constraints to `Book`, assigning the right group to each constraint:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、関連する制約を `Book` に追加し、各制約に適切なグループを割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, add a `@ConvertGroup` annotation next to your `@Valid` annotation in your validated method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、検証済みメソッドの `@Valid` アノテーションの横に `@ConvertGroup` アノテーションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the `Put` group, meaning only constraints assigned to the `Put` (and `Default`) groups will be validated for the `book` parameter of the `put` method.  In this case, it means `Book.id` must be `null` and `Book.title` must not be blank.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Put` グループを有効にします。これは、 `Put` (および `Default`) グループに割り当てられた制約のみが、 `put` メソッドの `book` パラメータに対して検証されることを意味します。この場合、 `Book.id` は `null` でなければならず、 `Book.title` は空白であってはならないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the `Post` group, meaning only constraints assigned to the `Post` (and `Default`) groups will be validated for the `book` parameter of the `post` method.  In this case, it means `Book.id` must not be `null` and `Book.title` must not be blank.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Post` グループを有効にします。これは、 `Post` (および `Default`) グループに割り当てられた制約のみが、 `post` メソッドの `book` パラメータに対して検証されることを意味します。この場合、 `Book.id` は `null` であってはならず、 `Book.title` は空白であってはならないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers the ability to automatically generate Kubernetes resources based on sane defaults and user-supplied configuration using https://github.com/dekorateio/dekorate/[dekorate].  It currently supports generating resources for vanilla &lt;&lt;#kubernetes,Kubernetes&gt;&gt;, &lt;&lt;#openshift,OpenShift&gt;&gt; and &lt;&lt;#knative,Knative&gt;&gt;.  Furthermore, Quarkus can deploy the application to a target Kubernetes cluster by applying the generated manifests to the target cluster's API Server.  Finally, when either one of container image extensions is present (see the link:container-image[container image guide] for more details), Quarkus has the ability to create a container image and push it to a registry *before* deploying the application to the target platform.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 link:https://github.com/dekorateio/dekorate/[dekorate] を使用して、妥当なデフォルトとユーザーが提供する設定に基づいてKubernetesリソースを自動的に生成する機能を提供しています。現在、バニラ link:#kubernetes[Kubernetes] 、 link:#openshift[OpenShift] 、 link:#knative[Knative] のリソース生成をサポートしています。さらに、Quarkusは、生成されたマニフェストをターゲットクラスターのAPI Serverに適用することで、ターゲットKubernetesクラスターにアプリケーションをデプロイすることができます。最後に、コンテナーイメージエクステンションのいずれかが存在する場合(詳細は link:container-image[コンテナーイメージガイド] を参照)、Quarkusでは、ターゲットプラットフォームにアプリケーションをデプロイする *前* に、 コンテナーイメージを作成してレジストリーにプッシュする機能があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>access to a Kubernetes cluster (Minikube is a viable option)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes クラスターへのアクセス (Minikube も選択可能なオプションです)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create a new project that contains both the Kubernetes and Jib extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes エクステンションとJib エクステンションの両方を含む新しいプロジェクトを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This added the following dependencies to the `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、以下の依存関係が `pom.xml`に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding these dependencies, we enable the generation of Kubernetes manifests each time we perform a build while also enabling the build of a container image using Jib.  For example, following the execution of `./mvnw package`, you will notice amongst the other files that are created, two files named `kubernetes.json` and `kubernetes.yml` in the `target/kubernetes/` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの依存関係を追加することで、ビルドを実行するたびに Kubernetes のマニフェストを生成できるようになり、同時に Jib を使用したコンテナーイメージのビルドも可能になります。例えば、 `./mvnw package` を実行すると、作成される他のファイルの中に `kubernetes.json` と `kubernetes.yml` という名前のファイルが `target/kubernetes/` ディレクトリーにあることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at either file you will see that it contains both a Kubernetes `Deployment` and a `Service`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらのファイルを見ても、Kubernetes `Deployment` と `Service` 両方が含まれていることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source of the `kubernetes.json` file looks something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`kubernetes.json` ファイルの完全なソースはこんな感じです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifest can be applied to the cluster from the project root using `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたマニフェストは、 `kubectl` を使用してプロジェクトのルートからクラスターに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An important thing to note about the `Deployment` is that is uses `yourDockerUsername/test-quarkus-app:1.0.0-SNAPSHOT` as the container image of the `Pod`.  The name of the image is controlled by the Jib extension and can be customized using the usual `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Deployment` について注意すべき重要なことは、 `Pod` のコンテナーイメージとして `yourDockerUsername/test-quarkus-app:1.0-SNAPSHOT` を使用していることです。イメージの名前は Jib エクステンションによって制御され、通常の `application.properties` を利用してカスタマイズできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example with a configuration like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、次のような設定の場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The image that will be used in the generated manifests will be `quarkus/demo-app:1.0`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたマニフェストで使用されるイメージは `quarkus/demo-app:1.0` となります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Namespace</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前空間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus omits the namespace in the generated manifests, rather than enforce the `default` namespace. That means that you can apply the manifest to your chosen namespace when using `kubctl`, which in the example below is `test`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusは生成されたマニフェストの名前空間を省略し、 `default` 名前空間を強制しません。つまり、 `kubctl` (以下の例では `test` )を使用している場合は、選択したネームスペースにマニフェストを適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify the namespace in your manifest customize with the following property in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マニフェストで名前空間を指定するには、 `application.properties` の中で次のプロパティによってカスタマイズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding this property along with the rest of the container image properties of the previous section, the generated manifests will use the image `my.docker-registry.net/quarkus/demo-app:1.0`.  The image is not the only thing that can be customized in the generated manifests, as will become evident in the following sections.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のセクションで説明したコンテナーイメージプロパティーと一緒にこのプロパティーを追加すると、生成されるマニフェストではイメージ `my.docker-registry.net/quarkus/demo-app:1.0` を使用するようになります。次のセクションで明らかになるように、生成されるマニフェストでカスタマイズできるのはイメージだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels and Annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ラベルとアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifests use the Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[recommended labels].  These labels can be customized using `quarkus.kubernetes.name`, `quarkus.kubernetes.version` and `quarkus.kubernetes.part-of`.  For example by adding the following configuration to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたマニフェストには、Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[推奨のラベル]が使用されます。これらのラベルは、 `quarkus.kubernetes.name`, `quarkus.kubernetes.version` および `quarkus.kubernetes.part-of` を使用してカスタマイズすることができます。例えば、 `application.properties` に以下の設定を追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is described in detail in the &lt;&lt;#openshift, OpenShift&gt;&gt; section, customizing OpenShift (or Knative) properties is done in the same way, but replacing `kubernetes` with `openshift` (or `knative`). The previous example for OpenShift would look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#openshift[OpenShift] のセクションで詳しく説明しているように、OpenShift (または Knative) のプロパティーのカスタマイズは同じ方法で行いますが、 `kubernetes` を `openshift` (または `knative` ) に置き換えます。OpenShiftに対する先ほどの例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The labels in generated resources will look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソースのラベルは次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Labels</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Custom Labels</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add additional custom labels, for example `foo=bar` just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のカスタムラベルを追加するには、例えば `foo=bar` を設定する場合、以下の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the `quarkus-container-image-jib` extension to build a container image, then any label added via the aforementioned property will also be added to the generated container image.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-container-image-jib` エクステンションモジュールを使用してコンテナーイメージを作成する場合、前述のプロパティーを介して追加されたラベルも生成されたコンテナーイメージに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Out of the box, the generated resources will be annotated with version control related information that can be used either by tooling, or by the user for troubleshooting purposes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたリソースにはバージョン管理に関連する情報がアノテーションされ、ツールによって、またはユーザーがトラブルシューティングの目的で使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom annotations can be added in a way similar to labels.For example to add the annotation `foo=bar` and `app.quarkus/id=42` just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、注釈 `foo=bar` と `app.quarkus/id=42` を追加するには、次の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes provides multiple ways of defining environment variables:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetesでは、環境変数を定義する方法が複数用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is described in detail in the &lt;&lt;#openshift, OpenShift&gt;&gt; section, customizing OpenShift properties is done in the same way, but replacing `kubernetes` with `openshift`. The previous example for OpenShift would look like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#openshift[OpenShift] の項で詳しく説明していますが、OpenShift のプロパティーのカスタマイズも同じ方法で行いますが、 `kubernetes` を `openshift` に置き換えます。OpenShiftの先ほどの例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previous versions of the Kubernetes extension supported a different syntax to add environment variables.The older syntax is still supported but is deprecated and it's advised that you migrate to the new syntax.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes エクステンションの以前のバージョンでは、環境変数を追加するための異なる構文をサポートしていました。古い構文はまだサポートされていますが、非推奨ですので、新しい構文に移行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.vars.my-env-var=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env.vars.my-env-var=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.configmaps=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env.configmaps=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.xxx.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.xxx.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.foo.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.foo.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.foo.value=field`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.foo.value=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.mapping.foo.with-key=field`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env.mapping.foo.with-key=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.foo.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars.foo.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you redefine the same variable using the new syntax while keeping the old syntax, **ONLY** the new version will be kept and a warning will be issued to alert you of the problem.For example, if you define both `quarkus.kubernetes.env-vars.my-env-var.value=foobar` and `quarkus.kubernetes.env.vars.my-env-var=newValue`, the extension will only generate an environment variable `MY_ENV_VAR=newValue` and issue a warning.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>古い文法を残した状態で新しい文法を使って同じ変数を再定義した場合、 新しいバージョン **のみ** が保持され、問題を通知するために警告が発せられます。例えば、`quarkus.kubernetes.env-vars.my-env-var.value=foobar` と `quarkus.kubernetes.env.vars.my-env-var=newValue` の両方を定義した場合、エクステンションは環境変数 `MY_ENV_VAR=newValue` のみを生成して警告を発します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kubernetes extension allows the user to configure both volumes and mounts for the application.  Any volume can be mounted with a simple configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes エクステンションを使用すると、アプリケーションのボリュームとマウントの両方を設定することができます。 簡単な設定で任意のボリュームをマウントすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add a mount to the pod for volume `my-volume` to path `/where/to/mount`.  The volumes themselves can be configured as shown in the sections below.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、Pod のパス `/where/to/mount` にボリューム `my-volume` のマウントを追加します。 ボリューム自体は、以下のセクションに示すように設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing application configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション設定の受け渡し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports passing configuration from external locations (via Smallrye Config). This usually requires setting an additional environment variable or system propertiy.  When you need to use a secret or a config map for the purpose of application configuration, you need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、外部の場所から（Smallrye Config経由で）設定を渡すことをサポートしています。これには通常、追加の環境変数やシステムの適切性を設定する必要があります。 アプリケーションの設定の目的で Secret や ConfigMap を使用する必要がある場合は、以下のようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To simplify things, quarkus provides single step alternative:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>物事を単純化するために、Quarkus はシングルステップの代替手段を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When these properties are used, the generated manifests will contain everything required.  The application config volumes will be created using path: `/mnt/app-secret` and `/mnt/app-config-map` for secrets and configmaps respectively.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのプロパティを使用すると、生成されたマニフェストには必要なものがすべて含まれます。 アプリケーションのコンフィグボリュームは、Secret と ConfigMap にそれぞれパスを使用して作成されます。Secret と ConfigMap  はそれぞれ `/mnt/app-secret` と `/mnt/app-config-map` を使用して作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: Users may use both properties at the same time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注：ユーザーは両方のプロパティを同時に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the number of replicas:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レプリカ数を変更する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change the number of replicas from 1 to 3:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レプリカ数を1から3に変更するためには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add readiness and liveness probes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>rediness および liveness プローブを追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Kubernetes resources do not contain readiness and liveness probes in the generated `Deployment`. Adding them however is just a matter of adding the SmallRye Health extension like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Kubernetesリソースは、生成された `Deployment` の中に readiness と liveness のプローブを含みません。しかし、これらを追加するには、以下のように SmallRye Health エクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values of the generated probes will be determined by the configured health properties: `quarkus.smallrye-health.root-path`, `quarkus.smallrye-health.liveness-path` and `quarkus.smallrye-health.readiness-path`.  More information about the health extension can be found in the relevant link:microprofile-health[guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されるプローブの値は、設定されたヘルスプロパティによって決定されます。`quarkus.smallrye-health.root-path`, `quarkus.smallrye-health.liveness-path`, `quarkus.smallrye-health.readiness-path` で決定されます。 health エクステンションの詳細については、関連リンク:microprofile-health[ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing the readiness probe:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>rediness プローブのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To set the initial delay of the probe to 20 seconds and the period to 45:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プローブの初期遅延を 20 秒、周期を 45 秒に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add hostAliases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>hostAliases の追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add entries to a Pod's `/etc/hosts` file (more information can be found in https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes documentation]), just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Podの`/etc/hosts`ファイルにエントリを追加するには(詳細は https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes documentation] )、以下の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This would generate the following `hostAliases` section in the `deployment` definition:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、`deployment`定義の中に以下の `hostAliases` セクションが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Resources Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナリソース管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CPU &amp; Memory limits and requests can be applied to a `Container` (more info in https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[Kubernetes documentation]) using the following configuration:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CPUやメモリの制限やリクエストは、以下の設定で `Container` (詳細は https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[Kubernetes documentation] を参照) に適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This would generate the following entry in the `container` section:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、`container`セクションに以下のエントリが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications that are deployed to Kubernetes and need to access the API server will usually make use of the `kubernetes-client` extension:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetesにデプロイされ、APIサーバにアクセスする必要があるアプリケーションは、通常 `kubernetes-client` エクステンションを利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access the API server from within a Kubernetes cluster, some RBAC related resources are required (e.g. a ServiceAccount, a RoleBinding etc.).  So, when the `kubernetes-client` extension is present, the `kubernetes` extension is going to create those resources automatically, so that application will be granted the `view` role.  If more roles are required, they will have to be added manually.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetesクラスタ内からAPIサーバにアクセスするためには、RBAC関連のリソース(ServiceAccountやRoleBindingなど)が必要である。 そのため、`kubernetes-client` エクステンションが存在する場合、`kubernetes` エクステンションはこれらのリソースを自動的に作成し、アプリケーションに `view` ロールを付与します。 より多くのロールが必要な場合は、手動で追加しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/kubernetes/minikube[Minikube] is quite popular when a Kubernetes cluster is needed for development purposes. To make the deployment to Minikube experience as frictionless as possible, Quarkus provides the `quarkus-minikube` extension. This extension can be added to a project like so:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/kubernetes/minikube[Minikube] は、開発目的でKubernetesクラスタが必要な場合に非常に人気があります。Minikubeへのデプロイをできるだけ摩擦のないものにするために、Quarkusは `quarkus-minikube` エクステンションを提供しています。このエクステンションは、以下のようなプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of this extension is to generate Kubernetes manifests (`minikube.yaml` and `minikube.json`) that are tailored to Minikube.  This extension assumes a couple things:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションの目的は、Minikube に合わせた Kubernetes マニフェスト (`minikube.yaml` と `minikube.json`) を生成することです。 このエクステンションはいくつかのことを前提としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users won't be using an image registry and will instead make their container image accessible to the Kubernetes cluster by building it directly into Minikube's Docker daemon. To use Minikube's Docker daemon you must first execute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザーはイメージレジストリを使用せず、コンテナイメージをMinikubeのDockerデーモンに直接ビルドしてKubernetesクラスタにアクセスできるようにします。MinikubeのDockerデーモンを使用するには、まず実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications deployed to Kubernetes won't be accessed via a Kubernetes `Ingress`, but rather as a `NodePort` `Service`.  The advantage of doing this is that the URL of an application can be retrieved trivially by executing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetesにデプロイされたアプリケーションは、Kubernetesの `Ingress` ではなく、`NodePort` `Service` としてアクセスされます。 この方法の利点は、アプリケーションのURLを実行することで、アプリケーションのURLを簡単に取得できることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the https://kubernetes.io/docs/concepts/services-networking/service/#nodeport[nodePort] that is used in this case, users can set `quarkus.kubernetes.node-port`.  Note however that this configuration is entirely optional because Quarkus will automatically use a proper (and non-changing) value if none is set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合に使用される https://kubernetes.io/docs/concepts/services-networking/service/#nodeport[nodePort] を制御するために、ユーザーは `quarkus.kubernetes.node-port` を設定することができます。 しかし、何も設定されていない場合、Quarkusは自動的に適切な（変更されない）値を使用するため、この設定は完全に任意であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is highly discouraged to use the manifests generated by the Minikube extension when deploying to production as these manifests are intended for development purposes only. When deploying to production, consider using the vanilla Kubernetes manifests (or the OpenShift ones when targeting OpenShift).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番環境へのデプロイ時に Minikube エクステンションで生成されたマニフェストを使用することはまったくお勧めできません。本番環境にデプロイする場合は、バニラ Kubernetes マニフェスト (または OpenShift をターゲットにしている場合は OpenShift マニフェスト) の使用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the assumptions the Minikube extension makes don't fit your workflow, nothing prevents you from using the regular Kubernetes extension to generate Kubernetes manifests and apply those to your Minikube cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Minikube エクステンションが想定している前提がワークフローに合わない場合、通常の Kubernetes エクステンションを使用して Kubernetes マニフェストを生成し、それを Minikube クラスタに適用することを妨げるものは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tuning the generated resources using application.properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.properties を使用して生成されたリソースをチューニングする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kubernetes extension allows tuning the generated manifest, using the `application.properties` file.  Here are some examples:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes のエクステンションでは、`application.properties` ファイルを使用して生成されたマニフェストをチューニングすることができます。 ここではいくつかの例を紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below describe all the available configuration options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の表は、利用可能なすべての設定オプションについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>false</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.kubernetes.resources.limits.cpu</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties that use non-standard types, can be referenced by expanding the property.  For example to define a `kubernetes-readiness-probe` which is of type `Probe`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非標準型を使用するプロパティーは、プロパティーを展開することで参照することができます。例えば、 `Probe` 型の  `kubernetes-readiness-probe` を定義するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example `initial-delay` and `period` are fields of the type `Probe`.  Below you will find tables describing all available types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、 `initial-delay` と `period` は `Probe` タイプのフィールドです。以下に、利用可能なすべてのタイプを説明した表を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Types</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本的なタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Allowed values: `cluster-ip`, `node-port`, `load-balancer`, `external-name`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>許可される値: `cluster-ip` , `node-port` , `load-balancer` . `external-name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way to deploy an application to OpenShift is to use s2i (source to image) to create an image stream from the source and then deploy the image stream:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを OpenShift にデプロイする方法の1つとして、s2i(source to image)を使用してソースからイメージストリームを作成し、イメージストリームをデプロイする方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See further information in link:deploying-to-openshift[Deploying to OpenShift].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は「 link:deploying-to-openshift[OpenShiftへのデプロイ] 」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A description of OpenShift resources and customisable properties is given below alongside Kubernetes resources to show similarities where applicable.   This includes an alternative to  `oc new-app ...` above, i.e. `oc apply -f target/kubernetes/openshift.json` .
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShiftリソースとカスタマイズ可能なプロパティーの説明を以下にKubernetesリソースと一緒に記載し、該当する場合には類似性を示します。これには、上記の `oc new-app …` の代替、すなわち `oc apply -f target/kubernetes/openshift.json` を含みます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to generate resources for both platforms (vanilla Kubernetes and OpenShift), then you need to include both (comma separated).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>両方のプラットフォーム(バニラKubernetesとOpenShift)のリソースを生成する必要がある場合は、両方を含める必要があります(カンマ区切り)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the execution of `./mvnw package -Dquarkus.container-image.build=true ` you will notice amongst the other files that are created, two files named `openshift.json` and `openshift.yml` in the `target/kubernetes/` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw package -Dquarkus.container-image.build=true` の実行後に、 `target/kubernetes/` ディレクトリーに `openshift.json` と `openshift.yml` という名前の2つのファイルが作成されたことに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These manifests can be deployed as is to a running cluster, using `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのマニフェストは、 `kubectl` を使用して、実行中のクラスターにそのままデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift users might want to use `oc` instead of `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShiftユーザーは、 `kubectl` の代わりに `oc` を使用した方が良いかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides the link:deploying-to-openshift[OpenShift] extension. This extension is basically a wrapper around the Kubernetes extension and relieves OpenShift users of the necessity of setting the `deployment-target` property to `openshift`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは link:deploying-to-openshift[OpenShift] エクステンションも提供しています。このエクステンションは基本的に Kubernetes エクステンションのラッパーであり、OpenShiftユーザーが `deployment-target` プロパティーを `openshift` に設定する必要性を緩和します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenShift resources can be customized in a similar approach with Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetesと同様のアプローチでOpenShiftのリソースをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Knative</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Knative</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable the generation of Knative resources, you need to include Knative in the target platforms:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Knative リソースの生成を可能にするには、ターゲットプラットフォームに Knative を含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the execution of `./mvnw package` you will notice amongst the other files that are created, two files named `knative.json` and `knative.yml` in the `target/kubernetes/` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`./mvnw package` の実行後、作成された他のファイルの中に `knative.json` と `knative.yml` という名前のファイルが `target/kubernetes/` ディレクトリーにあることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at either file you will see that it contains a Knative `Service`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どちらかのファイルを見ると、Knative `Service` が含まれることが確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source of the `knative.json` file looks something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`knative.json` ファイルの完全なソースはこんな感じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifest can be deployed as is to a running cluster, using `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたマニフェストは、 `kubectl` を使用して、実行中のクラスターにそのままデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated service can be customized using the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたサービスは、以下のプロパティーを使用してカスタマイズすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expose a dedicated url for referncing this target</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このターゲットを参照するための専用URLを公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally provided to indicate that the latest revision should be used for this traffic target</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この Traffic ターゲットに最新のリビジョンを使用することを示すためにオプションで提供される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates the percent of traffic that is be routed to this revision</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリビジョンにルーティングされる Traffic の割合を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment targets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメントターゲット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mentioned in the previous sections was the concept of `deployment-target`. This concept allows users to control which Kubernetes manifests will be generated and deployed to a cluster (if `quarkus.kubernetes.deploy` has been set to `true`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のセクションで述べたのは `deployment-target` という概念です。この概念により、ユーザーはどの Kubernetes マニフェストを生成してクラスターにデプロイするかを制御することができます ( `quarkus.kubernetes.deploy` が `true` に設定されている場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when no `deployment-target` is set, then only vanilla Kubernetes resources are generated and deployed. When multiple values are set (for example `quarkus.kubernetes.deployment-target=kubernetes,openshift`) then the resources for all targets are generated, but only the resources that correspond to the *first* target are applied to the cluster (if deployment is enabled).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `deployment-target` が設定されていない場合は、バニラ Kubernetes リソースのみが生成され、デプロイされます。複数の値が設定されている場合 (例: `quarkus.kubernetes.deployment-target=kubernetes,openshift` )、すべてのターゲットのリソースが生成されますが、 *最初* のターゲットに対応するリソースのみがクラスターに適用されます (デプロイが有効な場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of wrapper extensions like OpenShift and Minikube, when these extensions have been explicitly added to the project, the default `deployment-target` is set by those extensions. For example if `quarkus-minikube` has been added to a project, then `minikube` becomes the default deployment target and its resources will be applied to the Kubernetes cluster when deployment via `quarkus.kubernetes.deploy` has been set.  Users can still override the deployment-targets manually using `quarkus.kubernetes.deployment-target`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShiftやMinikubeのようなラッパーエクステンションの場合、これらのエクステンションがプロジェクトに明示的に追加されているときは、それらのエクステンションによってデフォルトの `deployment-target` が設定されます。例えば、 `quarkus-minikube` がプロジェクトに追加されている場合、 `minikube` がデフォルトのデプロイメントターゲットになり、 `quarkus.kubernetes.deploy` 経由のデプロイメントが設定されていると、そのリソースが Kubernetes クラスターに適用されます。ユーザーは、 `quarkus.kubernetes.deployment-target` を使用して手動でディプロイメント ターゲットを上書きすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecated configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非推奨の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following categories of configuration properties have been deprecated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のカテゴリの構成プロパティーは非推奨となりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties without the quarkus prefix</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus接頭辞のないプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In earlier versions of the extension, the `quarkus.` was missing from those properties. These properties are now deprecated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以前のバージョンのエクステンションでは、これらのプロパティーに `quarkus.` がありませんでした。これらのプロパティーは現在非推奨となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties for configuring `docker` and `s2i` are also deprecated in favor of the new container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`docker` と `s2i` を設定するためのプロパティーも非推奨となり、新しいコンテナーイメージエクステンションが採用されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config group arrays</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンフィググループ配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, `kubernetes.env-vars[0]` etc) have been converted to maps, to align with the rest of the Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンフィググループ配列を参照するプロパティー(例: `kubernetes.labels[0]` 、 `kubernetes.env-vars[0]` など)は、Quarkusのエコシステムの他の部分と一致するようにマップに変換されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `labels` config:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコードは `labels` の設定を変更した様子を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `env-vars` config:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のコードは `env-vars` の設定を変更した様子を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars` are deprecated (though still currently supported as of this writing) and the new declaration style should be used instead.  See &lt;&lt;#env-vars&gt;&gt; and more specifically &lt;&lt;env-vars-backwards&gt;&gt; for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.kubernetes.env-vars` は非推奨です(この記事を書いている時点ではまだサポートされていますが)ので、代わりに新しい宣言スタイルを使うべきです。詳細は link:#env-vars[[env-vars]] とより具体的には link:#env-vars-backwards[[env-vars-backwards] を] 参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger building and deploying a container image you need to enable the `quarkus.kubernetes.deploy` flag (the flag is disabled by default - furthermore it has no effect during test runs or dev mode).  This can be easily done with the command line:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージをビルドしてデプロイするには、 `quarkus.kubernetes.deploy` フラグを有効にする必要があります (このフラグはデフォルトでは無効になっています - さらに、テスト実行中や開発モードでは何の効果もありません)。これはコマンドラインで簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a container image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a container image is possible, using any of the 3 available `container-image` extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナーイメージのビルドは、利用可能な3つの `container-image` エクステンションのいずれかを使用して可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each time deployment is requested, a container image build will be implicitly triggered (no additional properties are required when the Kubernetes deployment has been enabled).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイが要求されるたびに、暗黙のうちにコンテナーイメージのビルドがトリガーされます(Kubernetes のデプロイが有効になっている場合は、追加のプロパティーは必要ありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When deployment is enabled, the Kubernetes extension will select the resources specified by `quarkus.kubernetes.deployment.target` and deploy them.  This assumes that a `.kube/config` is available in your user directory that points to the target Kubernetes cluster.  In other words the extension will use whatever cluster `kubectl` uses. The same applies to credentials.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイを有効にすると、Kubernetes エクステンションは `quarkus.kubernetes.deployment.target` で指定されたリソースを選択してデプロイします。これは、ターゲットの Kubernetes クラスターを指す `.kube/config` がユーザーディレクトリーで利用可能であることを前提としています。言い換えれば、エクステンションは `kubectl` が使用しているクラスターを使用します。クレデンシャルについても同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment no additional options are provided for further customization.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のところ、さらなるカスタマイズのための追加オプションは提供されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using existing resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のリソースの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it's desirable to either provide additional resources (e.g. a ConfigMap, a Secret, a Deployment for a database etc) or provide custom ones that will be used as a `base` for the generation process.  Those resources can be added under `src/main/kubernetes` directory and can be named after the target environment (e.g. kubernetes.json, openshift.json, knative.json, or the yml equivalents). Each of these files may contain one or more Kubernetes resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時には、追加のリソース(例えば、ConfigMap、Secret、データベースのデプロイメントなど)を提供するか、生成プロセスのために `base` として使用されるカスタムのリソースを提供することが望ましい場合があります。これらのリソースは `src/main/kubernetes` ディレクトリーの下に追加することができ、ターゲット環境にちなんだ名前をつけることができます (例: kubernetes.json、openshift.json、knative.json、または yml 等価のもの)。これらのファイルのそれぞれには、1つ以上のKubernetesリソースが含まれている可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any resource found will be added in the generated manifests. Global modifications (e.g. labels, annotations etc) will also be applied to those resources.  If one of the provided resources has the same name as one of the generated ones, then the generated resource will be created on top of the provided resource, respecting existing content when possible (e.g. existing labels, annotations, environment variables, mounts, replicas etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>見つかったリソースは、生成されたマニフェストに追加されます。グローバルな変更(ラベルや注釈など)は、それらのリソースにも適用されます。提供されたリソースの一つが、生成されたリソースの一つと同じ名前を持つ場合、生成されたリソースは提供されたリソースの上に作成され、可能な限り既存のコンテンツ(既存のラベル、アノテーション、環境変数、マウント、レプリカなど)を尊重します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the resource is determined by the application name and may be overridden by `quarkus.kubernetes.name`, `quarkus.openshift.name` and `quarkus.knative.name`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソースの名前はアプリケーション名によって決定され、 `quarkus.kubernetes.name` 、 `quarkus.openshift.name` 、 `quarkus.knative.name` で上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, in the `kubernetes-quickstart` application, we can add a `kubernetes.yml` file in the `src/main/kubernetes` that looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `kubernetes-quickstart` アプリケーションでは、 `src/main/kubernetes` の中に `kubernetes.yml` のようなファイルを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated `kubernetes.yml` will look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `kubernetes.yml` は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided replicas &lt;1&gt;, labels &lt;2&gt; and environment variables &lt;3&gt; were retained. However, the image &lt;4&gt; and container port &lt;5&gt; were modified. Moreover, the default annotations have been added.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>提供されたレプリカ &lt;1&gt;, ラベル &lt;2&gt;, 環境変数 &lt;3&gt; はそのまま引き継がれました。ただし、イメージ &lt;4&gt; とコンテナーポート &lt;5&gt; は変更されました。また、デフォルトのアノテーションが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the resource name does not match the application name (or the overridden name) instead of reusing the resource a new one will be added. Same goes for the container.  If the name of the container does not match the application name (or the overridden name), container specific configuration will be ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リソース名がアプリケーション名(またはオーバーライドされた名前)と一致しない場合は、リソースを再利用する代わりに新しいリソースが追加されます。コンテナーについても同様です。コンテナーの名前がアプリケーション名 (またはオーバーライドされた名前) と一致しない場合、コンテナー固有の設定は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, the following Quarkus extensions support this feature:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在、以下のQuarkusエクステンションがこの機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This list of extensions will grow as more services with supported bindings become available on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションのリストは、サポートされたバインディングを持つサービスがKubernetesで利用できるようになるにつれ、増えていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable Service Binding support, in addition to one of the currently supported extensions, the `quarkus-kubernetes-service-binding` extension needs to be added to the application dependencies.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスバインディングのサポートを有効にするには、現在サポートされているエクステンションの1つに加えて、アプリケーションの依存関係に `quarkus-kubernetes-service-binding` エクステンションを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have a Hibernate ORM-based application? You want to provide a full-featured full-text search to your users? You're at the right place.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMベースのアプリケーションをお持ちですか?フル機能のフルテキスト検索をユーザーに提供したいですか?あなたは正しい場所にいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application described in this guide allows to manage a (simple) library: you manage authors and their books.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドに記載されているアプリケーションは、(シンプルな) 図書館を管理することができます:あなたは、著者とその本を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entities are stored in a PostgreSQL database and indexed in an Elasticsearch cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティはPostgreSQLデータベースに格納され、Elasticsearchクラスターにインデックスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `hibernate-search-orm-elasticsearch-quickstart` {quickstarts-tree-url}/hibernate-search-orm-elasticsearch-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `hibernate-search-orm-elasticsearch-quickstart` {quickstarts-tree-url}/hibernate-search-orm-elasticsearch-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the following extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、以下のエクステンションをインポートするMaven構造体を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM with Panache,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM with Panache,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the PostgreSQL JDBC driver,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQL JDBCドライバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search + Elasticsearch,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search + Elasticsearch,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy and Jackson.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasyとJackson。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `hibernate-search-orm-elasticsearch` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `hibernate-search-orm-elasticsearch` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, let's delete the two generated tests `LibraryResourceTest` and `NativeLibraryResourceIT` present in `src/test/java`.  If you are interested in how you can test this application, just refer to the solution in the quickstarts Git repository: it contains a lot of tests and the required testing infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは、 `src/test/java` にある `LibraryResourceTest` と `NativeLibraryResourceIT` の 2 つの生成されたテストを削除してみましょう。このアプリケーションのテスト方法に興味があれば、 quickstarts の Git リポジトリにあるソリューションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the bare entities</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベアエンティティーの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create our Hibernate ORM entities `Book` and `Author` in the `model` subpackage.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、 `model` サブパッケージに Hibernate ORM エンティティー `Book` と `Author` を作成しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using Hibernate ORM with Panache, it is not mandatory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PanacheでHibernate ORMを使用していますが、必須ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are loading these elements eagerly so that they are present in the JSON output.  In a real world application, you should probably use a DTO approach.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは、これらの要素がJSON出力に存在するように前もってロードしています。実際のアプリケーションでは、おそらくDTOアプローチを使うべきでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing out of the ordinary here: it is just good old Hibernate ORM with Panache operations in a standard JAX-RS service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは何も特別なことはありません。標準的なJAX-RSサービスでPanache操作を行う古き良きHibernate ORMです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go back to our entities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンティティに戻りましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling full text search capabilities for them is as simple as adding a few annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フルテキスト検索機能を有効にするには、いくつかのアノテーションを追加するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatic import script</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自動インポートスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purpose of this demonstration, let's import an initial dataset.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このデモの目的のために、初期データセットをインポートしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create a `src/main/resources/import.sql` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/resources/import.sql` ファイルを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preparing the infrastructure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インフラの準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need a PostgreSQL instance and an Elasticsearch cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PostgreSQLインスタンスとElasticsearchクラスターが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's use Docker to start one of each:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dockerを使ってそれぞれ1つずつ起動してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring multiple persistence units</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の永続化ユニットを設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject Hibernate Search's main entry points, `SearchSession` and `SearchMapping`, using CDI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDI を使用して、Hibernate Search のメインエントリーポイント `SearchSession` と `SearchMapping` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will inject the `SearchSession` of the default persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、デフォルトの永続化ユニットの `SearchSession` を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To inject the `SearchSession` of a named persistence unit (`users` in our example), just add a qualifier:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前付き永続化ユニット(この例では `users` )の `SearchSession` を注入するには、修飾子を追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the `@io.quarkus.hibernate.orm.PersistenceUnit` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `@io.quarkus.hibernate.orm.PersistenceUnit` のアノテーションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject the `SearchMapping` of a named persistence unit using the exact same mechanism:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>全く同じメカニズムを使って、名前付き永続化ユニットの `SearchMapping` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual with native executable compilation, this operation consumes a lot of memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブの実行ファイルのコンパイルと同様に、この操作は大量のメモリーを消費します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might be safer to stop the two containers while you are building the native executable and start them again once you are done.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルをビルドしている間は2つのコンテナーを停止して、ビルドが終わったら再度起動した方が安全かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/hibernate-search-orm-elasticsearch-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行は `./target/hibernate-search-orm-elasticsearch-quickstart-1.0-SNAPSHOT-runner` を実行するだけであり簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then point your browser to `http://localhost:8080/` and use your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、ブラウザで `http://localhost:8080/` を開きアプリケーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The startup is a bit slower than usual: it is mostly due to us dropping and recreating the database schema and the Elasticsearch mapping every time at startup.  We also inject some data and execute the mass indexer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>起動がいつもより少し遅いのは、起動時に毎回データベーススキーマとElasticsearchマッピングを落として再作成しているのが原因です。また、いくつかのデータを注入し、マスインデクサーを実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a real life application, it is obviously something you won't do at startup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実際のアプリケーションでは、明らかに起動時に実行しないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in learning more about Hibernate Search 6, the Hibernate team publishes link:{hibernate-search-doc-prefix}[an extensive reference documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search 6について詳しく知りたい方は、Hibernateチームが link:{hibernate-search-doc-prefix}[広範なリファレンスドキュメント] を公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why Elasticsearch only?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜElasticsearchだけなのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search supports both a Lucene backend and an Elasticsearch backend.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate SearchはLuceneバックエンドとElasticsearchバックエンドの両方をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the context of Quarkus and to build microservices, we thought the latter would make more sense.  Thus we focused our efforts on it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusとマイクロサービスを構築するという文脈では、後者の方がより意味があると考えました。そこで、私たちは後者に力を入れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't have plans to support the Lucene backend in Quarkus for now.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところ、QuarkusでLuceneバックエンドをサポートする予定はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When referencing beans using a string value in configuration properties, that string is parsed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定プロパティーで文字列の値を使用してBeanを参照する場合、その文字列は解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are the most common formats:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最も一般的なフォーマットは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`bean:` followed by the name of a `@Named` CDI bean.  For example `bean:myBean`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`bean:` の後に `@Named` CDI Beanの名前が続きます。例えば `bean:myBean` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`class:` followed by the fully-qualified name of a class, to be instantiated through CDI if it's a CDI bean, or through its public, no-argument constructor otherwise.  For example `class:com.mycompany.MyClass`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`class:` の後にクラスの完全修飾名を付けて、CDI Beanの場合は CDI を通して、そうでない場合はパブリックで引数なしのコンストラクタを通してインスタンス化されます。例えば `class:com.mycompany.MyClass` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An arbitrary string referencing a built-in implementation.  Available values are detailed in the documentation of each configuration property, such as `async`/`read-sync`/`write-sync`/`sync` for &lt;&lt;quarkus-hibernate-search-orm-elasticsearch_quarkus.hibernate-search-orm.automatic-indexing.synchronization.strategy,`quarkus.hibernate-search-orm.automatic-indexing.synchronization.strategy`&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルトイン実装を参照する任意の文字列。 `async` `read-sync` `write-sync` `sync` 利用可能な値は、各設定プロパティーのドキュメントで詳しく説明されています。 link:#quarkus-hibernate-search-orm-elasticsearch_quarkus.hibernate-search-orm.automatic-indexing.synchronization.strategy[`quarkus.hibernate-search-orm.automatic-indexing.synchronization.strategy`] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other formats are also accepted, but are only useful for advanced use cases.  See link:{hibernate-search-doc-prefix}#configuration-bean-reference-parsing[this section of Hibernate Search's reference documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他の形式も認められていますが、高度なユースケースでのみ有用です。詳細については、 link:{hibernate-search-doc-prefix}#configuration-bean-reference-parsing[Hibernate Searchのリファレンスドキュメントのこのセクション] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Funqy Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - Funqy Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy Funqy functions to Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Funqy 関数を Google Cloud Functions にデプロイする方法をクイックスタートコードで説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-google-cloud-functions-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-google-cloud-functions-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このソリューションは `funqy-google-cloud-functions-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-google-cloud-functions-quickstart[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an application with the `quarkus-funqy-google-cloud-functions` extension.  You can use the following Maven command to create it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-funqy-google-cloud-functions` のエクステンションを持つアプリケーションを作成します。  以下の Maven コマンドを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the code and more importantly nothing Google Cloud specific.  Funqy functions can be deployed to many different environments and Google Cloud Functions is one of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコードには何も特別なものはありません。また、重要なこととして、Google Cloud に特化したものは何もありません。Funqy 関数はさまざまな環境にデプロイすることができ、Google Cloud Functions はそのうちの 1 つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only one Funqy function can be exported per Google Cloud Functions deployment.  If you only have one method annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined within your project, then you will need to choose the function within your Quarkus `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions のデプロイごとにエクスポートできる Funqy 関数は 1 つだけです。プロジェクト内に `@Funq` でアノテーションされたメソッドが 1 つしかない場合は、心配ありません。プロジェクト内に複数の関数が定義されている場合は、Quarkus `application.properties` 内で関数を選択する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can set the `QUARKUS_FUNQY_EXPORT` environment variable when you create the Google Cloud Function using the `gcloud` cli.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、`gcloud` cliを使って Google Cloud Function を作成する際に、環境変数 `QUARKUS_FUNQY_EXPORT` を設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create two background functions. Background functions allow to react to Google Cloud events like PubSub messages, Cloud Storage events, Firestore events, ...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、2 つのバックグラウンド関数を作成します。バックグラウンド関数は、PubSub メッセージ、Cloud Storage イベント、Firestore イベントなどの Google Cloud イベントに反応することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.funqy.Funq;
import io.quarkus.funqy.gcp.functions.event.PubsubMessage;
import io.quarkus.funqy.gcp.functions.event.StorageEvent;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.funqy.Funq;
import io.quarkus.funqy.gcp.functions.event.PubsubMessage;
import io.quarkus.funqy.gcp.functions.event.StorageEvent;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class GreetingFunctions {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class GreetingFunctions {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject GreetingService service; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject GreetingService service; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Funq // &lt;2&gt;
    public void helloPubSubWorld(PubsubMessage pubSubEvent) {
        String message = service.hello(pubSubEvent.data);
        System.out.println(pubSubEvent.messageId + " - " + message);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Funq // &lt;2&gt;
    public void helloPubSubWorld(PubsubMessage pubSubEvent) {
        String message = service.hello(pubSubEvent.data);
        System.out.println(pubSubEvent.messageId + " - " + message);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Funq // &lt;3&gt;
    public void helloGCSWorld(StorageEvent storageEvent) {
        String message = service.hello("world");
        System.out.println(storageEvent.name + " - " + message);
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Funq // &lt;3&gt;
    public void helloGCSWorld(StorageEvent storageEvent) {
        String message = service.hello("world");
        System.out.println(storageEvent.name + " - " + message);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Function return type can also be Mutiny reactive types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関数の戻り値の型は、Mutiny 反応型も可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a background function that takes as parameter a `io.quarkus.funqy.gcp.functions.event.PubsubMessage`, this is a convenient class to deserialize a PubSub message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、`io.quarkus.funqy.gcp.functions.event.PubsubMessage` をパラメーターとするバックグルアンド関数で、PubSub メッセージをデシリアライズする便利なクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a background function that takes as parameter a `io.quarkus.funqy.gcp.functions.event.StorageEvent`, this is a convenient class to deserialize a Google Storage event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、`io.quarkus.funqy.gcp.functions.event.StorageEvent` をパラメーターとするバックグラウンド関数で、Google Storage イベントをデシリアライズするための便利なクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>we provide convenience class to deserialize common Google Cloud event inside the `io.quarkus.funqy.gcp.functions.event` package.  They are not mandatory to use, you can use any object you want.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.funqy.gcp.functions.event` パッケージ内の Google Cloud の共通イベントをデシリアライズするための便利なクラスを提供しています。これらのクラスは必須ではなく、任意のオブジェクトを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As our project contains multiple function, we need to specify which function needs to be deployed via the following property inside our `application.properties` :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトには複数の関数が含まれているので、どの関数を、`application.properties` 内の以下のプロパティーからデプロイする必要があるかを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.funqy.export=helloPubSubWorld
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.funqy.export=helloPubSubWorld
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build your application, you can package your application via `mvn clean package`.  You will have a single JAR inside the `target/deployment` repository that contains your classes and all your dependencies in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをビルドするには、 `mvn clean package` からアプリケーションをパッケージ化することができます。`target/deployment` リポジトリー内には、クラスとすべての依存関係が含まれた単一の JAR があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you will be able to use `gcloud` to deploy your function to Google Cloud, the `gcloud` command will be different depending from which event you want to be triggered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、`gcloud` を使用して Google Cloud に関数をデプロイすることができるようになります。`gcloud` コマンドは、どのイベントをトリガーにしたいかによって異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Background Functions - PubSub</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バックグラウンド関数 - PubSub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this command to deploy to Google Cloud Functions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドを使用して、Google Cloud Functions にデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry point always needs to be `io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction` as it will be this class that will bootstrap Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus をブートストラップするのはこのクラスなので、エントリーポイントは常に `io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `--trigger-resource` option defines the name of the PubSub topic, and the `--trigger-event google.pubsub.topic.publish` option define that this function will be triggered by all message publication inside the topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--trigger-resource` オプションは PubSub トピックの名前を定義し、`--trigger-event google.pubsub.topic.publish` オプションは、この関数がトピック内のすべてのメッセージ公開によってトリガーされることを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger an event to this function, you can use the `gcloud functions call` command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この関数にイベントをトリガーするには、 `gcloud functions call` コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gcloud functions call quarkus-example-funky-pubsub --data '{"data":"Pub/Sub"}'
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gcloud functions call quarkus-example-funky-pubsub —data ‘{“data”:”Pub/Sub”}’
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `--data '{"data":"Hello, Pub/Sub"}'` option allow to specify the message to be send to PubSub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--data '{"data":"Hello, Pub/Sub"}'` オプションでは、メッセージが PubSub に送信されるようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Background Functions - Cloud Storage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バックグラウンド関数 - クラウドストレージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, use this command to deploy to Google Cloud Functions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、このコマンドを使って Google Cloud Functions にデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `--trigger-resource` option defines the name of the Cloud Storage bucket, and the `--trigger-event google.storage.object.finalize` option define that this function will be triggered by all new file inside this bucket.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--trigger-resource` オプションは Cloud Storage のバケット名を定義します。また、`--trigger-event google.storage.object.finalize` オプションはこのバケット内のすべての新規ファイルに対してこの関数がトリガーされることを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gcloud functions call quarkus-example-funky-storage --data '{"name":"test.txt"}'
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gcloud functions call quarkus-example-funky-storage --data '{"name":"test.txt"}'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `--data '{"name":"test.txt"}'` option allow to specify a fake file name, a fake Cloud Storage event will be created for this name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`--data '{"name":"test.txt"}'` オプションでは、偽のファイル名を指定することができ、この名前に対して偽のクラウドストレージイベントが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also simply add a file to Cloud Storage using the command line of the web console.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Web コンソールのコマンドラインを使用して、Cloud Storage にファイルを追加するだけでも簡単にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use it to launch your function locally, again, the command depends on the type of function and the type of events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、これは、ローカルで関数を起動するために使用することができます。このコマンドは、関数の種類とイベントの種類に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For background functions, you launch the invoker with a target class of `io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バックグラウンド関数の場合は、 `io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction` のターゲットクラスで invoker を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl localhost:8080 -d '{"data":{"data":"world"}}'
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>curl localhost:8080 -d '{"data":{"data":"world"}}'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will call your PubSub background function with a PubSubMessage `{"data":"hello"}`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、PubSub のバックグラウンド関数を PubSubMessage で呼び出します `{"data":"hello”}`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl localhost:8080 -d '{"data":{"name":"text"}}'
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>curl localhost:8080 -d '{"data":{"name":"text"}}'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will call your PubSub background function with a Cloud Storage event `{"name":"file.txt"}`, so an event on the `file.txt` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Cloud Storage のイベント `{"name":"file.txt"}` (`file.txt` ファイル上のイベント) で PubSub のバックグラウンド関数を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for JAX-RS, Servlet or Vert.x support for Google Cloud Functions, we have it thanks to our link:gcp-functions-http[Google Cloud Functions HTTP binding].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions の JAX-RS、Servlet、Vert.x サポートをお探しですか。Google Cloud link:gcp-functions-http[Functions HTTP バインディング] によりサポートしております。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus アプリケーションが SmallRye Reactive Messaging を利用して Apache Kafka とやりとりする仕組みを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Kafka cluster, or Docker Compose to start a development cluster</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行中の Kafka クラスター、または開発クラスターを開始するための Docker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、1 つのコンポーネントでランダムな価格 (price) を生成します。これらの価格は、Kafka トピック (`prices`) に書かれています。2 番目のコンポーネントは `prices` Kafka トピックから読み込み、この価格に変換を適用します。その結果は、JAX-RS リソースによって消費されるインメモリーストリームに送られます。データは、サーバーから送信されたイベントを使用してブラウザーに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-guide-architecture.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>kafka-guide-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このソリューションは `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=kafka-quickstart \
    -DclassName="org.acme.kafka.PriceResource" \
    -Dpath="/prices" \
    -Dextensions="resteasy,smallrye-reactive-messaging-kafka"
cd kafka-quickstart
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=kafka-quickstart \
    -DclassName="org.acme.kafka.PriceResource" \
    -Dpath="/prices" \
    -Dextensions="resteasy,smallrye-reactive-messaging-kafka"
cd kafka-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-reactive-messaging-kafka"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-reactive-messaging-kafka"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `src/main/java/org/acme/kafka/PriceGenerator.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A bean producing random prices every 5 seconds.
 * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.
 */
@ApplicationScoped
public class PriceGenerator {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/**
 * A bean producing random prices every 5 seconds.
 * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.
 */
@ApplicationScoped
public class PriceGenerator {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドは、_Reactive Stream_ を返します。生成されたアイテムは `generated-price` という名前のストリームに送られます。このストリームは、次に作成する `application.properties` ファイルを使用して Kafka にマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>価格コンバーターは、Kafka から価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/kafka/PriceConverter.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A bean consuming data from the "prices" Kafka topic and applying some conversion.
 * The result is pushed to the "my-data-stream" stream which is an in-memory stream.
 */
@ApplicationScoped
public class PriceConverter {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/**
 * A bean consuming data from the "prices" Kafka topic and applying some conversion.
 * The result is pushed to the "my-data-stream" stream which is an in-memory stream.
 */
@ApplicationScoped
public class PriceConverter {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("prices")                                     // &lt;1&gt;
    @Outgoing("my-data-stream")                             // &lt;2&gt;
    @Broadcast                                              // &lt;3&gt;
    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // &lt;4&gt;
    public double process(int priceInUsd) {
        return priceInUsd * CONVERSION_RATE;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Incoming("prices")                                     // &lt;1&gt;
    @Outgoing("my-data-stream")                             // &lt;2&gt;
    @Broadcast                                              // &lt;3&gt;
    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // &lt;4&gt;
    public double process(int priceInUsd) {
        return priceInUsd * CONVERSION_RATE;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the method consumes the items from the `prices` topic</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドが `prices` トピックのアイテムを消費することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the objects returned by the method are sent to the `my-data-stream` stream</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このメソッドによって返されたオブジェクトが `my-data-stream` ストリームに送られることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to acknowledge the incoming message</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>incoming メッセージの受け取りを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`process` メソッドは、`prices` トピック (アプリケーション設定の中で設定) からの Kafka _レコード_ ごとに呼び出されます。すべての結果は `my-data-stream` インメモリーストリームに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、ストリームを JAX-RSリソース にバインドしてみましょう。以下の内容の `src/main/java/org/acme/kafka/PriceResource.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.jboss.resteasy.annotations.SseElementType;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.jboss.resteasy.annotations.SseElementType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A simple resource retrieving the in-memory "my-data-stream" and sending the items as server-sent events.
 */
@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/**
 * A simple resource retrieving the in-memory "my-data-stream" and sending the items as server-sent events.
 */
@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS) // &lt;2&gt;
    @SseElementType("text/plain") // &lt;3&gt;
    public Publisher&lt;Double&gt; stream() { // &lt;4&gt;
        return prices;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS) // &lt;2&gt;
    @SseElementType("text/plain") // &lt;3&gt;
    public Publisher&lt;Double&gt; stream() { // &lt;4&gt;
        return prices;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the data contained within the server sent events is of type `text/plain`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーから送信されたイベントに含まれるデータのタイプが `text/plain` であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka コネクターを設定する必要があります。これは `application.properties` ファイルで行います。このキーは以下のような構造になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.generated-price.connector=smallrye-kafka
mp.messaging.outgoing.generated-price.topic=prices
mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.generated-price.connector=smallrye-kafka
mp.messaging.outgoing.generated-price.topic=prices
mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定の詳細は、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。これらのプロパティは、`kafka` という接頭辞で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is "mp.messaging.incoming.prices.health-readiness-enabled=false"?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"mp.messaging.incoming.prices.health-readiness-enabled=false" とは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `health-readiness-enabled` disables the readiness health check.  By default, it verifies that there is an active connection with the broker.  In our case, the connection only happens when we get the first consumer.  This is because the stream is consumed as an SSE, waiting lazily for the first connection to trigger the whole stream.  So, if you are running in an environment only routing traffic to containers that are _ready_ (such as Kubernetes), it would not send traffic to your application, which, as a consequence, will never connect to Kafka and pass the readiness check.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`health-readiness-enabled` は、Readinessヘルスチェックを無効にします。デフォルトでは、ブローカーとのアクティブな接続があるかどうかを検証します。今回のケースでは、最初のコンシューマを取得したときにのみ接続が発生します。これは、ストリームがSSEとして消費され、最初の接続がストリーム全体のトリガーとなるのをのんびりと待っているからです。そのため、 _準備_ ができているコンテナにのみトラフィックをルーティングする環境（Kubernetesなど）で実行している場合、アプリケーションにトラフィックを送らないことになり、結果としてKafkaに接続してReadinessチェックを通過することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about health reporting is given in &lt;&lt;kafka-health-check&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスレポートについての詳細は、 &lt;&lt;kafka-health-check&gt;&gt;に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  zookeeper:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  zookeeper:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  kafka:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  kafka:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you need to have an imperative way of sending messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時には、命令的な方法でメッセージを送ることが必要になる場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Emitter` の設定は、`@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、Kafkaのヘルスチェックをいくつか提供しています。これらのチェックは、 `quarkus-smallrye-health` エクステンションと組み合わせて使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the `quarkus-kafka` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  That check requires an _admin connection_ with the Kafka broker.  This check is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-kafka` エクステンションを使用している場合、 `application.properties` で `quarkus.kafka.health.enabled` プロパティを `true` に設定することで、 _Readinessヘルスチェック_ を有効にすることができます。このチェックでは、 _デフォルトの_ Kafkaブローカー（ `kafka.bootstrap.servers` を使用して構成）との相互作用の状態が報告されます。そのチェックには、Kafka ブローカーとの _admin接続_ が必要です。このチェックは、デフォルトでは無効になっています。有効にすると、アプリケーションの `/q/health/ready` エンドポイントにアクセスしたときに、接続検証のステータスに関する情報が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides a _liveness_ and _readiness_ check.  The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka.  The _readiness_ check verifies that communication with Kafka is established.  For each channel, you can disable the checks using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive MessagingとKafkaコネクタを使用する場合、設定された各チャネル（受信または送信）は、 _Liveness_ と _Readiness_ のチェックを提供します。 _Liveness_ チェックでは、Kafkaとの通信中に発生した回復不能な障害を捕捉します。 _Readiness_ チェックでは、Kafkaとの通信が確立されていることを確認します。各チャネルでは、以下の方法でチェックを無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the `bootstrap.servers` for each channel. Defaults is `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各チャンネルの `bootstrap.servers` を設定することができます。デフォルトは `kafka.bootstrap.servers` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging readiness check offers two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messaging のReadinessチェックには2つのストラテジーがあります。デフォルトの方法では、ブローカーとの間にアクティブな接続が確立されているかどうかを確認します。この方法は、組み込みのメトリクスに基づいているため、邪魔にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the `health-readiness-topic-verification=true` attribute, you can also check the topics used by the application exist in the broker.  Note that, to achieve this, an _admin connection_ is required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`health-readiness-topic-verification=true` 属性を使用すると、アプリケーションが使用するトピックがブローカーに存在することも確認できます。なお、これを行うためには、 _admin接続_ が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in capabilities to deal with JSON Kafka messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus には、JSON Kafka メッセージを扱う機能が組み込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine we have a `Fruit` pojo as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のように `Fruit` の pojo があると想像してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public String name;
    public int price;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    public String name;
    public int price;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、Kafka からメッセージを受信して、何らかの価格変換を行い、Kafka にメッセージを送り返すために使いたいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
* A bean consuming data from the "fruit-in" Kafka topic and applying some price conversion.
* The result is pushed to the "fruit-out" stream.
*/
@ApplicationScoped
public class FruitProcessor {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/**
* A bean consuming data from the "fruit-in" Kafka topic and applying some price conversion.
* The result is pushed to the "fruit-out" stream.
*/
@ApplicationScoped
public class FruitProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, we will need to setup JSON serialization with Jackson or JSON-B.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのためには、Jackson や JSON-B で JSON シリアライゼーションを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With JSON serialization correctly configured, you can also use `Publisher&lt;Fruit&gt;` and `Emitter&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON シリアライゼーションが正しく設定されていれば、 `Publisher&lt;Fruit&gt;` や `Emitter&lt;Fruit&gt;` も利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、`quarkus-jackson` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jackson` のエクステンションを使用している場合は、これは必要ありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package com.acme.fruit.jackson;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package com.acme.fruit.jackson;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your streams to use the Jackson serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、Jackson シリアライザーとデシリアライザーを使用するようにストリームを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、Kafka メッセージには、Fruit pojo の Jackson によるシリアライズ表現が含まれるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、`quarkus-jsonb` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jsonb` のエクステンションを使用している場合は不要です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package com.acme.fruit.jsonb;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package com.acme.fruit.jsonb;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.kafka.client.serialization.JsonbDeserializer;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.kafka.client.serialization.JsonbDeserializer;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your streams to use the JSON-B serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、JSON-B シリアライザーとデシリアライザーを使用するようにストリームを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、Kafka のメッセージには、JSON-B でシリアライズされた Fruit pojo の表現が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy で JSON Server-Sent Events を送信したい場合は、`@SseElementType` アノテーションを使用してイベントのコンテンツタイプを定義する必要があります。これは、このメソッドが `@Produces(MediaType.SERVER_SENT_EVENTS)` のアノテーションが付くためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example shows how to use SSE from a Kafka topic source.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次の例は、Kafka トピックソースから SSE を使用する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @Channel("fruit-out") Publisher&lt;Fruit&gt; fruits;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    @Channel("fruit-out") Publisher&lt;Fruit&gt; fruits;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.APPLICATION_JSON)
    public Publisher&lt;Fruit&gt; stream() {
        return fruits;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.APPLICATION_JSON)
    public Publisher&lt;Fruit&gt; stream() {
        return fruits;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking processing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブロッキング処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messaging とデータベースインタラクションなどのブロッキング処理を組み合わせる必要がある状況は少なくありません。そのためには、処理が _ブロックしていて_ 呼び出し元のスレッドで実行できないこと示している `@Blocking` アノテーションを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、以下のコードは、Hibernate with Panacheを 使用してデータベースに受信ペイロードを格納する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.panache;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>package org.acme.panache;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class PriceStorage {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@ApplicationScoped
public class PriceStorage {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("prices")
    @Blocking
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Incoming("prices")
    @Blocking
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全な例は `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Blocking` アノテーションは 2 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>効果はどちらも同じです。したがって、両方を使うことができます。最初のものは、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2 番目のものは、Quarkus の他のリアクティブ機能でも使用され、デフォルトのワーカープールを使用し、順序を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing without a broker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブローカーなしでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka ブローカーを起動しなくてもアプリケーションをテストできるのは便利です。これを行うには、Kafka コネクターで管理しているチャンネルを _インメモリー_ に _切り替え_ できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a Quarkus Test Resource as follows:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、以下のように Quarkus Test Resource を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");  // &lt;1&gt;
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("queue");   // &lt;2&gt;
        env.putAll(props1);
        env.putAll(props2);
        return env;  // &lt;3&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");  // &lt;1&gt;
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("queue");   // &lt;2&gt;
        env.putAll(props1);
        env.putAll(props2);
        return env;  // &lt;3&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void stop() {
        InMemoryConnector.clear();  // &lt;4&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public void stop() {
        InMemoryConnector.clear();  // &lt;4&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the incoming channel "orders" (expecting messages from Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>(Kafka からのメッセージが想定される) 受信チャンネル "order" をインメモリーに切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the outgoing channel "queue" (writing messages to Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>送信チャネル "キュー" (Kafka へのメッセージの書き込み) をインメモリーに切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む `Map` をビルドして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Quarkus Test using the test resource created above:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記で作成したテストリソースを使用して Quarkus テストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject @Any
    InMemoryConnector connector; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject @Any
    InMemoryConnector connector; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; orders = connector.source("orders"); // &lt;2&gt;
        InMemorySink&lt;Beverage&gt; queue = connector.sink("queue");    // &lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; orders = connector.source("orders"); // &lt;2&gt;
        InMemorySink&lt;Beverage&gt; queue = connector.sink("queue");    // &lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        orders.send(order);  // &lt;4&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        orders.send(order);  // &lt;4&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(queue::received, t -&gt; t.size() == 1); // &lt;5&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(queue::received, t -&gt; t.size() == 1); // &lt;5&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Beverage queuedBeverage = queue.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        Beverage queuedBeverage = queue.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the in-memory connector in your test class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストクラスにインメモリーコネクタ－を挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>受信チャンネルを取得します (`orders`) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>送信チャネルを取得します (`queue`) - テストリソース内でチャネルがインメモリーに切り替えられている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `send` method to send a message to the `orders` channel. So, the application will process this message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`send` メソッドを使用して、`orders` チャンネルにメッセージを送信します。つまり、アプリケーションはこのメッセージを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `received` method to check the messages produced by the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが生成するメッセージを確認するには、`received` メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting Kafka in a test resource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストリソースでの Kafka の起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あるいは、テストリソースで Kafka ブローカを起動することもできます。次のスニペットは、 https://www.testcontainers.org/modules/kafka/[Testcontainers] を使用して Kafka ブローカを起動するテストリソースを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class KafkaResource implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class KafkaResource implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private final KafkaContainer kafka = new KafkaContainer();
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    private final KafkaContainer kafka = new KafkaContainer();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  // &lt;1&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  // &lt;1&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void stop() {
        kafka.close();
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public void stop() {
        kafka.close();
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the Kafka bootstrap location, so the application connects to this broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションがこのブローカーに接続するように、Kafka ブートストラップの場所を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka ブローカーが認証メカニズムとして OAuth を使用している場合は、この認証プロセスを有効にするために Kafka コンシューマーを設定する必要があります。まず、以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この依存関係は、OAuth ワークフローを処理するために必要なコールバックハンドラーを提供します。そして、`application.properties` で追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`oauth.client.id`、`oauth.client.secret`、`oauth.token.endpoint.uri` の値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth authentication works for both JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth 認証は JVM とネイティブモードの両方で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_outgoing_ チャンネルでは、 `compression.type` 属性を `snappy` に設定することで、Snappy 圧縮を有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JVMモードでは、変更なしで動作します。しかし、アプリケーションをネイティブ実行ファイルにコンパイルするには、以下のことが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` に `quarkus.kafka.snappy.enabled=true`を追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードでは、Snappyはデフォルトで無効になっています。Snappyを使用するには、ネイティブライブラリを埋め込み、アプリケーションの起動時にそれを解凍する必要があるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.8/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation].  The most important attributes are listed in the tables below:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Reactive Messagingの設定についての詳細は、 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.8/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation]に記載されています。最も重要な属性を以下の表に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following attributes are configured using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の属性は以下のように設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.incoming.your-channel-name.attribute=value
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.messaging.incoming.your-channel-name.attribute=value
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some properties have aliases which can be configured globally:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一部のプロパティには、グローバルに設定可能なエイリアスがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incoming Attributes of the 'smallrye-kafka' connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'smallrye-kafka' connectorのIncoming属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute (_alias_)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>属性 (_alias_)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandatory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必須</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*bootstrap.servers*

_(kafka.bootstrap.servers)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*bootstrap.servers*

_(kafka.bootstrap.servers)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`localhost:9092`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`localhost:9092`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*topic*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*topic*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消費/投入されるKafkaトピック。このプロパティも `topics` のプロパティも設定されていない場合は、チャネル名が使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*health-enabled*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*health-enabled*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether health reporting is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスレポートが有効（デフォルト）か無効か

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*health-readiness-enabled*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*health-readiness-enabled*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether readiness health reporting is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レディネスレポートが有効（デフォルト）か無効か

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*health-readiness-topic-verification*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*health-readiness-topic-verification*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin connection.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブローカにトピックが存在するかどうかをReadinessチェックで確認するかどうか。デフォルトはfalseです。これを有効にするには、admin接続が必要です。

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*health-readiness-timeout*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*health-readiness-timeout*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Readinesチェックの間、コネクタはブローカーに接続し、トピックのリストを取得します。この属性では、検索にかける最大時間（ms）を指定します。これを超えると、チャネルは準備ができていないとみなされます。

Type: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*tracing-enabled*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*tracing-enabled*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether tracing is enabled (default) or disabled

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トレースを有効（デフォルト）にするか、無効にするか

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウド イベント サポートを有効（デフォルト）または無効にします。 _incoming_ チャネルで有効にすると、コネクタは受信レコードを分析し、Cloud Event メタデータの作成を試みます。 _outgoing_ 側で有効にすると、メッセージに Cloud Event Metadata が含まれている場合、コネクタはoutgoingメッセージを Cloud Event として送信します。

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*topics*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*topics*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comma-separating list of topics to be consumed. Cannot be used with the `topic` or `pattern` properties

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>消費されるトピックのコンマ区切りのリスト。 `topic` または `pattern` のプロパティとは併用できません。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*pattern*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*pattern*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that the `topic` property is a regular expression. Must be used with the `topic` property. Cannot be used with the `topics` property

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`topic` プロパティが正規表現であることを示す。 `topic` プロパティと併用する必要があります。 `topics` プロパティとは併用できません。

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*key.deserializer*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*key.deserializer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deserializer classname used to deserialize the record's key

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコードのキーをデシリアライズするために使用されるデシリアライザのクラス名

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.serialization.StringDeserializer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.serialization.StringDeserializer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*value.deserializer*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*value.deserializer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deserializer classname used to deserialize the record's value

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコードの値のデシリアライズに使用されるデシリアライザのクラス名

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>true</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*fetch.min.bytes*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*fetch.min.bytes*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The minimum amount of data the server should return for a fetch request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フェッチ・リクエストに対してサーバーが返すべきデータの最小量。デフォルトの1バイトの設定は、1バイトのデータが利用可能になるか、データの到着を待ってフェッチリクエストがタイムアウトするとすぐにフェッチリクエストに応答することを意味します。

Type: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*group.id*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*group.id*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A unique string that identifies the consumer group the application belongs to.

If not set, defaults to the application name as set by the `quarkus.application.name` configuration property.

If that is not set either, a unique, generated id is used.
It is recommended to always define a `group.id`, the automatic generation is only a convenient feature for development.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが所属するコンシューマーグループを識別するための一意の文字列。

設定されていない場合、デフォルトでは、 `quarkus.application.name`構成プロパティで設定されたアプリケーション名になります。

それも設定されていない場合は、生成された一意のIDが使用されます。
常に `group.id` を定義することをお勧めします。自動生成は、開発用の便利機能にすぎません。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*enable.auto.commit*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*enable.auto.commit*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabled, consumer's offset will be periodically committed in the background by the underlying Kafka client, ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting and let Reactive Messaging handles the commit.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定を有効にすると、コンシューマーのオフセットは、レコードの実際の処理結果を無視して、基礎となるKafkaクライアントによってバックグラウンドで定期的にコミットされます。この設定を有効にしないで、Reactive Messaging にコミットを任せることをお勧めします。

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*retry*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*retry*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not the connection to the broker is re-attempted in case of failure

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>障害発生時にブローカーへの接続を再試行するかどうか

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*retry-attempts*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*retry-attempts*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of reconnection before failing. -1 means infinite retry

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失敗するまでの最大再接続回数を指定します。-1は無限再試行を意味します。

Type: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*retry-max-wait*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*retry-max-wait*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The max delay (in seconds) between 2 reconnects

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2回の再接続の間の最大遅延時間（秒）

Type: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*broadcast*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*broadcast*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*auto.offset.reset*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*auto.offset.reset*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`latest`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`latest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*failure-strategy*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*failure-strategy*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `fail` (default), `ignore`, or `dead-letter-queue`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコードから生成されたメッセージが否定的に確認された（nack）場合に適用する失敗戦略を指定します。値は、 `fail` （デフォルト）、 `ignore` 、または `dead-letter-queue`

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`fail`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*commit-strategy*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*commit-strategy*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `latest`, `ignore` or `throttled`. If `enable.auto.commit` is true then the default is `ignore` otherwise it is `throttled`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコードから生成されたメッセージが確認されたときに適用するコミットストラテジーを指定します。値は、 `latest` 、 `ignore` 、 `throttled` のいずれかです。 `enable.auto.commit` がtrueであれば、デフォルトは `ignore` です。そうでなければ `throttled` です。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*throttled.unprocessed-record-max-age.ms*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*throttled.unprocessed-record-max-age.ms*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `throttled` commit-strategy, specify the max age in milliseconds that an unprocessed message can be before the connector is marked as unhealthy.

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`throttled` commit-strategy を使用している場合の、コネクタが不健全であるとマークされるまでの未処理メッセージの最大時間をミリ秒単位で指定します。

Type: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-queue.topic*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-queue.topic*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates on which topic the record is sent. Defaults is `dead-letter-topic-$channel`

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`failure-strategy` に `dead-letter-queue` が設定されている場合、どのトピックにレコードが送信されるかを示します。デフォルトは `dead-letter-topic-$channel`

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-queue.key.serializer*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-queue.key.serializer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates the key serializer to use. If not set the serializer associated to the key deserializer is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`failure-strategy` に `dead-letter-queue` が設定されている場合、 使用するキーシリアライザを示します。設定されていない場合は、キーデシリアライザに関連付けられたシリアライザが使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dead-letter-queue.value.serializer*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*dead-letter-queue.value.serializer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the `failure-strategy` is set to `dead-letter-queue` indicates the value serializer to use. If not set the serializer associated to the value deserializer is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`failure-strategy` に `dead-letter-queue` が設定されている場合、使用する値のシリアライザを示します。設定されていない場合は、値のデシリアライザに関連付けられたシリアライザが使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*partitions*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*partitions*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers. It should match the number of partition of the targeted topic

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同時に消費されるパーティションの数です。コネクタは、指定された数のKafkaコンシューマーを作成します。これは、対象となるトピックのパーティション数と一致する必要があります。

Type: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*consumer-rebalance-listener.name*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*consumer-rebalance-listener.name*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener`. If set, this rebalance listener is applied to the consumer.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` を実装するBeanの `javax.inject.Named` で設定された名前です。設定された場合、このリバランスリスナーはコンシューマーに適用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*key-deserialization-failure-handler*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*key-deserialization-failure-handler*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing keys are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` を実装するBeanの `javax.inject.Named` で設定された名前です。設定されている場合、キーをデシリアライズする際に起こるデシリアライズの失敗は、フォールバック値を提供することができるこのハンドラに委ねられます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*value-deserialization-failure-handler*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*value-deserialization-failure-handler*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing values are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` を実装するBeanの `javax.inject.Named` で設定された名前です。設定されている場合、値のデシリアライズがこのハンドラに委ねられているときにデシリアライズの失敗が起こり、フォールバック値が提供されることがあります。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*graceful-shutdown*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*graceful-shutdown*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not a graceful shutdown should be attempted when the application terminates.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの終了時に、グレースフルシャットダウンを行うかどうか。

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing channel configuration (writing to Kafka)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outgoingチャンネルの設定（Kafkaへの書き込み)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.outgoing.your-channel-name.attribute=value
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mp.messaging.outgoing.your-channel-name.attribute=value
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Outgoing Attributes of the 'smallrye-kafka' connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>'smallrye-kafka' connectorのoutgoing 属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*acks*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*acks*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. Accepted values are: 0, 1, all

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストが完了したとみなす前に、プロデューサーがリーダーに受信を要求する確認応答の数。これは、送信されるレコードの耐久性を制御します。許容される値は0、1、all

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*buffer.memory*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*buffer.memory*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The total bytes of memory the producer can use to buffer records waiting to be sent to the server.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーへの送信待ちのレコードをバッファリングするために、プロデューサーが使用できるメモリの総バイト数。

Type: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*close-timeout*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*close-timeout*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-data-content-type*

_(cloud-events-default-data-content-type)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-data-content-type*

_(cloud-events-default-data-content-type)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outgoing Cloud Eventのデフォルトの `datacontenttype` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `datacontenttype` 属性を設定していない場合に使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-data-schema*

_(cloud-events-default-data-schema)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-data-schema*

_(cloud-events-default-data-schema)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outgoing Cloud Eventのデフォルトの `dataschema` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `dataschema` 属性を設定していない場合に使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-insert-timestamp*

_(cloud-events-default-timestamp)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-insert-timestamp*

_(cloud-events-default-timestamp)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether or not the connector should insert automatically the `time` attribute` into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コネクタが、outgoing Cloud Eventに `time` 属性` を自動的に挿入するかどうかを指定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージ自身が `time` 属性を構成していない場合に使用されます。

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-mode*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-mode*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cloud Eventのモード（ `structured` または `binary` （デフォルト））。outgoing レコードにCloud Eventをどのように書き込むかを示します

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`binary`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`binary`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-source*

_(cloud-events-default-source)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-source*

_(cloud-events-default-source)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outgoing Cloud Eventのデフォルトの `source` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `source` 属性を設定していない場合に使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-subject*

_(cloud-events-default-subject)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-subject*

_(cloud-events-default-subject)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outgoing Cloud Eventのデフォルトの `subject` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `subject` 属性を設定していない場合に使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cloud-events-type*

_(cloud-events-default-type)_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*cloud-events-type*

_(cloud-events-default-type)_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outgoing Cloud Eventのデフォルトの `type` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `type` 属性を設定していない場合に使用されます。

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*key*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*key*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A key to used when writing the record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコードを書くときに使うキー

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*key.serializer*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*key.serializer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The serializer classname used to serialize the record's key

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レコードのキーをシリアル化するために使用されるシリアライザのクラス名

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.kafka.common.serialization.StringSerializer`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.apache.kafka.common.serialization.StringSerializer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*max-inflight-messages*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*max-inflight-messages*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafkaに同時に書き込まれるメッセージの最大数。ブローカーが書き込みと確認を待っているメッセージの数を制限します。この属性を `0` に設定することで、制限を取り除くことができます。

Type: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*merge*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*merge*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should allow multiple upstreams

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コネクタが複数のアップストリームを許可するかどうか

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*partition*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*partition*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The target partition id. -1 to let the client determine the partition

Type: _int_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ターゲットのパーティションID。-1の場合、クライアントがパーティションを決定

Type: _int_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*retries*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*retries*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ゼロより大きい値を設定すると、一時的なエラーで送信に失敗したレコードをクライアントが再送信する。

Type: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*value.serializer*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*value.serializer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The serializer classname used to serialize the payload

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ペイロードのシリアライズに使用されるシリアライザーのクラス名

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*waitForWriteCompletion*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*waitForWriteCompletion*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the client waits for Kafka to acknowledge the written record before acknowledging the message

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントがメッセージを確認する前に、Kafkaが書き込まれたレコードを確認するのを待つかどうか

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus を使用して Kafka とやりとりする方法を示しました。SmallRye Reactive Messaging を利用して、データストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、ロギングとその設定方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally, Quarkus uses JBoss Log Manager and the JBoss Logging facade. + You can use the JBoss Logging facade inside your code as it's already provided, or any of the supported Logging API listed in the next chapter as Quarkus will send them to JBoss Log Manager.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内部的には、QuarkusはJBoss Log ManagerとJBoss Logging ファサードを使用します。+ JBoss Logging ファサードはすでに提供されているので、コード内部で使用することができますが、QuarkusがJBoss Log Managerに送信するため、次の章でリストアップされているサポートされたロギングAPIのいずれかを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the logging configuration will then be done inside your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのロギング設定は、 `application.properties` の中で実施されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Logging APIs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているロギング API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications and components may use any of the following APIs for logging, and the logs will be merged:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションやコンポーネントは、以下のいずれかのAPIを使用してログを出力することができ、ログはマージされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally Quarkus uses JBoss Logging; you can also use it inside your application so that no other dependencies should be added for your logs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは内部的にJBoss Loggingを使用しています。アプリケーションの内部で使用することもできるので、ログに他の依存関係を追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use JBoss Logging but one of your libraries uses a different logging API, you may need to configure a link:#logging-adapters[Logging Adapter].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JBoss Logging を使用しているけれども、ライブラリの 1 つが異なるロギング API を使用している場合は、 link:#logging-adapters[ロギングアダプター] を設定する必要がある場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also inject a configured `org.jboss.logging.Logger` instance in your beans and resource classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、設定済みの `org.jboss.logging.Logger` インスタンスを Bean やリソースクラスに注入することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The FQCN of the declaring class is used as a logger name, i.e. `org.jboss.logging.Logger.getLogger(SimpleBean.class)` will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.jboss.logging.Logger.getLogger(SimpleBean.class)` 宣言したクラスのFQCNがロガー名として使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the name _foo_ is used as a logger name, i.e. `org.jboss.logging.Logger.getLogger("foo")` will be used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.jboss.logging.Logger.getLogger("foo")` この場合、ロガー名として _foo_ という名前が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The logger instances are cached internally. Therefore, a logger injected e.g. into a `@RequestScoped` bean is shared for all bean instances to avoid possible performance penalty associated with logger instantiation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロガーインスタンスは内部的にキャッシュされます。したがって、例えば `@RequestScoped` Bean に注入されたロガーは、ロガーのインスタンス化に関連する可能性のあるパフォーマンスのペナルティを回避するために、すべての Bean インスタンスで共有されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about Apache Log4j ?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Log4j はどうですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://logging.apache.org/log4j/2.x/[Log4j] is a logging implementation: it contains a logging backend and a logging facade.  Quarkus uses the JBoss Log Manager backend, so you will need to include the `log4j2-jboss-logmanager` library to route Log4j logs to JBoss Log Manager.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://logging.apache.org/log4j/2.x/[Log4j] はロギングの実装の一つです: ロギングバックエンドとロギングファサードが含まれています。QuarkusはJBoss Log Managerバックエンドを使用するため、Log4jログをJBoss Log Managerにルーティングするためには `log4j2-jboss-logmanager` ライブラリをインクルードする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then use the Log4J API inside your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、アプリケーション内でLog4J APIを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not include any Log4j dependencies. The `log4j2-jboss-logmanager` library includes what's needed to use Log4j as a logging facade.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Log4jの依存関係を含めないでください。 `log4j2-jboss-logmanager` ライブラリは、Log4j をロギング・ファサードとして使用するために必要なものを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging levels</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログレベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the log levels used by Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらはQuarkusで使用されているログレベルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special level to turn off logging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギングをオフにするための特別なレベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A critical service failure/complete inability to service requests of any kind.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>致命的なサービス障害/いかなる種類のサービス要求にも完全に対応できないこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A significant disruption in a request or the inability to service a request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストの大幅な中断、またはリクエストに対応できないこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A non-critical service error or problem that may not require immediate correction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要ではないサービスのエラーや問題で、すぐに修正する必要がない場合があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service lifecycle events or important related very-low-frequency information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスのライフサイクルイベントまたは重要な関連する非常に低頻度の情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages that convey extra information regarding lifecycle or non-request-bound events which may be helpful for debugging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デバッグに役立つかもしれない、ライフサイクルまたは非リクエストバウンドイベントに関する余分な情報を伝えるメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages that convey extra per-request debugging information that may be very high frequency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエストごとのデバッグ情報を伝えるメッセージで、非常に高い頻度で送信される可能性があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special level for all messages including custom levels.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムレベルを含むすべてのメッセージのための特別なレベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the following levels may be configured for applications and libraries using link:https://docs.oracle.com/javase/8/docs/api/java/util/logging/Level.html[`java.util.logging`]:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>加えて、 link:https://docs.oracle.com/javase/8/docs/api/java/util/logging/Level.html[`java.util.logging`] を利用して、アプリケーションとライブラリに対して以下のレベルを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **ERROR**.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**ERROR** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **WARN**.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**WARN** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service configuration information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービス構成情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **DEBUG**.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**DEBUG** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **TRACE**.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**TRACE** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Event more debugging information than `TRACE`, maybe with even higher frequency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベント `TRACE` よりも多くのデバッグ情報、さらに高頻度である可能性があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run time logging is configured in the `application.properties` file, for example, to set the default log level to `INFO` logging and include Hibernate `DEBUG` logs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時ロギングは `application.properties` ファイルで設定します。例えばデフォルトのログレベルを `INFO` ロギングに設定し、Hibernate の `DEBUG` ログを含めるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting a log level below `DEBUG` requires the minimum log level to be adjusted, either globally via the `quarkus.log.min-level` property or per-category as shown in the example above, as well as adjusting the log level itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログレベルを `DEBUG` より下に設定するには、ログレベル自体を調整するだけでなく、グローバルに `quarkus.log.min-level` プロパティーを介して、または上記の例のようにカテゴリごとに、最小ログレベルを調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Minimum logging level sets a floor level that Quarkus will be needed to potentially generate, opening the door to optimization opportunities.  As an example, in native execution the minimum level enables lower level checks (e.g. `isTraceEnabled`) to be folded to `false`, resulting in dead code elimination for code that will never to be executed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最小ロギングレベルは、Quarkusが潜在的に生成するために必要となるフロアレベルを設定し、最適化の機会の扉を開きます。例えば、ネイティブ実行では、最小レベルを設定することで、低レベルのチェック(例: `isTraceEnabled` )を `false` に折りたたむことができ、結果として、実行されることのないコードのデッドコードを排除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All possible properties are listed in &lt;&lt;loggingConfigurationReference, the logging configuration reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>可能なすべてのプロパティーは、 link:#loggingConfigurationReference[ロギング設定リファレンス] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are adding these properties via command line make sure `"` is escaped.  For example `-Dquarkus.log.category.\"org.hibernate\".level=TRACE`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドラインでこれらのプロパティーを追加する場合は、 `"` がエスケープされていることを確認してください。例えば `-Dquarkus.log.category.\"org.hibernate\".level=TRACE` とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging categories</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギングカテゴリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging is done on a per-category basis.  Each category can be independently configured.  A configuration which applies to a category will also apply to all sub-categories of that category, unless there is a more specific matching sub-category configuration.  For every category the same settings that are configured on ( console / file / syslog ) apply.  These can also be overridden by attaching a one or more named handlers to a category. See example in &lt;&lt;category-named-handlers-example&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギングはカテゴリごとに行われます。各カテゴリは独立して設定することができます。あるカテゴリに適用される設定は、より特定の一致するサブカテゴリの設定がない限り、そのカテゴリのすべてのサブカテゴリにも適用されます。すべてのカテゴリに対して、( console / file / syslog ) で設定されているのと同じ設定が適用されます。これらの設定は、1つ以上の名前付きハンドラーをカテゴリにアタッチすることで上書きすることもできます。 link:#category-named-handlers-example[category-named-handlers-example]] の例を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".leve</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.category."&lt;category-name&gt;".leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>INFO footnote:[Some extensions may define customized default log levels for certain categories, in order to reduce log noise by default.  Setting the log level in configuration will override any extension-defined log levels.]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>INFO footnote:[いくつかのエクステンションは、ログノイズを削減するために、特定のカテゴリに対してカスタマイズされたデフォルトログレベルを定義しているかもしれません。コンフィグレーションでのログレベル設定は、エクステンション定義のログレベルをオーバーライドします。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The level to use to configure the category named `&lt;category-name&gt;`.  The quotes are necessary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;category-name&gt;` という名前のカテゴリを設定するために使用するレベル。クオートが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".min-leve</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.category."&lt;category-name&gt;".min-leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The minimum logging level to use to configure the category named `&lt;category-name&gt;`.  The quotes are necessary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`&lt;category-name&gt;` という名前のカテゴリを設定するために使用する最小ロギングレベル。クオートが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".use-parent-handler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.category."&lt;category-name&gt;".use-parent-handler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tru</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>tru</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify whether or not this logger should send its output to its parent logger.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このロガーがその出力を親ロガーに送信するかどうかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".handlers=[&lt;handler&gt;]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.category."&lt;category-name&gt;".handlers=[&lt;handler&gt;]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>empty footnote:[By default the configured category gets the same handlers attached as the one on the root logger.]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>empty footnote:[デフォルトでは設定されたカテゴリはルートロガーにアタッチされたハンドラーと同じものを受け取ります。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The names of the handlers that you want to attach to a specific category.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定のカテゴリにアタッチしたいハンドラーの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quotes shown in the property name are required as categories normally contain '.' which must be escaped. An example is shown in &lt;&lt;category-example&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カテゴリには通常 '.' が含まれているため、プロパティー名に表示されているクオートはエスケープされている必要があります。例を link:#category-example[[category-example]] に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Root logger configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルートロガーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The root logger category is handled separately, and is configured via the following properties:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルート ロガー カテゴリは個別に処理され、次のプロパティーで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.leve</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default log level for every log category.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各ログカテゴリのデフォルトのログレベル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.min-leve</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.log.min-leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default minimum log level for every log category.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各ログカテゴリのデフォルトの最小ログレベル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no level configuration exists for a given logger category, the enclosing (parent) category is examined. If no categories are configured which enclose the category in question, then the root logger configuration is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>与えられたロガー カテゴリにレベル設定が存在しない場合、包含(親)カテゴリが検査されます。対象のカテゴリを囲むカテゴリが設定されていない場合、ルート ロガー設定が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging Format</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログフォーマット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus uses a pattern-based logging formatter that generates human-readable text logs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkusはパターンベースのログフォーマッタを使用して、人間が読めるテキストログを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the format for each log handler via a dedicated property.  For the console handler, the property is `quarkus.log.console.format`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各ログハンドラーのフォーマットは、専用のプロパティーで設定することができます。コンソールハンドラーの場合、プロパティーは `quarkus.log.console.format` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The logging format string supports the following symbols:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログフォーマット文字列は、以下のシンボルをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Symbo</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Symbo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders a simple `%` character.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>単に `%` 文字をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%c</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カテゴリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the category name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カテゴリ名をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source clas</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source class name.footnote:calc[Format sequences which examine caller information may affect performance]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースクラス名をレンダリングします。 footnote:calc[呼び出し元の情報を検査するフォーマットシーケンスはパフォーマンスに影響する可能性があります。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%d{xxx}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>d{xxx}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dat</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders a date with the given date format string, which uses the syntax defined by `java.text.SimpleDateFormat`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java.text.SimpleDateFormat` で定義されている構文を使用した、指定した日付書式の文字列で日付をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Exception</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the thrown exception, if any.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>投げられた例外があれば、その例外をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source fil</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source file name.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースファイル名をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Host nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ホスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the system simple host name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>システムの単純なホスト名をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualified host nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全修飾ホスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the system's fully qualified host name, which may be the same as the simple host name, depending on OS configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>システムの完全修飾されたホスト名をレンダリングします。OSの設定によっては、単純ホスト名と同じかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%i</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Process ID</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロセスID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the current process PID.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のプロセスPIDをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source location</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースの場所</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source location information, which includes source file name, line number, class name, and method name.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースファイル名、行番号、クラス名、メソッド名を含むソース・ロケーション情報をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source lin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースライン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source line number.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソース行番号をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Messag</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フルメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the log message plus exception (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログメッセージと例外(もしあれば)を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source metho</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source method name.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースメソッド名をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%n</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Newlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>改行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the platform-specific line separator string.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラットフォーム固有の改行文字列をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Process nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロセス名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the name of the current process.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在のプロセスの名前をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%p</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Leve</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the log level of the message.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージのログレベルをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%r</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Relative tim</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>相対時間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the time in milliseconds since the start of the application log.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションログの開始からの時間をミリ秒単位でレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple messag</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders just the log message, with no exception trace.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログメッセージのみを表示し、例外のトレースは表示しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%t</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread nam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スレッド名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the thread name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スレッド名をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%t{id}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%t{id}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread ID</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スレッドID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the thread ID.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スレッドIDをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%z{&lt;zone name&gt;}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%z{&lt;zone name&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time zon</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>タイムゾーン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the time zone of the output to `&lt;zone name&gt;`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>出力のタイムゾーンを `&lt;zone name&gt;` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%X{&lt;MDC property name&gt;}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%X{&lt;MDC property name&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapped Diagnostics Context Valu</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マップされた診断コンテキスト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the value from Mapped Diagnostics Context</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マップされた診断コンテキストの値をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapped Diagnostics Context Value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マップされた診断コンテキスト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders all the values from Mapped Diagnostics Context in format {property.key=property.value}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マップされた診断コンテキストのすべての値を {property.key=property.value} 形式でレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>%x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nested Diagnostics context value</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入れ子になった診断コンテキスト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders all the values from Nested Diagnostics Context in format {value1.value2}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネストされた診断コンテキストからのすべての値を {value1.value2} 形式でレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Console Logging Formats</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールログの代替フォーマット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to change the output format of the console log. This can be useful in environments where the output of the Quarkus application is captured by a service which can, for example, process and store the log information for later analysis.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールログの出力形式を変更することができます。これは、Quarkusアプリケーションの出力がサービスによってキャプチャされ、例えば、後で分析するためにログ情報を処理して保存することができる環境で有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to configure the JSON logging format, the `quarkus-logging-json` extension may be employed.  Add this extension to your application POM as the following snippet illustrates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON ログフォーマットを設定するために、 `quarkus-logging-json` エクステンションモジュールを使用することができます。次のスニペットが示すように、このエクステンションをアプリケーションPOMに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  &lt;dependencies&gt;
    &lt;!-- ... your other dependencies are here ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-logging-json&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>  &lt;dependencies&gt;
    &lt;!-- ... your other dependencies are here ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-logging-json&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The presence of this extension will, by default, replace the output format configuration from the console configuration.  This means that the format string and the color settings (if any) will be ignored.  The other console configuration items (including those controlling asynchronous logging and the log level) will continue to be applied.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションが存在すると、デフォルトではコンソール設定からの出力フォーマット設定を置き換えます。つまり、フォーマット文字列と色の設定(もしあれば)は無視されます。他のコンソール設定項目(非同期ロギングやログレベルを制御するものを含む)は引き続き適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For some, it will make sense to use logging that is humanly readable (unstructured) in dev mode and JSON logging (structured) in production mode. This can be achieved using different profiles, as shown in the following configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの場合、devモードでは人間が読める(構造化されていない)ロギングを使用し、本番モードではJSONロギング(構造化されている)を使用することが理にかなっているでしょう。これは、以下の設定で示されているように、異なるプロファイルを使用して達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable JSON logging in application.properties for dev and test mode</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.properties で dev および test モードに対する JSONロギングを無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JSON logging extension can be configured in various ways.  The following properties are supported:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON ロギングエクステンションは、さまざまな方法で設定することができます。以下のプロパティーがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling pretty printing might cause certain processors and JSON parsers to fail.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プリティプリントを有効にすると、特定のプロセッサーやJSONパーサーで解釈できなくなる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Printing the details can be expensive as the values are retrieved from the caller. The details include the source class name, source file name, source method name and source line number.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>呼び出し元から値を取得するため、詳細を表示するとコストがかかります。詳細には、ソースクラス名、ソースファイル名、ソースメソッド名、ソース行番号が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log Handlers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A log handler is a logging component responsible for the emission of log events to a recipient.  Quarkus comes with three different log handlers: **console**, **file** and **syslog**.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログハンドラーは、受信者へのログイベントの送信を担当するロギングコンポーネントです。Quarkusには、 **コンソール** 、 **ファイル** 、 **syslog** という3つの異なるログハンドラーが用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Console log handler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールログハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The console log handler is enabled by default.  It outputs all log events to the console of your application (typically to the system's `stdout`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールログハンドラーはデフォルトで有効になっています。これはすべてのログイベントをアプリケーションのコンソールに出力します (通常はシステムの `stdout` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details of its configuration options, see link:#quarkus-log-logging-log-config_quarkus.log.console[the Console Logging configuration reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その構成オプションの詳細については、「 link:#quarkus-log-logging-log-config_quarkus.log.console[コンソール ロギング」の構成リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File log handler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ファイルログハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file log handler is disabled by default. It outputs all log events to a file on the application's host.  It supports log file rotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ファイルログハンドラーはデフォルトでは無効になっています。すべてのログイベントをアプリケーションのホスト上のファイルに出力します。ログファイルのローテーションをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details of its configuration options, see link:#quarkus-log-logging-log-config_quarkus.log.file[the File Logging configuration reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その構成オプションの詳細については、「 link:#quarkus-log-logging-log-config_quarkus.log.file[ファイル ロギング」の構成リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://en.wikipedia.org/wiki/Syslog[Syslog] is a protocol for sending log messages on Unix-like systems using a protocol defined by link:https://tools.ietf.org/html/rfc5424[RFC 5424].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://en.wikipedia.org/wiki/Syslog[Syslogは] 、 link:https://tools.ietf.org/html/rfc5424[RFC 5424] で定義されたプロトコルを用いてUnix系システム上でログメッセージを送信するためのプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syslog handler sends all log events to a syslog server (by default, the syslog server that is local to the application).  It is disabled by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>syslog ハンドラーは、すべてのログイベントを syslog サーバー (デフォルトでは、アプリケーションのローカルにある syslog サーバー) に送信します。デフォルトでは無効になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details of its configuration options, see link:#quarkus-log-logging-log-config_quarkus.log.syslog[the Syslog Logging configuration reference].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その構成オプションの詳細については、「 link:#quarkus-log-logging-log-config_quarkus.log.syslog[Syslog Logging」の構成リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Console DEBUG Logging except for Quarkus logs (INFO), No color, Shortened Time, Shortened Category Prefixes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソール DEBUG ログ、Quarkusのログ(INFO)を除く、カラーなし、時間短縮、カテゴリプレフィックス短縮</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are adding these properties via command line make sure `"` is escaped.  For example `-Dquarkus.log.category.\"io.quarkus\".level=DEBUG`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドラインでこれらのプロパティーを追加する場合は、 `"` がエスケープされていることを確認してください。例えば `-Dquarkus.log.category.\"io.quarkus\".level=DEBUG` のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File TRACE Logging Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ファイル TRACE ログ設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we don't change the root logger, console log will only contain `INFO` or higher order logs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルートロガーを変更しないので、コンソールログには `INFO` 以上の順位のログしか表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named handlers attached to a category</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カテゴリにアタッチされた名前付きハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>集中ログ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to send your logs to a centralized tool like Graylog, Logstash or Fluentd, you can follow the link:centralized-log-management[Centralized log management guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ログをGraylog、Logstash、Fluentdなどの集中型ツールに送信したい場合は、 link:centralized-log-management[集中型ログ管理ガイド] に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to Configure Logging for `@QuarkusTest`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTest` のログ設定方法 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to configure logging for your `@QuarkusTest`, don't forget to set up the `maven-surefire-plugin` accordingly.  In particular, you need to set the appropriate `LogManager` using the `java.util.logging.manager` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusTest` のロギングを設定したい場合は、それに応じて `maven-surefire-plugin` を設定することを忘れないでください。特に、 `java.util.logging.manager` system プロパティーを使用して適切な `LogManager` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure the `org.jboss.logmanager.LogManager` is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.jboss.logmanager.LogManager` が使用されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable debug logging for all logging categories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのロギングカテゴリのデバッグロギングを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle, add this to your `build.gradle`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleを使用している場合は、 `build.gradle` にこれを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also: &lt;&lt;getting-started-testing.adoc#test-from-ide,Running `@QuarkusTest` from an IDE&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>こちらも参照: &lt;&lt;link:getting-started-testing.html#test-from-ide[IDE から `@QuarkusTest` を実行する &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging Adapters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギングアダプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus relies on the JBoss Logging library for all the logging requirements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、すべてのロギング要件をJBoss Loggingライブラリに依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using libraries that have dependencies on other logging libraries such as Apache Commons Logging, Log4j or Slf4j, you need to exclude them from the dependencies and use one of the adapters provided by JBoss Logging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Commons Logging、Log4j、Slf4j などの他のロギングライブラリに依存関係があるライブラリを使用している場合は、それらを依存関係から除外し、JBoss Logging が提供するアダプターのいずれかを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is especially important when building native executables as you could encounter issues similar to the following when compiling the native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行ファイルをコンパイルする際に以下のような問題が発生する可能性があるため、ネイティブ実行ファイルをビルドする際には特に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is due to the logging implementation not being included in the native executable.  Using the JBoss Logging adapters will solve this problem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、ロギングの実装がネイティブ実行ファイルに含まれていないことが原因です。JBoss Logging アダプターを使用することで、この問題は解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These adapters are available for most of the common Open Source logging components, such as Apache Commons Logging:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのアダプターは、Apache Commons Logging のような一般的なオープンソースのロギングコンポーネントのほとんどで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log4j:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Log4j:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log4j2:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Log4j2:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And Slf4j:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして Slf4j:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not needed for libraries that are dependencies of a Quarkus extension as the extension will take care of this for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Quarkusエクステンションの依存関係にあるライブラリには必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging configuration reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギング設定のリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hello World Quarkus アプリの作成方法を説明します。 このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>機能テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の JDK をインストール済みで、Maven が意図した Java を使用するかわからない場合は、予期しない結果になることがあります。Maven が使用する JDK は、`mvn --version` コマンドで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、`hello` エンドポイントを提供する簡単なアプリケーションを作成します。依存性の注入を示すために、このエンドポイントでは `greeting` Bean を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、エンドポイントのテストについても解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `getting-started` {quickstarts-tree-url}/getting-started[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cmd を使っている場合 (バックスラッシュは使わないでください)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Powershell を使用する場合は、`-D` パラメーターを二重引用符で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のように `./getting-started` に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.getting.started.GreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`org.acme.getting.start.GreetingResource` リソースは、`/hello` で公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたら、`pom.xml` を確認してください。 Quarkus の BOM のインポートが存在することが分かります。これにより、異なる Quarkus の依存関係のバージョンを省略できます。さらに、アプリケーションのパッケージングと開発モードを処理する `quarkus-maven-plugin` が存在することが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係の部分に注目すると、REST アプリケーションの開発を可能にするエクステンションを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト作成時には、 `src/main/java/org/acme/getting/started/GreetingResource.java` ファイルが以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "hello" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは非常にシンプルな REST エンドポイントで、"/hello" 上のリクエストに "hello" を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バニラ JAX-RS との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus では、`Application` クラスを作成する必要がありません。作成は可能ですが、必須ではありません。加えて、リソースは 1 つのみが作成され、リクエスト毎に 1 つではありません。これは、異なる `*Scoped` アノテーション (`ApplicationScoped`、`RequestScoped` など) を使用することで設定可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application.  Use: `./mvnw compile quarkus:dev`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでアプリケーションを実行する準備が整いました。 `./mvnw compile quarkus:dev` を実行してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`CTRL+C` を押してアプリケーションを停止したり、アプリケーションを起動したままにでき、快適な操作を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the link:cdi[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の依存性注入は、Quarkus のアーキテクチャに合わせて調整された CDI ベースの依存性注入ソリューションである ArC をベースにしています。 CDI が初めての方は、 link:cdi[CDI入門] ガイドをお読みになることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the link:cdi-reference[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は CDI 機能のサブセットのみを実装しており、非標準の機能や特定の API が付属しています。詳細は、 link:cdi-reference[Contexts and Dependency Injection ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/getting/started/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを変更してコンパニオン Bean を追加してみましょう。 以下の内容で `src/main/java/org/acme/getting/started/GreetingService.java` ファイルを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`GreetingResource` クラスを編集して `GreetingService` を注入し、それを使って新しいエンドポイントを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application, restart the application with `./mvnw compile quarkus:dev`.  Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを停止した場合は、`./mvnw compile quarkus:dev` でアプリケーションを再起動します。 そして、エンドポイントが `hello quarkus` を期待通りに返すことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus:dev` は、開発モードで Quarkus を実行します。これにより、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に反映されます。 これは、設定プロパティーファイルなどのリソースファイルに対しても機能します。 ブラウザをリフレッシュすると、ワークスペースのスキャンがトリガーされ、変更が検出された場合、Java ファイルが再コンパイルされ、アプリケーションが再デプロイされます。リクエストは、再デプロイされたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページで通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはポート `5005` のデバッガーもリッスンします。デバッガーがアタッチされるのを待ってから実行する場合は、コマンドラインで `-Dsuspend` を渡してください。デバッガーを全く必要としない場合は `-Ddebug=false` を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、ここまでは問題ありませんが、念のためにテストをした方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated `pom.xml` file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `pom.xml` ファイルでは、2 つのテスト依存関係を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[Junit 5] tests.  Because of this, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は https://junit.org/junit5/[Junit 5] テストをサポートしています。 デフォルトのバージョンでは Junit 5 をサポートしていないため、 https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] のバージョンを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `java.util.logging` システムプロパティーを設定して、テストが正しいログマネージャーを使用することを確認し、 `maven.home` からカスタム設定が適用されることを確認します (該当する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/getting/started/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたプロジェクトには簡単なテストが含まれています。 `src/test/java/org/acme/getting/started/GreetingResourceTest.java` を以下の内容に合わせて編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QuarkusTest` ランナーを使うことで、テストの前にアプリケーションを起動するように JUnit に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP レスポンスのステータスコードと内容を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのテストでは http://rest-assured.io/[RestAssured] を使用していますが、お好きなライブラリーをご自由にお使いください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらは Maven を使って実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、IDE から直接テストを実行することもできます (最初にアプリケーションを停止したことを確認してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、実行中のアプリケーションと競合しないように、テストはポート `8081` で実行されます。 RestAssured は、この 8081 ポートを使用するように自動的にを設定されます。別のクライアントを使用したい場合は、`@TestHTTPResource` アノテーションを使用して、テストされたアプリケーションの URL をテストクラスのフィールドに直接注入する必要があります。このフィールドは `String`、 `URL`、`URI` のいずれかの型になります。このアノテーションにはテストパスの値を指定することもできます。例えば、`/myservlet` にマップされたサーブレットをテストしたい場合、次のようにテストに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストポートは、`quarkus.http.test-port` 設定プロパティーで制御できます。Quarkus はまた、インジェクションを使用できない場合のためにベースとなるテストURLに設定される `test.url` というシステムプロパティーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチモジュールプロジェクトや外部モジュールとの連携</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus はビルド時に https://github.com/wildfly/jandex[Jandex] を多用して、さまざまなクラスやアノテーションを発見しています。これをすぐに認識できるアプリケーションの1つは、CDI Beanのディスカバリーです。 その結果、このビルド時のディスカバリーが適切に設定されていないと、Quarkusのエクステンションのほとんどが正しく動作しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このインデックスは、Maven と Gradle プラグインのおかげで、Quarkus が設定されているプロジェクト上にデフォルトで作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the link:maven-tooling#multi-module-maven[Maven] or link:gradle-tooling#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、マルチモジュールプロジェクトで作業する場合は、 link:maven-toolsing#multi-module-maven[Maven] または link:gradle-toolsing#multi-module-maven[Gradle] ガイドの 「マルチモジュールプロジェクトでの作業」のセクションを必ず読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>外部モジュール (例えば、すべてのドメインオブジェクトのための外部ライブラリ) を使用する予定がある場合は、Jandex プラグインを追加するか (変更できる場合)、 `application.properties` 内の `quarkus.index-dependency` プロパティーを使って (モジュールを変更できない場合に便利です)、これらのモジュールをインデックス作成プロセスに知らせておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は、CDI ガイドの link:cdi-reference#bean_discovery[Bean Discovery] セクションを必ずお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パッケージングとアプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using `./mvnw package`.  It produces several outputs in `/target`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは `./mvnw package` を使ってパッケージングされています。 これは `/target` に 2 つの jar ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar`: プロジェクトのクラスとリソースだけを含み、Maven ビルドによって生成される通常のアーティファクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`getting-started-1.0.0-SNAPSHOT-runner.jar`: 実行可能な _jar_ です。依存関係が `target/lib` ディレクトリーにコピーされているので、これは _über-jar_ ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar` を使ってアプリケーションを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをどこかに(典型的にはコンテナに)デプロイしたい場合は、 `quarkus-app` ディレクトリ全体をデプロイする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを実行する前に、ホットリロードモードを停止する (CTRL+C) ことを忘れないでください 。停止しないと、ポートが衝突します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バナーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkus アプリケーションが起動すると (通常モードまたは開発モードで) 、ASCII アートバナーが表示されます。バナーを無効にするには、 `application.properties` で `quarkus.banner.enabled=false` を設定するか、 `Dquarkus.banner.enabled=false` の Java システムプロパティーを設定するか、 `QUARKUS_BANNER_ENABLED` 環境変数を `false` に設定します。 さらに、 `src/main/resources` にバナーファイルを配置し、 `application.properties` に `quarkus.banner.path=nam-of-file` を設定することで、ユーザーはカスタムのバナーを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the link:building-native-image[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the link:getting-started-reactive[Getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus を使用したアプリケーションの作成について説明しました。 しかし、まだまだ多くのことがあります。 link:built-native-image[ネイティブ実行可能ファイルのビルド] では、ネイティブ実行ファイルの作成とコンテナーへのパッケージングを説明します。 リアクティブに興味がある場合は、link:get-started-reactive[リアクティブ入門ガイド] をお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the link:tooling[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、link:tooling[ツールガイド] のドキュメントでは、以下の方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>enable the _development mode_ (hot reload)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_development mode_ (ホットリロード) を有効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>get-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>get-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/get-started/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/get-started/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get Started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Be Guided Through First Application]({{site.baseurl}}/guides/getting-started)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[はじめてのアプリケーション入門]({{site.baseurl}}/guides/getting-started)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Getting Started with Reactive]({{site.baseurl}}/guides/getting-started-reactive)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[リアクティブ入門]({{site.baseurl}}/guides/getting-started-reactive)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Quickly Bootstrap Your Application](https://code.quarkus.io)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[アプリケーションのクイック起動](https://code.quarkus.io)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Building Native Executables]({{site.baseurl}}/guides/building-native-image)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[ネイティブ実行ファイルのビルド]({{site.baseurl}}/guides/building-native-image)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Using our Tooling]({{site.baseurl}}/guides/tooling)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[ツールの使用]({{site.baseurl}}/guides/tooling)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Get More Guides]({{site.baseurl}}/guides)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[その他のガイド]({{site.baseurl}}/guides)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through Your First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はじめてのアプリケーション入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Bootstrapping an application
- Creating a JAX-RS endpoint
- Injecting beans
- Functional tests
- Packaging of the application
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは以下をカバーします:
- アプリケーションの起動
- JAX-RSエンドポイントの作成
- Beanの挿入
- ファンクションテスト
- アプリケーションのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.
This guide covers:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでリアクティブアプリケーションを作成する方法を学習し、Quarkusによって提供される様々なリアクティブ機能を学びます。
このガイドは以下をカバーします：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping a reactive application
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブアプリケーションのクイック起動
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSエンドポイントの作成（非同期、ストリーム...）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブデータベースアクセス
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のリアクティブAPIの使用
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのクイック起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt; では、数クリックでQuarkusアプリケーションを起動し、エクステンションエコシステムを発見出来ます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus applications can be made with.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションを作成する際に利用できる幅広いテクノロジーをご覧ください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行可能ファイルのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Compiling the application to a native executable
- The packaging of an application in a Docker container
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは以下をカバーします：
- アプリケーションのネイティブ実行可能ファイルへのコンパイル
- アプリケーションのDockerコンテナへのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide requires:
- Completion of the [Creating Your First Application]({{site.baseurl}}/guides/getting-started) guide
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは以下を必要とします:
- [最初のアプリケーションの作成]({{site.baseurl}}/guides/getting-started) ガイドの完了
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ツールの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application.
In this guide, we will explore:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus には開発者がライブリロードからKubernetesへのアプリケーションのデプロイまで、ツールチェインが付属しています。
このガイドでは、以下について説明します：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use Maven as a build tool
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mavenをビルドツールとして使用する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use Gradle as a build tool
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Gradleをビルドツールとして使用する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the native CLI for your toolchain (coming soon)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ツールチェインにネイティブCLIを使用する方法（近日公開）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to create and scaffold a new project
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいプロジェクトをスキャフォールド (骨組を作成) する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDEでアプリケーションを開発する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to compile your application natively
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDEでアプリケーションをコンパイルする方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we're not limited to standards we can go beyond and extend your possibilities.  Of course, {project-name} is not a passive consumer.  Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我々は標準に限定されない為、あなたの可能性を広げることが可能です。 もちろん、{project-name} は受動的な消費者ではありません。 私たちのゴールは、使用する技術を改善、革新し、私たちが頼りにしているオープンソースプロジェクトと標準に貢献することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs with very little effort.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、MicroProfile REST Clientを使用して、ほとんど手間をかけずにREST APIとやりとりする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations. In our case the interface should be created at `src/main/java/org/acme/rest/client/CountriesService.java` and have the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile REST Client を使うのは、適切な JAX-RS と MicroProfile アノテーションを使ってインターフェースを作成するのと同じくらい簡単です。私たちの場合、インターフェイスは `src/main/java/org/acme/rest/client/CountriesService.java` で作成され、次のような内容になっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning a `Uni`, every _subscription_ invokes the remote service.  It means you can re-send the request by re-subscribing on the `Uni`, or use a `retry` as follow:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni` を返すとき、すべての _サブスクリプション_ は 、リモートサービスを呼び出します。つまり、 `Uni` で再購読してリクエストを再送信するか、以下のように `retry` を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ERROR: (gcloud.beta.functions.deploy) OperationError: code=7, message=Build Failed: Cloud Build has not been used in project &lt;project_name&gt; before or it is disabled. Enable it by visiting https://console.developers.google.com/apis/api/cloudbuild.googleapis.com/overview?project=&lt;my-project&gt; then retry.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ERROR: (gcloud.beta.functions.deploy) OperationError: code=7, message=Build Failed: Cloud Build has not been used in project &lt;project_name&gt; before or it is disabled. Enable it by visiting https://console.developers.google.com/apis/api/cloudbuild.googleapis.com/overview?project=&lt;my-project&gt; then retry.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn dependency:copy \
  -Dartifact='com.google.cloud.functions.invoker:java-function-invoker:1.0.0-beta1' \
  -DoutputDirectory=.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn dependency:copy \
  -Dartifact='com.google.cloud.functions.invoker:java-function-invoker:1.0.0-beta1' \
  -DoutputDirectory=.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you will be able to use `gcloud beta functions deploy` command to deploy your function to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのビルド後、 `gcloud beta functions deploy` コマンドを使って Google Cloud に関数をデプロイすることができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the `agroal` extension plus one of `jdbc-db2`, `jdbc-derby`, `jdbc-h2`, `jdbc-mariadb`, `jdbc-mssql`, `jdbc-mysql`, or `jdbc-postgresql`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`agroal` エクステンションに加えて、`jdbc-db2`、`jdbc-derby`、`jdbc-h2`、`jdbc-mariadb`、`jdbc-mssql`、`jdbc-mysql`、`jdbc-postgresql` のいずれかを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the full list of properties is available in the https://github.com/quarkusio/quarkus/blob/master/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティーの完全なリストは、 link:https://github.com/quarkusio/quarkus/blob/master/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] クラスで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have `generate-code` goal of `quarkus-maven-plugin` enabled in your `pom.xml`.  If you wish to generate code from different `proto` files for tests, also add the `generate-code-tests` goal:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`pom.xml` で `generate-code` ゴールの `quarkus-maven-plugin` が有効になっていることを確認してください。テスト用に異なる `proto` ファイルからコードを生成したい場合は、 `generate-code-tests` ゴールも追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`proto` ファイルを更新するたびに、クラスを再生成する必要があります ( `mvn compile` を使用して)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides an additional model with Mutiny, a Reactive Programming API integrated in Quarkus.  Learn more about Mutiny on the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].  A Mutiny implementation of this service would be:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、Quarkusに統合されたReactive Programming APIであるMutinyを使用した追加モデルも提供しています。Mutinyの詳細については、 link:getting-started-reactive#mutiny[Getting Started with Reactiveガイド] を参照してください。このサービスのMutinyの実装は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the server is exposed on `localhost:9000`, and uses _plain-text_ (so no TLS).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、サーバーは `localhost:9000` で公開されており、 _プレーンテキスト_ を使用します(そのため TLS は使用しません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[here]), or starting a mock HTTP server using http://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here]).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、 `QuarkusTestResourceLifecycleManager`  の実装がいくつか提供されていますが(H2データベースを起動する `io.quarkus.test.h2.H2DatabaseTestResource` や、モックKubernetes APIサーバーを起動する `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource`  を参照)、特定のアプリケーションのニーズに対応するためにカスタム実装を作成するのが一般的です。一般的なケースとしては、 link:https://www.testcontainers.org/[Testcontainers]を使ってdockerコンテナーを起動したり(その例は link:https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[こちら]にあります)、 link:http://wiremock.org/[Wiremock]を使ってモックHTTPサーバを起動したり(その例は link:https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[こちら]にあります)などがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] was made to make those Quarkus extensions work properly in reactive/async settings. It works by capturing those contextual values that used to be in thread-locals, and restoring them when your code is called.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] は、リアクティブ/非同期設定でQuarkusエクステンションが正しく動作するようにするために作られました。これは、スレッドローカルにあったコンテキスト値を取得し、コードが呼び出されたときにそれらを復元することで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the password. This defaults to using bcrypt hashed passwords, but you can also configure it for clear text passwords.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、パスワードに使用するフィールドを示します。これはデフォルトでは bcrypt ハッシュ化されたパスワードを使用するように設定されていますが、クリアテキストパスワード用に設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, applications using the `quarkus-oidc` extension are marked as a `service` type application (see `quarkus.oidc.application-type`). This extension currently supports only such `service` type applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `quarkus-oidc` エクステンションを使用するアプリケーションは `service` タイプのアプリケーションとしてマークされます ( `quarkus.oidc.application-type` を参照)。このエクステンションは現在、そのような `service` タイプのアプリケーションのみをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More About Configuring Protected Resources </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>保護されたリソースの設定についてさらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the protected routes using the `@RolesAllowed` annotation or the `application.properties` file, check the link:security-openid-connect[Using OpenID Connect Adapter to Protect JAX-RS Applications] guide. For more details, check the link:security[Security guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@RolesAllowed` アノテーションまたは `application.properties` ファイルを使用して保護されたルートを構成するには、「 link:security-openid-connect[Using OpenID Connect Adapter to Protect JAX-RS Applications] 」ガイドを確認してください。詳細については、 link:security[セキュリティー] ガイドを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the simple experience easiest, unify the configuration in `application.properties` via MicroProfile Config.  Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルな体験を最も簡単にするために、MicroProfile Configを経由して `application.properties` で設定を統一してください。ライブラリ固有の設定ファイルは避けるか、少なくともオプションにしてください: 例: Hibernate ORMの為の `persistence.xml` はオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build.  When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションがSSLを必要とし、ネイティブイメージのビルド中に有効にする必要があることをQuarkusに伝える便利な方法です。この機能を使用する場合は、 link:https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[ネイティブおよびsslガイド] の、自動的にSSLサポートを提供するエクステンションのリストに、作成したエクステンションを追加することを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle support is considered preview.  You can use Gradle to create Quarkus projects as outlined in our guides. If you go beyond there will be cases where the Gradle tasks https://github.com/quarkusio/quarkus/issues/5101[does not behave as expected].  This is just a caution, and we recommend if you like Gradle you try it out and give us feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の Gradle サポートはプレビューとされています。このガイドで Gradle を使用して Quarkus プロジェクトを作成する方法の概要を説明しています。これを超えると、Gradleのタスクが link:https://github.com/quarkusio/quarkus/issues/5101[期待通りに動作しない場合があります] 。これはあくまでも注意事項であり、Gradle が好きな方は試してみてフィードバックをいただくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Quarkus in dev mode on the remote host. Now you need to connect your local agent to the remote host:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートホストでQuarkusをdevモードで起動します。ここで、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's what a full CORS filter configuration could look like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CORS フィルターの完全な構成は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.cors=true
quarkus.http.cors.origins=http://foo.com,http://www.bar.io
quarkus.http.cors.methods=GET,PUT,POST
quarkus.http.cors.headers=X-Custom
quarkus.http.cors.exposed-headers=Content-Disposition
quarkus.http.cors.access-control-max-age=24H
quarkus.http.cors.access-control-allow-credentials=true
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus.http.cors=true
quarkus.http.cors.origins=http://foo.com,http://www.bar.io
quarkus.http.cors.methods=GET,PUT,POST
quarkus.http.cors.headers=X-Custom
quarkus.http.cors.exposed-headers=Content-Disposition
quarkus.http.cors.access-control-max-age=24H
quarkus.http.cors.access-control-allow-credentials=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - GraphQL</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - GraphQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the **Eclipse MicroProfile GraphQL** specification through the SmallRye GraphQL extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye GraphQLエクステンションを使用して **Eclipse MicroProfile GraphQL** 仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-graphql` extension which is an implementation of the MicroProfile GraphQL specification used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Quarkusで使用されているMicroProfile GraphQL仕様の実装である `smallrye-graphql` エクステンションをインポートして、Mavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraphiQL can be accessed from http://localhost:8080/graphql-ui/ .</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraphiQLは、 http://localhost:8080/graphql-ui/ からアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile GraphQL enables clients to retrieve the exact data that is required preventing `Over-fetching` and `Under-fetching`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile GraphQLを使用すると、クライアントは、必要なデータだけを取得することが出来、`Over-fetching` と `Under-fetching` を防ぐことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize MicroProfile JWT (MP JWT) to verify https://tools.ietf.org/html/rfc7519[JSON Web Token]s, represent them as MP JWT `org.eclipse.microprofile.jwt.JsonWebToken` and provide secured access to the Quarkus HTTP endpoints using Bearer Token Authorization and https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile JWT(MP JWT)を利用して、 link:https://tools.ietf.org/html/rfc7519[JSON Web Token] を検証し、MP JWT( `org.eclipse.microprofile.jwt.JsonWebToken` )として表現し、Bearer Token Authorizationと link:https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control] を使用してQuarkus HTTPエンドポイントへのセキュアなアクセスを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/eclipse/microprofile-jwt-auth/releases/download/1.1.1/microprofile-jwt-auth-spec.html[MP JWT 1.1.1 HTML]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/eclipse/microprofile-jwt-auth/releases/download/1.1.1/microprofile-jwt-auth-spec.html[MP JWT 1.1.1 HTML]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/eclipse/microprofile-jwt-auth/releases/download/1.1.1/microprofile-jwt-auth-spec.pdf[MP JWT 1.1.1 PDF]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/eclipse/microprofile-jwt-auth/releases/download/1.1.1/microprofile-jwt-auth-spec.pdf[MP JWT 1.1.1 PDF]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code are a _no go_ (even if we all did it at some point ;-)).  In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードの中にハードコードされた値を使うことは _できません_ (たとえ誰もがどこかの時点でそうしていたとしてもです ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and therefore `quarkus.` should **never** be used as prefix for application specific properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上述したように、 `quarkus.` で始まるプロパティーは、Quarkus 自体を設定するために実質的に予約されているため、アプリケーション固有のプロパティーのプレフィックスとして `quarkus.` を使用してはいけ *ません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to generate an example `application.properties` with all known configuration properties, to make it easy to see what Quarkus configuration options are available. To do this, run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Quarkus 設定オプションがどのようなものかを簡単に確認できるように、すべての既知の設定プロパティーを含むサンプル (`application.properties`) を生成することもできます。これを行うには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a `src/main/resources/application.properties.example` file that contains all the config options exposed via the extensions you currently have installed. These options are commented out, and have their default value when applicable. For example this HTTP port config entry will appear as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、現在インストールされているエクステンションを介して公開されているすべての設定オプションを含む `src/main/resources/application.properties.example` ファイルが作成されます。これらのオプションはコメントアウトされ、該当する場合はデフォルト値となります。たとえば、この HTTP ポート設定エントリーは次のように表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a config option is already present (commented or not) it will not be added, so it is safe to run this after adding an additional extension to see what additional options have been added.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定オプションが既に存在する場合 (コメントされていてもいなくても) は追加されないため、エクステンションを追加した後にこれを実行して、どのような追加オプションが追加されたかを確認するのが安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の HTTP ポートは 9090 になります。この場合は、`dev` プロファイルがアクティブでない限り、8181 になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These expressions are resolved when the property is read.  So if your configuration property is a build time configuration property, the property expression will be resolved at build time.  If your configuration property is overridable at runtime, the property expression will be resolved at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの式は、プロパティーの読み込み時に解決されます。したがって、設定プロパティーがビルド時の設定プロパティーである場合、プロパティー式はビルド時に解決されます。設定プロパティーが実行時にオーバーライド可能になると、プロパティー式は実行時に解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>callable.url=https://${remote.host}/
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>callable.url=https://${remote.host}/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will result in the value of the `callable.url` property being set to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、`callable.url` プロパティーの値が設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example would be defining different database servers depending on the profile used:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別の例としては、使用するプロファイルに応じて異なるデータベースサーバーを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>can be simplified by having:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、以下を指定することで簡略化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining Property Expressions and Environment Variables</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロパティー式と環境変数の組み合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>application.host=${HOST:${remote.host}}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>application.host=${HOST:${remote.host}}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default Quarkus application runtime profile is set to the profile used to build the application.  For example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの Quarkus アプリケーションランタイムプロファイルは、アプリケーションの構築に使用されるプロファイルに設定されています。たとえば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドは、`prod-aws` プロファイルで実行されます。これは `quarkus.profile` システムプロパティーを使用して上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile Configuration specification defines configuration keys as an arbitrary `.`-delimited string.  However, structured formats like YAML naively only support a subset of the possible configuration namespace.  For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`.  One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile の設定仕様は、設定キーを任意の `.` 区切り文字列として定義しています。ただし、YAML のような構造化されたフォーマットは、可能な設定名前空間のサブセットしかサポートしていません。たとえば、`quarkus.http.cors` および `quarkus.http.cors.methods` の 2 つの設定プロパティーについて考えてみましょう。あるプロパティーは別のプロパティーの接頭辞なので、YAML の設定で両方のキーをどのように指定するかはすぐにはわからないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus relies on SmallRye Config and inherits its features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus は SmallRye Config に依存しており、その機能を継承しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Converters</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のコンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Relocate Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定プロパティーの再配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fallback Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールバック設定プロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hide Secrets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>secret の非表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mandrelは現在のところ、Linuxのコンテナー化された環境をターゲットとしたネイティブ実行ファイルの構築にのみ推奨されています。つまり、Mandrelユーザーはコンテナーを使用してネイティブ実行ファイルを構築する必要があります。もしmacOSやWindowsをターゲットにしたプラットフォーム用のネイティブ実行ファイルをビルドする場合、Mandrelは現在これらのプラットフォームをターゲットにしていないため、代わりにOracle GraalVMを使用することを検討すべきです。ベアメタルのLinux上で直接ネイティブ実行ファイルをビルドすることも可能ですが、詳細は https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[rel README]と https://github.com/graalvm/mandrel/releases[Mandrelのリリース]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のセクションでは、Mavenを使用してネイティブ実行ファイルをビルドする方法を示しましたが、適切なGraalVMバージョンがビルドマシン(ローカルマシンまたはCI/CDインフラストラクチャ)にインストールされていることが暗黙のうちに要求されていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dockerビルドを起動する前に、デフォルトの `.dockerignore`  ファイルを更新する必要があります。 `target`  ディレクトリー以外は全てフィルタリングされ、コンテナー内でビルドする予定なので、 `src`  ディレクトリーをコピーできるようにする必要があります。そのため、 `.dockerignore`  を編集して、その内容を削除するかコメントしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してAMQPと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後になりますが、MutinyにはMicroProfile Context Propagationとの統合が組み込まれているので、リアクティブパイプラインでトランザクションやトレーサビリティデータなどを伝搬することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no tracing specific code included in the application. By default, requests sent to this endpoint will be traced without any code changes being required. It is also possible to enhance the tracing information. For more information on this, please see the https://github.com/eclipse/microprofile-opentracing/blob/master/spec/src/main/asciidoc/microprofile-opentracing.asciidoc[MicroProfile OpenTracing specification].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションにはトレースに特化したコードが含まれていないことに注意してください。デフォルトでは、このエンドポイントに送信されたリクエストは、コードの変更を必要とせずにトレースされます。また、トレース情報を強化することも可能です。これについての詳細は、 link:https://github.com/eclipse/microprofile-opentracing/blob/master/spec/src/main/asciidoc/microprofile-opentracing.asciidoc[MicroProfile OpenTracing 仕様] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Scheduled#delay()` がゼロよりも大きい値に設定されている場合、 `@Scheduled#delayed()` の値は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a built-in bean of type `io.quarkus.scheduler.Scheduler` that can be injected and used to pause/resume the scheduler.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `io.quarkus.scheduler.Scheduler` 型のビルトインBeanを提供しており、これを注入してスケジューラーを一時停止/再開するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#s2i[container-image-jib]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:container-image#s2i[container-image-jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tip: You don't necessarily need to add this property in the `application.properties`. You can pass it as a command line argument:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヒント: このプロパティーを `application.properties` で追加する必要はありません。コマンドラインの引数として渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM installed with `GRAALVM_HOME` configured appropriately if you want to use the native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブモードを使用したい場合は、 `GRAALVM_HOME` を適切に設定して GraalVM をインストールしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple: the user can add elements in a list using a form, and the items list is updated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドで構築されたアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、アイテムリストが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `quickstart` link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューションは `quickstart` link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will be building a REST application using the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] to simplify the Data Access Layer code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Data Access Layerのコードを簡略化するために、 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] を使ってRESTアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, the Mapper itself:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、マッパー本体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `FruitService` that will be the business layer of our application and store/load the fruits from the Cassandra database.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、アプリケーションのビジネス層となる `FruitService` を作成し、Cassandraデータベースから果物をセーブ/ロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how the service receives a `FruitDao` instance in the constructor. This DAO instance is provided by `FruitDaoProducer` and injected automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンストラクタで，サービスが `FruitDao` インスタンスを受け取っていることに注目してください．この DAO インスタンスは `FruitDaoProducer` によって提供され、自動的に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main properties to configure are: `contact-points`, to access the Cassandra database, `local-datacenter`, which is required by the driver, and – optionally – the keyspace to bind to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>構成する主なプロパティーは次のとおりです。 Cassandraデータベースにアクセスするための `contact-points` 、ドライバーによって必要とされる `local-datacenter` そしてオプションでバインド先のキースペースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your cluster requires plain text authentication, you can also provide two more settings: `username` and `password`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスタがプレーンテキスト認証を必要とする場合は、さらに2つの設定を行うことができます。 `username` と `password` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connecting to a cloud DataStax Astra database</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドDataStax Astraデータベースへの接続</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When connecting to Astra, instead of providing a contact point and a datacenter, you should provide `secure-connect-bundle`, which should point to a valid path to an Astra secure connect bundle, as well as `username` and`password`, since authentication is always required on Astra clusters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Astra に接続する際には、コンタクトポイントとデータセンターを提供する代わりに、`secure-connect-bundle` を提供する必要があります。これは、Astra のセキュアな接続バンドルへの有効なパスを指すとともに、Astra クラスタでは常に認証が必要となるため、 `username` と `password` も提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced driver configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高度なドライバー設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure other Java driver settings using `application.conf` or `application.json` files.  They need to be located in the classpath of your application.  All settings will be passed automatically to the underlying driver configuration mechanism.  Settings defined in `application.properties` with the `quarkus.cassandra` prefix will have priority over settings defined in `application.conf` or `application.json`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.conf` または `application.json` ファイルを使用して、他の Java ドライバーの設定を設定することができます。これらのファイルは、アプリケーションのクラスパスに配置する必要があります。すべての設定は、基礎となるドライバー設定メカニズムに自動的に渡されます。 `application.properties` で `quarkus.cassandra` のプレフィックスを付けて定義された設定は、 `application.conf` または `application.json` で定義された設定よりも優先されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `CassandraClient` is configured to access a local Cassandra database on port 9042 (the default Cassandra port).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、 `CassandraClient` は、ポート 9042(デフォルトの Cassandra ポート)でローカル Cassandra データベースにアクセスするように構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Docker to run a Cassandra database, you can use the following command to launch one:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dockerを使用してCassandraデータベースを起動したい場合は、以下のコマンドを使用して起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with `mvn clean quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusを起動する `mvn clean quarkus:dev`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Cassandra Client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブCassandraクライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're not familiar with Mutiny, read the link:getting-started-reactive[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyに慣れていない場合は、まず link:https://quarkus.io/guides/getting-started-reactive[Getting Started with Reactiveガイド] を読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's rewrite the previous example using reactive programming with Mutiny.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先ほどの例をMutinyを使ったリアクティブプログラミングで書き換えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Firstly, we need to implement the `@Dao` that works in a reactive way:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、リアクティブに動作する `@Dao` を実装する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to obtain the query execution info. If you don't need anything in that interface, you can also simply declare your method to return `Multi`: `Multi&lt;Fruit&gt; findByIdAsync(String id)`,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`MutinyMappedReactiveResultSet` の使い方に注意してください。これは、ドライバが返すオリジナルの `Publisher` から変換された特殊な `Mutiny` 型で、クエリの実行情報を取得するなど、いくつかの追加メソッドも公開されています。このインターフェイスで何も必要としない場合は、単純に `Multi` を返すようにメソッドを宣言することもできます。`Multi&lt;Fruit&gt; findByIdAsync(String id)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, we need to adapt the `FruitMapper` to construct a `FruitDaoReactive` instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 `FruitDaoReactive` のインスタンスを構築するために、 `FruitMapper` を適応させる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we can create a `FruitReactiveService` that leverages the reactive `@Dao`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、リアクティブな `@Dao` を利用した `FruitReactiveService` を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method above returns `Multi`, and the `add()` method returns `Uni`; these types are compatible with the Quarkus reactive REST API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の `get()` メソッドは `Multi` を返し、 `add()` メソッドは `Uni` を返します。これらのタイプは、Quarkus のリアクティブ REST API と互換性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To integrate the reactive logic with REST API, you need to have a dependency to `quarkus-resteasy-mutiny`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブロジックをRESTAPIと統合するには、 `quarkus-resteasy-mutiny` への依存関係が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, we can create a `FruitReactiveResource`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、 `FruitReactiveResource` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive frontend</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブなフロントエンドの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitReactiveResource`.  In the `src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the content from this link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/reactive-fruits.html[reactive-fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、 `FruitReactiveResource` を操作する簡単なWebページを追加してみましょう。 `src/main/resources/META-INF/resources` ディレクトリに、この link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/reactive-fruits.html[reactive-fruits.html] ファイルの内容を含む、 `reactive-fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser to `http://localhost:8080/reactive-fruits.html`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラザで `http://localhost:8080/reactive-fruits.html` を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `cassandra-quarkus` will automatically add a readiness health check to validate the connection to the cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、 `quarkus-quarkus` は、クラスタへの接続を検証するための Readiness ヘルスチェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.cassandra.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作は、 `application.properties` で `quarkus.cassandra.health.enabled` プロパティを `false` に設定することで無効にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the full list of available metrics, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference] and the `advanced.metrics` section.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能なメトリクスの全リストについては、リンク:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[ドライバーの設定リファレンス] と `advanced.metrics` セクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Swagger UI is included by default when running in `dev` or `test` mode, and can optionally added to `prod` mode.  See &lt;&lt;openapi-swaggerui.adoc#use-swagger-ui-for-development,the Swagger UI&gt;&gt; Guide for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Swagger UIは、 `dev` または `test` モードで実行しているときにデフォルトで含まれており、オプションで `prod` モードに追加することができます。詳細については、 link:openapi-swaggerui.html#use-swagger-ui-for-development[Swagger UI] ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Amazon DynamoDB extension (`quarkus-amazon-dynamodb`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon DynamoDBエクステンション ( `quarkus-amazon-dynamodb` ),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Keycloak extension (`quarkus-keycloak`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Keycloak エクステンション ( `quarkus-keycloak` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the MongoDB extension (`quarkus-mongodb-client`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB エクステンション ( `quarkus-mongodb-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the OAuth2 extension (`quarkus-elytron-security-oauth2`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OAuth2 エクステンション ( `quarkus-elytron-security-oauth2` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the REST client extension (`quarkus-rest-client`),</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST クライアントエクステンション ( `quarkus-rest-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As long as you have one of those extensions in your project, the SSL support will be enabled by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトにこれらのエクステンションのいずれかがある限り、SSLサポートはデフォルトで有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - MicroProfile Metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - MicroProfile Metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Metrics specification through the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Metricsエクステンションを使用してMicroProfile Metrics仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile Metrics allows applications to gather various metrics and statistics that provide insights into what is happening inside the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Metricsは、アプリケーションで様々なメトリクスや統計情報を収集して、アプリケーション内で何が起こっているかについての洞察を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-metrics` extension which is an implementation of the MicroProfile Metrics specification used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Quarkusで使用されているMicroProfile Metrics仕様の実装である `smallrye-metrics` エクステンションをインポートして、Mavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An `insert` section may define the default content that is rendered if not overridden.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`insert` セクションは、オーバーライドされない場合にレンダリングされるデフォルトのコンテンツを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Template Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>組み込みテンプレートエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no `@ResourcePath` qualifier provided, the field name is used to locate the template. In this particular case, we're injecting a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@ResourcePath` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この特定のケースでは、パスが `templates/hello.txt` であるテンプレートを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must build a mutable application, using the `mutable-jar` format. Set the following properties in `application.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを行うには、 `mutable-jar`  形式を使用して、ミュータブルアプリケーションを構築する必要があります。 `application.xml`  で以下のプロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you start Quarkus on the remote host set the environment variable `QUARKUS_LAUNCH_DEVMODE=true`. If you are on bare metal you can just set this via the `export QUARKUS_LAUNCH_DEVMODE=true` command, if you are running using docker start the image with `-e QUARKUS_LAUNCH_DEVMODE=true`. When the application starts you should now see the following line in the logs: `Profile dev activated. Live Coding activated`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモートホストでQuarkusを起動する前に、環境変数 `QUARKUS_LAUNCH_DEVMODE=true`  を設定します。ベアメタルを使用している場合は、 `export QUARKUS_LAUNCH_DEVMODE=true`  コマンドで設定します。dockerを使用している場合は、 `-e QUARKUS_LAUNCH_DEVMODE=true`  でイメージを起動します。アプリケーションが起動すると、ログに次のような行が表示されるはずです: `Profile dev activated. Live Coding activated` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually, dependencies of an application (which is a Maven project) could be displayed using `mvn dependency:tree` command. In case of a Quarkus application, however, this command will list only the runtime dependencies of the application.  Given that the Quarkus build process adds deployment dependencies of the extensions used in the application to the original application classpath, it could be useful to know which dependencies and which versions end up on the build classpath.  Luckily, the `quarkus-bootstrap` Maven plugin includes the `build-tree` goal which displays the build dependency tree for the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常、アプリケーション(Mavenプロジェクト)の依存関係は、 `mvn dependency:tree`  コマンドを使用して表示することができます。しかし、Quarkusアプリケーションの場合、このコマンドはアプリケーションの実行時の依存関係のみを表示します。Quarkusのビルドプロセスは、アプリケーションで使用されているエクステンションのデプロイメント依存関係を元のアプリケーションのクラスパスに追加するので、どの依存関係とどのバージョンがビルドクラスパスで終わるかを知ることは便利です。幸いにも、 `quarkus-bootstrap`  Mavenプラグインには、アプリケーションのビルド依存関係ツリーを表示する `build-tree`  ゴールが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt;
      &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.0.7&lt;/version&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;make-index&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;jandex&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt;
      &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.0.7&lt;/version&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;make-index&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;jandex&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the challenges brought by the distributed nature of microservices is that communication with external systems is inherently unreliable. This increases demand on resiliency of applications. To simplify making more resilient applications, Quarkus contains an implementation of the MicroProfile Fault Tolerance specification.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイクロサービスの分散型の性質がもたらす課題の1つは、外部システムとの通信が本質的に信頼性が低いことです。これにより、アプリケーションの回復力に対する要求が高まります。より回復力の高いアプリケーションを簡単に作成するために、QuarkusにはMicroProfile Fault Tolerance仕様の実装が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure, importing the extensions for RESTEasy/JAX-RS and SmallRye Fault Tolerance, which is an implementation of the MicroProfile Fault Tolerance spec that Quarkus uses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、RESTEasy/JAX-RSとSmallRye Fault ToleranceのエクステンションをインポートしてMaven構造体を生成し、Quarkusが使用するMicroProfile Fault Tolerance仕様の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fluentd alternative: use Syslog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Fluentdの代替:Syslogの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will display the help information with all the available commands.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、利用可能なすべてのコマンドのヘルプ情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a new project we use the create-project command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいプロジェクトを作成するには、create-project コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a folder called 'hello-world' in your current working directory using default groupId, artifactId and version values (groupId='org.acme', artifactId='quarkus' and version='1.0.0-SNAPSHOT').</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、デフォルトの groupId、artifactId、および version の値 (groupId='org.acme', artifactId='quarkus', version='1.0.0-SNAPSHOT') を使用して、現在の作業ディレクトリーに 'hello-world' という名前のフォルダーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify the groupId, artifactId and version values, use the '--groupid', '--artifactid' and '--version' options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>groupId、artifactId、および version の値を指定するには、'--groupid'、'--artifactid'、および '--version' オプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the help option to display all the possible options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能なすべてのオプションを表示するには、ヘルプオプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus CLI では、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can add Quarkus extensions to your project with the 'add-extension' command:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus CLI では、'add-extension' コマンドを使用して、Quarkus のエクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start dev mode from the Quarkus CLI do:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus CLI から dev モードを起動するには、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and repositories (also known as DAOs) with some automatically provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight change or two.  To Panache-enable your entity, you would define it something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Panacheガイドで見たように、Panacheを使うと、エンティティーやリポジトリ(DAOとも呼ばれます)の機能を自動で提供される機能で拡張することができます。Kotlin を使用する場合のアプローチは Java 版と非常によく似ていますが、若干の変更点があります。エンティティーを Panache で有効にするには、次のように定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get started using Panache with Kotlin, you can, generally, follow the steps laid out in the Java tutorial.  The biggest change to configuring your project is the Quarkus artifact to include.  You can, of course, keep the Java version if you need but if all you need are the Kotlin APIs then include the following dependency instead:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KotlinでPanacheを使い始めるには、一般的には、Javaチュートリアルで説明されている手順に従います。プロジェクトを設定する上で最も大きな変更点は、インクルードするQuarkusのアーティファクトです。もちろん、必要であればJavaバージョンのままでも構いませんが、KotlinのAPIだけが必要な場合は、代わりに以下の依存関係をインクルードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Amazon Lambda with RESTEasy, Undertow, or Vert.x Web </seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - RESTEasy、Undertow、またはVert.x Webを使用した Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Lambda を純粋な Java jar としてデプロイすることもできますし、プロジェクトをネイティブイメージにコンパイルしてデプロイすることで、より少ないメモリーフットプリントと起動時間を実現することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>POM には `quarkus-amazon-lambda-http` エクステンションが依存関係として含まれている以外に特別なことは何もありません。このエクステンションは Lambda のデプロイに必要なものをすべて自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things to note though that are particular to the `quarkus-amazon-lambda-http` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`sam.yaml` の構文はこのドキュメントの範囲を超えています。しかし、 `quarkus-amazon-lambda-http` エクステンションに特有の注意点がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon's API Gateway assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AmazonのAPI Gatewayでは、設定でどのメディアタイプがバイナリーであるかを明示的に指定しない限り、HTTPレスポンスボディはテキストであることを前提としています。より簡単にするために、QuarkusエクステンションはすべてのHTTP応答メッセージのバイナリー(ベース64)エンコーディングを強制します。 `sam.yaml` ファイルでは、すべてのメディアタイプがバイナリーであると仮定するようにAPI Gatewayを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another thing to note is that for pure Java lambda deployments, do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つ注意すべきことは、純粋な Java Lambda ラムダデプロイメントの場合、 Lambda ハンドラーの名前を変更しないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、ネイティブなGraalVMデプロイメントのために設定しなければならない環境変数があります。 `sam.native.yaml` を見ると、以下のようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC generation provides several stubs, providing different way to consume a service.  Quarkus gRPC can inject:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPC生成はいくつかのスタブを提供し、サービスを消費するためのさまざまな方法を提供します。QuarkusのgRPCはインジェクトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>reactive stubs based on Mutiny</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyをベースにしたリアクティブスタブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, it also can inject the gRPC `io.grpc.Channel`, that lets you create other types of stubs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、それはまた gRPC `io.grpc.Channel` を注入することができ、他のタイプのスタブを作成することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The stub class names are computed from the service name.  For example, if you use `Greeter` as service name as in:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタブクラス名はサービス名から計算されます。例えば、サービス名として `Greeter` とした場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny stub name is: `MutinyGreeterGrpc.MutinyGreeterStub` The blocking stub name is: `GreeterGrpc.GreeterBlockingStub`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyのスタブ名は `MutinyGreeterGrpc.MutinyGreeterStub` です。ブロッキングのスタブ名は `GreeterGrpc.GreeterBlockingStub` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client injection must be qualified using `@GrpcService`.  This annotation indicates the configuration prefix used to configure the service.  For example, if you set it to `hello-service`, configuring the host of the service is done using `hello-service.host`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クライアントインジェクションは、 `@GrpcService` を使用して修飾する必要があります。このアノテーションは、サービスを構成するために使用する構成プレフィックスを示します。たとえば、 `hello-service` に設定した場合、サービスのホストの構成は `hello-service.host` を使用して行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in this example, the `quarkus.grpc.clients.hello.host` property must be set.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、 `quarkus.grpc.clients.hello.host` プロパティーを設定する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 2 following examples uses _hello_ as service name.  Don't forget to replace it with the name you used in in the `@GrpcService` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の2つの例では、サービス名として _hello_ を使用しています。 `@GrpcService` アノテーションで使用した名前に置き換えることを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to generate (random) temperature values in one component (named `generator`).  These values are associated to given weather stations and are written in a Kafka topic (`temperature-values`).  Another topic (`weather-stations`) contains just the master data about the weather stations themselves (id and name).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、(ランダムな)温度値を 1 つのコンポーネント ( `generator` ) で生成します。これらの値は、与えられた気象観測所に関連付けられ、Kafka トピック ( `temperature-values` ) に書き込まれます。別のトピック ( `weather-stations` ) には、気象観測所自体に関するマスターデータ (id と名前) だけが格納されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC service implementations exposed as beans are automatically registered and served by quarkus-grpc.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Beanとして公開されたgRPCサービス実装は、自動的に登録され、quarkus-grpcによって提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first classname is structured as follows: `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.  The second classname is structured as follows: `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のクラス名は `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase` のように構成されています。 2番目のクラス名は `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase` のように構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you use `Greeter` as service name as in:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、次のようにサービス名を `Greeter` とした場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The regular implementation base is: `GreeterGrpc.GreeterImplBase`.  The second implementation base is: `MutinyGreeterGrpc.GreeterImplBase`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常の実装ベースは `GreeterGrpc.GreeterImplBase` です。第二の実装ベースは `MutinyGreeterGrpc.GreeterImplBase` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a service with the default gRPC API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのgRPC APIでサービスを実装する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Server configuration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サーバーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you encounter the following error when running your application in native mode: + `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can't find a codec for class org.acme.MyVariable.` + This means that the `org.acme.MyVariable` class is not known to GraalVM, the remedy is to add the `@RegisterForReflection` annotation to your `MyVariable class`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをネイティブモードで実行しているときに以下のエラーが発生した場合。 `@RegisterForReflection` `MyVariable class` + `Failed to encode 'MyObject'. Encoding 'myVariable' errored with: Can’t find a codec for class org.acme.MyVariable.` + これは、 `org.acme.MyVariable` クラスが GraalVM に知られていないことを意味します。対処方法としては、 `MyVariable class` に `@RegisterForReflection` アノテーションを追加することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a standard Kubernetes service definition yaml file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはKubernetesの標準的なサービス定義のyamlファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you change the image url to point to the image you built and pushed earlier!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたが以前に構築してプッシュしたイメージを指すように、イメージのURLを変更することを確認してください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For our quickstart, one Kubernetes service will contain all functions.  There's no reason you couldn't break up this quickstart into multiple different projects and deploy a service for each function.  For simplicity, and to show that you don't have to have a deployment per function, the quickstart combines everything into one project, image, and service.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のクイックスタートでは、1つのKubernetesサービスにすべての機能が含まれます。このクイックスタートを複数の異なるプロジェクトに分割して、機能ごとにサービスをデプロイできない理由はありません。シンプルにするために、また、機能ごとにデプロイする必要がないことを示すために、このクイックスタートでは、すべての機能を1つのプロジェクト、イメージ、サービスにまとめています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy the service yaml.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスyamlをデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next step is to deploy Knative Event triggers for each of the event types.  As noted in the code section, each Funqy function is mapped to a specific Cloud Event type.  You must create Knative Event triggers that map a Cloud Event and route it to a specific Kubernetes service.  We have 4 different triggers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のステップは、イベントタイプごとにKnative Eventのトリガーを展開することです。コードのセクションで述べたように、各Funqy関数は特定のCloud Eventタイプにマッピングされています。Cloud Eventをマッピングし、特定のKubernetesサービスにルーティングするKnative Eventトリガーを作成する必要があります。ここでは4つの異なるトリガーを用意しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's a trigger yaml file for each of our 4 Funqy functions.  Deploy them all:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>4つのFunqy関数それぞれのトリガーyamlファイルがあります。それらをすべてデプロイしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will provide you a url like this (exactly like this if you followed the knative tutorial): `http://default-broker.knativetutorial.svc.cluster.local` Remember this URL.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなURLが表示されます(knativeのチュートリアルに従った場合はこのようになります)。 `http://default-broker.knativetutorial.svc.cluster.local` このURLを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next thing we need to do is ssh into our Kubernetes cluster so that we can send a curl request to our broker.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に行う必要があるのは、Kubernetes クラスタに ssh して、ブローカーに curl リクエストを送信できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now be in a shell within the Kubernetes cluster.  Within the shell, execute this curl command</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでKubernetesクラスタ内のシェルになります。シェル内で、次のような curl コマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use the `@ResourcePath` qualifier to specify the template path: `templates/reports/v1/report_01.html`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、 `@ResourcePath` の修飾子を使用してテンプレートのパスを指定します: `templates/reports/v1/report_01.html` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project (without any classes) and import the `undertow-websockets` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Mavenプロジェクト(クラスなし)を生成し、 `undertow-websockets` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `undertow-websockets` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `undertow-websockets` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - MicroProfile Health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus - MicroProfile Health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Health specification through the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Healthエクステンションを使用してMicroProfile Health仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile Health allows applications to provide information about their state to external viewers which is typically useful in cloud environments where automated processes must be able to determine whether the application should be discarded or restarted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Health は、アプリケーションの状態に関する情報を外部のビューアーに提供することを可能にします。これは、アプリケーションを廃棄するか再起動するかを自動化されたプロセスで判断する必要があるクラウド環境で一般的に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-health` extension which is an implementation of the MicroProfile Health specification used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコマンドは、Quarkusで使用されているMicroProfile Health仕様の実装である `smallrye-health` エクステンションをインポートして、Mavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile Health provides a way for your application to distribute information about its healthiness state to state whether or not it is able to function properly.  Liveness checks are utilized to tell whether the application should be restarted and readiness checks are used to tell whether the application is able to process requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Health は、アプリケーションが正常に機能するかどうかを示すために、アプリケーションの健康状態に関する情報を配布する方法を提供します。Livenessチェックはアプリケーションを再起動すべきかどうかを伝えるために利用され、Readinesチェックはアプリケーションがリクエストを処理できるかどうかを伝えるために利用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All that is needed to enable the MicroProfile Health features in Quarkus is:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのMicroProfile Health機能を有効にするために必要なのは、これだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gcloud beta functions deploy quarkus-example-funky-pubsub \
  --entry-point=io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction \
  --runtime=java11 --trigger-resource hello_topic --trigger-event google.pubsub.topic.publish \
  --source=target/deployment
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gcloud beta functions deploy quarkus-example-funky-pubsub \
  --entry-point=io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction \
  --runtime=java11 --trigger-resource hello_topic --trigger-event google.pubsub.topic.publish \
  --source=target/deployment
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gcloud beta functions deploy quarkus-example-funky-storage \
  --entry-point=io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction \
  --runtime=java11 --trigger-resource quarkus-hello --trigger-event google.storage.object.finalize \
  --source=target/deployment
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gcloud beta functions deploy quarkus-example-funky-storage \
  --entry-point=io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction \
  --runtime=java11 --trigger-resource quarkus-hello --trigger-event google.storage.object.finalize \
  --source=target/deployment
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>java -jar java-function-invoker-1.0.0-beta1.jar \
  --classpath target/funqy-google-cloud-functions-1.0.0-SNAPSHOT-runner.jar \
  --target io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>java -jar java-function-invoker-1.0.0-beta1.jar \
  --classpath target/funqy-google-cloud-functions-1.0.0-SNAPSHOT-runner.jar \
  --target io.quarkus.funqy.gcp.functions.FunqyBackgroundFunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging 利用して Apache Kafka とやりとりする仕組みを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need a Kafka cluster.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、Kafka クラスターが必要です。https://kafka.apache.org/quickstart[Apache Kafka の Web サイト] の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @Channel("my-data-stream") Publisher&lt;Double&gt; prices; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Inject
    @Channel("my-data-stream") Publisher&lt;Double&gt; prices; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.prices.connector=smallrye-kafka
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.prices.connector=smallrye-kafka
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Output` because your method has parameters.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、POST リクエストを受信したときに、REST エンドポイントの内部からストリームにメッセージを送信する必要があるとします。この場合、メソッドにはパラメーターがあるため、`@Output` を使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この動作を有効にするには、`application.properties` の `quarkus.kafka.health.enabled` プロパティを `true` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B, but the corresponding deserializer is generic, so it needs to be subclassed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON-B によってすべての pojos をシリアライズするために使用できる既存の `JsonbSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、一般的な `JsonbDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>pojo に個別にデシリアライザーを作成したくない場合は、`javax.json.JsonObject` にデシリアライズする汎用の `io.vertx.kafka.client.serialization.JsonObjectDeserializer` を使用することができます。対応するシリアライザーも使用できます。`io.vertx.kafka.client.serialization.JsonObjectSerializer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson, but the corresponding deserializer is generic, so it needs to be subclassed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jackson によって全ての POJO をシリアルに変換することができる既存の `ObjectMapperSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、`ObjectMapperDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.  It utilizes MicroProfile Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus を使用して Kafka とやりとりする方法を示しました。MicroProfile Reactive Messaging を利用して、データストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the library needed for Log2J version 2; if you use the legacy Log4J version 1 you need to use `log4j-jboss-logmanager` instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはLog2Jのバージョン2に必要なライブラリです。もしレガシーなLog4Jのバージョン1を使用している場合は、代わりに `log4j-jboss-logmanager` を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントバスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your work with a Quarkus OIDC `web-app` application then it is Quarkus OIDC Code Authentication mechanism which is managing the user session lifespan.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus OIDC `web-app` アプリケーションで作業している場合、ユーザーセッションの寿命を管理しているのはQuarkus OIDCコード認証メカニズムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Note**: Versions of localstack newer than v0.11.5 require port `4566` instead of port `4572`. See this https://github.com/localstack/localstack/issues/2983[GitHub issue] for details on this change
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**Note** : v0.11.5 より新しいバージョンの localstack では、ポート `4572` の代わりに `4566` を必要とします。この変更の詳細は link:https://github.com/localstack/localstack/issues/2983[GitHub issue] を参照してください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now ships with a new experimental Dev UI, which is available in dev mode (when you start quarkus with `mvn quarkus:dev`) at http://localhost:8080/q/dev[/q/dev] and will show you something like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは現在、新しく実験的なDev UIを搭載しています。このUIは、 devモード( `mvn quarkus:dev` でquarkusを起動)で利用可能で、link:http://localhost:8080/q/dev[/q/dev] に存在し、以下のようなものが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The style system currently in use is https://getbootstrap.com/docs/4.0/getting-started/introduction/[Bootstrap V4 (4.5.3)] but note that this might change in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在使用されているスタイルシステムは link:https://getbootstrap.com/docs/4.0/getting-started/introduction/[Bootstrap V4(4.5.3)] ですが、将来的に変更される可能性があるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `urlbase` template parameter to point to where your full-page templates are located</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`urlbase` テンプレートパラメーターを使用して、フルページテンプレートが配置されている場所を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the restrictions imposed by GraalVM, extra care needs to be taken when implementing an `io.fabric8.kubernetes.client.Watcher` if the application is intended to work in native mode.  Essentially every `Watcher` implementation needs to specify the Kubernetes model class that it handles via the ``Watcher``'s generic type at class definition time.  To better understand this, suppose we want to watch for changes to Kubernetes `Pod` resources. There are a couple ways to write such a `Watcher` that are guaranteed to work in native:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMによって課せられた制限のため、アプリケーションがネイティブモードで動作することを意図している場合、 `io.fabric8.kubernetes.client.Watcher` を実装する際には特に注意が必要です。基本的にすべての `Watcher` の実装は、クラス定義時に `Watcher` のジェネリック型を介して扱う Kubernetes モデルクラスを指定する必要があります。これをよりよく理解するために、例えばKubernetes `Pod` リソースの変更を監視したいとします。このような `Watcher` を書くには、ネイティブでの動作が保証されている方法がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expose your implementation as bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実装をBeanとして公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the service and configure its name. This name is used in the application configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サービスをインジェクトし、その名前を設定します。この名前は、アプリケーションの設定で使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`hello` is the name of the service used in the `@GrpcService` annotation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`hello` は `@GrpcService` アノテーションで使用されるサービスの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer defines a core library and a set of additional libraries that support different monitoring systems.  Quarkus Micrometer extensions are structured similarly: `quarkus-micrometer` provides core micrometer support and runtime integration and other supporting Quarkus and Quarkiverse extensions bring in additional dependencies and requirements to support specific monitoring systems.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Micrometerは、コアライブラリと、さまざまなモニタリングシステムをサポートする追加ライブラリのセットを定義しています。Quarkus Micrometerのエクステンションも同様に構成されています。 `quarkus-micrometer` は Micrometer コアのサポートとランタイムの統合を提供し、その他のサポートするQuarkusやQuarkiverseのエクステンションは、特定のモニタリングシステムをサポートするための追加の依存関係や要件を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To view the metrics, execute `curl localhost:8080/q/metrics/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メトリクスを表示するには、 `curl localhost:8080/q/metrics/` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, a singleton CDI bean will produce two different `MeterFilter` beans. One will be applied only to Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied to all `MeterRegistry` instances. An application configuration property is also injected and used as a tag value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では、シングルトン CDI Beanは、2 つの異なる `MeterFilter` Beanを生成します。1 つは Prometheus `MeterRegistry` インスタンスのみに適用され ( `@MeterFilterConstraint` qualifier を使用)、もう 1 つはすべての `MeterRegistry` インスタンスに適用されます。アプリケーション構成プロパティーも注入され、タグ値として使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry. Note that naming conventions between the two systems will change, but you can use MeterFilters to remap names or tags to what your dashboards require.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションで MicroProfile Metrics API を使用している場合、Micrometer 拡張機能は、これらのメトリクスを Micrometer レジストリにマッピングするための適応レイヤーを作成します。2 つのシステム間の命名規則は変更されますが、MeterFilters を使用して名前やタグをダッシュボードが必要とするものに再マッピングすることができることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this reference guide we're going to describe various aspects of Quarkus configuration.  A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.  Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.  All of the standard features are supported.  Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリファレンスガイドでは、Quarkus の設定の様々な側面について説明します。Quarkus アプリケーションと Quarkus 自体 (コアとエクステンション) の両方は、link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API を活用した同じメカニズムを介して設定されます。Quarkus の設定は、MicroProfile Config 仕様の実装である link:https://github.com/smallrye/smallrye-config[SmallRye Config] に基づいています。標準機能はすべてサポートされています。さらに、Quarkus だけでなく、SmallRye Config プロジェクトでも利用可能な追加機能がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Sources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus reads configuration properties from several sources (in decreasing priority):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkus は、複数のソースから設定プロパティーを (優先度の高い順に) 読み取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;system_properties,System properties&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#system_properties[システムプロパティー]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;environment_variables,Environment variables&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#environment_variables[環境変数]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;env_file,File named `.env`&gt;&gt; placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在の作業ディレクトリーに置かれた link:#env_file[`.env` という名前のファイル]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;application_properties_file,An application configuration file&gt;&gt;, i.e. `src/main/resources/application.properties`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:#application_properties_file[アプリケーション設定ファイル] (すなわち `src/main/resources/application.properties`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile Config].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>環境変数名は、link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile Config] の変換ルールに従っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File named `.env` placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在の作業ディレクトリーに置かれた `.env` という名前のファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for &lt;&lt;environment_variables&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`QUARKUS_DATASOURCE_PASSWORD` という名前は、link:#environment_variables[environment_variables] と同じルールで変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>dev モードの場合、このファイルはプロジェクトのルートに置くことができますが、バージョン管理を選択 **しない** ことが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).  Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`config/application.properties` 機能は開発モードでも利用可能です。これを利用するには、ビルドツールの出力ディレクトリー (Maven の場合は `target` 、Gradle の場合は `build/classes/java/main`) の中に `config/application.properties` を置く必要があります。ただし、`mvn clean` や `gradle clean` のようなビルドツールからのクリーンアップ操作は、`config` ディレクトリーも削除してしまうことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An application configuration file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション設定ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the main application configuration file located in `src/main/resources/application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `src/main/resources/application.properties` にあるメインのアプリケーション設定ファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example `application.properties` file</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`application.properties` ファイル例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.  The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.  This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@Inject @ConfigProperty` を使用することも、 `@ConfigProperty` だけを使用することもできます。 `@Inject` アノテーションは、 `@ConfigProperty` でアノテーションされたメンバーには必要ありません。この動作は link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定されていない設定プロパティーをアプリケーションが注入しようとすると、エラーが発生するため、設定が完了した時期をすぐに知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the notion of configuration profiles.  These allow you to have multiple configurations in the same file and select between them via a profile name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、設定プロファイルという概念をサポートしています。これにより、同じファイル内に複数の設定を持つことができ、プロファイル名を使用してそれらの間で選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in `application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 自体は、アプリケーションと同じメカニズムで設定されます。Quarkus は、独自の設定とすべてのエクステンションの設定のために、`quarkus.` 名前空間を予約します。たとえば、HTTP サーバーポートを設定するには、`application.properties` で `quarkus.http.port` を設定します。Quarkus の設定プロパティーはすべて link:all-config[文書化されており、検索可能です]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and its extensions.  Therefore `quarkus.` should **never** be used as prefix for application specific properties.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上述したように、`quarkus.` で始まるプロパティーは、事実上、Quarkus 自体とそのエクステンションを設定するために予約されています。したがって、`quarkus.` は、アプリケーション固有のプロパティーの接頭辞として使用すべきでは**ありません**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, some extensions do define properties that can be _overriden at runtime_.  A canonical example is the database URL, username and password which are only known specifically in your target environment.  This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do.  The list of runtime properties is therefore lean.  You can override these runtime properties with the following mechanisms (in decreasing priority) using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、いくつかのエクステンションは _実行時に上書き_ できるプロパティーを定義します。典型的な例としては、データベースの URL、ユーザー名、およびパスワードがありますが、これらはターゲット環境でのみ認識されます。これは、ランタイムプロパティーが多いほど、Quarkus が実行できるビルド時間の前処理が少なくなるため、トレードオフの関係にあります。そのため、ランタイムプロパティーの一覧は無駄がありません。これらのランタイムプロパティーは、以下のメカニズムを使用して (優先度の高い順に) 上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run time properties which are optional, and which have had values set at build time or which have a default value, may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect runtime properties, and will _only_ work with properties whose values are not required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>任意であり、ビルド時に値が設定されていたり、デフォルト値が設定されていたりするランタイムプロパティーは、空の文字列をプロパティーに代入することで明示的に削除することができます。これはランタイムプロパティーに _のみ_ 影響し、値が必須ではないプロパティーで _のみ_ 動作することに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comma-separated list of origins allowed for CORS. The filter allows any origin if this is not set or set to '*'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CORS に許可されるオリジンのコンマ区切りリスト。これが設定されていないか '*' に設定されている場合、フィルターは任意のオリジンを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find a set of extensions to access various Google Cloud Services in the Quarkiverse (a GitHub organization for Quarkus extensions maintained by the community), including PubSub, BigQuery, Storage, Spanner, Firestore (visit the repository for an accurate list of supported services).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PubSub、BigQuery、Storage、Spanner、Firestore(サポートされているサービスの正確なリストはリポジトリを参照してください)など、さまざまなGoogle Cloud ServicesにアクセスするためのエクステンションのセットをQuarkiverse(コミュニティによってメンテナンスされているQuarkusエクステンションのためのGitHub組織)で見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.log.category."io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator".level=TRACE` and `quarkus.log.category."io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator".min-level=TRACE` to see more details about the token verification or decryption errors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.log.category."io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator".level=TRACE` と `quarkus.log.category."io.quarkus.smallrye.jwt.runtime.auth.MpJwtValidator".min-level=TRACE` を設定すると、トークンの検証エラーや復号エラーの詳細が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus reads configuration properties from &lt;&lt;config-reference.adoc#configuration_sources,several sources&gt;&gt;.  For the purpose of this guide, we will use an application configuration file located in `src/main/resources/application.properties`.  Edit the file with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、Quarkus は link:config-reference.html#configuration_sources[複数のソース] から設定プロパティーを読み取ります。このガイドでは、 `src/main/resources/application.properties` にあるアプリケーション設定ファイルを使用します。以下の内容でファイルを編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the application attempts to inject a configuration property that is not set, an error is thrown.  So you can quickly know when your configuration is complete.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが設定されていない設定プロパティーを注入しようとすると、エラーがスローされます。そのため、設定が完了したときにすぐに知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, some extensions do define properties _overridable at runtime_.  A canonical example is the database URL, username and password which is only known specifically in your target environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、いくつかのエクステンションは _実行時にオーバーライド可能な_ プロパティーを定義しています。定型的な例としては、データベースの URL、ユーザー名とパスワードがありますが、これはターゲット環境でしか知られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuring_quarkus,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:config-reference.html#configuring_quarkus[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is using https://github.com/eclipse/microprofile-config[Eclipse MicroProfile Config] for wiring application configuration. A Quarkus platform may be used as another source of configuration in the hierarchy of the configuration sources dominated by the application's `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、アプリケーション設定の接続に link:https://github.com/eclipse/microprofile-config[Eclipse MicroProfile Config]を使用しています。Quarkusプラットフォームは、アプリケーションの `application.properties` によって支配されている構成ソースの階層の別の構成ソースとして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST endpoints are automatically traced.  If you need to trace additional methods, you can use the `org.eclipse.microprofile.opentracing.Traced` annotation at class or method level.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST エンドポイントは自動的にトレースされます。追加でメソッドをトレースする必要がある場合は、クラスやメソッドレベルで `org.eclipse.microprofile.opentracing.Traced` アノテーションを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the best way to add OpenTracing capability to reactive messaging based applications is by adding the `Traced` annotation to all incoming methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messagingベースのアプリケーションに OpenTracing 機能を追加する最善の方法は、すべての受信メソッドに `Traced` アノテーションを追加することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc-client` and `quarkus-oidc-client-filter` extensions to acquire and refresh access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-oidc-client` および `quarkus-oidc-client-filter` エクステンションを使用して、OpenId Connect および link:https://www.keycloak.org/about.html[Keycloak] などの OAuth 2.0 準拠の認可サーバーからアクセストークンを取得し、更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.secret=secret ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.secret=secret ```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.secret=secret quarkus.oidc-client.grant.type=password quarkus.oidc-client.grant-options.password.username=alice quarkus.oidc-client.grant-options.password.password=alice ``` In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.secret=secret quarkus.oidc-client.grant.type=password quarkus.oidc-client.grant-options.password.username=alice quarkus.oidc-client.grant-options.password.password=alice ``` In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` import javax.inject.PostConstruct; import javax.inject.Inject; import javax.ws.rs.GET;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` import javax.inject.PostConstruct; import javax.inject.Inject; import javax.ws.rs.GET;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.oidc.client.OidcClient; import io.quarkus.oidc.client.Tokens;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>import io.quarkus.oidc.client.OidcClient; import io.quarkus.oidc.client.Tokens;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/service")  public class OidcClientResource {</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Path("/service")  public class OidcClientResource {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Tokens tokens = currentTokens;
        if (tokens.isAccessTokenExpired()) {
            tokens = client.refreshTokens(tokens.getRefreshToken()).await().indefinitely();
            currentTokens = tokens;
        } 
        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc
    }
}
```
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>        Tokens tokens = currentTokens;
        if (tokens.isAccessTokenExpired()) {
            tokens = client.refreshTokens(tokens.getRefreshToken()).await().indefinitely();
            currentTokens = tokens;
        } 
        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc
    }
}
```
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` @Provider @Priority(Priorities.AUTHENTICATION)  @RequestScoped public class OidcClientRequestCustomFilter implements ClientRequestFilter {</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` @Provider @Priority(Priorities.AUTHENTICATION)  @RequestScoped public class OidcClientRequestCustomFilter implements ClientRequestFilter {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + tokens.getAccessToken());
    }
}
```
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + tokens.getAccessToken());
    }
}
```
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Tokens` producer will acquire and refresh the tokens and the custom filter will decide how and when to use the token.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Tokens` プロデューサーがトークンを取得して更新し、カスタムフィルターがいつどのようにトークンを使用するかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.oidc.client.OidcClients` is a container of `OidcClient`s - it includes a default `OidcClient` (which can also be injected directly as described above) and named clients which can be configured like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkus.oidc.client.OidcClients` は、 `OidcClient` のコンテナです。デフォルトの `OidcClient` (上記のように直接注入することも可能です) と名前付きクライアントを含み、このように設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.secret=mysecret ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.secret=mysecret ```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.client-secret.value=mysecret quarkus.oidc-client.credentials.client-secret.method=post ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.client-secret.value=mysecret quarkus.oidc-client.credentials.client-secret.method=post ```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow ```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.jwt.key-file=privateKey.pem ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.jwt.key-file=privateKey.pem ```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.jwt.key-store-file=keystore.jks quarkus.oidc-client.credentials.jwt.key-store-password=mypassword quarkus.oidc-client.credentials.jwt.key-password=mykeypassword quarkus.oidc-client.credentials.jwt.key-id=mykey ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus/ quarkus.oidc-client.client-id=quarkus-app quarkus.oidc-client.credentials.jwt.key-store-file=keystore.jks quarkus.oidc-client.credentials.jwt.key-store-password=mypassword quarkus.oidc-client.credentials.jwt.key-password=mykeypassword quarkus.oidc-client.credentials.jwt.key-id=mykey ```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `private_key_jwt` or `private_key_jwt` authentication methods ensures that no client secret goes over the wire.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`private_key_jwt` または `private_key_jwt` 認証方法を使用することで、クライアントシークレットが漏れることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important elements are these 3 options:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>重要な要素は次の3つのオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:micrometer[Micrometer] is the recommended approach to metrics for Quarkus.  Use the MicroProfile Metrics extension when it's required to retain MicroProfile specification compatibility.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:micrometer[Micrometerは] 、Quarkusのメトリクスへの推奨アプローチです。MicroProfile仕様の互換性を維持する必要がある場合は、MicroProfile Metricsエクステンションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also declare your templates in your Java code.  If using &lt;&lt;resteasy_integration,templates in JAX-RS resources&gt;&gt;, you can rely on the following convention:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Java コードでテンプレートを宣言することもできます。 link:#resteasy_integration[JAX-RSリソースでテンプレート] を使用する場合は、以下の規約に従うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus --help
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ quarkus --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus -i
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ quarkus -i
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window="_blank"].  Therefore, bean classes that don't have a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window="_blank"] are ignored.  Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、アプリケーションは link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[ビーンディスカバリモード `annotated`, window="_blank"] でアノテーションされた単一のBeanアーカイブで表現されます。したがって、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[Bean 定義アノテーション, window="_blank"] を持たないBeanクラスは無視されます。Bean定義アノテーションはクラスレベルで宣言され、スコープ、ステレオタイプ、 `@Interceptor` を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If more than one custom `SecurityIdentityAugmentor` is registered then they will be considered equal candidates and invoked in random order.
You can enforce the order by implementing a default `SecurityIdentityAugmentor#priority` method. Augmentors with higher priorities will be invoked first.
===
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数のカスタム `SecurityIdentityAugmentor` が登録されている場合、それらは同等の候補とみなされ、ランダムな順序で呼び出されます。
デフォルトの `SecurityIdentityAugmentor#priority` メソッドを実装することで順番を強制することができます。優先度の高いエクステンションが最初に起動されます。
===
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging を使用して HTTP メッセージを消費および生成する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes MicroProfile Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このエクステンションは、MicroProfile Reactive Messaging を利用してデータストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already covered in the link:hibernate-orm-panache[Panache guide].  In this guide, we'll cover the Kotlin specific changes needed to use Panache in your Kotlin-based Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMはデファクトスタンダードなJPA実装であり、Javaエコシステムではよく知られています。Panacheはこのお馴染みのフレームワークの上に新しいレイヤーを提供します。これらの詳細については link:hibernate-orm-panache[Panacheのガイド] ですでに説明しているので、このガイドでは触れません。このガイドでは、KotlinベースのQuarkusアプリケーションでPanacheを使用するために必要なKotlin固有の変更点について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can build stream processing applications using Quarkus and the Kafka Streams APIs, both in JVM and native modes.  For running your KStreams application in production, you could also add health checks and metrics for the data pipeline.  Refer to the Quarkus guides on link:micrometer[Micrometer], link:microprofile-metrics[MicroProfile Metrics], and link:microprofile-health[health checks] to learn more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusとKafka Streams APIを使用して、JVMとネイティブモードの両方でストリーム処理アプリケーションを構築する方法を紹介しました。KStreamsアプリケーションを本番環境で実行するために、データパイプラインのヘルスチェックやメトリクスを追加することもできます。詳細については、 link:micrometer[Micrometer] 、 link:microprofile-metrics[MicroProfile Metrics] 、 link:microprofile-health[ヘルスチェック] に関するQuarkusのガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a gRPC service using the default gRPC API, create a class extending the default implementation base.  Then, override the methods defined in the service interface.  Finally, implement the service as a CDI bean using the `@Singleton` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの gRPC API を使用して gRPC サービスを実装するには、デフォルトの実装ベースを extend したクラスを作成します。次に、サービス・インターフェースで定義されたメソッドをオーバーライドします。最後に、 `@Singleton` アノテーションを使用して、CDI Beanとしてサービスを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a gRPC service using the Mutiny gRPC API, create a class extending the Mutiny implementation base.  Then, override the methods defined in the service interface.  These methods are using Mutiny types.  Finally, implement the service as a CDI bean using the `@Singleton` annotation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny gRPC API を使用して gRPC サービスを実装するには、Mutiny 実装ベースを extend したクラスを作成します。そして、サービスインタフェースで定義されているメソッドをオーバーライドします。これらのメソッドは、Mutiny型を使用しています。最後に、 `@Singleton` アノテーションを使用して CDI Bean としてサービスを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking service implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブロッキングサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/metrics` endpoint of your application you will have information about the connection pool status.  When using link:microprofile-metrics[SmallRye Metrics], connection pool metrics will be available under the `vendor` scope.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、アプリケーションの `/q/metrics` エンドポイントにアクセスすると、接続プールの状態に関する情報を得ることができます。 link:microprofile-metrics[SmallRye Metrics] を使用する場合、接続プールのメトリクスは `vendor` スコープの下で利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'org.kordamp.gradle.jandex' version '0.6.0'
}
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>plugins {
    id 'org.kordamp.gradle.jandex' version '0.6.0'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to define a Kubernetes/OpenShift service to points to your the docker image you created and pushed during build.  Take a look at {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/funqy-service.yaml[funqy-service.yaml]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のステップは、ビルド時に作成してプッシュしたdockerイメージを指すKubernetes/OpenShiftサービスを定義することです。クイックスタート/src/main/k8s/funqy-service.yaml[funqy-service.yaml]を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=funqy-google-cloud-functions \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello" \
    -Dextensions="resteasy,funqy-google-cloud-functions"
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=funqy-google-cloud-functions \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello" \
    -Dextensions="resteasy,funqy-google-cloud-functions"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first time you launch the `gcloud beta functions deploy`, you can have the following error message:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初めて `gcloud beta functions deploy` を起動すると、以下のようなエラーメッセージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tika</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/neo4j</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/neo4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/microprofile-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: security
title: Security
permalink: /security/
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: security
title: セキュリティー
permalink: /security/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのチームとコミュニティは、すべてのセキュリティーバグを非常に深刻に受け止めています。ポリシーとセキュリティー開示に関するQuarkusのガイドラインはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティー問題の報告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリストには誰でも投稿できます。このリストの購読者は、Quarkusコミュニティの信頼できる個人のみで、報告されたセキュリティー問題の解決を秘密を守って処理します。報告においては、問題を発見したことについてどのようにクレジットされたいか、またエンバーゴ処理を適用したい場合はその詳細を記載してください。現在、以下のディストリビューションのセキュリティー対応チームがこのリストに登録されており、あなたのレポートに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エコシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、多くのエクステンションと多くのライブラリ(Eclipse Vert.x、Hibernate、Apache Camelなど)からなるエコシステムであり、そのほとんどはQuarkusチームの直接の責任下にはありません。これらのライブラリに根ざしている可能性のあるセキュリティーバグを見つけた場合は、それらのライブラリに直接開示するか、Quarkusチームに開示することが出来(このプロセスに従ってください)、その場合、責任を持ってそれぞれのエクステンションまたはライブラリのメンテナに開示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロセスに従う理由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティーバグは機密性が高いため、通常のバグよりも開示プロセスに制約があります。我々は、適切な修正のための時間を与え、攻撃の時間枠を制限する、業界で認められたこれらのガイドラインに従っていただけることに感謝します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サポートされているバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティは、https://quarkus.io/get-started/ で公開されている最新の major.minor バージョンのセキュリティーバグを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We may fix the vulnerability to older versions depending on the severity of the issue and the age of the release, but we are only committing to the latest version released.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題の深刻度やリリースの経過時間によっては、古いバージョンへの脆弱性を修正する場合がありますが、コミットしているのは、リリースされた最新バージョンのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティー問題への対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you represent a Quarkus extension or a Quarkus platform, you are welcome to subscribe to the security at quarkus.io mailing list. Your subscription will only be approved if you can demonstrate that you will handle issues in confidence and properly credit reporters for discovering issues (e.g. experience with embargoe process).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのエクステンションやQuarkusのプラットフォームを代表している場合は、security at quarkus.ioのメーリングリストを購読することを歓迎します。あなたの購読は、あなたが問題を秘密を守って処理し、問題を発見した報告者を適切にクレジット出来ると証明できる場合にのみ承認されます(例:エンバーゴ処理の経験)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus tailors your application for GraalVM and HotSpot. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. We use a technique we call compile time boot. &lt;a href="/vision/container-first"&gt;Learn more.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはアプリケーションをGraalVMとHotSpot向けに最適化します。驚くべき高速起動と、信じられないほどの低RSSメモリ（ヒープサイズだけではありません！）により、Kubernetesなどのコンテナオーケストレーションプラットフォームでほぼ瞬時にスケールアップし、高密度のメモリ使用率を実現します。コンパイル時ブートと呼ばれる手法を使用します。&lt;a href="/vision/container-first"&gt;詳細&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code class="bash"&gt;$ ./my-native-java-rest-app
Quarkus started in 0.008s&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code class="bash"&gt;$ ./my-native-java-rest-app
Quarkus started in 0.008s&lt;/code&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Best of Breed Libraries and Standards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各分野最高のライブラリと標準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a cohesive, fun to use, full-stack framework by leveraging a growing list of over fifty best-of-breed libraries that you love and use. All wired on a standard backbone. &lt;a href="/vision/standards"&gt;Learn more about Quarkus Extensions&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは50を超えて拡大している各分野における最高のライブラリを活用することで、良くまとまった、使って楽しいフルスタックフレームワークを提供します。全て、標準のバックボーンに接続されています。&lt;a href="/vision/standards"&gt;Quarkusエクステンションについて詳細はこちらをご覧ください&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは&lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;でライセンスされるオープンソースプロジェクトです。何よりもまず、オープンなコミュニティであり、貢献、アイデア、ディスカッションに対してオープンであり、コントリビューターを歓迎します。Javaアプリケーションの将来を築く為に、協力していきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roadmap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロードマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about the community plans for the future. Here is &lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;our current roadmap&lt;/a&gt;. This is driven by the community, come and tell us what &lt;i&gt;your&lt;/i&gt; needs are.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将来に向けた、コミュニティの計画を読んでみて下さい。現在の&lt;a href="https://github.com/orgs/quarkusio/projects/5"&gt;我々のコミュニティロードマップ&lt;/a&gt;はこちらです。 Quarkusはコミュニティ駆動であり、&lt;i&gt;あなた&lt;/i&gt;のニーズが何であるか、教えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code and Issue Tracker</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードと課題管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code is hosted on &lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;. If you need to report a bug or request a new feature, look for a similar one on our &lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub issue tracker&lt;/a&gt;. If you don’t find any, &lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;create a new issue&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソースコードは&lt;a href="https://github.com/quarkusio/quarkus"&gt;GitHub&lt;/a&gt;にホストされています。バグを報告したり、新機能を要望する必要がある場合は、&lt;a href="https://github.com/quarkusio/quarkus/issues"&gt;GitHub 課題管理&lt;/a&gt;で似た課題がないか探してみてください。見つからなかった場合は、&lt;a href="https://github.com/quarkusio/quarkus/issues/new/choose"&gt;新しい課題を作成して下さい&lt;/a&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write QuickStart Guides</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クイックスタートガイドの執筆</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are always new users trying to get started quickly. Share your experience with everyone by writing a Quickstart and submitting it for peer review.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すぐ入門したい新しいユーザーは常に存在します。 クイックスタートを執筆し、ピアレビューに送信して、あなたの経験を皆に共有して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write New Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are an extension developer or want to contribute to Quarkus development, join our mailing list either &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;emailing us&lt;/a&gt; or by visiting our &lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groups page&lt;/a&gt;. Make sure you visit our extensive &lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;Writing extensions guide&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの開発者か、Quarkusの開発に貢献したい場合、&lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;emailする&lt;/a&gt;か、&lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groupsページ&lt;/a&gt;にアクセスしてメーリングリストに参加して下さい。 是非、充実した &lt;a href="{{site.baseurl}}/guides/writing-extensions"&gt;エクステンション作成ガイド&lt;/a&gt;にアクセスして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A periodical video podcast hosted by Quarkus Developers about things moving in and around Quarkus ecosystem. View the &lt;a href="{{site.baseurl}}/insights"&gt;live podcasts&lt;/a&gt; and check out older episodes on the Podcasts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエコシステム内および周辺に関する、Quarkus開発者によってホストされる定期的なビデオポッドキャストです。 &lt;a href="{{site.baseurl}}/insights"&gt;ライブポッドキャスト&lt;/a&gt; を視聴し、過去のエピソードをチェックしてみて下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of our updates go out on &lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt;. Sometimes our project team speaks at industry events, and sometimes they post cool ways people use Quarkus. Wash, rinse, and retweet.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我々のアップデートの多くは &lt;a href="https://twitter.com/quarkusio"&gt;Twitter&lt;/a&gt; で公開されています。 プロジェクトチームが業界のイベントで公園することもあれば、Quarkusのクールなユースケースを投稿することもあります。どんどんリツイートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q Tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Q Tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community publishes thoughtful how-to videos to help you get started. Check them out on &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus コミュニティは入門をお手伝いする為に親切なハウツー・ビデオを公開しています。&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;YouTube&lt;/a&gt; でチェックしてみて下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are heaps of helpful &lt;a href="{{site.baseurl}}/publications"&gt;articles and blog posts&lt;/a&gt; out there presenting interesting use-cases and examples of Quarkus in action.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの興味深いユースケースと実践例を示す、役立つ&lt;a href="{{site.baseurl}}/publications"&gt;記事やブログ投稿&lt;/a&gt;が沢山存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Awards</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Awards</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Share in our excitement when the project receives &lt;a href="{{site.baseurl}}/awards"&gt;awards and recognition&lt;/a&gt; for all of the hard work done by the community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティによって行われた全てのハードワークに対して&lt;a href="{{site.baseurl}}/awards"&gt;賞と表彰&lt;/a&gt;を受けた時、興奮を分かち合いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Report a Vulnerability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>脆弱性報告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Found a security vulnerability in Quarkus, its extensions or the dependencies they use? See the &lt;a href="{{site.baseurl}}/security"&gt;security policy page&lt;/a&gt; to learn to report it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus、あるいはそのエクステンション、依存関係にセキュリティ脆弱性を見つけましたか？報告方法について、&lt;a href="{{site.baseurl}}/security"&gt;セキュリティポリシーページ&lt;/a&gt;を確認下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Books</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get new and deeper views into Quarkus from the community through &lt;a href="{{site.baseurl}}/books"&gt;these great books&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/books"&gt;これらの素晴らしい本&lt;/a&gt;を通じてコミュニティからQuarkusについて新しく、深い洞察を得てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Need More Than Community Support?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティサポート以上のサポートが必要ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you require a higher level of support, you have options.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティ以上のサポートが必要な場合の選択肢があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Red Hat Build of Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Red Hat Build of Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enterprise support provided by Red Hat for the product.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Red Hatから製品に対するエンタープライズレベルのサポートが提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://www.redhat.com/en/topics/cloud-native-apps/why-choose-red-hat-quarkus" class="button-cta btn-sm"&gt;Red Hat Support&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://www.redhat.com/en/topics/cloud-native-apps/why-choose-red-hat-quarkus" class="button-cta btn-sm"&gt;Red Hat Support&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;an IDE&lt;/a&gt; like &lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;, &lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt; or even &lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt; or &lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://www.jetbrains.com/idea/download/"&gt;IntelliJ IDEA&lt;/a&gt;、&lt;a href="https://www.eclipse.org/downloads/"&gt;Eclipse&lt;/a&gt;、&lt;a href="https://code.visualstudio.com/Download"&gt;VSCode&lt;/a&gt;もしくは&lt;a href="https://spacevim.org/use-vim-as-a-java-ide/"&gt;Vim&lt;/a&gt;や&lt;a href="http://spacemacs.org"&gt;Emacs&lt;/a&gt;のような&lt;a href="https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java" target="_blank"&gt;IDE&lt;/a&gt;が必要です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a &lt;a href="https://adoptopenjdk.net" target="_blank"&gt;a JDK {{ site.data.versions.jdk }}&lt;/a&gt; (any distribution)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://adoptopenjdk.net" target="_blank"&gt;JDK {{ site.data.versions.jdk }}&lt;/a&gt; (ディストリビューションは問いません) が必要です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally get &lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.versions.graalvm }} for native compilation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オプションとして、ネイティブコンパイルには&lt;a href="https://www.graalvm.org/" target="_blank"&gt;GraalVM&lt;/a&gt; {{ site.data.versions.graalvm }} が必要です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need &lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://maven.apache.org/" target="_blank"&gt;Apache Maven {{ site.data.versions.maven }}&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://code.quarkus.io"&gt;Start Coding&lt;/a&gt; with Quarkus {{ site.data.versions.quarkus.version }} [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;announce&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;changelog&lt;/a&gt;]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus {{ site.data.versions.quarkus.version }} で &lt;a href="https://code.quarkus.io"&gt;コーディングを開始&lt;/a&gt; [&lt;a href="{{ site.data.versions.quarkus.announce }}"&gt;announce&lt;/a&gt;|&lt;a href="https://github.com/quarkusio/quarkus/releases/tag/{{ site.data.versions.quarkus.version }}"&gt;changelog&lt;/a&gt;]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Session Abstracts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セッション概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Welcome to the Quarkus World Tour.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus ワールドツアーへようこそ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS 2.0 IS HERE!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus 2.0 登場!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 continues the mission of making Java the preferred framework for Kubernetes-native development with new developer tools and improved performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0は、新しい開発者ツールと改善されたパフォーマンスにより、JavaをKubernetesネイティブ開発に適したフレームワークにするという使命を継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#" class="scroll-down" address="true"&gt;&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="#" class="scroll-down" address="true"&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各分野における最高の Java ライブラリと標準を元に、 OpenJDK HotSpot と GraalVM に最適化された Kubernetes ネイティブ Java スタック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/worldtour/"&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="{{site.baseurl}}/worldtour/"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus World Tour</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus World Tour</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Available</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Now Available</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus {{ site.data.versions.quarkus.version | replace: ".Final", "" }}</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus {{ site.data.versions.quarkus.version | replace: ".Final", "" }}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feedback and Help</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィードバックとヘルプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For usage questions, we recommend to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用方法については、以下でお問い合わせ頂くことをお勧めします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow (&lt;code&gt;quarkus&lt;/code&gt;タグ)で質問&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#users&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt;によるチャット (&lt;code&gt;#users&lt;/code&gt; stream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For questions related to the development of Quarkus:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの開発に関する質問は、以下をご利用下さい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://groups.google.com/d/forum/quarkus-dev" target="_blank"&gt;quarkus-dev Google Groups&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chat using &lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt; (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="https://quarkusio.zulipchat.com" target="_blank"&gt;Zulip&lt;/a&gt;によるチャット (&lt;code&gt;#dev&lt;/code&gt; stream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your help is more than welcome! Don’t hesitate to join the crowd.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>あなたの参加は大歓迎です！躊躇わずに参加して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out our &lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt; for details on reporting issues and the process for submitting pull requests.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題の報告とPull Requestの送信プロセスの詳細については、&lt;a href="https://github.com/quarkusio/quarkus" target="_blank"&gt;GitHub&lt;/a&gt;をご覧下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every contribution is valuable. It can be a bug report, an example application, a feature request, a fix in the documentation or just feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バグレポート、サンプルアプリケーション、フィーチャーリクエスト、ドキュメントの修正、フィードバック、全ての貢献が有益です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発者満足度に最適化された凝集度の高いプラットフォーム:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero config, live reload in the blink of an eye</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ゼロコンフィグ、瞬く間のライブ・リロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Streamlined code for the 80% common usages, flexible for the 20%</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>80%の一般的な使用法の為に合理化されたコード、20%の為の柔軟性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No hassle native executable generation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>容易なネイティブ実行可能ファイル生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code class="bash"&gt;$ mvn package -Pnative

  # Or

$ gradle build -Dquarkus.package.type=native&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;code class="bash"&gt;$ mvn package -Pnative

  # Or

$ gradle build -Dquarkus.package.type=native&lt;/code&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/vision/developer-joy"&gt;Learn more&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;a href="/vision/developer-joy"&gt;詳細&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Help from the Community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティからのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation. Be sure to check our &lt;a href="{{site.baseurl}}/get-started/"&gt;Getting started page&lt;/a&gt;, and all our &lt;a href="{{site.baseurl}}/guides/"&gt;guides&lt;/a&gt;. Also check out our &lt;a href="{{site.baseurl}}/faq/"&gt;FAQ section&lt;/a&gt; and &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>沢山のドキュメントが存在します。 &lt;a href="{{site.baseurl}}/get-started/"&gt;「はじめに」のページ&lt;/a&gt;と&lt;a href="{{site.baseurl}}/guides/"&gt;ガイド&lt;/a&gt;を全て確認してみてください。また、&lt;a href="{{site.baseurl}}/faq/"&gt;FAQセクション&lt;/a&gt;と&lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tipsプレイリスト&lt;/a&gt;も確認してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask your questions on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;. After the documentation, it’s probably the best place to look for answers. We actively monitor the &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus tag&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow&lt;/a&gt;で質問して下さい。ドキュメントを確認した後、答えを探すのに恐らく最適の場所です。 私達はアクティブに&lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Quarkus tag&lt;/a&gt;をチェックしています。&lt;/p&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Live Chat</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライブチャット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer live chat with the developers, we have a &lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip chat&lt;/a&gt; where we all hang out.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発者とのライブチャットを希望する場合は、&lt;a href="https://quarkusio.zulipchat.com/"&gt;Zulip chat&lt;/a&gt;に居ますのでご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mailing List</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発メーリングリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also have a dedicated mailing list to discuss the development of Quarkus. Join the group via &lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;email&lt;/a&gt; or by visiting the &lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;quarkus-dev Google Groups page&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの開発の議論専用のメーリングリストもあります。&lt;a href="mailto:quarkus-dev+subscribe@googlegroups.com"&gt;email&lt;/a&gt;するか、&lt;a href="https://groups.google.com/d/forum/quarkus-dev"&gt;Google Groupsページ&lt;/a&gt;にアクセスしてグループに参加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初めてのQuarkusアプリケーションを作成する方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初めてのアプリケーションを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusを使用したリアクティブアプリケーションの開発については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMやMandrelを使ってネイティブの実行可能ファイルをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの開発を非常に高速で楽しいものにするQuarkus開発者ツールチェーンをご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>core</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>core</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードの中でハードコードされた値を使用することはできません (たとえ誰もがどこかの時点でそうしていたとしても ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusアプリケーションを設定する為の詳細について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションごとのすべての設定プロパティのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての設定プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、アプリケーションの停止時や起動時に通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの初期化と終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのDIソリューションは、 [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec )仕様に基づいています。このガイドでは、CDIの基本を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDIのQuarkus実装についてさらに詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>arc</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、以下の内容をカバーしています：
* JVM モードでのテスト 
* ネイティブモードでのテスト 
* テストへのリソースの注入
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロギングの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリファレンスガイドでは、Quarkusを使用してコマンドラインアプリケーションを開発する方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドモードリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native images to support SSL, as native images don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、ネイティブイメージがそのままではSSLをサポートしていないため、ネイティブイメージをSSLに対応させる方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージでのSSLの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with our implementation of MicroProfile Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Context Propagation の実装を使ってコンテキスト情報を渡す方法の詳細については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテキストの伝搬</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは、アプリケーションをネイティブ実行可能ファイルにコンパイルする際に遭遇する問題を解決するためのヒントをまとめたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ウェブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JSON は現在、マイクロサービス間の共通言語となっています。このガイドでは、REST サービスが JSON ペイロードを消費して生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable reactive REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSとRESTEasyReactiveを使用して拡張性の高いリアクティブRESTサービスを開発する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Highly Scalable Reactive REST Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高度にスケーラブルなリアクティブRESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM REST Data with Panacheは、JAX-RSとHibernate ORMをベースにしたCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シンプルなREST CRUDサービスの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、RESTサービスでHibernate Validator/Bean Validationを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、MicroProfile REST Clientを使ってREST API(JSONなど)とほとんど手間をかけずにやりとりする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTクライアントを使う（JSONを含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、MicroProfile REST クライアントを使用してマルチパート REST リクエストを送信する方法、典型的にはドキュメントをアップロードする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マルチパートでのRESTクライアントの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize MicroProfile JWT RBAC to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、アプリケーションがMicroProfile JWT RBACを利用してJAX-RSエンドポイントへのセキュアなアクセスを提供する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがWeb Socketを利用してインタラクティブなウェブアプリケーションを作成する方法を説明します。定型的なWeb Socketアプリケーションなので、簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、OpenAPI エクステンションを使用して OpenAPI ディスクリプタを生成し、Swagger UI フロントエンドを取得して REST エンドポイントをテストする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのVert.xベースのHTTPレイヤーの設定についての詳細と、サーブレットを使用している場合のUndertowについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Fault Toleranceエクステンションを使用してMicroProfile Fault Tolerance仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールトトレランスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、リアクティブルートの使用方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage Eclipse MicroProfile GraphQL to consume and implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Eclipse MicroProfile GraphQL を活用して GraphQL サービスを利用したり、実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusを使用すると、データソースを簡単に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データソースの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの完全な息吹を提供します。Quarkusでは見事に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。
複雑なマッピングを可能にしますが、単純で一般的なマッピングをつまらなくするものではありません。
Panacheは、エンティティを些細なことではなく、書いていて楽しいものにすることに焦点を当てています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>KotlinプロジェクトでHibernate ORMをPanacheで使う場合に固有の事情について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Searchは、Elasticsearchクラスタ内のエンティティをインデックス化し、Hibernate ORMベースのすべてのアプリケーションで簡単に全文検索を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusにはTransaction Managerが付属しており、これを使用してアプリケーションにトランザクションを調整して公開します。
永続性を扱う各エクステンションは、これと統合されます。
そして、CDIを介して明示的にトランザクションと対話することになります。
このガイドでは、これらすべてについて説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トランザクションの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Blaze-Persistenceを使用してデータとDTOレイヤーを簡素化する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、シンプルなアノテーションを使用してCDI Beanの高価なメソッド呼び出しをキャッシュする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションデータのキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Flyway エクステンションを使用してスキーマのマイグレーションを管理する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、スキーマのマイグレーションを管理するための Liquibase エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients for MySQL and PostgreSQL in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusのMySQLおよびPostgreSQL用のReactive SQLクライアントの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ SQL クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、低レベルまたは高レベルのRESTクライアントを使用してElasticsearchクラスタを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでMongoDBを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、アクティブなレコードやリポジトリを使ったMongoDBの使い方について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでRedisデータストアを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでNeo4jグラフデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでApache Cassandra NoSQLデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでAmazon DynamoDBデータベースを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでのAmazon S3クラウドストレージの使い方を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-s3</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-s3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、ソフトウェア・トランザクション・メモリ(STM)の使用法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソフトウェア・トランザクション・メモリの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>messaging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブメッセージングでのAMQPの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、イベントバスを使用して異なるBeanがどのように相互作用するかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションが、Apache Qpid JMSを使用してAMQP 1.0でJMSメッセージングを使用する方法、またはApache ActiveMQ Artemis JMSを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは、Quarkusのすべてのセキュリティに関するエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>セキュリティの概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションが.propertiesファイルを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>.propertiesファイルでセキュリティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してHibernate ORMを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jpa</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがLDAPディレクトリを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Keycloak to protect your JAX-RS applications using bearer token authorization, where these tokens are issued by a Keycloak server.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloakを使用して、ベアラートークン認証を使用してJAX-RSアプリケーションを保護する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sso</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>sso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect Extension to protect your web application based on the Authorization Code Flow using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusを使用してAuthorization Code Flowに基づいてWebアプリケーションを保護するためにOpenID Connect Extensionを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、単一のアプリケーションから複数のテナントにサービスを提供できるように、OpenID Connectアプリケーションがマルチテナントをサポートする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloak認可サービスを使用して保護されたリソースへのアクセスを認可する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、OpenID ConnectとOAuth2クライアント、フィルタを使用してアクセストークンを取得、更新、伝播する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、HashiCorp Vaultを使用してQuarkusにクレデンシャルを安全に保存する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、HashiCorp Vaultを「サービスとしての暗号化」に利用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヴォールトトランジットシークレットエンジンの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-transit</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vault-transit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データベースの資格情報をVaultに保存して、機密を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-datasource</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vault-datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusがサポートする、Vaultへの認証を行うためのさまざまな方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-auth</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/vault-auth</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Vault の資格情報プロバイダを使用する方法、または独自のカスタムのものを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>business-automation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>business-automation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビジネスオートメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、OptaPlannerの制約解決人工知能（AI）を使用してQuarkusアプリケーションを作成するプロセスを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Apache Camel でのシステム統合について説明します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command-line</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>command-line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Picocli エクステンションでコマンドラインアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbangを使った簡単なQuarkusベースのスクリプティング方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbangの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのビルドの一部として、Jib、S2I、またはDockerを使用してコンテナイメージをビルドしてプッシュする方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルドコンテナイメージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Kubernetes上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、OpenShift上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ConfigMapsをQuarkusアプリケーションの設定ソースとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Fabric8 Kubernetes クライアントを使用して Kubernetes クラスタと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションをMicrosoft Azure Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAzure Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusベースのAmazon Lambdasをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAmazon Lambdaとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションをGoogle Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusベースのGoogle Cloud Functionsを導入する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをGoogle Cloud Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Funqyフレームワークの基本、シンプルなポータブルクロスプロバイダーCloud Function APIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、FunqyのHTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>FunqyのAmazon Lambdaバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>FunqyのAmazon Lambda HTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、FunqyのKnative Eventsバインディングについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、FunqyのAzure Functions HTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>FunqyのGoogle Cloud Platform Functionsバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>FunqyのGoogle Cloud Platform FunctionsのHTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでのAmazon Key Management Serviceの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-kms</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-kms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでのAmazon Identity and Access Managementの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-iam</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-iam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでAmazon Simple Mail Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-ses</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-ses</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでAmazon Simple Notification Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sns</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-sns</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでAmazon Simple Queue Serviceを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>observability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ヘルスチェックの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションがMicrometerエクステンションを使用してメトリクスを収集する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Sentry を使ってアプリケーションを監視し、例外が発生したときに通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging-sentry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/logging-sentry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Graylog Extended Log Format (GELF) を使用して Logstash または Fluentd でログを集中管理する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>serialization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シリアル化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションにgRPCサービスを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCサービスを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>gRPCサービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、以下の内容について説明します。
* Maven の設定 
* 新しいプロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドは以下の内容をカバーしています。
* Gradle の設定 
* 新規プロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションのテストカバレッジを測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストカバレッジの測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>compatibility</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インジェクションにはCDIアノテーションを使用することが推奨されていますが、Quarkusはspring-diエクステンションの形でSpring依存性インジェクション用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTエンドポイントの定義にはJAX-RSアノテーションを使用することが推奨されていますが、QuarkusはSpring-webエクステンションという形でSpring Webとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>データレイヤーにはHibernate ORM with Panacheを使用することが推奨されていますが、Quarkusはspring-data-jpaエクステンションの形でSpring Data JPAの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Data RESTは、当社のSpring Data互換性レイヤをベースにCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのセキュリティレイヤーを使用してアプリケーションを保護することが推奨されていますが、Quarkusはspring-securityのエクステンションの形でSpring Securityとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションレベルのキャッシングにはCacheエクステンションを使用することが推奨されていますが、QuarkusはSpring Cacheエクステンションの形でSpring Cacheの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SchedulerやQuartzのエクステンションを使ってタスクをスケジュールすることが推奨されていますが、QuarkusはSpring-scheduledエクステンションの形でSpring Scheduledとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile Config アノテーションの代わりに Spring Boot の `@ConfigurationProperties`  を使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、Spring-cloud-config-clientエクステンションの形でSpring Cloud Config用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>miscellaneous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>miscellaneous</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクをスケジュールする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>定期的なタスクのスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラーエクステンションの詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジューラリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スケジュールされたタスクにクラスタリングのサポートが必要ですか？このガイドでは、そのための Quartz エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブメールクライアントを使用してQuarkusアプリケーションからメールを送信する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メールの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quteのテンプレートエンジンを使ったアプリケーションでのテンプレートの使用方法については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quteのテンプレートエンジンについて知りたい方は、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Tika ツールキットを使ってドキュメントからコンテンツを抽出する方法についての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、QuarkusでVert.xを使用してリアクティブアプリケーションを構築する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、JGitを使ってGitリポジトリにアクセスする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jgit</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/jgit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションが実行時にConsulから設定プロパティを読み取る方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/consul-config</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/consul-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Quarkusアプリケーションのフットプリントを最適に測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パフォーマンスの測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>alternative-languages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>alternative-languages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>代替言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このガイドでは、Kotlinの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>writing-extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単なエクステンションを構築する方法をステップバイステップで学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>初めてのエクステンションのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをQuarkusのCDIコンテナに統合する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションを Dev UI に機能貢献させる方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションで消費/生産できるすべての BuildItems を調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのビルドアイテム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのエクステンションは、可能な限り多くの作業をビルド処理にプッシュすることで、アプリケーションを最適化します。このガイドでは、Quarkusエクステンションの根拠を説明し、独自のエクステンションを作成する方法を説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>独自のエクステンションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusクラスのローディングインフラストラクチャについてはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスローディングリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの世界でプラットフォームと呼ばれているものについては、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プラットフォームのコンセプトを理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus integrations in IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IDEのQuarkus統合についてはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Tools in your favorite IDE</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お好みのIDEのQuarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/ide-tooling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/guides/ide-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous Testing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>継続的テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye OpenAPI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye OpenAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today we're proud to announce link:https://github.com/quarkiverse[Quarkiverse Hub], a GitHub organization where any contributor can host their Quarkus extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今日は、コントリビューターが誰でもQuarkusのエクステンションをホストできるGitHub Organizationである https://github.com/quarkiverse[Quarkiverse Hub]を発表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hosting your extension in the Quarkiverse Hub makes it available to all Quarkus users through the Quarkus tooling.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションをQuarkiverse Hubでホスティングすると、Quarkusツールを介してすべてのQuarkusユーザーが利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So read on to discover more and find out how you can make your extension available to all Quarkus developers today!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細をお読みになり、すべてのQuarkus開発者が今すぐエクステンションを利用できるようにする方法をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering and publishing artifacts to Maven central can become a daunting task. In Quarkiverse that is automated by GitHub Actions, requiring no manual interaction with any command line tools.  Releasing an artifact is as simple as opening a pull-request changing the https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[`.github/project.yml`] file in the extension's repository.  Once the pull-request is merged, a GitHub action is triggered invoking `mvn release:prepare release:perform` and the extension is deployed to Maven central.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven centralに成果物を登録して公開するのは、大変な作業になることがあります。Quarkiverseでは、GitHub Actionsによって自動化されており、コマンドラインツールを使って手動で操作する必要はありません。アーティファクトのリリースは、プルリクエストを開いて  https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[.github/project.yml]ファイルを作成します。プルリクエストがマージされると、GitHub アクションがトリガーされて `mvn release:prepare release:perform` が呼び出され、エクステンションが Maven セントラルにデプロイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Core releases happen constantly and keeping up with the latest changes before a release is performed is crucial. Quarkiverse extensions are built daily against the latest https://github.com/quarkusio/quarkus[Quarkus core] using the https://github.com/quarkusio/quarkus-ecosystem-ci[Quarkus Ecosystem CI] and listed in the https://status.quarkus.io/[Quarkus Status] page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusコアのリリースは常に行われており、リリースを実行する前に最新の変更点を把握しておくことは非常に重要です。Quarkiverseのエクステンションは、Quark https://github.com/quarkusio/quarkus-ecosystem-ci[us Ecosystem CI]を使用して最新の https://github.com/quarkusio/quarkus[Quarkusコア]に対して毎日ビルドされ、Quark https://status.quarkus.io/[usのステータス]ページに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consistent formatting and release of projects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトの一貫したフォーマットとリリース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkiverse-parent` artifact (inherited by each extension in Quarkiverse) enables plugins that will format your source code to the same format used in Quarkus core.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkiverse-parent` アーティファクト(Quarkiverseの各エクステンションに継承されています)は、プラグインがソースコードをQuarkusコアで使用されているのと同じフォーマットにフォーマットすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation aggregation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントの集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get your versioned extension documentation automatically published (including guides)! Quarkiverse Hub uses https://antora.org[Antora] to aggregate each extension documentation in the Quarkiverse docs website.  Although the layout is still a work in progress, you can check it out at https://quarkiverse.github.io/quarkiverse-docs/</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>バージョン管理されたエクステンションドキュメント(ガイドを含む)を自動的に公開しましょう!Quarkiverse Hubでは、 https://antora.org[Antora]を使用して、Quarkiverse docsのウェブサイト内の各エクステンションドキュメントを集約しています。レイアウトはまだ作業中ですが、 https://quarkiverse.github.io/quarkiverse-docs/ で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automated inclusion in the upcoming Extension registry</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今後のエクステンションレジストリーへの自動インクルード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Extension registry is still a work in progress (https://registry.quarkus.io), but the gist of it is to have a single place to browse for extensions (including https://code.quarkus.io, command line and IDE plugins).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Extension レジストリーはまだ作業中ですが( https://registry.quarkus.io )、その要旨は、エクステンション ( https://code.quarkus.io 、コマンドライン、IDE プラグインを含む) を単一の場所で閲覧できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requirements</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to automate extension releases and publication of docs, there are some rules that need to be followed for projects under the Quarkiverse organization:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのリリースやドキュメントの公開を自動化するために、Quarkiverseの組織の下にあるプロジェクトでは、いくつかのルールに従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension repository should be named `quarkiverse-&lt;project&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのリポジトリの名前は `quarkiverse-&lt;project&amp;amp&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkiverse extension MUST belong to the `io.quarkiverse.&lt;project&gt;` groupId</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkiverseのエクステンションは、 `io.quarkiverse.&lt;project&gt;` groupIdに属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The root pom.xml MUST inherit from `io.quarkiverse:quarkiverse-parent`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルート pom.xml は `io.quarkiverse:quarkiverse-parent` を継承しなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *deployment*, *runtime* and *integration-test* directories containing the extension classes. See link:https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[How to create new extension modules using Maven] for more details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*デプロイメント* 、 *ランタイム* 、および *統合テスト* のディレクトリーがエクステンションクラスを含みます。詳細は「 https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[Mavenを使って新しいエクステンションを作成する方法]」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*docs* (optional): The docs should follow the link:https://docs.antora.org/antora/2.3/standard-directories/[Antora's Standard File and Directory Set]. See an example link:https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[here].
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*docs* (オプション)。docsは https://docs.antora.org/antora/2.3/standard-directories/[Antoraの標準ファイルとディレクトリーセット]に従ってください。サンプルは https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[ここ] を参照して下さい。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, look at the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I sign-up?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どうやったら申し込めますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an *Extension Proposal* ticket in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] (first check if the extension you're proposing is not created yet) and let us know if you want to lead the development of this extension by commenting on the issue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/issues[Quarkusの課題管理]で *エクステンション提案の* チケットを作成し(まず、提案しているエクステンションがまだ作成されていないかどうかを確認してください)、このエクステンションの開発をリードしたい場合は、イシューにコメントをつけてお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team will get you started with the boring stuff of setting up a brand new repository and deployment scripts, so you'll have fun coding it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusチームは、ブランドの新しいリポジトリやデプロイメントスクリプトを設定するという退屈な作業すませるので、あなたは楽しくコーディングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, we're always improving, so take a look at link:https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse] for the process we are currently using.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他と同様に、我々は常に改善していますので、現在使用しているプロセスについては、 https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What extensions are in Quarkiverse already?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すでにQuarkiverseにはどのようなエクステンションがあるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;amp;type=Repositories[すでにあるエクステンション]をチェックしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stay tuned for the latest info about Quarkiverse in the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]では、Quarkiverseの最新情報をご確認いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I reuse this setup for an extension outside the Quarkiverse organization?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この設定をQuarkiverseの組織外のエクステンションに再利用することはできますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, right now we're in the process of documenting the extra steps to make your extension releases visible to our tooling in this case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、現在、外部のエクステンションのリリースを我々のツールから見えるようにするための追加のステップを文書化しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full changelog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Come Join Us</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>参加のお誘い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We value your feedback a lot so please report bugs, ask for improvements... Let's build something great together!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私達は皆様からのフィードバックに重きを置いています。バグ報告、改善要望を是非お願いします。一緒に素晴らしいものを作り上げていきましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Quarkus user or just curious, don't be shy and join our welcoming community:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusユーザーの場合でも、単に興味を持っているだけの場合でも、恥ずかしがらずにコミュニティに参加して下さい!:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>provide feedback on https://github.com/quarkusio/quarkus/issues[GitHub];</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/issues[GitHub] でフィードバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>craft some code and https://github.com/quarkusio/quarkus/pulls[push a PR];</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードを作成し、 https://github.com/quarkusio/quarkus/pulls[プルリクエスト] を送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>discuss with us on https://quarkusio.zulipchat.com/[Zulip] and on the https://groups.google.com/d/forum/quarkus-dev[mailing list];</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://quarkusio.zulipchat.com/[Zulip] や https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] でディスカッションに参加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ask your questions on https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow] で質問</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We just released 1.13.4.Final, a new maintenance release for the 1.13 release train.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13リリーストレインの新しいメンテナンスリリースである1.13.4.Finalをリリースしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.4.Final is a safe upgrade for everyone using Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.4.Finalは、Quarkus 1.13を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.13 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.13[1.13 migration guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだ1.13を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.13[1.13移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's new?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.4.Final[the full changelog of 1.13.4.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.4.Final[1.13.4.Finalの完全な変更履歴はGitHub] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.3.Final released - Bugfixes'
date: 2020-12-08
tags: release
synopsis: 1.10.3.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.10.3.Finalリリース - バグフィックス
date: 2020-12-08
tags: release
synopsis: 1.10.3.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.3.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.10.3.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it really helped a lot!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題を報告し、再現手順を提供してくれたすべてのコントリビューターに感謝します。非常に助かりました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.10.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.10を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.10 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10 migration guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだ1.10をお使いでない方は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10移行ガイド] をご参照ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリリースはメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[the full changelog of 1.10.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[GitHub上の1.10.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enjoy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>楽しんで!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.9.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Quarkus 1.9を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.9 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9 migration guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだ1.9を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コントリビューター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving Forward</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>将来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thank you for reading and stay tuned for the next release!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お読みいただきありがとうございました。次のリリースをお待ちください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Links</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リンク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: About to release Quarkus 2 - ask us anything!
date: 2021-05-27
tags: insights
synopsis: Next Wednesday (Jun 2.), we will do Quarkus Insights based on your questions.
author: maxandersen
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 2のリリース間近 - 何でも聞いてください! 
date: 2021-05-27
tags: insights
synopsis: 来週の水曜日（6月2日）には、皆さんからの質問をもとにQuarkus Insightsを行います。
author: maxandersen
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus 2 approaching its imminent release and we passed 50 episodes of Quarkus Insights we want to do Q&amp;A episode similar to what we did earlier in the year.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2のリリースが近づき、Quarkus Insightsのエピソードが50回を超えたので、今年の初めに行ったのと同じようなQ&amp;A エピソードを行いたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will cover the most often asked questions we have seen and any question tagged with `#quarkusinsights` on our various social media presences: https://twitter.com/search?q=%23quarkusinsights[Twitter], https://www.facebook.com/hashtag/quarkusinsights/[Facebook] or https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは、これまでによく見られた質問や、私たちの様々なソーシャルメディア link:https://twitter.com/search?q=%23quarkusinsights[Twitter]、 link:https://www.facebook.com/hashtag/quarkusinsights/[Facebook]、 https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] 上で `#quarkusinsights` とタグ付けされた質問を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a question about Quarkus you would like answered let us know on one of thoses sites using `quarkusinsights` as a tag.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusについて質問がある場合は、 `quarkusinsights` をタグとして使用して、いずれかのサイトで教えていただきたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have had an unusually bumpy ride the last few weeks. Path resolution can be sneakily complicated, and in trying to make things better, we accidentally made them worse! We've fixed it all now, but you might notice some changes. Hopefully, this post will make clear what those changes are, what they mean, and what you can do to put everything back the way you want it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここ数週間、私たちは通常になく揺れ動いていました。パスの解決はこっそりと複雑になることがあり、物事を良くしようとしているうちに、私たちは誤って悪化させてしまったのです!今はすべて修正しましたが、いくつかの変更点があることに気づくかもしれません。うまくいけば、この記事でその変更が何であるか、その意味、そしてあなたが望むようにすべてを元の状態に戻すために何ができるか明確になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**TL;DR:** As of `1.11.5.Final` and `1.12.1.Final`, leading slashes matter in config. So if you use `/endpoint`, that endpoint will be served from the absolute root. If you want it relative to some containing bucket, omit that leading slash. For example, `quarkus.http.non-application-root-path` is now `q` by default, which nests it under `quarkus.http.root-path`, matching the original behavior. You can use an absolute path, e.g. `/q`, to serve non-application endpoints from the absolute root (as a sibling of the http root, if that is set). To remove the non-application endpoint behavior entirely, set `quarkus.http.non-application-root-path` to the same value as `quarkus.http.root-path`. The most foolproof way to do this is using a variable: `quarkus.http.non-application-root-path=${quarkus.http.root-path}`.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**TL;DR:** `1.11.5.Final` と `1.12.1.Final` の時点では、設定における先頭のスラッシュは重要です。つまり、 `/endpoint` を使用した場合、そのエンドポイントは絶対ルートから提供されます。もし、包含するバケットからの相対的なものにしたいのであれば、先頭のスラッシュを省略してください。例えば、 `quarkus.http.non-application-root-path` はデフォルトでは `q` になり、 `quarkus.http.root-path` の下に入れ子になり、元の動作と一致します。アプリケーション以外のエンドポイントを絶対ルートから (設定されている場合は http ルートの兄弟として) 提供するために、例えば `/q` のような絶対パスを使うことができます。アプリケーション以外のエンドポイントの動作を完全に削除するには、 `quarkus.http.non-application-root-path` を `quarkus.http.root-path` と同じ値に設定します。これを行う最も簡単な方法は、変数を使用することです: `quarkus.http.non-application-root-path=${quarkus.http.root-path}`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The long story</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>長文での説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once upon a time, Quarkus defined additional endpoints for things like health checks and metrics. They were served from the `quarkus.http.root-path` alongside any endpoints the application defined. This isn't always obvious, as `quarkus.http.root-path` is `/` by default, making it effectively invisible.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>昔々、Quarkusでは、ヘルスチェックやメトリクスなどのエンドポイントを追加で定義していました。これらは、アプリケーションが定義したエンドポイントと一緒に `quarkus.http.root-path` から提供されていました。デフォルトでは `quarkus.http.root-path` は `/` であり、事実上見えないようになっているため、これは必ずしも明らかではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As these proliferated, we started worrying about link:https://groups.google.com/g/quarkus-dev/c/FMnmlDIcGRY[polluting the application endpoint namespace], and thinking about how we could group these non-application endpoints together to avoid colliding with application endpoints and make it easier to deal with security and access policies. Some users further asked if we could serve these non-application endpoints from link:https://github.com/quarkusio/quarkus/issues/13602[another port entirely] (we haven't gotten there yet).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 link:https://groups.google.com/g/quarkus-dev/c/FMnmlDIcGRY[アプリケーションエンドポイント]との衝突を避け、セキュリティやアクセスポリシーの処理を容易にするために、アプリケーション以外のエンドポイントをどのようにグループ化するかを考え始めました。さらに何人かのユーザからは、これらの非アプリケーションエンドポイントを link:https://github.com/quarkusio/quarkus/issues/13602[完全に別のポートから提供できないか]という意見もありました (まだ実現していません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step was to group all of these extension-defined endpoints together. This was the genesis of the link:https://github.com/quarkusio/quarkus/pull/13601[non-application endpoint path]. The default location of this new path was `/q`, and it was nested under the HTTP root path, just as the other endpoints had been. The effect was to move `/health` to `/q/health`, as an example.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初のステップは、これらのエクステンションで定義されたエンドポイントをすべて一緒にグループ化することでした。これが、 link:https://github.com/quarkusio/quarkus/pull/13601[非アプリケーションエンドポイントパス]の始まりでした。この新しいパスのデフォルトの場所は `/q` で、他のエンドポイントと同様に HTTP ルートパスの下に入れ子になっていました。この効果は、例えば `/health` を `/q/health` に移動させることでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We knew that moving some of these endpoints, like metrics and health, would be problematic for already deployed applications and human muscle memory. To ease the transition, we added redirects for some of these endpoints, so that if you visited `/metrics` you would be redirected to `/q/metrics`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは、メトリクスやヘルスなどのエンドポイントの一部を移動することは、すでに展開されているアプリケーションや人間の記憶にとって問題があることを知っていました。移行を容易にするために、これらのエンドポイントの一部にリダイレクトを追加し、 `/metrics` にアクセスした場合は `/q/metrics` にリダイレクトされるようにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-application endpoint support shipped in `1.11.0.Final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション以外のエンドポイントのサポートは `1.11.0.Final` で出荷されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then things started to link:https://github.com/quarkusio/quarkus/pull/14179[go] link:https://github.com/quarkusio/quarkus/issues/15030[sideways]. Some cloud hosting providers only accept `200` as a definition of health, for example, so the redirect (a `301`) didn't have the intended effect. There was also some confusion about how to turn the non-application endpoint off to return to previous behavior, and further questions about how to move specific endpoints out of this non-application endpoint collection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、事態は link:https://github.com/quarkusio/quarkus/issues/15030[悪化]  link:https://github.com/quarkusio/quarkus/pull/14179[し]始めました。クラウドホスティングプロバイダの中には、例えば、ヘルスの定義として `200` のみを受け入れるものがあり、リダイレクト ( `301`) は意図した効果を発揮しませんでした。また、アプリケーション以外のエンドポイントをオフにして以前の動作に戻す方法についても混乱があり、特定のエンドポイントをこのアプリケーション以外のエンドポイントコレクションから移動させる方法についても疑問が残りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an aside, how we got into this situation is not helped by differences in how libraries behave. Vert.x always wants segments beginning with leading slashes when creating routes, for example, while JAX-RS effectively ignores leading slashes in `@Path` annotations. Anyone used to Vert.x always adds leading slashes, and anyone using JAX-RS just does whatever and it magically works.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>余談ですが、どのようにしてこのような状況になったかというと、ライブラリの挙動の違いによるものではありません。Vert.x は、例えばルートを作成する際に、常に先頭のスラッシュで始まるセグメントを求めますが、JAX-RS は `@Path` のアノテーションでは先頭のスラッシュを事実上無視します。Vert.x に慣れている人は常に先頭のスラッシュを追加し、JAX-RS を使用している人は何をしても魔法のように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, an implementation detail was exposed by accident: non-application endpoints defined by extensions are based on Vert.x routes. Default path configuration values started with slashes to enable quick route creation and allow simple append behavior. There wasn't anything in the early days of Quarkus to suggest this was a bad idea, and developers with experience in JAX-RS didn't have any warnings one way or the other, because JAX-RS handles it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、実装の詳細が偶然にも露わになりました。エクステンションによって定義されたアプリケーション以外のエンドポイントは、Vert.xのルートをベースにしています。デフォルトのパス設定値はスラッシュで始まり、迅速なルート作成を可能にし、単純な追加動作を可能にします。Quarkusの初期の頃は、これが悪い考えであることを示唆するようなものは何もなく、JAX-RSの経験がある開発者は、JAX-RSが処理するので、どちらにしても警告を受けることはありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, however, we were in the situation where paths weren't being resolved as people expected, and the configuration changes required to resolve that situation either weren't intuitive or lead to other problems. We ended up putting all of the possible configuration permutations into a spreadsheet so we could see side by side what happened when you combined different configuration values. The results were not awesome. However, the exercise allowed us to step back and look at the big picture to evaluate what needed to change to allow application and non-application endpoints to behave as you need them to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、人々が期待していた通りにパスが解決されず、その状況を解決するために必要な設定の変更が直感的ではなかったり、別の問題を引き起こしたりする状況に陥りました。そこで私たちは、異なる設定値を組み合わせたときに何が起こるかを並べて見ることができるように、すべての可能な設定の組み合わせをスプレッドシートに入れてみました。結果はそれほど素晴らしいものではありませんでした。しかし、この演習により、アプリケーションと非アプリケーションのエンドポイントが必要な動作をするようにするために何を変更する必要があるかを評価するために、一歩下がって全体像を見ることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the set of configuration attributes used to configure paths in Quarkus remains unchanged, how configured values are interpreted is different:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでパスを設定するために使用される設定属性のセットは変更されませんが、設定された値がどのように解釈されるかは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Endpoint path configuration defaults are now relative values.** `/q` is now `q`, `/metrics` is now `metrics`, etc. This means that, out of the box, these endpoints will resolve relative to the containing root, which is what JAX-RS does per spec, and is what we believe most users intuitively expect.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**エンドポイントのパス設定のデフォルト値が相対値になりました。** `/q` は `q` に、 `/metrics` は `metrics` になりました。これは、設定変更なしで、これらのエンドポイントが含まれているルートに対して相対的に解決されることを意味します。これは、JAX-RSが仕様ごとに行うことであり、ほとんどのユーザーが直感的に期待していることです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Leading slashes in explicitly configured values matter.** We know some of you want to move endpoints to specific places, and the most consistent way to express that intent is to allow you to specify the exact uri you want an endpoint to use. If you specify `/metrics`, that is where you will find the metrics endpoint.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>**明示的に設定された値の先頭のスラッシュは重要です。** エンドポイントを特定の場所に移動させたいと考えている人がいることは承知しており、その意図を表現する最も一貫した方法は、エンドポイントに使用させたい URI を正確に指定できるようにすることです。 `/metrics` を指定すると、それがメトリクス・エンドポイントを見つける場所になります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These updates have been made available and the dust should all have settled with `1.11.5.Final` and `1.12.1.Final`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`1.11.5.Final` と `1.12.1.Final` でこれらのアップデートが利用可能になり、埃は全て解消するはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that convenience redirects for non-application endpoints are still present, but they can be disabled by setting `quarkus.http.redirect-to-non-application-root-path` to `false`. That hasn't changed at all.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション以外のエンドポイントのための便利なリダイレクトはまだ存在しますが、 `quarkus.http.redirect-to-non-application-root-path` を `false` に設定することで無効にすることができます。これは全く変わっていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resolution of configured paths</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定されたパスの解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go through some examples of how paths resolve using our new rules. We'll start with the following assumptions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいルールを使用してパスがどのように解決されるか、いくつかの例を見てみましょう。まず、以下の前提条件から始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a Hello World application that defines `@ApplicationPath("/hello")`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg> `@ApplicationPath("/hello")` という定義のあるHello World アプリケーションがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application specifies two endpoints using `@Path("world")` and `@Path("/aliens")`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションは、 `@Path("world")` と `@Path("/aliens")` のある2つのエンドポイントを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration attributes we care most about are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちが最も気にしている設定属性は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.root-path` - The HTTP root path. All web content is served relative to this root path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.root-path` - HTTP ルートパス。すべてのウェブコンテンツはこのルートパスからの相対パスで提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path` - The non-application endpoint root path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.non-application-root-path` - アプリケーション以外のエンドポイントのルートパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll also highlight some configurable non-application endpoints of interest:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、設定可能なアプリケーション以外のエンドポイントにも注目しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.micrometer.export.prometheus.path` - The location of the micrometer metrics endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.micrometer.export.prometheus.path` - Micrometerメトリクスのエンドポイントの場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.root-path` - The location of the all-encompassing health endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.smallrye-health.root-path` - すべてを網羅したヘルスエンドポイントの場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.liveness-path` - The location of the liveness endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.smallrye-health.liveness-path` - liveness エンドポイントの場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's look at what happens when we start pulling levers. In the examples below, pay attention to punctuation in config, as that will be the key to why things behave the way they do.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レバーを引き始めると何が起こるかを見てみましょう。以下の例では、config の句読点に注意を払ってください。句読点が、そのように動作する鍵となるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are the default configuration values:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトの設定値は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.root-path=/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.root-path=/`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path=q`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.non-application-root-path=q`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.micrometer.export.prometheus.path=metrics`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.micrometer.export.prometheus.path=metrics`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.root-path=health`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.smallrye-health.root-path=health`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.liveness-path=liveness`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.smallrye-health.liveness-path=liveness`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That configuration (combined with the declared application endpoints) leads to the following valid URLs if our Quarkus application is running in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（宣言されたアプリケーションエンドポイントと組み合わされた）この設定は、Quarkusアプリケーションがdevモードで実行されている場合、次のような有効なURLになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/world</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/hello/world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/aliens</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/hello/aliens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/q/metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/q/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/q/health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/q/health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/q/health/liveness</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/q/health/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `quarkus.http.root-path` is hiding in this example, because its value is `/`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この例では `quarkus.http.root-path` が隠れていることに注意してください。値が `/` だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are convenience redirects in this case as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. In this configuration, `/metrics` will be redirected to `/q/metrics`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合、 `quarkus.http.non-application-root-path` と `quarkus.http.root-path` は同じではないので、利便性の為のリダイレクトがあります。この設定では、 `/metrics` は `/q/metrics` にリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's change the HTTP root path to `/root` so the impact it has on resource resolution is visible:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP のルートパスを `/root` に変更して、リソース解決への影響が見えるようにしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.root-path=/root`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.root-path=/root`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This results in the following dev mode URLs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その結果、以下のようなdevモードのURLになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/hello</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/hello/world</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/hello/world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/hello/aliens</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/hello/aliens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/q/metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/q/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/q/health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/q/health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/q/health/liveness</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/q/health/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are convenience redirects in this case, too, as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. In this configuration, `/root/metrics` will be redirected to `/root/q/metrics`. This is consistent with previous behavior, where non-application endpoints were implicitly relative to the HTTP root path.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合も、 `quarkus.http.non-application-root-path` と `quarkus.http.root-path`.は同じではないので、便利なリダイレクトがあります。この設定では、 `/root/metrics` は `/root/q/metrics` にリダイレクトされます。これは、アプリケーション以外のエンドポイントが暗黙のうちに HTTP ルートパスから相対化されていた以前の動作と一致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the non-application root path (/q)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション以外のルートパスを移動 (/q)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try something we couldn't do before. We'll move the non-application endpoint outside of the HTTP root path by specifying an absolute path, `/q`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今までできなかったことをやってみましょう。絶対パス `/q` を指定して、アプリケーション以外のエンドポイントをHTTPルートパスの外側に移動させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path=/q`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.non-application-root-path=/q`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are still convenience redirects in this case, as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. Redirected URLs are still relative to HTTP root, so `/root/metrics` will be redirected to `/q/metrics`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この場合も、 `quarkus.http.non-application-root-path` と `quarkus.http.root-path` が同一ではない為、利便性の為のリダイレクトが存在します。リダイレクトされた URL はまだ HTTP ルートに対する相対的なものなので、 `/root/metrics` は `/q/metrics` にリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move individual non-application endpoints (/metrics and /liveness)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション以外のエンドポイントを個別に移動 (/metrics と /liveness)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is is another configuration that was not previously possible. We can individually move configurable non-application endpoints to a specified absolute path, specifically `/metrics` and `/liveness` in this example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、以前は不可能だったもう一つの設定です。設定可能なアプリケーション以外のエンドポイントを、指定された絶対パスに個別に移動させることができます。特にこの例では `/metrics` と `/liveness` に移動させることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.micrometer.export.prometheus.path=/metrics`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.micrometer.export.prometheus.path=/metrics`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.liveness-path=/liveness`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.smallrye-health.liveness-path=/liveness`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/liveness</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are still convenience redirects in this case, as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. However, these redirects only apply to non-application endpoints controlled by the non-application endpoint root. We've essentially removed the metrics and liveness endpoints from that root, so they won't be redirected. In this configuration, if you request `/root/health`, it will be redirected to `/q/health`. A redirect will not be provided for `/root/health/liveness` or `/root/metrics`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.non-application-root-path` は `quarkus.http.root-path` と同じではないので、この場合も利便性の為のリダイレクトがあります。しかし、これらのリダイレクトは、非アプリケーションエンドポイントのルートによって制御される非アプリケーションエンドポイントにのみ適用されます。私たちは、基本的にそのルートからメトリクスとlivenessのエンドポイントを削除しているので、リダイレクトされることはありません。この設定では、 `/root/health` をリクエストすると `/q/health` にリダイレクトされます。 `/root/health/liveness` や `/root/metrics` にはリダイレクトされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the non-application endpoint root</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非アプリケーションエンドポイントのルートの削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of you have asked how to turn this non-application endpoint root stuff off entirely. A clear expression of your intent is best. To disable the non-application endpoint, make it identical to the HTTP root path. In essence, you are telling the runtime to "serve all non-application endpoints from the HTTP root". This example uses a variable to ensure the values remain the same:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何人かの方から、このアプリケーション以外のエンドポイントルートのものを完全にオフにするにはどうすればよいかという質問を受けました。あなたの意図を明確に表現するのがベストです。非アプリケーションエンドポイントを無効にするには、HTTPルートパスと同じにしてください。要するに、ランタイムに「HTTPルートからすべての非アプリケーションエンドポイントを提供する」ように指示していることになります。この例では、値が同じであることを保証するために変数を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path=${quarkus.http.root-path}`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.http.non-application-root-path=${quarkus.http.root-path}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/metrics</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/health/liveness</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>http://localhost:8080/root/health/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no convenience redirects in this scenario, as the non-application endpoint behavior has been disabled entirely.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このシナリオでは、アプリケーション以外のエンドポイントの動作が完全に無効化されているため、利便性のためのリダイレクトはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Knock-on effects</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ノックオン効果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the most part, we hope this will be transparent. We discovered some very inconsistent path handling along the way, which lead us to believe that many (or even most) of these values are never customized.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ほとんどの部分では、これが透明であることを願っています。途中で非常に一貫性のないパス処理を発見し、これらの値の多く（あるいはほとんど）がカスタマイズされることはないと考えさせられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are most likely to see a behavior change if you have customized the HTTP root path. In that case, we hope the new rules and examples above will help you understand how to tweak your configuration to get everything to behave the way you want it to.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTP ルートパスをカスタマイズしている場合は、挙動の変化に気づく可能性が高いでしょう。その場合は、上記の新しいルールと例が、設定を微調整してすべてを思い通りに動作させる方法を理解するのに役立つことを願っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension writers will see the biggest change. The link:https://quarkus.io/guides/writing-extensions#extension-defined-endpoints[Writing extensions guide] has been updated to describe changes to the build items used to create non-application endpoints. The general rule, however, is to avoid constructing your own endpoint paths, and rely on `NonApplicationRootPathBuildItem` and `HttpRootPathBuildItem` to construct them for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション開発者は最も大きな変更点を目にすることになるでしょう。 link:https://quarkus.io/guides/writing-extensions#extension-defined-endpoints[エクステンション開発ガイド]が更新され、アプリケーション以外のエンドポイントを作成するために使用されるビルド項目の変更が記述されています。しかし、一般的なルールとしては、自分でエンドポイントパスを構築することは避け、 `NonApplicationRootPathBuildItem` と `HttpRootPathBuildItem` に頼って構築してもらうようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parting thoughts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おわりに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While we know it is impossible to make everyone happy, we hope we have at least managed to acheive a pattern for configuration that leads to more predictable and consistent results. And we apologize (again), for any behavior changes you may have observed as we sorted this out.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべての人を幸せにすることは不可能であることはわかっていますが、少なくとも、より予測可能で一貫性のある結果につながる設定のパターンを達成することができたことを願っています。また、この問題を解決した際に観察された挙動の変化については、（再度）お詫び申し上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.12.1.Final released - Bugfixes'
date: 2021-03-03
tags: release
synopsis: 1.12.1.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.12.1.1.Finalリリース - バグフィックス
date: 2021-03-03
tags: release
synopsis: 1.12.1.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.12.1.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.1.Final is a safe upgrade for everyone using Quarkus 1.12.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.12.1.Finalは、Quarkus 1.12を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.12 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12 migration guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだ1.12を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.12.1.Final[the full changelog of 1.12.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.1.Final[GitHubで1.12.1.1.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We took a little break, but now another Newsletter round of stories found!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>少しお休みをとっていましたが、かなりの量の見つかったストーリーのニュースレターを発行します!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the news below - give it a read and if you feel something is missing or have an article coming out for future Quarkus Newsletter install the https://github.com/quarkusio/url2quarkuspub[bookmarklet] on your laptop and phone to easily submit a story. If you prefer the manual way please https://github.com/quarkusio/quarkusio.github.io/issues[open an issue] with a short description and a url.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のニュースを読んで、もし、何かが欠けていると感じたり、将来のQuarkus ニュースレターのために記事をお持ちの場合は、 link:https://github.com/quarkusio/url2quarkuspub[ブックマークレット] をラップトップやスマートフォンにインストールして、簡単に記事を投稿することができます。あなたが手動の方法を好む場合は、短い説明とURLを link:https://github.com/quarkusio/quarkusio.github.io/issues[Issueを登録] してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It has been a week since the release of `1.13.0.Final` so it is time for our traditional `.1` release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`1.13.0.Final` のリリースから1週間が経ちましたので、恒例の `.1` のリリースの時間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.1.Finalは、バグの修正とドキュメントの改善を行ったメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.1.Final is a safe upgrade for everyone using Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.1.Finalは、Quarkus 1.13を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instrumentation-based live reload disabled by default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インスツルメンテーションベースのライブリロードがデフォルトで無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have made several iterations of our instrumentation-based live reload (meaning we don't restart Quarkus but just perform class redefinition when we can) since its first introduction.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インストゥルメンテーションベースのライブリロード（可能な場合にQuarkusを再起動せず、クラスの再定義を行うこと）を最初に導入して以来、何度もイテレーションを繰り返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It has matured a lot but we decided it was too much of a change compared to our initial promise of "you refresh, everything is fully restarted".  So, in 1.13.1.Final, we disabled it by default.  If your live reloads are taking too long or if you want to keep the application state as much as possible, you can enable it by adding `quarkus.live-reload.instrumentation=true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能は非常に成熟していますが、「リフレッシュするとすべてが完全に再起動される」という当初の約束と比べると、あまりにも変化が大きすぎると判断しました。そこで、1.13.1.Finalでは、この機能をデフォルトで無効にしました。ライブリロードに時間がかかりすぎる場合や、アプリケーションの状態をできるだけ維持したい場合には、 `application.properties` に `quarkus.live-reload.instrumentation=true` を追加することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.1.Final[the full changelog of 1.13.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.1.Final[1.13.1.Finalの完全な変更履歴はGitHub] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have any questions, suggestions or feedback, by all means please https://github.com/redhat-developer/intellij-quarkus/issues[open an issue].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご質問、ご意見、ご感想などがありましたら、ぜひ link:https://github.com/redhat-developer/intellij-quarkus/issues[イシューを開いて]ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ADOPTERS.md</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ADOPTERS.md</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To share stories about Quarkus usage, we added https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[an `ADOPTERS.md` file] at the root of the repository.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus の使用方法についてのストーリーを共有するために、リポジトリのルートに link:https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[`ADOPTERS.md`] ファイルを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus and would like to be interviewed on our blog or simply added to this file, please contact us and we will be happy to oblige.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusをご利用の方で、ブログで取材を受けたい方や、このファイルに単純に追加したい方は、ご連絡いただければ、喜んでお受けいたします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.8.3.Final released - Bugfixes'
date: 2020-10-09
tags: release
synopsis: 1.8.3.Final downgrades slf4j-jboss-logging to fix a regression.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.8.3.Finalリリース - バグフィックス
date: 2020-10-09
tags: release
synopsis: 1.8.3.Finalではリグレッションを修正するためにslf4j-jboss-loggingをダウングレードしました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we released Quarkus 1.8.3.Final which contains a fix for an annoying regression and some other fixes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、Quarkus 1.8.3.Finalをリリースしました。このリリースには、迷惑なリグレッションの修正やその他いくつかの修正が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.8.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.8を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release that fixes various bugs found in 1.8.2.Final and provides some documentation updates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリリースは、1.8.2.Final で発見された様々なバグを修正し、ドキュメントを更新したメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main change we made is a downgrade of `slf4j-jboss-logging` motivated by a regression in `slf4j-jboss-logging`: https://github.com/quarkusio/quarkus/issues/12615 .</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>我々が行った主な変更点は、 `slf4j-jboss-logging`:https://github.com/quarkusio/quarkus/issues/12615 のリグレッションを理由とした `slf4j-jboss-logging` のダウングレードです .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.8.3.Final[the full changelog of 1.8.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.3.Final[GitHubで1.8.3.Finalの完全な変更履歴] は入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.8.1.Final released - Bugfixes, RESTEasy Multipart extension'
date: 2020-09-18
tags: release
synopsis: 1.8.1.Final fixes some regressions and bugs and introduces the RESTEasy Multipart extension.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.8.1.1.Finalリリース - バグフィックス、RESTEasy Multipartエクステンション
date: 2020-09-18
tags: release
synopsis: 1.8.1.Finalでは、いくつかの回帰やバグを修正し、RESTEasy Multipartエクステンションを導入しました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we released Quarkus 1.8.1.Final with some bugfixes and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、Quarkus 1.8.1.Finalをリリースし、いくつかのバグフィックスとドキュメントの改善を行いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also introduced a new RESTEasy Multipart extension to fix an recurring encoding issues with multipart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、新しい RESTEasy Multipart エクステンションを導入し、multipart で繰り返し発生するエンコーディングの問題を修正しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using 1.8.0.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.8.0.Finalを使っている人なら誰でも安心してアップグレードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release that fixes various bugs found in 1.8.0.Final and provides some documentation updates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリリースは、1.8.0.Final で発見された様々なバグを修正し、いくつかのドキュメントを更新するメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.8.1.Final[the full changelog of 1.8.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.1.Final[GitHubで1.8.1.1.Finalの完全な変更履歴] は入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Multipart</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default encoding for multipart requests in RESTEasy is US-ASCII which is not very convenient in 2020.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasyでのマルチパートリクエストのデフォルトエンコーディングはUS-ASCIIで、2020年にはあまり便利ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the `quarkus-resteasy-multipart` extension, the default encoding is now UTF-8 and it can be configured if needed.  If working with multipart, make sure you use this extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-resteasy-multipart` エクステンションのおかげで、デフォルトのエンコーディングが UTF-8 になり、必要に応じて設定できるようになりました。マルチパートに取り組む場合は、このエクステンションを使用するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More on this in the link:/guides/rest-json#multipart-support[Writing JSON REST Services guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これについての詳細は、 link:/guides/rest-json#multipart-support[JSON RESTサービスの作成ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today we're proud to announce our quarkus.io Japanese localization site (https://ja.quarkus.io[https://ja.quarkus.io]) is now open. It is where our valuable guides and blog entries are translated.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、quarkus.io日本語版サイト (https://ja.quarkus.io[https://ja.quarkus.io]) が公開されましたことをお知らせします。ここでは、Quarkusの価値あるガイドや、ブログエントリの翻訳が公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/ja-quarkus-io/ja-quarkus-io.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/ja-quarkus-io/ja-quarkus-io.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some contents have not been translated yet, but we are continuing to translate them one by one.  We are working on the localization of the contents on a GitHub public repository (https://github.com/quarkusio/ja.quarkus.io[https://github.com/quarkusio/ja.quarkus.io]), and we are welcoming pull-requests to translate them.  If you are interested in localizing quarkus.io, come and join us! For more details about how to contribute the localization project, please see https://github.com/quarkusio/ja.quarkus.io/blob/master/translation-guide.ja.md[translation guide(ja)].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一部のコンテンツはまだ翻訳されていませんが、1つずつ翻訳を続けています。GitHubのパブリックレポジトリ (https://github.com/quarkusio/ja.quarkus.io[https://github.com/quarkusio/ja.quarkus.io]) でコンテンツのローカリゼーションに取り組んでおり、翻訳のPull-Requestは大歓迎です。quarkus.ioのローカライズに興味がある場合は、ぜひご参加ください。ローカリゼーションプロジェクトへの貢献方法の詳細については、 https://github.com/quarkusio/ja.quarkus.io/blob/master/translation-guide.ja.md[翻訳ガイド(ja)] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We hope https://ja.quarkus.io[https://ja.quarkus.io] will be of great help to the user community in Japan.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://ja.quarkus.io[https://ja.quarkus.io] が日本のユーザーコミュニティに大いに役立つことを願っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few months back, I blogged about https://quarkus.io/blog/kafka-avro/[Quarkus, Kafka, and Avro] (using the Apicurio schema registry).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数ヶ月前に、 https://quarkus.io/blog/kafka-avro/[QuarkusとKafka、Avro] (Apicurio schema registryを使用)についてブログを書きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We developed a simple application, receives HTTP requests, writes Kafka records, and reads them from Kafka.  It uses Avro to serialize and deserialize the records.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HTTPリクエストを受信し、Kafkaのレコードを書き込み、Kafkaからレコードを読み出すというシンプルなアプリケーションを開発しました。  Avroを使ってレコードのシリアライズとデシリアライズを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that time, the https://github.com/cescoffier/quarkus-kafka-and-avro[application] was **NOT** working in native mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その時は、 https://github.com/cescoffier/quarkus-kafka-and-avro[アプリケーション] はネイティブモードで動作して **いません** でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why didn't it work?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜうまくいかなかったのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native compiler does not support everything that is possible to do in Java.  There are cases not yet supported, and Avro is using some of these unsupported constructs.  Fortunately, we can implement _substitutions_ (to replace unsupported constructs in the code directly) and use Quarkus extensions to configure the compiler correctly.  As a result, your application does not have to configure anything, "it just works™️".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブコンパイラは、Javaでできることをすべてサポートしているわけではありません。  まだサポートされていないケースがあり、Avroではこれらのサポートされていない構文のいくつかを使用しています。幸いなことに、_substitutions_(コード内のサポートされていない構文を直接置き換える)を実装し、Quarkusのエクステンションを使用してコンパイラを正しく設定することができます。その結果、アプリケーションは何も設定する必要がなく、「it just works™️」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's come back to Avro.  Avro uses https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[method handles] that are not supported by the GraalVM native compiler.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Avro の話に戻りましょう。  Avro は GraalVM ネイティブコンパイラがサポートしていない https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[メソッドハンドル] を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To workaround the unsupported constructs used by Avro, we implemented a set of https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions].  We replaced method handles with reflection.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Avro が使用するサポートされていない構文を回避するために、 https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions] のセットを実装しました。 メソッドハンドルをリフレクションに置き換えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GenericDatumReader` also needs a bit of work as it touches threads at build time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 `GenericDatumReader` は、ビルド時にスレッドに触れるため、少し作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, in the Quarkus Avro Processor (part of the Quarkus extension), we register for reflection all the classes annotated with `@AvroGenerated`, as we are using reflection to create new instances of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、Quarkus Avro Processor(Quarkusエクステンションの一部)で、 `@AvroGenerated` でアノテーションされたすべてのクラスをリフレクションの為に登録します。新しいインスタンスの生成にリフレクションを使用している為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>見せて!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the https://github.com/cescoffier/quarkus-kafka-and-avro[code] of the application, and make sure you have GraalVM installed.  Then, build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの https://github.com/cescoffier/quarkus-kafka-and-avro[コード] を取得し、GraalVMがインストールされていることを確認してください。そして、ネイティブ実行ファイルを次のようにビルドします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grab a coffee or tea, as it may take a few minutes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数分かかる場合がありますので、コーヒーや紅茶を淹れましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, run the application with `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、 `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner` でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send some movies to the application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの映画をアプリに送信します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check they are processed successfully in the application log output:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>正常に処理されていることをアプリケーションログ出力で確認してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Avro support in native is still experimental.  In the last Quarkus version, we made significant progress, but there may be some uncovered areas.  Let us know if you find anything https://github.com/quarkusio/quarkus/issues/new/choose[odd]!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブでのAvroサポートはまだ実験的なものです。前回のQuarkusバージョンでは、かなりの進歩を遂げましたが、いくつかの未発見の部分があるかもしれません。 https://github.com/quarkusio/quarkus/issues/new/choose[何かおかしな点を見つけましたら教えてください] !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We released 1.13.5.Final today with a new set of bugfixes for our 1.13 release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、1.13リリースのバグフィックスを含む1.13.5.Finalをリリースしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.5.Final is a safe upgrade for everyone using Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.5.Finalは、Quarkus 1.13を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven 3.8.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven 3.8.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given there are a couple of CVEs in Maven 3.6, we upgraded the Maven version included in the generated projects to 3.8.1 (the one from the Maven wrapper).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Maven 3.6 にはいくつかの CVE が存在するため、生成されたプロジェクトに含まれる Maven のバージョンを 3.8.1 (Maven ラッパーのもの) にアップグレードしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also upgraded our Maven internal dependencies to 3.8.1.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Mavenの内部依存関係を3.8.1にアップグレードしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can still use Maven 3.6 if you are so inclined.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要であれば、Maven 3.6を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.5.Final[the full changelog of 1.13.5.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.5.Final[1.13.5.Finalの完全な変更履歴はGitHub] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migration Guide</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>移行ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.8.2.Final released - Bugfixes'
date: 2020-10-06
tags: release
synopsis: 1.8.2.Final fixes some bugs and includes some documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.8.2.Finalリリース - バグフィックス
date: 2020-10-06
tags: release
synopsis: 1.8.2.Finalでは、いくつかのバグを修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we released Quarkus 1.8.2.Final with some bugfixes and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、Quarkus 1.8.2.Finalをリリースし、いくつかのバグフィックスとドキュメントの改善を行いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release that fixes various bugs found in 1.8.1.Final and provides some documentation updates.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリリースは、1.8.1.Final で発見された様々なバグを修正し、いくつかのドキュメントの更新を提供するメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.8.2.Final[the full changelog of 1.8.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.2.Final[GitHubで1.8.2.Finalの完全な変更履歴] は入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.3.Final mainly fixes a regression introduced in 1.11.2.Final that makes it impossible to build native executables while using both the RESTEasy and OpenTracing extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.11.3.Finalは主に1.11.2.Finalで導入された、RESTEasy と OpenTracing の両方のエクステンションを使用している場合にネイティブの実行ファイルをビルドできないようにするリグレッションを修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.11 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11 migration guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まだ1.11を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11移行ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[the full changelog of 1.11.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[GitHubで1.11.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and Reactive: the elevator pitch</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令型とリアクティブ型: エレベーターピッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloudevents.io/[Cloud Events] is a specification for describing events.  It aims to ease interoperability.  With the rise of event-driven architecture, it's not surprising to see Cloud Events gaining popularity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://cloudevents.io/[クラウドイベントは]、イベントを記述するための仕様です。相互運用性を容易にすることを目的としています。イベント駆動型アーキテクチャの台頭により、Cloud Eventsの人気が高まっているのは驚くに値しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post explains how you can generate and consume Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを生成して消費する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Cloud Event?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドイベントとは?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's look at the why.  Events are everywhere.  Many modern systems are using events one way or another.  Events can be used to implement event sourcing, communicate facts, trigger out-of-band processing, or send notifications.  Events become an essential piece of any system.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まずは「なぜ」を見てみましょう。イベントはどこにでもあります。最近のシステムの多くは、何らかの方法でイベントを使用しています。イベントは、イベントソーシングの実装、事実の伝達、帯域外処理のトリガー、通知の送信などに使用できます。イベントはどんなシステムにも欠かせないものとなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yet event publishers tend to describe events differently.  I don't mean the content is different, but the envelope and the event's format are heterogeneous, even if these events transit on the same event mesh.  Some applications choose JSON and encode everything in the event's payload; some other systems prefer binary formats, such as Avro or Protobuf, and use the protocol capability, such as headers or properties, to transport metadata about the wrapped payload.  While event-driven architecture claims to ease the integration with external systems, this disparity is doing the opposite.  It's not rare to need a specific event translator with the only purpose to adapt events from one format to another.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、イベント発行者はイベントを異なる形で表現する傾向があります。内容が違うという意味ではありませんが、エンベロープとイベントのフォーマットは異種混在で、たとえこれらのイベントが同じイベントメッシュ上を通過するとしてもです。アプリケーションの中には JSON を選択してイベントのペイロードにすべてをエンコードするものもあれば、Avro や Protobuf のようなバイナリー形式を好み、ヘッダやプロパティーのようなプロトコル機能を使って、ラップされたペイロードに関するメタデータを転送するものもあります。イベント駆動型アーキテクチャは外部システムとの統合を容易にすると主張していますが、この不均衡はその逆を行っています。イベントをあるフォーマットから別のフォーマットに適応させることだけを目的とした特定のイベントトランスレータを必要とすることは珍しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, what's Cloud Event? Cloud Event proposes a common way to describe events.  The goal is, obviously, interoperability and easing the integration burden.  Cloud Event 1.0 was released almost a year ago.  Over the past year, many Cloud Providers adopted this format, such as Azure and Oracle.  Several middlewares have also added support for Cloud Events, such as Knative, Kogito, Debezium, and Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>では、クラウドイベントとは何か?クラウドイベントは、イベントを記述するための共通の方法を提案しています。目的は明らかに相互運用性と統合負担の軽減です。クラウドイベント1.0はほぼ1年前にリリースされました。この1年で、AzureやOracleなど、多くのクラウドプロバイダーがこの形式を採用しました。また、Knative、Kogito、Debezium、Quarkusなど、いくつかのミドルウェアがクラウドイベントのサポートを追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me some examples!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例を見せてください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, so, how does it look? The easiest way to understand Cloud Event is to look at one of them:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さてさて、どんな感じでしょうか?クラウドイベントを理解する一番簡単な方法は、そのうちの一つを見てみることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This event is described in JSON, but that's just one of the possibilities.  Let's look at the fields.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このイベントはJSONで記述されていますが、それは可能性の一つに過ぎません。フィールドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the `specversion` indicates which version of Cloud Event it is using (1.0).  The `id` field provides an id for that specific event.  The `source` attribute is a URI identifying the event source, i.e., the context in which an event happened or the application that emitted that specific event.  Combining the `id` and the `source` provides a unique identifier.  Such uniqueness is essential to implement idempotence and handle potential duplicates.  The `type` is the last mandatory attribute.  It indicates the _type_ of the event.  Here, I use the fully qualified class name, but you can imagine anything.  It should refer to the kind of event you have defined in your system.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、 `specversion`  は、使用しているクラウドイベントのバージョン(1.0)を示しています。 `id`  フィールドは、その特定のイベントの ID を提供します。 `source`  属性は、イベントソースを識別する URI であり、イベントが発生したコンテキストや、特定のイベントを発生させたアプリケーションを示します。 `id`  と `source`  を組み合わせることで、一意な識別子が得られます。このような一意性は、冪等性を実装し、潜在的な重複を処理するために不可欠です。 `type`  は最後の必須属性です。これはイベントの _タイプ_ を示します。ここでは完全修飾クラス名を使用していますが、何を想像しても構いません。システムで定義されているイベントの種類を参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other attributes are optional.  `datacontenttype` defines the content-type of the `data` attribute.  `subject` allows passing extra details about the event, such as an additional hint about the context or the type of event.  `time` is a timestamp, generally indicating the creation time.  There is another optional attribute not used in my example.  The `dataschema` attribute lets you pass the schema of the event data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`datacontenttype`  は `data`  属性の content-type を定義します。 `subject`  では、コンテキストやイベントのタイプに関する追加のヒントなど、イベントに関する追加の詳細を渡すことができます。 `time`  はタイムスタンプで、一般的には作成時刻を示します。私の例では使用していない別のオプションの属性があります。 `dataschema`  属性は、イベントデータのスキーマを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `data` attribute contains the wrapped business event.  It is an essential part, and the other attributes are just providing details about that specific business event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`data`  属性には、ラップされたビジネスイベントが含まれています。これは本質的な部分であり、他の属性はその特定のビジネスイベントについての詳細を提供しているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also define _extensions_.  These extensions would be a set of custom attributes used when the proposed set of attributes is not enough for your use case.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_拡張_ を定義することもできます。これらの拡張は、提案された属性のセットがユースケースに十分でない場合に使用されるカスタム属性のセットになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's it! So, we can summarize Cloud Events as _just enough metadata to understand an event_ - its source, an id, a type, and the business data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これだ!これだ!と思ったイベントをまとめてみました。ということで、クラウドイベントを、 _イベントを理解するために必要な最低限のメタデータ、つまり、イベントの_ ソース、ID、タイプ、ビジネスデータとしてまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Events on the wire - the bindings</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>転送におけるクラウドイベント - バインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, how would these events be encoded? The previous example using JSON is nice, but some protocols may want to leverage their own capabilities to transmit these metadata.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、これらのイベントはどのようにエンコードされるのでしょうか?JSON を使った先ほどの例もいいですが、プロトコルによっては、独自の機能を活用してこれらのメタデータを送信したい場合もあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's why Cloud Events also proposes bindings.  A binding is a set of recommendations specific to one protocol.  It explains how each protocol should encode Cloud Events.  For example, there is a binding for HTTP, one for Kafka, and another for AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、Cloud Eventsではバインディングも提案しています。バインディングとは、あるプロトコルに固有の推奨事項のセットです。各プロトコルがどのようにCloud Eventsをエンコードすべきかを説明します。例えば、HTTP用のバインディング、Kafka用のバインディング、AMQP用のバインディングがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of these bindings propose two approaches:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのバインディングのほとんどは、2つのアプローチを提案しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>structured</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>structured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>binary</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>binary</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach keeps event metadata and data together in the payload of the message or request.  It generally uses JSON to encode that data.  If you pass the Cloud Event example (from above), in an HTTP request, it will use the structured mode.  It will also use the structured mode when you write that JSON snippet in a Kafka record's value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>構造化されたアプローチは、イベントのメタデータとデータをメッセージやリクエストのペイロードにまとめて保持します。一般的には JSON を使用してデータをエンコードします。Cloud Event の例 (上記) を HTTP リクエストで渡すと、構造化モードを使用します。また、Kafka レコードの値にその JSON スニペットを書き込む場合も構造化モードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach allows simple forwarding across multiple protocols.  However, it may not be efficient and may constraint the type of business data.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>構造化されたアプローチでは、複数のプロトコルをまたいで簡単に転送することができます。しかし、効率的でない場合があり、ビジネスデータの種類を制約する場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other approach relies on protocol capabilities and enables efficient transfer and encoding.  If we use the binary mode with Kafka, we will store the `data` attribute value in the Kafka record's value and pass the other attributes using the record's headers.  Consequently, business data can be encoded using binary protocols such as Avro, leading to higher efficiency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つのアプローチはプロトコルの能力に依存しており、効率的な転送とエンコードを可能にします。Kafkaでバイナリーモードを使用する場合、Kafkaレコードの値に `data`  属性の値を格納し、レコードのヘッダを使用して他の属性を渡すことになります。その結果、Avroなどのバイナリープロトコルを使ってビジネスデータをエンコードすることができ、効率化につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the post explains how you can send and receive Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>残りの記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを送受信する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Cloud Events on Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドイベントをKafkaで送信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector used by Quarkus has built-in support for Cloud Events.  It can send and consume Cloud Events using the structured mode (encoding everything in a JSON payload) or the binary mode (using Kafka headers).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusが使用するKafkaコネクタは、Cloud Eventsをビルトインでサポートしています。構造化モード(JSONペイロードですべてをエンコード)またはバイナリーモード(Kafkaヘッダーを使用)を使用して、クラウドイベントを送信したり消費したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write your outgoing messages as Cloud Event, you only need to specify the `cloud-events-type` and `cloud-events-source` attributes on your channel:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>送信メッセージをクラウドイベントとして記述するには、チャンネルに `cloud-events-type`  と `cloud-events-source`  属性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector writes Cloud Events using the binary mode.  The connector generates a random `id` for each message.  You can also customize the other Cloud Event attributes using `cloud-events-$attribute`, such as `cloud-events-subject`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでは、コネクタはバイナリーモードを使用してクラウドイベントを書き込みます。コネクタはメッセージごとにランダムな `id`  を生成します。 `cloud-events-$attribute`  を使用して、 `cloud-events-subject`  などの他のクラウドイベント属性をカスタマイズすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration shown above is applied to all the outgoing messages.  Sometimes, you want to customize the value for each message individually.  To achieve this, you can also attach `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` to your message to customize the id, source, type and subject for each message:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の設定は、すべての送信メッセージに適用されます。場合によっては、各メッセージの値を個別にカスタマイズしたいこともあるでしょう。これを実現するには、メッセージに `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata`  を添付して、各メッセージの id、ソース、タイプ、件名をカスタマイズすることもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector also supports the _structured_ mode.  You can write structured Cloud Events by setting the `cloud-events-mode` attribute to `structured`.  It only supports JSON at the moment.  The written record gets its `content-type` header set to `application/cloudevents+json; charset=UTF-8`, which allows the receiver to understand that it's a structured Cloud Event.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コネクタは _構造化_ モードもサポートしています。 `cloud-events-mode`  属性を `structured`  に設定することで、構造化された Cloud Events を書くことができます。現時点では JSON のみサポートしています。書き込まれたレコードの `content-type`  ヘッダーは `application/cloudevents+json; charset=UTF-8`  に設定され、これにより受信者はそれが構造化されたクラウドイベントであることを理解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Cloud Event from Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラウドイベントをKafkaから消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, the connector can also consume Cloud Events.  The connector detects Cloud Events automatically by checking the record's headers.  It also determines the mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当然のことながら、コネクタはクラウドイベントを消費することもできます。コネクタは、レコードのヘッダをチェックすることで、自動的にクラウドイベントを検出します。また、モードも決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the connector receives a Cloud Event, it attaches an `IncomingKafkaCloudEventMetadata` to the message metadata.  So, you can retrieve the various attributes as well as the extensions:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コネクタはクラウドイベントを受信すると、メッセージのメタデータに `IncomingKafkaCloudEventMetadata`  をアタッチします。そのため、拡張だけでなく様々な属性を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the rise of event-driven architecture, Cloud Events are becoming highly popular.  Since Quarkus 1.9, the Kafka Connector used in Quarkus has built-in support for Cloud Events.  This post introduced Cloud Events and showed how you could write and read Cloud Events easily.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベント駆動型アーキテクチャの台頭に伴い、クラウドイベントの人気が高まっています。Quarkus 1.9以降、Quarkusで使用されているKafka ConnectorはCloud Eventsをビルトインでサポートしています。この投稿では、Cloud Eventsを紹介し、Cloud Eventsを簡単に書いたり読んだりする方法を紹介しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many more options are http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[available], and Kafka is not the only part of Quarkus with Cloud Events support.  For example, Funqy[https://quarkus.io/guides/funqy#context-injection] also supports Cloud Event out of the box.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他にも多くのオプションが http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[用意]されており、KafkaだけがクラウドイベントをサポートしているQuarkusの一部ではありません。例えば、Funqy https://quarkus.io/guides/funqy#context-injection ]もクラウドイベントをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team is proud to announce the availability of the Final release of Quarkus 2.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusチームは、Quarkus 2.0のファイナルリリースを発表しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This version has been a gigantic effort to bring Quarkus to a whole new level, while keeping its roots: fast boot, low memory usage and developer joy.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このバージョンは、Quarkusのルーツである高速起動、低メモリ使用、開発者満足度を維持しつつ、Quarkusを全く新しいレベルに引き上げるための巨大な努力がなされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A big thank you to everyone involved in the community, contributors, testers...  This version is a team effort and wouldn't be as great without all of you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コミュニティに参加してくださった皆様、コントリビューターの皆様、テスターの皆様、本当にありがとうございました。このバージョンはチームの努力の賜物であり、皆様のおかげで素晴らしいものになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The good news is that upgrading to Quarkus 2.0 will be very low effort and, as usual, we have a https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0[migration guide] to help you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>良いニュースとしては、Quarkus 2.0へのアップグレードは非常に簡単で、いつものように link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0[移行ガイド]を用意しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you encounter any issue upgrading to this new version, please report it so that we can either fix it or add the information to the guide.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この新しいバージョンにアップグレードする際に問題が発生した場合は、報告していただければ、修正するか、ガイドに情報を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already presented the novelties of this version in the Alphas/CRs announcements but here is a summary of what's new in this version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このバージョンの新しさは、すでにAlphas/CRの発表で紹介していますが、ここではその内容をまとめてみました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also have a look at this week's Quarkus Insights `Quarkus 2.0 Launch Party`, with several Quarkus contributors talking about the new features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、今週のQuarkus Insights `Quarkus 2.0 Launch Party` で、複数のQuarkusコントリビューターが新機能について語っていますので、ご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 as minimal version</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最小バージョンとしてのJDK 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 is the minimal version to use Quarkus 2.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK 11が、Quarkus 2.0を使用するための最小バージョンになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 8 is not supported anymore (but you can keep using 1.13.x if you are stuck with it!).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JDK 8はもうサポートされていません（ただし、1.13.xにこだわっている方は使い続けることができます！）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 21.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM 21.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 21.1 is the recommended version for Quarkus 2.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM 21.1は、Quarkus 2.0の推奨バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x 4</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x is at the core of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.xはQuarkusの中核です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 brings Vert.x 4.  You can learn more about it in https://vertx.io/blog/eclipse-vert-x-4-released/[the announcement] and the https://vertx.io/blog/whats-new-in-vert-x-4/[What's new blog post].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0はVert.x 4を搭載しています。詳細は link:https://vertx.io/blog/eclipse-vert-x-4-released/[アナウンス]と link:https://vertx.io/blog/whats-new-in-vert-x-4/[変更点のブログ記事]でご覧いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse MicroProfile 4</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse MicroProfile 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile 4 is the latest evolution of the https://github.com/eclipse/microprofile/releases/tag/4.0[MicroProfile specifications].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MicroProfile 4は、 link:https://github.com/eclipse/microprofile/releases/tag/4.0[MicroProfile仕様]の最新版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the SmallRye components in Quarkus have been updated to the latest and greatest and, apart from implementing MicroProfile 4, they also come with additional new features.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのSmallRyeコンポーネントはすべて最新のものにアップデートされており、MicroProfile 4を実装しているだけでなく、追加の新機能も搭載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I'll let the stage to Stuart Douglas for that one as he's the author of this amazing new feature.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この素晴らしい新機能を開発したのはStuart Douglas氏なので、彼にお任せします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release contains a brand new feature improving developer productivity: Continuous Testing.  This allows tests to be run automatically in development mode, and can be enabled by pressing `r` in the console (or through the Dev UI). If you enable testing, your test suite will be run once at the start, and then continuous testing will run your tests as you are coding, and tell you if your changes will break any tests. This will give you instant feedback on your changes, without having to switch to a browser. As much as possible we only run tests that are relevant to the code that has been changed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリリースには、開発者の生産性を向上させる全く新しい機能が含まれています。継続的テストです。この機能は、開発モードでテストを自動的に実行できるようにするもので、コンソール（または Dev UI）で `r` を押すと有効になります。テストを有効にすると、最初にテストスイートが一度だけ実行され、その後はコーディング中に継続的テストがテストを実行し、変更によってテストが壊れるかどうかを教えてくれます。これにより、ブラウザに切り替えることなく、変更内容を即座にフィードバックすることができます。可能な限り、変更されたコードに関連するテストのみを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature has also introduced some changes that may affect your application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、この機能はいくつか変更点をもたらすため、お客様のアプリケーションに影響を与える可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Class Loading model for testing is now the same as development mode (as tests need to be hot reloaded), if this causes issues for your application you can set `quarkus.test.flat-class-path=true` to revert to the old model, but it will disable continuous testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テスト用のクラス・ローディング・モデルは、開発モードと同じになりました（テストはホット・リロードが必要なため）。もしこのモデルがアプリケーションに問題を起こすようであれば、 `quarkus.test.flat-class-path=true` を設定して古いモデルに戻すことができますが、継続的なテストは無効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a compatible terminal is detected Quarkus will display status messages at the bottom of the console window, and react to input without the need to press enter. If this interferes with your application it can be disabled via `quarkus.test.basic-console=true` (note that gradle will always use the basic console at this time).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>互換性のある端末が検出された場合、Quarkusはコンソールウィンドウの下部にステータスメッセージを表示し、Enterキーを押すことなく入力に反応します。これがアプリケーションの邪魔になる場合は、 `quarkus.test.basic-console=true` で無効にすることができます（現時点では、gradleは常に基本コンソールを使用することに注意してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want any test output in the console and just want to interact through the Dev UI you can set `quarkus.test.console=false`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンソールでのテスト出力を必要とせず、開発者用のUIで対話したい場合は、 `quarkus.test.console=false` を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous Testing is part of a long tradition of developer-targeted innovation in Quarkus.  As such, we are eager to hear about your feedback on it and how we can make it even better.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>継続的なテストは、Quarkusにおける開発者を対象とした革新の長い伝統の一部です。そのため、私たちはそれについてのあなたのフィードバックと、更に良くする方法について聞いてみたいと思っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a video presenting Continuous Testing in motion:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、継続的テストの動作を紹介するビデオを紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus CLI</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Historically, you interacted with your Quarkus projects using Maven or Gradle commands.  This will soon be over as Quarkus 2.0 introduces a brand new and improved Quarkus CLI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、MavenやGradleのコマンドを使ってQuarkusプロジェクトを操作していました。しかし、それももうすぐ終わりです。Quarkus 2.0では新しく改良されたQuarkus CLIが導入されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are still working on publishing it everywhere for easy consumption on all systems but you can already use JBang to run it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてのシステムで簡単に利用できるように、どこにでも公開できるようにまだ取り組んでいますが、すでに実行にJBangを使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details in the link:/guides/cli-tooling[dedicated CLI guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は link:/guides/cli-tooling[専用のCLIガイド]でご確認ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other notable features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の注目すべき機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now offers a GraphQL client in the form of the link:/guides/smallrye-graphql-client[SmallRye GraphQL Client extension].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 link:/guides/smallrye-graphql-client[SmallRye GraphQL Client エクステンション]という形で、GraphQLクライアントを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.5 and the Hibernate ORM extension now has support for metadata contributors.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORMが5.5にアップグレードされ、Hibernate ORMエクステンションがメタデータ・コントリビューターをサポートするようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC, our CDI implementation, supports CDI decorators.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CDIの実装であるArCは、CDIのデコレーターをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB with Panache now comes with transaction support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDB with Panacheは、トランザクションをサポートするようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Kotlin story got some nice additions: the RESTEasy Reactive, REST Client and Reactive Messaging extensions now support coroutines.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive、REST Client、Reactive Messagingの各エクステンションがコルーチンをサポートするようになり、Kotlinのストーリーにいくつかの素晴らしい追加要素が加わりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An link:/guides/amazon-ssm[extension for Amazon SSM] has been added.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/guides/amazon-ssm[Amazon SSM エクステンション]が追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Changelog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of the various intermediary versions that lead to this Final on GitHub:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のFinalに至るまでの様々な中間バージョンの完全な変更履歴はGitHubで入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha1[2.0.0.Alpha1]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha1[2.0.0.Alpha1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha2[2.0.0.Alpha2]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha2[2.0.0.Alpha2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha3[2.0.0.Alpha3]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha3[2.0.0.Alpha3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR1[2.0.0.CR1]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR1[2.0.0.CR1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR2[2.0.0.CR2]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR2[2.0.0.CR2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR3[2.0.0.CR3]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR3[2.0.0.CR3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Final[2.0.0.Final]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Final[2.0.0.Final]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[496 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusコミュニティは成長を続けており、現在496名の方に link:https://github.com/quarkusio/quarkus/graphs/contributors[ご協力いただいて]います。皆さまに感謝いたします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.2.Final released - Bugfixes'
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.11.2.Final リリース - バグ修正
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final では問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.2.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.11.2.Final は、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to Hibernate ORM 5.4.27.SP1 which fixes an important issue, potentially causing data losses.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM 5.4.27.SP1 にアップグレードし、データ損失を引き起こす可能性のある重要な問題が修正されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the upgrade is highly recommended.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>したがって、アップグレードを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[the full changelog of 1.11.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[GitHub 上で 1.11.2.Final の完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We just released 1.13.2.Final, a new maintenance release for the 1.13 release train.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13リリーストレインの新しいメンテナンスリリースである1.13.2.Finalをリリースしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, this release fixes bugs and includes some documentation improvements but it also introduces a new extension for the Oracle JDBC driver.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のリリースでは、通常通り、バグの修正とドキュメントの改善が行われていますが、それに加えて、Oracle JDBCドライバ用の新しいエクステンションが導入されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.2.Final is a safe upgrade for everyone using Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.2.Finalは、Quarkus 1.13を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While 1.13.2.Final is a maintenance release, we had some users asking for a backport of the brand new Oracle JDBC driver extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.2.Finalはメンテナンスリリースですが、新しいOracle JDBCドライバエクステンションのバックポートを求める声がありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given this work is self contained, it was judged safe enough to be included in this release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは自己完結型であるため、今回のリリースに収録するには十分な安全性があると判断しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the Oracle Database with Quarkus, in JVM mode and native mode, you can now include the following snippet in your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Oracle DatabaseをJVMモードおよびネイティブモードでQuarkusと一緒に使用するには、次のスニペットを `pom.xml` に含めることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and use our standard datasource configuration infrastructure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、標準的なデータソース設定基盤を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.2.Final[the full changelog of 1.13.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.2.Final[1.13.2.Finalの完全な変更履歴はGitHub] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.9 comes with a lot of improvements on top of our existing feature set:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.9 では、既存の機能セットに対して多くの改良が加えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis clients are supported (as well as Sentinel connections)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>複数の Redis クライアントのサポート (Sentinel 接続も同様)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, it also comes with its fair share of bugfixes and usability and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、バグ修正や使い勝手の改善、ドキュメントの改善なども行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, we also started &lt;&lt;quarkiverse,the Quarkiverse initiative&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後ですが重要なことに、 link:#quarkiverse[Quarkiverseの取組] も開始しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[our migration guide for 1.9].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のアプリケーションの移行をお考えですか?ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9の移行ガイド] があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The biggest change is that the old datasource (JDBC and reactive) configuration that was deprecated in 1.3 is now gone.  So if your datasources don't work anymore, that's probably because you haven't migrated to the new configuration yet.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最大の変更点は、1.3 で非推奨となった古いデータソース (JDBC とリアクティブ) の設定がなくなったことです。ですから、もしあなたのデータソースが動作しなくなった場合、それはおそらくあなたがまだ新しい設定に移行していないことが原因です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11 のフレーバーの GraalVM 20.2 が、推奨される GraalVM のバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.8 introduced a new Micrometer extension.  During the 1.9 development cycle, it matured a lot and is now the recommended way to collect metrics in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.8 では、新しく Micrometer エクステンションが導入されました。1.9 の開発サイクルの間に、このエクステンションは大きく発展し、現在では Quarkus でメトリクスを収集するための推奨される方法となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, you now get metrics for Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、Kafka のメトリクスを取得できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Validation constraints are now taken into account for parameters and return values (`Uni` is supported but not `Multi`) of Reactive Routes methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bean Validation 制約が Reactive Routes メソッドのパラメーターと戻り値 ( `Uni` はサポートされていますが、 `Multi` はサポートされていません) で考慮されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Reactive Changes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>更なるリアクティブの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.4.0 which includes several improvements - including Cloud Event support for Kafka - and bugfixes and Mutiny to 0.9.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Reactive Messaging は 2.4.0 にアップグレードされました。KafkaのCloud Event サポートを含むいくつかの改善、バグ修正などが含まれています。Mutinyは 0.9.0 へアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/quarkusio/quarkus/pull/12470[pull request description] lists the main changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/12470[プルリクエストの説明] に主な変更点が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is now easier than ever to use Mutiny with the REST Client thanks to the `quarkus-rest-client-mutiny` extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-rest-client-mutiny` エクステンションのおかげで、REST クライアントで Mutiny を使用することがこれまで以上に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation is our response to a recurring request from the community: having the ability to rollback changes made in a test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアノテーションは、コミュニティからの繰り返し要望のあった、テストで行われた変更をロールバックする機能への対応です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of annotating your test with `@Transactional` (which will persist the changes), annotate your test with `@TestTransaction` and the changes will be automatically rolled back at the end of the test.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストを (変更を持続させる) `@Transactional` でアノテーションするのではなく、テストを `@TestTransaction` でアノテーションすると、テストの最後に変更が自動的にロールバックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, you could only connect to one Redis instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは 1 つの Redis インスタンスにしか接続できませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with 1.9, you can connect to multiple instances.  Also Sentinel is now supported.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.9 からは、複数のインスタンスに接続できるようになりました。また、Sentinel にも対応しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Changes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now have a separate JAXP extension. Until now, it was intertwined with the JAXB extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAXP のエクステンションを別に用意するようになりました。今までは JAXB エクステンションと絡み合っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.22.Final and Hibernate Reactive to 1.0.0.Alpha10</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM が 5.4.22.Final に、Hibernate Reactive が 1.0.0.Alpha10 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] and https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkiverse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus wouldn't be as successful if it weren't for its extension ecosystem.  In the beginning, we were adding all extensions to the core Quarkus repository, but eventually it became too much of an overhead or just not always sensible to include an extension into the core.  Some have since then created their own repositories external to Quarkus, but others just never happened because not everyone wants the overhead of maintaining a build setup while in other cases we actually had an idea for an extension but not solidified enough yet to be included in core (and consequently failed to find other community members interested and eager to help).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションのエコシステムがなければ、Quarkus はこれほどの成功を収められなかったでしょう。当初は、すべてのエクステンションを Quarkus のコアリポジトリーに追加していました。しかし、最終的にはオーバーヘッドが大きすぎたり、エクステンションをコアに含めることが必ずしも賢明とは限らなくなってしまいました。それ以来、Quarkus の外部に独自のリポジトリーを作成した人もいますが、誰もがビルドセットアップを維持するためのオーバーヘッドを望んでいるわけではないので、それが実現しなかった人もいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse is a separate GitHub organization (https://github.com/quarkiverse) that offers:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkiverse は GitHub とは別の組織 (https://github.com/quarkiverse) で、以下を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inclusion in registry used by Quarkus tooling to browse extensions (i.e. code.quarkus.io, command line and IDE tools).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンション (code.quarkus.io、コマンドライン、IDEツールなど) を参照するための Quarkus ツールで使用されるレジストリーへの収録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bigger Community outreach and a great place to collaborate</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より大きなコミュニティのアウトリーチと素晴らしいコラボレーションの場</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to lead the development of an extension, see if it wasn't already https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[proposed on GitHub] or https://github.com/quarkusio/quarkus/issues/new/choose[create an Extension Proposal issue].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの開発をリードしたい場合は、 link:https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[GitHub でまだ提案されていないかどうか] を確認したり、 link:https://github.com/quarkusio/quarkus/issues/new/choose[エクステンションの提案課題を作成] してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A blog post is in the works and should give more details.  In the meantime, check out https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[the extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブログ記事を作成中ですので、そちらで詳細をお知らせします。それまでは、 link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[すでにあるエクステンション] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[378 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus コミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[378人のコントリビューター] がいます。一人一人に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.2.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.12.2.Finalは、バグの修正とドキュメントの改善を行ったメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a recommended upgrade for everyone using Quarkus 1.12.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、Quarkus 1.12を使用しているすべての人に推奨されるアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two important regressions fixed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つの重要なリグレッションの修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.2.Final fixes two important regressions that were introduced in 1.12.1.Final:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.12.2.Finalでは、1.12.1.Finalで発生した2つの重要なリグレッションが修正されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building native images on Windows was broken.  We added a CI check to be sure we don't break it again in the future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Windows でのネイティブイメージのビルドが壊れていました。今後、二度と壊れないように、CIチェックを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to OpenShift was also not working properly in 1.12.1.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.12.1.Finalでは、OpenShiftへのデプロイも正常に動作していませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.12.2.Final[the full changelog of 1.12.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.2.Final[GitHubに1.12.2.Finalの完全な変更履歴]は掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What’s nice about Extension codestarts is that it’s useful for fresh Quarkus developers as well as experienced ones. This is because of the wide range (and growing) of Quarkus extensions, you simply can’t know them all.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Extension codestartsの良い点は、新しくQuarkusを開発したばかりの開発者だけでなく、経験豊富な開発者にも役立つ点です。これは、Quarkusのエクステンションの範囲が広い(そして増え続けている)ため、すべてを知っていることが単純に不可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When I am comparing frameworks, I think that Doc is a very important factor, but I am also often pretty lazy when it comes to reading it... don't you?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フレームワークの比較をしていると、ドキュメントはとても重要な要素だと思うのですが、私もいざ読むとなるとかなり怠けてしまうとが多いです...あなたはどうですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By the way you can see that Quarkus is pretty well https://quarkus.io/guides/[documented,role=external,window=_blank].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ちなみにQuarkusはかなり https://quarkus.io/guides/[ガイド, role=external, window=_blank]が充実しているのがわかるかと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this feature, we tried to take it a step further and transform that boring learning part to the thing we love most *CODING*..</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この機能では、さらに一歩進んで、退屈な学習の部分を、私たちが最も好きな *コーディング* に変えようとしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting now, when you wish to try some new extensions, you directly have the code showing you their true power, ready to run in your favorite IDE in a matter of seconds!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今から、いくつかの新しいエクステンションを試してみたいときには、その真の力を示すコードが直接表示され、お気に入りのIDEであっという間に実行できるようになります!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this, using your chosen build tool (Maven, Gradle or also Gradle with Kotlin DSL) and your chosen language (Java, Kotlin or Scala).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらはすべて、選択したビルドツール(Maven、Gradle、またはKotlin DSLによるGradle)と選択した言語(Java、Kotlin、またはScala)を使用して行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Existing Extension codestarts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のエクステンションのコードスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already prepared examples for a dozen of extensions, you may spot them on https://code.quarkus.io[code.quarkus.io,role=external,window=_blank] (with the jet fighter icon).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちはすでに沢山のエクステンションの例を用意しており、 https://code.quarkus.io[code.quarkus.io, role=external, window=_blank](ジェット戦闘機のアイコンが付いている)で見ることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also find them on most of our Quarkus tooling:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Quarkusのほとんどのツールでも見つけることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI, it is still experimental, and we don't provide an installer yet. Still, you can easily try it using the amazing https://jbang.dev/[JBang,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus CLIは、まだ実験的なもので、インストーラーはまだ提供されていません。それでも、素晴らしい https://jbang.dev/[JBang, role=external, window=_blank]を使って簡単に試すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://quarkus.io/blog/march-of-ides/[IDE plugins,role=external,window=_blank] which support "Wizards w/code.quarkus.io"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"Wizards w/code.quarkus.io" をサポートする https://quarkus.io/blog/march-of-ides/[IDEプラグイン, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit of fun in some of our examples</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの例の中で、ちょっとした楽しみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>My favorite one is the new Qute example with a subatomic-particles generator :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私のお気に入りは、素粒子ジェネレーターを備えた新しいQuteのサンプルです :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;a=subatomic-particles-generator&amp;v=1.0.0-SNAPSHOT&amp;b=MAVEN&amp;s=xTN&amp;cn=code.quarkus.io[Here on code.quarkus.io,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;amp;a=subatomic-particles-generator&amp;amp;v=1.0.0-SNAPSHOT&amp;amp;b=MAVEN&amp;amp;s=xTN&amp;amp;cn=code.quarkus.io[code.quarkus.ioでは、以下のようになっています。, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the CLI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>With the CLI:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need more Extension codestarts!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もっとエクステンションのcodestartsが必要です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts are designed to make it easy and quick to provide new examples for extensions. So whether you are an extension owner, or you are keen to create an example for an extension you like, contributions are very welcome!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コードスタートは、エクステンションのための新しいサンプルを簡単かつ迅速に提供できるように設計されています。ですから、あなたがエクステンションの所有者の場合でも、あなたが好きなエクステンションの例を作りたい場合でも、貢献は大歓迎です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We provide https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[doc and tooling,role=external,window=_blank] for it, you may also https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[come and ping me (@ia3andy) on Zulip,role=external,window=_blank] for more info.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちはそれのための https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[ドキュメントとツール, role=external, window=_blank]を提供しています。 https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[チャットに来て、私(@ia3andy)にpingを打って, role=external, window=_blank] 詳細について聞くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, we focus on the https://github.com/quarkusio/quarkus/blob/master/extensions[core extensions,role=external,window=_blank], but we will make it available to the broader ecosystem soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところは https://github.com/quarkusio/quarkus/blob/master/extensions[コアなエクステンション, role=external, window=_blank]に焦点を当てていますが、近いうちにより広いエコシステムで利用できるようにする予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We just released our second Alpha for Quarkus 2.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0の2回目のアルファ版をリリースしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We had a lot of feedback and Continuous Testing got a lot of fixes and improvements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くのフィードバックがあり、継続的テストでは多くの修正や改善が行われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please keep the feedback coming!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引き続き、ご意見をお寄せください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have missed our Alpha1 announcement: here are link:/blog/quarkus-2-0-0-alpha1-released/[the main new features of Quarkus 2.0].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Alpha1の発表を見逃した方のために、 link:/blog/quarkus-2-0-0-alpha1-released/[Quarkus 2.0の主な新機能]をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will keep the Migration Guide up to date here: https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイグレーションガイドは、こちら: https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0 で随時更新していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, the documentation for our `main` branch is not available on the website yet.  It will be available soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところ、 `main` ブランチのドキュメントは、まだウェブサイトでは公開されていません。近いうちに公開される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most visible being a far improvement integration in the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最も顕著な変更は、Dev UIの統合が大幅に改善されたことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another notable one is the addition of `quarkus.test.type` which can be used to define which tests are run in continuous testing, `unit`, `quarkus-test` or `all`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう1つの注目すべき点は、 `quarkus.test.type` が追加されたことです。これは、継続的テストで実行するテストを `unit` 、 `quarkus-test` 、 `all` のいずれかに定義するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha2[2.0.0.Alpha2] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha2[2.0.0.Alpha2]の完全な変更履歴はGitHubに掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And here comes 1.13.7.Final, our (most probably!) last round of bugfixes for the 1.13 release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13リリースのための（おそらく！）最後のバグフィックスである1.13.7.Finalがやって来ました
。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.7.Final[the full changelog of 1.13.7.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.7.Final[1.13.7.Finalの完全な変更履歴はGitHub] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will soon start a new chapter with Quarkus 2.0.0.Final.  It should be released by the end of this month.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もうすぐQuarkus 2.0.0.Finalで新しい章が始まります。今月末にはリリースされる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information in https://groups.google.com/g/quarkus-dev/c/18Ocz1wtKjo/m/tuRVB97aAAAJ[the announcement].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は link:https://groups.google.com/g/quarkus-dev/c/18Ocz1wtKjo/m/tuRVB97aAAAJ[アナウンス]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please test your applications with our latest 2.0.0.CR3 and report back!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新の2.0.0.CR3でアプリケーションをテストして、報告してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Stylish API'
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: Swagger UI configuration and custom styling
author: phillipkruger
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: スタイリッシュAPI
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: SwaggerのUI設定とカスタムスタイリング
author: phillipkruger
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stylish API</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタイリッシュAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this blog post we are going to look at the new styling and other new options available in OpenAPI and Swagger UI Quarkus extensions (version 1.10+).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のブログ記事では、OpenAPIとSwagger UIのQuarkusエクステンション(バージョン1.10+)で利用できる新しいスタイリングやその他の新しいオプションについて見ていきたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the source code for the examples below is https://github.com/phillip-kruger/openapi-example[available here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の例のすべてのソースコードは、 https://github.com/phillip-kruger/openapi-example[ここ]にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Styling</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタイリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default style</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトスタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default style for Swagger UI has changed from the vanilla Swagger UI to a Quarkus branded page:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Swagger UIのデフォルトスタイルがバニラのSwagger UIからQuarkusブランドのページに変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post we mostly focus on Swagger UI, but the styling options also apply to the https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI] and the https://quarkus.io/guides/microprofile-health#health-ui[Health UI].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この記事では主に Swagger UI に焦点を当てていますが、スタイリングオプションは https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI]と https://quarkus.io/guides/microprofile-health#health-ui[Health UI] にも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テーマ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://ostranme.github.io/swagger-ui-themes/[Swagger UI Themes] are now available in configuration, with the default theme being 'feeling blue'.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://ostranme.github.io/swagger-ui-themes/[SwaggerのUIテーマ]が設定で利用できるようになり、デフォルトのテーマは「フィーリングブルー」になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the theme by setting the `quarkus.swagger-ui.theme` property, for example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、 `quarkus.swagger-ui.theme` プロパティーを設定することでテーマを変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also go back to the original (vanilla) Swagger UI theme:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、元の(バニラの)Swagger UIテーマに戻すこともできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme options available:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テーマのオプションが用意されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>feeling-blue (default)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>feeling-blue (default)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>flattop</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>flattop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>material</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>material</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>monokai</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>monokai</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>muted</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>muted</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>newspaper</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>newspaper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>outline</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>outline</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logo</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ロゴマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As part of the custom branding, you can supply your own logo to replace the Quarkus logo. For example, let's say you own a company that makes everything, ACME, and you are using REST Services for your online store, and wants to brand the Swagger UI Page:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>カスタムブランディングの一環として、Quarkusのロゴの代わりに独自のロゴを付与することができます。例えば、なんでも屋のACMEという会社を経営していて、オンラインストアにRESTサービスを利用していて、Swagger UIページをブランディングしたいとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme logo</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>acme logo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot reload is not working for logo changes, and remember browser cache, you might need to https://refreshyourcache.com/en/cache/[force refresh] your browser.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ホットリロードは、ロゴ変更には動作しません。とブラウザのキャッシュを覚えておいてください。ブラウザを https://refreshyourcache.com/en/cache/[強制的にリフレッシュする]必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To supply your own logo, you need to place a file called `logo.png` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>独自のロゴを提供するには、 `logo.png`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Style</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go further, and supply your own `style.css`, to fine-tune the branding. As an example, to change the `topbar` of the Swagger UI screen to fit the corporate colors of ACME:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、独自の `style.css`  を提供して、ブランディングを微調整することもできます。例として、Swagger UI画面の `topbar`  を ACME のコーポレートカラーに合わせて変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>here set the `topbar` background color.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは `topbar`  の背景色を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme css</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>acme css</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change any styling element in this css file, you need to place this file called `style.css` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このCSSファイルの中で、任意のスタイル要素を変更することができます。 `style.css`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other styling options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のスタイリングオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Along with other OpenAPI Header fields that can be set via configuration properties (as discussed in link:/blog/openapi-for-everyone/[this post]):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定プロパティーを介して設定できる他の OpenAPI Header フィールドと一緒に( /blog/openapi-for-everyone/[この記事]で説明しています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme footer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>acme footer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Swagger UI Options</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他のスワガーUIオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another new feature available in Quarkus (version 1.10+) is the ability to set any of the https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[configuration options] available in Swagger UI. As an example, we can set the `urls` and add the petstore (as the default selected option) to Swagger UI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus(バージョン1.10+)で利用できるもう一つの新機能は、Swagger UIで利用できる https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[設定オプション]を任意に設定できることです。例えば、 `urls`  を設定して、Swagger UI にペットストア(デフォルトで選択されているオプションとして)を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will change the `topbar` to have a dropdown box with the urls provided:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `topbar`  は、提供されたURLのドロップダウンボックスを持つように変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>petstore</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>petstore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example, `supportedSubmitMethods` can hide the `Try it out` button for certain HTTP Method Types:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別の例として、 `supportedSubmitMethods`  は特定の HTTP メソッドタイプに対して `Try it out`  ボタンを非表示にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note below the missing `Try it out` button on the `POST`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`POST` の `Try it out`  ボタンがなくなっていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try it out</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>try it out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the other Swagger UI options are now available to configure the UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のSwagger UIオプションはすべてUIの設定が可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other small new features</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その他の小さな新機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let me present you two small new features in OpenAPI and Swagger UI: the ability to add the Health Endpoints and the ability to disable the UI and/or Schema at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenAPIとSwagger UIの2つの小さな新機能を紹介します。Health Endpointsを追加する機能と、実行時にUIやSchemaを無効にする機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `smallrye-health` extension, you can add the Health Endpoints to OpenAPI:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`smallrye-health`  エクステンションを使用している場合は、OpenAPI にヘルスエンドポイントを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable at Runtime</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行時に無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you included the UI in your app (`quarkus.swagger-ui.always-include=true`), you can now disable it when starting the application.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリにUIが含まれている場合( `quarkus.swagger-ui.always-include=true` )、アプリ起動時にUIを無効にできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will return a *HTTP 404 (Not Found)* on the Swagger UI page.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは Swagger UI ページで *HTTP 404 (Not Found) を* 返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly you can disable the schema (usually under `/openapi`) by doing:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>同様に、以下のようにしてスキーマを無効にすることができます (通常は `/openapi`  の下にあります):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Conclusion</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.amqp.org/[AMQP 1.0] is a standard for passing messages between applications or organizations.  It connects systems, feeds business processes with the information they need, and reliably handles communication between systems.  AMQP is a robust and mature protocol widely used in event-driven applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.amqp.org/[AMQP 1.0] は、アプリケーションや組織間でメッセージを渡すための標準規格です。AMQP はシステムを接続し、ビジネスプロセスに必要な情報を供給し、システム間の通信を確実に処理します。AMQP は、イベント駆動型のアプリケーションで広く使用されている堅牢で成熟したプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post is the equivalent of the https://quarkus.io/blog/getting-started-kafka/[Kafka getting started post], but focuses on the usage of AMQP.  You will learn how to get started with AMQP in your Quarkus application in less than ten steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] - a declarative approach to building event-driven microservices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この投稿は、 link:https://quarkus.io/blog/getting-started-kafka/[Kafkaの入門記事] と同等の内容を説明しますが、AMQPの使用方法に焦点を当てています。QuarkusアプリケーションでAMQPを使い始める方法を10ステップ以内で学ぶことができます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub] から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Generate your project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ 1 - プロジェクトの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the very beginning, getting a new project structure with the right dependencies.  Go to https://code.quarkus.io, enter your group id and artifact id.  Then in the extension list, select:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初の一歩として、正しい依存関係を持つ新しいプロジェクト構造を取得してみましょう。 https://code.quarkus.io  にアクセスして、グループIDとアーティファクトIDを入力します。そして、エクステンションのリストで以下を選択します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Jackson</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project containing examples.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"Example Code" を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, click on __Generate your application__, download the project as a zip file, unzip it, and load it in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 _Generate your application_ をクリックして、プロジェクトをzipファイルとしてダウンロードし、解凍して、お気に入りのIDEにロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-amqp` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-amqp` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。なのでコードを書く準備が出来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 2 - What are we going to exchange?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ2 - 何を交換するか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need something to exchange.  Without much originality, let's say we will send and receive `Movie` objects.  In your project, create the `org.acme.Movie` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>交換するものが必要です。あまりオリジナリティを持たずに、 `Movie` オブジェクトを送受信するとしましょう。プロジェクトの中で、以下の内容の `org.acme.Movie` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With AMQP, we exchange http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[messages], which can have multiple _data_ sections (or multiple AMQP sequences, or a single AMQP value section).  In our application, as we are exchanging `Movie` object, it encodes the instances as JSON and transfers it in a single _data_ section.  The `content-type` header is set to `application/json`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQPでは、複数の _データ_ セクション(または複数のAMQPシーケンス、または単一のAMQP値セクション)を持つことができる link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[メッセージ] を交換します。私たちのアプリケーションでは、 `Movie` オブジェクトを交換しているので、インスタンスを JSON としてエンコードし、単一の _データ_ セクションで転送しています。 `content-type` ヘッダは `application/json` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP messages are sent to a destination.  To keep things simple, let's name it __movies__.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>AMQPメッセージを送信先に送信します。簡単にするために、 __movies__ という名前にしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 3 - Configure the application</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ3 - アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  We must indicate that our reception and publication channels will use the __movies__ address in our application.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の通り、Reactive Messagingを使用します。リアクティブメッセージングを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、設定によって基礎となるメッセージング技術にマッピングされます。受信および公開チャンネルがアプリケーションで __movies__ アドレスを使用することを示す必要があります。 `src/main/resources/application.properties` で、次の内容を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location and credentials (`amqp-` properties), we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブローカーの場所と資格情報( `amqp-` プロパティー)を設定した後、 `movies-in` (レコードを受信)と `movies-out` (レコードを公開)の2つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the AMQP connector.  We also need to specify the consumed destination using the `address` attribute.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>チャンネルの設定には、 `mp.messaging.incoming.movies-in` というプレフィックスを使用します。 `connector` 属性は、このチャネルの責任者(ここでは AMQP コネクタ)を示します。また、 `address` 属性を使用して、消費先を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicating who's responsible for that channel, we also need to configure the address.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` プレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、アドレスも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to AMQP</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ4 - AMQPへのムービーの公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send messages.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、いよいよメッセージを送信する時が来ました。以下の内容で `org.acme.MovieProducer` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter,` i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and will send messages to AMQP).  The connector automatically encoded the content as JSON and set the `content-type` header.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクラスでは、 `Emitter,` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (AMQP にメッセージを送信します)。コネクタは自動的にコンテンツを JSON としてエンコードし、 `content-type` ヘッダを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to make sure your payload can be encoded to JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ペイロードが JSON にエンコードできることを確認する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can use the `send` method to send a movie to our AMQP destination.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、私たちのアプリケーションの残りの部分は、 `send` メソッドを使用して、AMQP の宛先にムービーを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 5 - Consuming movies</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ5 - 映画を消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from AMQP.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今度は反対側に目を向けて、AMQPからムービーを取得してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here, we use the `@Incoming` annotation to indicate to Quarkus to call the `receive` method for every received record.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、 `@Incoming` アノテーションを使用して、受信したレコードごとに `receive` メソッドを呼び出すようにQuarkusに指示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, the movie is encoded into JSON, so we need to help the connector produce a `Movie` from the received JSON.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ムービーは JSON にエンコードされていることを思い出してください。コネクタが受信した JSON から `Movie` を生成するのを支援する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `org.acme.JsonToObjectConverter` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の内容の `org.acme.JsonToObjectConverter` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class is a _converter_.  It maps the content of a `Message` to another type.  In the `canConvert` method, we verify that the incoming message is coming from AMQP (so contain the `IncomingAmqpMetadata` metadata) and that the content-type is set to `application/json`.  The `convert` method maps the received `JsonObject` into the target type (`Movie` in our case).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクラスは _converter_ です。 `Message` の内容を別の型にマッピングします。 `canConvert` メソッドでは、受信メッセージが AMQP からのものであること (つまり `IncomingAmqpMetadata` メタデータを含むこと) と、content-type が `application/json` に設定されていることを確認します。 `convert` メソッドは、受信した `JsonObject` をターゲット型 (私たちの場合は `Movie` ) にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this converter, our `consume` method will receive the `Movie` objects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコンバータにより、 `consume` メソッドは `Movie` オブジェクトを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 6 - Sending movies from a REST endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ6 - RESTエンドポイントからのムービーの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to AMQP from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTエンドポイントからAMQPにメッセージを送信することはよくあることです。これを行うには、以下の内容で `org.acme.MovieResource` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class uses the `MovieProducer` we implemented above to send the `movies`.  You could also use an `Emitter` directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクラスは、上で実装した `MovieProducer` を使用して `movies` を送信します。 `Emitter` を直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 7 - Let's get this running!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ7 - これを実行してみましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need an AMQP broker, for example http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis].  You can follow the http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] documentation, or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、AMQPブローカー、例えば link:http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis] が必要です。 link:http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] のドキュメントに従うか、以下の `docker-compose.yaml` ファイルを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d'</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します: `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, run the application using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、アプリケーションを次のように実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application runs in dev mode, meaning that you can still update the code.  It will reload it automatically.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションはdevモードで動作します。つまり、コードをまだ変更することが出来、変更した場合、自動的にリロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, emit a few HTTP POST request such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別の端末で、次のようなHTTP POSTリクエストをいくつか送信します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the terminal running the application, you will see:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを実行しているターミナルでは、以下のように表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It works!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>動いています!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 8 - Native packaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ8 - ネイティブパッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://quarkus.io/guides/building-native-image[GraalVM installed and configured correctly], you can package this application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://quarkus.io/guides/building-native-image[GraalVMが正しくインストールされ、設定されている場合] 、このアプリケーションをネイティブの実行ファイルとしてパッケージ化することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using AMQP starting in a few milliseconds and consuming a ridiculous amount of memory: only 33Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、AMQPを使用したQuarkusアプリケーションが数ミリ秒で起動し、とんでもない量:100レコードを取り込んでもたったの33MB!になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using AMQP.  If you want to go further, check the https://quarkus.io/guides/amqp[AMQP guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>10分もしないうちに、AMQPを使った新しいQuarkusアプリケーションができました。もっと詳しく知りたい方は、 link:https://quarkus.io/guides/amqp[AMQPガイド] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is with a bit of emotion that I announce today the release of Quarkus 2.0.0.Alpha1.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、Quarkus 2.0.0.Alpha1のリリースを少しの感慨を持って発表したいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As previously presented, Quarkus 2.0 is in the continuity of Quarkus 1.x and won't require too many changes on your side.  But we consider it a major release as major parts of our infrastructure have changed:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以前に紹介したように、Quarkus 2.0はQuarkus 1.xの連続性の中にあり、ユーザー側ではあまり多くの変更を必要としません。しかし、インフラの主要部分が変更されたため、メジャーリリースと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.0 is also a good moment to bring new features that, we believe, could change your daily coding for the better.  The first one to come to life is called Continuous Testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2.0は、日々のコーディングをより良いものに変えてくれると信じている新機能を提供する良い機会でもあります。最初に登場するのは、「継続的テスト」と呼ばれるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have applications using Quarkus 1.x, please give a try to Quarkus 2.0 and report any issue you could experience on GitHub, be it in terms of bugs, broken compatibility or usability.  We are in this together to build the best Quarkus release ever.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.xを使ったアプリケーションをお持ちの場合は、ぜひQuarkus 2.0を試してみてください。また、バグや互換性の低下、使い勝手など、何か問題があればGitHubに報告してください。私たちは、これまでで最高のQuarkusリリースを作るために一緒に取り組んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release contains an Alpha implementation of Continuous Testing. This allows tests to be run in development mode, and can be enabled by pressing 'e' in the console (or through the Dev UI). If you enable testing, your test suite will be run once at the start, and then continuous testing will run your tests as you are coding, and tell you if your changes will break any tests. This will give you instant feedback on your changes, without having to switch to a browser. As much as possible we only run tests that are relevant to the code that has been changed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このリリースには、継続的テストのアルファ版の実装が含まれています。これにより、開発モードでもテストを実行できるようになり、コンソールで「e」を押すことで（または Dev UI で）有効にすることができます。テストを有効にすると、テストスイートは最初に一度だけ実行され、その後はコーディング中に継続的テストがテストを実行し、変更によってテストが壊れるかどうかを教えてくれます。これにより、ブラウザに切り替えることなく、変更内容を即座にフィードバックすることができます。可能な限り、変更されたコードに関連するテストのみを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an Alpha release and there are some known limitations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはアルファリリースであり、いくつかの既知の制限があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The docs are not done yet (stay tuned for an upcoming blog post)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントはまだ完成していません (次回のブログ記事をお楽しみに)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an alpha quality feature, so please try it out and if you have any feedback let us know on the mailing list, and file a GitHub issue for any problems you encounter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはアルファ・フェーズの機能であり、是非試して、何かフィードバックがあればメーリングリストでお知らせください、何か問題が発生した場合はGitHub に課題登録ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha1[2.0.0.Alpha1] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha1[2.0.0.Alpha1]の完全な変更履歴はGitHubでご覧いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org/[Apache] Kafka is a prevalent distributed streaming platform offering a unique set of characteristics such as message retention, replay capabilities, consumer groups, and so on.  Kafka is highly scalable, fault-tolerant, and is becoming the spine of many modern systems.  That being said, Kafka is not the only one out there, and choosing the right messaging technology for your application can be challenging.  There are many articles to help you drive your decision, such as https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[this one].  This post is about Kafka, and an equivalent post about AMQP will be published later.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://kafka.apache.org/[Apache Kafka] は、メッセージの保持、再生機能、コンシューマーグループなどのユニークな特性を提供する分散型ストリーミングプラットフォームとして広く普及しています。Kafka は非常に拡張性が高く、耐障害性に優れており、多くの近代的なシステムの要になりつつあります。とはいえ、Kafka単体で存在するものではなく、アプリケーションに適したメッセージング技術を選択するのは難しいことです。 link:https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[このリンク先] のように、あなたの決定を後押しするために役立つ記事がたくさんあります。この記事は Kafka についてのもので、AMQP についての同等の記事は後日公開される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, you will learn how to get started with Apache Kafka in your Quarkus application in less than 10 steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] - a declarative approach to build event-driven microservices, but you can also use _bare_ Kafka APIs or Kafka Streams.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この投稿では、QuarkusアプリケーションでApache Kafkaを10ステップ未満で使い始める方法を学びます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] を使用しますが、 _ベア_ Kafka APIやKafka Streamsを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub]から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project to contain examples.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>"Example Code"を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-kafka` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-kafka` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, we produce and consume records.  A record contains a key and a value.  Let's say we will use the movie's publication year as key and the title as value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka では、レコードを生成、消費します。レコードにはキーと値が含まれています。例えば、映画の公開年をキーにして、タイトルを値にするとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to decide on which topic we are going to send these records.  Let's keep things simple and name our topic __movies__.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、これらのレコードを送信するトピックを決める必要があります。単純化して、トピックを _movies_ としましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  In our application, we must indicate that our reception and publication channels will use the __movies__ Kafka channel.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上記の通り、Reactive Messagingを使用します。Reactive Messagingを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、基礎となるメッセージング技術に設定によってマッピングされます。このアプリケーションでは、受信および配信チャンネルが _movies_ Kafkaチャンネルを使用することを指定する必要があります。 `src/main/resources/application.properties` で、以下の内容を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location with `kafka.bootstrap.servers`, we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブローカーの場所を `kafka.bootstrap.servers` で設定した後、 `movies-in` (レコードを受信)と `movies-out` (レコードを配信)の 2 つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the Kafka connector.  We also need to configure the key and value deserializers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`mp.messaging.incoming.movies-in` というプレフィックスを使ってチャネルを設定します。 `connector` 属性は、このチャネルを担当するコネクタ (ここでは Kafka コネクタ) を示しています。また、キーと値のデシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicate who's responsible for that channel, we also need to configure the key and value serializers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` のプレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、キーと値のシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to Kafka</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ 4 - Kafkaにムービーを公開する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send a record to Kafka.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、いよいよKafkaにレコードを送信します。以下の内容で `org.acme.MovieProducer` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter`, i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and so will send messages to Kafka).  We are sending `Record` objects containing the movie's publication year as key and its title as value.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このクラスでは、 `Emitter` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (つまり、Kafka にメッセージを送信します)。映画の公開年をキーに、タイトルを値にして `Record` オブジェクトを送信しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can simply use the `sendMovieToKafka` method to send a movie to our Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、残りのアプリケーションは `sendMovieToKafka` メソッドを使って、Kafka トピックにムービーを送信するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from Kafka.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今度は反対側に目を向けて、Kafkaからムービーを取り出してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to Kafka from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST エンドポイントから Kafka にメッセージを送信することはよくあることです。そのためには、以下のような内容の `org.acme.MovieResource` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need a Kafka broker.  You can follow the https://kafka.apache.org/quickstart[Apache Kafka quickstart], or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、まずはKafkaブローカーが必要です。 link:https://kafka.apache.org/quickstart[Apache Kafka のクイックスタート] に従うか、以下の `docker-compose.yaml` ファイルを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します: `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using Kafka starting in a few milliseconds and consuming a ridiculous amount of memory: less than 30Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、Kafkaを使用したQuarkusアプリケーションが数ミリ秒で起動し、消費するメモリー量はとんでもない量:100レコードを取り込んでも30MB未満!になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using Apache Kafka.  If you want to go further, check the https://quarkus.io/guides/kafka[Kafka guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>10分もしないうちに、Apache Kafkaを使った新しいQuarkusアプリケーションができました。さらに進みたい場合は、 link:https://quarkus.io/guides/kafka[Kafkaガイド]をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 2.0.0.CR3 released - Towards Final'
date: 2021-06-04
tags: release
synopsis: We fixed some more issues in this CR. Final is coming at the end of June.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: 'Quarkus 2.0.0.CR3リリース - Finalに向けて'
date: 2021-06-04
tags: release
synopsis: 今回のCRでは、さらにいくつかの問題を修正しました。最終版は6月末にリリースされます。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to your feedback, we fixed some more issues in Quarkus 2.0 and we thought a new CR was necessary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィードバックのお陰で、Quarkus 2.0ではさらにいくつかの問題を修正し、新しいCRが必要だと考えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, it also comes with documentation refinements.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いつものように、ドキュメントの改善も施されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will build the Final artifacts on June 23rd so keep the feedback coming!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>6月23日に最終アーティファクトを作成しますので、フィードバックをお待ちしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We keep the Migration Guide up to date here: https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新のマイグレーションガイドはこちらです: https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the Jandex Maven plugin or the Jandex Gradle plugin in your applications, you need to update them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションでJandex MavenプラグインやJandex Gradleプラグインを使用している場合は、それらをアップデートする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0#jandex-upgrade[migration guide] for the details.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-2.0#jandex-upgrade[移行ガイド]をご参照ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The documentation for the `main` branch is available link:/version/main/guides/[on the website].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`main` ブランチのドキュメントは link:/version/main/guides/[ウェブサイト] で公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR3[2.0.0.CR3] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR3[2.0.0.CR3]の完全な変更履歴はGitHubに掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.3.0 release of Quarkus Tools for IntelliJ.  This release brings codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Tools for IntelliJの1.3.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードにcodestartsのサポートが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Codestarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard adds a new codestarts option, allowing to enable/disable codestarts generation for Quarkus extensions that support this feature.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトウィザードに新しいcodestartsオプションが追加され、この機能をサポートするQuarkusエクステンションのcodestarts生成を有効/無効にすることができるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-tools1.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-tools1.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We just started the candidate release cycle for 2.0.0.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2.0.0.Finalの候補リリースサイクルを開始しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feedback is very welcome so if you have a Quarkus app around, please give it a go.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フィードバックをお待ちしておりますので、Quarkusのアプリをお持ちの方はぜひお試しください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you update both the BOM version and the Quarkus Maven Plugin version to 2.0.0.CR2.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>BOMのバージョンとQuarkus Maven Pluginのバージョンの両方を2.0.0.CR2にアップデートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, we only publish the `quarkus-bom` for non-Final releases so make sure you use this BOM and not the `quarkus-universe-bom` for testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、最終版以外のリリースでは `quarkus-bom` のみを公開していますので、テスト用には `quarkus-universe-bom` ではなく、このBOMを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We noticed a last minute issue with IDEs today related to a new annotation processor we introduced.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>導入した新しいアノテーションプロセッサに関連して、本日、直前になってIDEで問題が発生しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The workaround for now is to disable annotation processors in your IDE (that might not work very well if you're using others though).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところの回避策は、IDEでアノテーションプロセッサを無効にすることです（他のものを使用している場合は、あまりうまくいかないかもしれません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, for Eclipse users, you can add the `&lt;m2e.apt.activation&gt;disabled&lt;/m2e.apt.activation&gt;` property in your POM file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、Eclipseユーザーの場合は、POMファイルに `&lt;m2e.apt.activation&gt;disabled&lt;/m2e.apt.activation&gt;` プロパティを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyway, this issue shouldn't prevent you from testing your existing applications and will be fixed in our Final release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いずれにしても、この課題は既存のアプリケーションのテストを妨げるものではなく、最終リリースで修正される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR1[2.0.0.CR1] https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR2[2.0.0.CR2] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR1[2.0.0.CR1] link:https://github.com/quarkusio/quarkus/releases/tag/2.0.0.CR2[2.0.0.CR2]の完全な変更履歴はGitHubでご覧いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a https://quarkus.io/blog/kafka-failure-strategy/[previous blog post], we have looked at failure strategies provided by the Reactive Messaging Kafka connector.  But, imagine it's our lucky day, and for once it worked.  We should inform Kafka that the processing succeeded.  In Kafka terminology, we call this: _offset commit_.  This post covers the different strategies to commit offsets with the Reactive Messaging Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://quarkus.io/blog/kafka-failure-strategy/[以前のブログ記事]では、Reactive Messaging Kafkaコネクタが提供する失敗戦略を見てきました。しかし、想像してみてください、それは幸運な日で、一度だけ成功しました。処理が成功したことをKafkaに知らせなければなりません。Kafkaの用語では、これを _オフセットコミット_ と呼びます。この記事では、Reactive Messaging Kafka コネクタを使ったオフセットコミットのさまざまな戦略について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Kafka Consumer Group and Offsets</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafkaコンシューマーグループとオフセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka organizes records (_i.e._ messages) around _topics_.  Each topic has a name, and applications send records to topics and poll records from topics.  So far, nothing out of the ordinary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka は、 _トピックを_ 中心にレコード ( _即ち_ メッセージ) を整理します。各トピックには名前があり、アプリケーションはトピックにレコードを送り、トピックからレコードをポーリングします。今のところ、特別なことは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Topics are divided into partitions.  Each partition is an ordered, immutable sequence of records.  Sending a message to a topic appends it to the selected partition.  Each message from a partition gets a sequential id number called _offset_.  It uniquely identifies each message within the partition.  So, with Kafka, you can identify an individual record using a `&lt;topic, partition, offset&gt;` tuple.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>トピックはパーティションに分割されます。各パーティションは、順序立てられた不変のレコードのシーケンスです。トピックにメッセージを送信すると、選択したパーティションにメッセージが追加されます。パーティションからの各メッセージは、 _offset_ と呼ばれる連続した ID 番号を取得します。これはパーティション内の各メッセージを一意に識別します。つまり、Kafka を使うと、 `&lt;topic, partition, offset&gt;` タプルを使って個々のレコードを識別することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an application consumes messages from Kafka, it uses a Kafka consumer.  With this consumer, it polls batches of messages from a specific topic, for example, `movies` or `actors`.  Retrieved messages belong to partitions assigned to this consumer.  And that aspect is essential.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションが Kafka からのメッセージを消費するとき、アプリケーションは Kafka コンシューマを使用します。このコンシューマでは、特定のトピック、例えば `movies` や `actors` などからのメッセージのバッチをポーリングします。取得したメッセージは、このコンシューマに割り当てられたパーティションに属します。そして、この点が重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumers belong to a consumer group, identified with a name (`A` and `B` in the picture above).  A group contains one or more consumers.  In general, when you scale up your application, it creates a consumer joining the same group.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンシューマーは、名前(上の図では `A` と `B` )で識別されるコンシューマーグループに属しています。1 つのグループには 1 つ以上のコンシューマーが含まれます。一般的に、アプリケーションをスケールアップすると、同じグループに参加するコンシューマーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each consumer group receives each record from a topic once.  To achieve this, it assigns each consumer from a group to a set of partitions.  For example, in the above picture, the consumer from the application A1 receives the records from the partitions 0 and 1.  A2 receives the records from the partition 2.  App B is the only consumer from its consumer group.  So, it gets the records from all three partitions.  Consequently (ignore rebalance or other subtilities for now), each record from a topic is only received once per consumer group, by a specific consumer from that group.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各コンシューマーグループは、トピックから各レコードを一度だけ受け取ります。これを実現するために、グループからの各コンシューマーをパーティションのセットに割り当てます。例えば、上の図では、アプリケーションA1のコンシューマーはパーティション0と1からレコードを受信し、A2はパーティション2からレコードを受信します。アプリBは、そのコンシューマグループからの唯一のコンシューマーです。したがって、3つのパーティションすべてからレコードを取得します。したがって、(今のところリバランスや他のサブユーティリティーは無視して)あるトピックの各レコードは、そのグループの特定のコンシューマーによって、コンシューマーグループごとに 1 回だけ受信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To orchestrate each consumer group's progress, each consumer periodically informs the broker of its current position - the last processed offset.  It commits the offset, indicating that all the previous records from that partition have been processed.  So, if a consumer stops and comes back later, it restarts from the last committed position (if assigned to that partition again).  Note that this behavior is configurable.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各コンシューマーグループの進捗を調整するために、各コンシューマーは定期的に現在の位置、つまり最後に処理されたオフセットをブローカに通知します。コンシューマは、そのパーティションの以前のレコードがすべて処理されたことを示すオフセットをコミットします。つまり、あるコンシューマーが停止して後で戻ってきた場合、最後にコミットされた位置から再スタートします(再びそのパーティションに割り当てられた場合)。この動作は設定可能であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's important to notice is the periodic aspect of the commit.  Offset commit is expensive, and to enhance performance, we should not commit the offset after each processed record.  In this regard, Kafka behaves differently from traditional messaging solutions, such as JMS, which acknowledges each message individually.  Another important characteristic is the positional aspect of the commit.  You commit the position indicating that all the records located before that position are processed.  But is it really the case?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>注目すべきは、コミットの周期的な側面です。オフセットコミットはコストがかかるので、パフォーマンスを向上させるためには、処理された各レコードの後にオフセットをコミットするべきではありません。この点で、Kafkaは、JMSのような従来のメッセージングソリューションとは異なる振る舞いをしており、各メッセージを個別に認識します。もう一つの重要な特徴は、コミットの位置的な側面です。位置をコミットすると、その位置より前にあるすべてのレコードが処理されることを示します。しかし、本当にそうなのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>### The Kafka default behavior</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka のデフォルトの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Apache Kafka consumer uses an auto-commit approach by default.  Applications using such a consumer are structured around a polling loop:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Apache Kafka のコンシューマーはデフォルトで自動コミットアプローチを使用しています。このようなコンシューマを使うアプリケーションはポーリングループを中心に構成されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a program polls a batch of records, processes them, and then polls the next set.  While calling the `poll` method, the consumer periodically commits the last offset of the previous batches transparently.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなプログラムは、レコードのバッチをポーリングして処理し、次のセットをポーリングします。 `poll` メソッドを呼び出している間、コンシューマーは定期的に前のバッチの最後のオフセットを透過的にコミットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite nice, right? If the application fails to process a message, it throws an exception, which either interrupts the while loop or is handled gracefully (within the `processRetrievedRecords` method).  In the first case, it means that it won't commit anymore (as it happens in the `poll` method, not called anymore).  If the application restarts, it resumes from the last committed offset (or apply the `auto.offset.reset` strategy, defaulting to `latest`, if there are no offsets for this group yet).  It may re-process a set of messages (it's the application's responsibility to handle duplicates), but at least nothing is lost.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なかなかいいですよね?アプリケーションがメッセージの処理に失敗した場合、アプリケーションは例外をスローし、while ループを中断するか、( `processRetrievedRecords` メソッド内で) 優雅に処理されます。最初のケースでは、それはもうコミットしないことを意味します( `poll` メソッド内で発生するので、もう呼ばれません)。アプリケーションが再起動した場合、最後にコミットされたオフセットから再開します (または `auto.offset.reset` ストラテジーを適用し、このグループのオフセットがまだない場合は `latest` をデフォルトとして使用します)。一連のメッセージを再処理するかもしれませんが(重複を処理するのはアプリケーションの責任です)、少なくとも何も失われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, is there anything wrong with this? Looks wonderful... until you add a pinch of asynchrony.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それで、これに何か問題があるの?見た目は素晴らしい...非同期のピンチを追加するまでは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What if the message's processing is asynchronous</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## メッセージの処理が非同期の場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the message processing is asynchronous (offloaded to another thread, use non-blocking I/O...), failures may not interrupt the while loop from above.  Failure happens asynchronously, outside the polling thread.  If the `poll` method gets called again despite a failed processing, and _auto-commit_ is still enabled, we may commit offsets while something wrong happened.  If some processing of previously retrieved records is not completed yet, while this auto commit happens, it may consider the record as processed correctly, but the outcome is unknown at that point.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージ処理が非同期(他のスレッドにオフロードされている、ノンブロッキングI/Oを使用している...)であれば、失敗は上からwhileループを中断しないかもしれません。失敗はポーリングスレッドの外で非同期に起こります。処理に失敗したにもかかわらず `poll` メソッドが再び呼び出され、 _オートコミット_ がまだ有効になっている場合、何か間違ったことが起こっている間にオフセットをコミットすることがあります。このオートコミットが発生している間に、以前に取得したレコードの処理がまだ完了していない場合、そのレコードは正しく処理されたとみなされるかもしれませんが、その時点では結果はわかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So to handle these case, we can disable the auto-commit and switch to manual commit.  In this case, it's the application's responsibility to commit the offsets regularly.  So, the application needs to track the polled records, their processing, failures, and periodically commits the offsets.  It might not look too tricky, but actually, it can become quite challenging.  Again, in asynchronous scenarios, you may complete the processing of messages in various orders.  For example, if you call a remote service for each record, the responses may not come in the same orders as the records.  You need to track messages individually and only commit the offsets if all the previous messages are processed successfully.  Without this, you may commit offsets while there is processing from previous records still in progress or even failed processing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、これらのケースを処理するために、自動コミットを無効にして手動コミットに切り替えることができます。この場合、定期的にオフセットをコミットするのはアプリケーションの責任です。したがって、アプリケーションはポーリングされたレコード、その処理、失敗を追跡し、定期的にオフセットをコミットする必要があります。これはそれほどトリッキーには見えないかもしれませんが、実際には非常に困難になることがあります。繰り返しになりますが、非同期のシナリオでは、様々な順序でメッセージの処理を完了させることができます。例えば、各レコードに対してリモートサービスを呼び出した場合、レスポンスはレコードと同じ順番で来るとは限りません。メッセージを個別に追跡し、前のすべてのメッセージが正常に処理された場合にのみオフセットをコミットする必要があります。これがないと、前のレコードからの処理がまだ進行中であったり、処理に失敗した場合にオフセットをコミットすることになるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What can we do about this?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはどうしたらいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, you entered an asynchronous world.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Messaging と Kafka コネクタを使用すると、非同期の世界に入りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message processing may not happen synchronously and sequentially.  When a Reactive Messaging `Message` processing completes, it acknowledges the message.  In the case of processing failures, it sends a negative acknowledgment.  The Kafka connector receives these acknowledgments and can decide what needs to be done, basically: to commit or not to commit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メッセージ処理は、同期的・逐次的に行われるとは限りません。リアクティブメッセージング `Message` 処理が完了すると、メッセージを確認します。処理に失敗した場合は、否定的な確認応答を送信します。Kafka コネクタはこれらの確認応答を受信して、コミットするかしないかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can choose among three strategies:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>3つの戦略から選択することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ignore (default if `enabled.auto.commit=true` is set)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>無視 ( `enabled.auto.commit=true` が設定されている場合のデフォルト)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is configured using the `commit-strategy` attribute:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは `commit-strategy` 属性を使用して設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The throttled strategy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## スロットル化された戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The throttled strategy can be seen as an asynchronous variant of the default "auto-commit" behavior described above.  When enabled, the connector tracks each received message and monitors their acknowledgment.  When the connector finds out that all messages before a position are processed successfully, it commits that position.  This commit happens periodically to avoid committing too often.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スロットル戦略は、上述のデフォルトの「オートコミット」動作の非同期的な変形として見ることができます。有効にすると、コネクタは受信した各メッセージを追跡し、その確認応答を監視します。コネクタは、あるポジションの前のすべてのメッセージが正常に処理されたことを確認すると、そのポジションをコミットします。このコミットは、頻繁にコミットしないように定期的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy provides very good throughput and can handle asynchronous processing.  To enable this strategy configures the channel with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このストラテジーは非常に優れたスループットを提供し、非同期処理を処理することができます。このストラテジーを有効にするには、チャネルを以下のように設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one detail to mention.  If an old message is neither acked nor nacked, the strategy cannot commit the position anymore.  It will enqueue messages forever, waiting for that missing ack to happen.  It can lead to out of memory, as the connector would never be able to commit a position and to clear the queue.  Fortunately, the strategy detects this situation and reports a failure to the connector, marking the application unhealthy.  The `throttled.unprocessed-record-max-age.ms` attribute configures the deadline for each message to be acked or nacked before being considered as a poison pill (Default is 1 minute).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一つだけ注意すべき点があります。古いメッセージが ack されず、nack されない場合、ストラテジーはもうポジションをコミットすることができません。それは永遠にメッセージをエンキューし、その欠落したアックが起こるのを待ちます。これは、コネクタがポジションをコミットしてキューをクリアすることができなくなるため、メモリー不足につながる可能性があります。幸いなことに、このストラテジーはこの状況を検出してコネクタに失敗を報告し、アプリケーションが不健全であることをマークします。 `throttled.unprocessed-record-max-age.ms` 属性は、ポイズンピルとみなされる前に、各メッセージが ack されるか nacked されるかの期限を設定します (デフォルトは 1 分です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses this strategy by default if you explicitly enabled Kafka's auto-commit (with the `enable.auto.commit` attribute set to `true`).  In this case, the connector ignores acknowledgment and won't commit the offsets.  The Kafka consumer commits the offset periodically when polling batches, as described above.  This strategy works well if the message processing is synchronous and failures handled gracefully.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka の自動コミットを明示的に有効にした場合 ( `enable.auto.commit` 属性を `true` に設定した場合)、コネクタはデフォルトでこのストラテジーを使用します。この場合、コネクタは確認応答を無視してオフセットをコミットしません。Kafka コンシューマは、前述のように、バッチをポーリングする際に定期的にオフセットをコミットします。この方法は、メッセージ処理が同期的で、失敗があっても潔く処理される場合に有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable this strategy by configured enabled-auto-commit to true:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>enabled-auto-commitをtrueに設定することで、このストラテジーを有効にすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that starting Quarkus 1.9, auto commit is disabled by default. So you need to explicitly enable it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.9からは、オートコミットがデフォルトで無効になっていることに注意してください。そのため、明示的に有効にする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't enable auto-commit, using this strategy is still possible but will never commit the offsets.  In other words, you would restart from the oldest stored records every time.  While there are use cases for this, double-check that's what you want. In this case, enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オートコミットを有効にしていない場合、この戦略を使用することは可能ですが、オフセットをコミットすることはありません。言い換えれば、保存されている最も古いレコードから毎回再起動することになります。これにはユースケースがありますが、あなたが望むものであることを再確認してください。当てはまる場合、以下のようにこのストラテジーを有効にします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The latest strategy</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 最新の戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy commits the offset every time a message is acknowledged.
This strategy tends to commit often, and so decrease the throughput.   
However, it also reduces the risk of duplicates if the messages are processed synchronously. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このストラテジーは、メッセージが確認されるたびにオフセットをコミットします。
このストラテジーは頻繁にコミットする傾向があるため、スループットが低下します。
しかし、メッセージが同期的に処理されている場合には、重複のリスクを減らすことができます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この戦略を有効にするのは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, use the `throttled` strategy.  It provides high-throughput and handles the asynchronous use cases.  This strategy is becoming the default strategy in Quarkus 1.10.  You can also switch to the `ignore` strategy if the Kafka auto-commit is acceptable for you, or if you want to skip offset commit altogether.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的には、 `throttled` 戦略を使用します。これはハイスループットを提供し、非同期のユースケースを処理します。このストラテジーは、Quarkus 1.10ではデフォルトのストラテジーになっています。また、Kafkaのオートコミットが許容できる場合や、オフセットコミットを完全にスキップしたい場合は、 `ignore` 戦略に切り替えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That concludes this blog post.  The next one will discuss how to receive and produce Cloud Events using the Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上でこのブログ記事は終了です。次回は、Kafkaコネクタを使ってクラウドイベントを受信して生成する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: Next Monday (8th Feb 21), we will do Quarkus Insights based on your questions.
author: maxandersen
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: 来週の月曜日(2月8日)は、ご質問をもとにQuarkus Insightsを行います。
author: maxandersen
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the next Quarkus Insights episode, we are trying something new.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のQuarkus Insightsのエピソードでは、新しいことを試しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will cover the most often asked questions we have seen and any question tagged with `#quarkusinsights` on our various social media presences: https://twitter.com/search?q=%23quarkusinsights[Twitter], https://www.facebook.com/hashtag/quarkusinsights/[Facebook], https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] or on the https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtube event] directly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは、私たちが見てきた最も頻繁に質問された質問や、私たちの様々なソーシャルメディアで `#quarkusinsights` とタグ付けされた任意の質問をカバーします( link:https://twitter.com/search?q=%23quarkusinsights[Twitter] 、 link:https://www.facebook.com/hashtag/quarkusinsights/[Facebook] 、 link:https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] 、または link:https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtubeイベント] で直接)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a question about Quarkus you would like answered let us know on one of thoses sites.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>答えてほしいQuarkusに関する質問がある場合は、以下のいずれかのサイトでお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See you all Monday!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>月曜日にお会いましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.1.Final released - Bugfixes'
date: 2021-01-27
tags: release
synopsis: 1.11.1.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.11.1.Finalリリース - バグフィックス
date: 2021-01-27
tags: release
synopsis: 1.11.1.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.11.1.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it allowed us to make steady progress on fixing issues.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題点を報告し、再現手順を提供してくれたすべての貢献者に感謝します。問題の修正の確かな進捗に繋がりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also a big thanks to all the contributors providing pull requests, be they for the code or the documentation!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、コードであれドキュメントであれ、プルリクエストを提供してくれたすべての貢献者にも感謝しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.11.1.Finalは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended GraalVM version is now GraalVM 20.3.1.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMの推奨バージョンはGraalVM 20.3.1になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[the full changelog of 1.11.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[GitHubで1.11.1.Finalの完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is my pleasure to announce the release of Quarkus 1.12.0.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.12.0.Finalのリリースを発表できることを嬉しく思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It comes with some significant changes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それはいくつかの重要な変更を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fast jar is now the default packaging when you build a jar.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Fast jar は、jar をビルドする際のデフォルトのパッケージングになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive keeps improving and it now has support for multipart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactiveは改善を続け、multipartをサポートするようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x Axle and RX Java managed instances have been dropped.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x AxleとRX Javaのマネージドインスタンスを削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to GraalVM 21.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM 21.0にアップグレードしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[our migration guide for 1.12].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のアプリケーションの移行をお考えですか？ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12の移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has always offered several types of jar packaging.  Historically, we had either a standard jar packaging (the one with the `-runner.jar` and the `lib/` directory) or an uber jar.  In Quarkus 1.5, we introduced a new packaging type called Fast jar, which main objective was to further improve our boot time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、常にいくつかのタイプのjarパッケージを提供してきました。歴史的には、標準のjarパッケージ（ `-runner.jar` と `lib/` ディレクトリのあるもの）か、uber jarがありました。Quarkus 1.5では、Fast jarと呼ばれる新しいパッケージタイプを導入しました。その主な目的は、ブート時間の更なる改善でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus time, 1.5 means a century ago and we think Fast jar is now ready for prime time and brings enough improvements to justify the change.  Thus the decision to make it the default starting with 1.12.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの時間軸では、1.5は100年前のことを意味し、Fast jarはもうゴールデンアワーの準備ができており、変更を正当化するのに十分な改善をもたらしていると考えています。そのため、1.12からデフォルトにすることを決定しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This change will have consequences on your workflow as the produced artifacts are now under a `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この変更は、生成された成果物が `quarkus-app` ディレクトリの下に置かれるようになったため、ワークフローに影響を及ぼします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So instead of starting your application with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションを以下で起動するのではなく、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now start it with:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これからは以下で起動します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When deploying your application, you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションをデプロイする際には、 `quarkus-app` ディレクトリ全体をデプロイする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your Dockerfiles will also need to be adjusted to take this into account.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Dockerfilesもこれを考慮して調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more details in our https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12#fast-jar-as-default[Migration guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細は link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12#fast-jar-as-default[移行ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's not the right time for you to change your workflow, you can easily go back to the previous packaging by adding the following property to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ワークフローを変更するタイミングではない場合は、 `application.properties`に以下のプロパティを追加することで、簡単に以前のパッケージングに戻ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We continue improving RESTEasy Reactive at a steady pace, and this time, we introduced Multipart support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactiveの改善を着実に続けており、今回はMultipart対応を導入しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very similar to the Multipart support of RESTEasy and looks like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasyのMultipart対応に非常に似ていて、以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in the updated https://quarkus.io/guides/resteasy-reactive#handling-multipart-form-data[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それについての詳細は、更新された link:https://quarkus.io/guides/resteasy-reactive#handling-multipart-form-data[RESTEasy Reactiveガイド]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 21</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM 21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.12 is GraalVM 21.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.12のGraalVMの推奨バージョンはGraalVM 21.0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They had been deprecated for quite a while, they are now gone.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>かなり前から非推奨になっていましたが、今はもうありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either use the raw Vert.x instance of the Mutiny one.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生のVert.xインスタンスを使用するか、Munityのを利用してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.12.0.CR1[1.12.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.12.0.Final[1.12.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.0.CR1[1.12.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.12.0.Final[1.12.0.Final]の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[445 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[445人の貢献者]がいます。一人ひとりの貢献者に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.9.2.Final released - Bugfixes'
date: 2020-11-05
tags: release
synopsis: 1.9.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.9.2.Finalリリース - バグフィックス
date: 2020-11-05
tags: release
synopsis: 1.9.2.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just a week after 1.9.1.Final, here comes 1.9.2.Final with some bugfixes and documentation improvements.  Thanks a lot to everyone providing feedback and pull requests!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.9.1.Finalからちょうど一週間後、バグフィックスとドキュメントの改善を加えた1.9.2.Finalがやってきました。フィードバックとプルリクエストを提供してくださった皆様、ありがとうございました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[the full changelog of 1.9.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[1.9.2.Finalの完全な変更履歴はGitHub]で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://quarkus.io/worldtour/[Quarkus World Tour] kicked off in March to provide a unique, hands-on Quarkus experience for Java developers across the globe. The goal of the tour is to introduce Quarkus to Java developers and set them down the path of creating applications and participating in the community.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://quarkus.io/worldtour/[Quarkus World Tour]は、世界中のJava開発者にQuarkusのユニークな実地体験を提供するために、3月にスタートしました。このツアーの目的は、Java開発者にQuarkusを紹介し、アプリケーションの作成やコミュニティへの参加への道筋をつけることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the tour began, we have performed for crowds of developers from *15+* JUGs across the world with many more https://quarkus.io/worldtour/[tour stops] being added every day.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このツアーが始まって以来、私たちは世界中の *15以上の* JUGから集まった大勢の開発者を前にパフォーマンスを行ってきましたが、毎日多くの link:https://quarkus.io/worldtour/[ツアー会場]が追加されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bands Make It “Rock”, Roadies Make It “Roll”</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Bands Make It “Rock”, Roadies Make It “Roll”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A global world tour takes an entire community to ensure its success. We have a great group of roadies that have made the world tour a success so far but we need your help.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>グローバルなワールドツアーを成功させるには、コミュニティ全体が必要です。これまでワールドツアーを成功させてきた素晴らしいローディたちがいますが、皆さんの協力が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ways You Can Help</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>協力できること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Much like a concert, we want each tour stop to be a unique experience for the audience. Each performer is encouraged to demo or talk about what they are passionate about with Quarkus. You *DO NOT* have to be an expert or know everything there is about Quarkus. The event organizer will work with you ahead of time to set the agenda and organize the demo setlist so you have time to prepare (see sample setlist below). It will be fun, we promise.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンサートのように、それぞれのツアー先でお客様にユニークな体験をしていただきたいと思っています。各パフォーマーは、自分がQuarkusで情熱を傾けていることをデモしたり、話したりすることができます。専門家である必要はあり *ません* し、Quarkusのすべてを知っている必要もありません。イベント主催者は、事前に参加者と協力してアジェンダを設定し、デモのセットリストを作成しますので、準備に時間をかけることができます（下記のサンプルセットリストを参照）。楽しいイベントになることをお約束します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Performers are needed for the following roles:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下の役柄で出演者を募集しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*MC* (kick things off, transition between demos, monitor chat and questions, etc.)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*MC* （キックオフ、デモの移行、チャットや質問のモニターなど
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Presenter* (demo Quarkus feature/capability of your choosing)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*プレゼンター* （任意のQuarkusの機能／性能をデモする
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Q&amp;A* (monitor chat and answer any questions behind the scenes or live)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*Q&amp;A* （チャットを監視し、舞台裏やライブで質問に答える
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Organizer* (help arrange logistics, agenda, JUG communication, etc.)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*オーガナイザー* （ロジスティックス、アジェンダ、JUGコミュニケーションなどの手配の手伝い）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Did we mention that you will get some pretty cool swag too?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、素敵なグッズがもらえることもお伝えしましたか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://forms.gle/qJi2eVq8sSc3xv2Z9[Sign Up] or send us an mailto:worldtour@quarkus.io[email] to help.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://forms.gle/qJi2eVq8sSc3xv2Z9[サインアップ]、または link:mailto:worldtour@quarkus.io[メール]でお問い合わせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch a World Tour Stop</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ワールド・ツアー・ストップを確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Setlist</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルセットリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example setlist for a tour stop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここでは、あるツアーのセットリストの例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to Quarkus (5-10 mins)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの紹介（5～10分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the stage, why Quarkus is relevant</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステージ設定、なぜQuarkusが必要なのか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Demo 1 - Hello, World!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デモ1 - Hello, World!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Demo 2 - Developer tooling &amp; productivity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デモ2 - デベロッパーツールと生産性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Demo 3 - JVM &amp; Native performance stats</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デモ3 - JVMとNativeのパフォーマンス統計</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take Requests - Open ended</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テイクリクエスト - オープンエンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote dev</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リモート開発</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automated deployment (Kubernetes/OpenShift)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自動デプロイメント（Kubernetes/OpenShift）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics with Micrometer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>マイクロメーターによるメトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ・アプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single-command Kubernetes deployment</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>シングルコマンドでのKubernetesへのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just before my PTO, someone told me: '_I don't like magic._' In this context, _magic_ refers to the amount of hidden _stuff_ done by Quarkus under the hood for the sake of simplicity.  It includes dependency injection, annotations, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>有休の直前に 誰かに言われました _"私はマジックが好きじゃない"_ って。この文脈では、 _マジック_ とは、シンプルにするためにQuarkusが裏側で行っている隠れた _作業_ のことを指します。これには依存性注入やアノテーションなどが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not the first time that I get that kind of comment, and coming from the Vert.x project, it makes sense.  Vert.x has (almost) no magic, and for a good reason: too much magic can be terrible and make production tuning utterly expensive.  Sometimes you want to have more control and avoid unexpected behaviors: execute the code you wrote, and nothing else.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このようなコメントを受けるのは初めてではないし、Vert.xプロジェクトから来ているので、それは理にかなっています。Vert.x には(ほとんど)マジックがありませんが、それには正当な理由があります: マジックが多すぎるとひどいことになり、プロダクションチューニングが全く大変になります。時には、より多くの制御をして予期せぬ動作を避けたい場合があります: ただ書いたコードだけが実行され、それ以外は何もしないで欲しい、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But magic is not inherently bad.  Magic is power that can be used for good or for bad.  After all, your application runs on a silicon with microcode magic powering an Operating System with abstraction magic powering the Java Virtual Machine with Just In Time magic.  There is magic, it's just magic you have enough knowledge (or trust) of vs magic you don't.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、マジックは本質的に悪いものではありません。マジックは良いことにも悪いことにも使えるパワーなのです。結局のところ、あなたのアプリケーションは、マイクロコードで力を与えられた半導体上で実行される、抽象化のマジックで力を与えられたオペレーティングシステム上の、JITのマジックで力を与えられたJava仮想マシンで動いています。マジックはありますが、それはあなたが十分な知識を持っている(または信頼している)マジックと、そうでないマジックのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may think that Quarkus has a lot of magic tricks.  It is true in some sense but it is easily understood and comes with strong benefits in either memory optimization, startup time optimization or last but not least developer experience improvements.  You can decide the amount of magic that you want and the amount of control you feel comfortable with.  You don't have to use dependency injection or managed clients if you prefer doing things yourself.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusにはたくさんのマジックのトリックがあると思うかもしれません。ある意味ではそうなのですが、簡単に理解でき、メモリーの最適化、起動時間の最適化、または開発者の経験の向上のいずれかにおいて強力なメリットがあります。あなたが望むマジックの量と、あなたが快適に感じるコントロールの量を決めることができます。もし自分でやりたいのであれば、依存性注入や管理クライアントを使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, we will cover three different approaches to reducing the amount of magic.  We will go from almost no magic to just enough to get a good developer experience.  Examples from this blog post are available on https://github.com/cescoffier/quarkus-magic-control[GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回の記事では、マジックの量を減らすための3つの異なるアプローチを取り上げます。マジックをほとんど使わない状態から、良い開発者体験を得るために必要なだけの状態にしていきます。このブログ記事の例は link:https://github.com/cescoffier/quarkus-magic-control[GitHub]で公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _almost no magic_ approach</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_ほとんどマジックがない_ アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are Java applications.  So, somewhere there is a `public static void main(String... args)`.  While you don't need to write that method when using Quarkus, it can still be convenient and give you more control about your application startup.  It's also a good trick to start your Quarkus application directly from your IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusのアプリケーションはJavaアプリケーションです。そのため、どこかに `public static void main(String…​ args)` が存在します。Quarkusを使用する際にそのメソッドを記述する必要はありませんが、それでも便利で、アプリケーションの起動についてより多くのコントロールが可能になります。また、IDEから直接Quarkusアプリケーションを起動するのも良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, we will implement a straightforward HTTP application. Nothing fancy:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例として、簡単な HTTP アプリケーションを実装します。派手なものは何もありません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete source code is available https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[here].  Don't expect much more; the application had only one Java class, but let's look into it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全なソースコードは link:https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[ここ]にあります。アプリケーションにはJavaクラスが1つしかありませんが、それを調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@QuarkusMain` indicates that Quarkus should use this class as the _main entry point_ of the application.  The `run` method contains your application logic.  We will come back to this logic later.  First, look at the `public static void main(String... args)` method.  It just starts the application.  You can use this entry point directly from your IDE.  Yes, there is still a bit of magic behind `Quarkus.run`; that's where the extension initialization happens - not unlike _any_ framework initialization including Vert.x.  As this application does not use any extension, nothing much will happen.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`@QuarkusMain` は、Quarkusがこのクラスをアプリケーションの _メインエントリーポイント_ として使用することを示しています。 `run` メソッドには、アプリケーションのロジックが含まれています。このロジックについては後ほど説明します。まず、 `public static void main(String…​ args)` メソッドを見てください。これはアプリケーションを起動するだけです。このエントリーポイントは、IDE から直接使用できます。そう、 `Quarkus.run` の背後にはまだちょっとしたマジックがあります。エクステンションの初期化が行われるのは、 Vert.x を含む _どの_ フレームワークの初期化とも異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[depends] directly on Vert.x Web and Vert.x Core.  The only Quarkus dependency is Arc (not used directly but required):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションは Vert.x Web と Vert.x Core に直接 link:https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[依存します]。Quarkusの依存関係はArcだけです(直接は使用しませんが必須です):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go back to the `run` method.  It contains the application logic, here, a dummy Vert.x application.  It creates the `Vertx` instance, a `Router`, registers a few routes, and starts the HTTP server.  Because we don't want the application to stop immediately, we _wait for exit_.  The `/bye` request handler illustrates how you can programmatically trigger the application shutdown.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`run` メソッドに戻りましょう。これにはアプリケーション・ロジックが含まれており、ここではダミーの Vert.x アプリケーションを使用しています。 `Vertx` インスタンス、 `Router` を作成し、いくつかのルートを登録し、HTTP サーバーを起動します。アプリケーションをすぐに停止させたくないので、 _終了を待ちます_。 `/bye` リクエスト・ハンドラーは、アプリケーションのシャットダウンをプログラムでトリガーする方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application has almost no magic, just a single annotation, and a regular Java entry point.  You may wonder why not using a bare Java program? Even used that way, Quarkus provides benefits. For example, you can access the built-in configuration support as illustrated in the snippet:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションにはマジックはほとんどなく、ただのアノテーション1つと、普通のJavaのエントリーポイントがあるだけです。なぜむき出しのJavaプログラムを使わないのかと疑問に思うかもしれません。そのように使用しても、Quarkusには利点があります。例えば、スニペットに示されているように、組み込みの設定サポートにアクセスすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is located in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定は、 `application.properties` ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This first approach has a few drawbacks.  It does not benefit from the built-time processing of Quarkus.  The logic executed at build time is packaged inside extensions, and in this case, we don't use extensions (except Arc).  Another issue is that compiling this application to native will fail because extensions are also involved during the native compilation.  Finally, the hot reload won't work, but you can directly restart the application from your IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この最初のアプローチには、いくつかの欠点があります。これはQuarkusのビルド時処理の恩恵を受けていません。ビルド時に実行されるロジックはエクステンションの中にパッケージ化されており、この場合はエクステンションは使用されません(Arcを除く)。もう一つの問題は、このアプリケーションをネイティブにコンパイルすると、ネイティブのコンパイル時にエクステンションも絡んでくるので失敗するということです。最後に、ホットリロードはうまくいきませんが、IDEから直接アプリケーションを再起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses Vert.x heavily.  The `quarkus-vertx-core` extension manages the Vert.x instance used by Quarkus.  You can use that instance directly and avoid creating the Vert.x instance.  If you need to configure the instance, you can configure it from https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[the `application.properties`].  It also enables native packaging (as that extension contains the directive to compile Vert.x applications to native).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはVert.xを多用しています。 `quarkus-vertx-core` エクステンションは、Quarkusが使用するVert.xインスタンスを管理します。そのインスタンスを直接使用することができ、Vert.xインスタンスを作成する必要はありません。インスタンスを設定する必要がある場合は、 link:https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[`application.properties`] から設定することができます。また、ネイティブパッケージングも可能になります(このエクステンションには Vert.x アプリケーションをネイティブにコンパイルするためのディレクティブが含まれているため)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your pom.xml file, just add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>pom.xmlファイルに以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, the _run_ method becomes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 _run_ メソッドは以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how it retrieves the managed Vert.x instance.  While you can use `@Inject`, you can also retrieve it programmatically, the rest of the code does not change.  See? No magic for you! We can still start it from the IDE using the _main_ method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理されている Vert.x インスタンスを取得する方法に注目してください。 `@Inject` を使用することができますが、プログラムで取得することも出来、残りのコードは変更しません。ご覧になりましたか?魔法はありません! _メイン_ メソッドを使用して、IDE から起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't include the `quarkus-vertx-core` extension (or any extension depending on it), Quarkus won't create the Vert.x instance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-vertx-core` エクステンション(またはそれに依存するエクステンション)を含まない場合、QuarkusはVert.xインスタンスを作成しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using extensions gives you some property wiring as well as the build time optimisations and native image compilation:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションを使用すると、プロパティーの設定や、ビルド時間の最適化、ネイティブイメージのコンパイルも行うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, still no hot reload 😿.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、やはりホットリロードはダメですね😿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of using only the `quarkus-vertx-core` extension, we can choose to delegate the HTTP server to Quarkus.  You may see that as a loss of control, but actually, we rarely do much around it, and again, you can configure it from the `application.properties` file if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-vertx-core` のエクステンションだけを使用するのではなく、HTTPサーバーをQuarkusに委任することもできます。 これは制御できないと思われるかもしれませんが、実際には、そのようなことは滅多にしませんが、必要なら、 `application.properties` ファイルから設定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of ``quarkus-vertx-core`, use `quarkus-vertx-http`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``quarkus-vertx-core` の代わりに、 `quarkus-vertx-http` を使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No need to depend on Vert.x Web directly, it's included.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x Webに直接依存する必要はなく、含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will still register your routes, but using a managed `Router`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ルートの登録は引き続き行いますが、管理されている `Router` を使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That approach enables the Quarkus hot reload as it intercepts the HTTP requests.  You are still in control of everything related to your application logic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプローチでは、HTTPリクエストをインターセプトするため、Quarkusのホットリロードが可能になります。アプリケーションロジックに関連するすべてのことを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start the hot reload using:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次を使ってホットリロードを開始することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final _magic touch_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後の _マジックタッチ_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The question, now, is how far are we from a _regular_ Quarkus application? Quite close, actually.  The equivalent application using RESTEasy Reactive would be something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題は、Quarkusの _通常の_アプリケーションからどれくらい離れているかということです。実際には、かなり近いです。RESTEasy Reactiveを使った同等のアプリケーションは、次のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the previous approaches, this one leverages a declarative (annotation-based) model.  Under the hood, it's not that different from the last approach.  Quarkus registers a route (on the router), which then calls the `hello` method when a matching request is received.  The router gets initialized during the `Quarkus.run` method.  No need for the _main_ endpoint, but you can still use one, often convenient in IDEs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでのアプローチとは異なり、このアプローチは宣言的な(アノテーションベースの)モデルを活用しています。内部では、前のアプローチとそれほど違いはありません。Quarkusは(ルーター上で)ルートを登録し、一致するリクエストを受信すると `hello` メソッドを呼び出します。ルータは、 `Quarkus.run` メソッドの間に初期化されます。 _メインエンドポイント_ は必要ありませんが、1つのエンドポイントを使用することができ、IDEでは便利なことが多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our relation to magic depends on our background and experience.  Quarkus lets you decide how much magic you accept.  This post presented fours configurations, going from almost no magic to the _regular_ Quarkus code.  Each approach has pros and cons:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのマジックとの関係は、私たちのバックグラウンドや経験によって異なります。Quarkusでは、どの程度のマジックを受け入れるかを決めることができます。この記事では、ほとんど魔法を使わない状態から _通常の_ Quarkusコードまで、4つの設定を紹介しました。それぞれのアプローチには長所と短所があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Control</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コントロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build time optimizations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブ実行可能ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot Reload</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ホットリロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Almost no magic_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_殆どマジックなし_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>完全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Regular_ Quarkus</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_通常の_ Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pick the approach that fits your needs.  Besides, most of Quarkus services are also available using a programmatic approach, as we have seen for configuration.  So, if you prefer avoiding managed objects, feel free just to use the available APIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ニーズに合ったアプローチを選びましょう。また、設定について見てきたように、Quarkusのサービスのほとんどは、プログラム的なアプローチを使用して利用することもできます。管理されたオブジェクトを避けたい場合は、利用可能なAPIを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We just released our third Alpha for Quarkus 2.0 which contains several enhancements and new features:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 2.0の3番目のアルファ版をリリースしました。いくつもの機能強化と新機能を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/17014[#17014] - Update to GraalVM 21.1</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/17014[#17014]- GraalVM 21.1へのアップデート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/17350[#17350] - SmallRye GraphQL Client extension + 1.2.1 upgrade</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/17350[#17350]- SmallRye GraphQL クライアントエクステンション + 1.2.1 アップグレード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/16857[#16857] - Add Amazon SSM extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/16857[#16857]- Amazon SSMエクステンションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/16963[#16963] - Add `quarkus:test` goal</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/16963[#16963]- `quarkus:test` ゴールを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/17232[#17232] - Introduce coroutine support in Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/17232[#17232]- Reactive Messagingにおけるcoroutineサポートの導入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/17056[#17056] - Add support for coroutines to the rest client</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/17056[#17056]- restクライアントにコルーチンのサポートを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/quarkusio/quarkus/pull/16951[#16951] - Add support for hibernate.metadata_builder_contributor</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/pull/16951[#16951]- hibernate.metadata_builder_contributor のサポートを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have missed our previous announcements:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでのアナウンスを見逃していた方へ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha3[2.0.0.Alpha3] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/2.0.0.Alpha3[2.0.0.Alpha3]の完全な変更履歴はGitHubに掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics are the measurements of any aspect of an application such as resource usage or behaviors. We can expose these metrics from our Quarkus applications by using the https://quarkus.io/guides/micrometer[Micrometer] extension via the `/q/metrics` endpoint.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メトリクスは、リソースの使用状況や動作など、アプリケーションのあらゆる側面の測定値です。Quarkusのアプリケーションからこれらのメトリクスを公開するには、 `/q/metrics` エンドポイント経由で link:https://quarkus.io/guides/micrometer[Micrometer]エクステンションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What metrics will be exposed? Only by adding the Micrometer extension, a lot of metrics are exposed by default for example metrics about the JVM engine like the number of current live threads `jvm_threads_live_threads` or metrics about the system itself like the current CPU usage `system_cpu_usage`. Additionally, more metrics will automatically be exposed depending on other Quarkus extensions we might be using. For example, if we are using a Quarkus REST extension such as Resteasy, it will automatically expose metrics about your running services:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どのようなメトリクスが公開されますか?Micrometerエクステンションを追加するだけで、多くのメトリクスがデフォルトで公開されます。例えば、現在のライブスレッド数のようなJVMエンジンに関するメトリクス `jvm_threads_live_threads` や、現在のCPU使用率のようなシステム自体に関するメトリクス `system_cpu_usage` などがあります。さらに、使用している他のQuarkusエクステンションに応じて、より多くのメトリクスが自動的に公開されます。例えば、ResteasyのようなQuarkusのRESTエクステンションを使用している場合、実行中のサービスに関するメトリクスが自動的に公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` http_server_requests_seconds_count{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 1.0 http_server_requests_seconds_sum{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 0.018198043 ```</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>``` http_server_requests_seconds_count{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 1.0 
http_server_requests_seconds_sum{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 0.018198043 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same will happen if we're using the Kafka extension. All this configuration is well documented in https://quarkus.io/guides/micrometer[the Quarkus Micrometer guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafkaエクステンションを使用している場合も同様です。これらの設定については、 link:https://quarkus.io/guides/micrometer[Quarkus Micrometerガイド]によく書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>__How are these metrics consumed?__ As said, Micrometer exposes the metrics on the `/q/metrics` endpoint in order to be consumed by third parties like https://prometheus.io/[Prometheus]. OpenShift provides an embedded Prometheus instance that we can use. So, let's see what we need to do to integrate our Quarkus Applications metrics and the Prometheus embedded instance provided in OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>__これらのメトリクスはどのように消費されるのですか？__ 前述の通り、Micrometer は link:https://prometheus.io/[Prometheus] のようなサードパーティが利用できるように `/q/metrics` エンドポイントでメトリクスを公開しています。OpenShiftにはPrometheusのインスタンスが埋め込まれているので、それを利用することができます。それでは、Quarkus Applicationsのメトリクスと、OpenShiftで提供されているPrometheusの埋め込みインスタンスを統合するために必要なことを見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basically, we need to complete the next following steps:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>基本的には、次のようなステップを踏む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Service monitor in our project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトにサービスモニターを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html[Openshift CLI]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html[Openshift CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Enable Monitoring for user-defined projects in OpenShift</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ1 - OpenShiftでユーザー定義のプロジェクトのモニタリングを有効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to enable the Monitoring for user-defined projects, we need to follow the instructions https://docs.openshift.com/container-platform/4.7/monitoring/enabling-monitoring-for-user-defined-projects.html[from OpenShift documentation].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユーザー定義のプロジェクトのモニタリングを有効にするためには、 link:https://docs.openshift.com/container-platform/4.7/monitoring/enabling-monitoring-for-user-defined-projects.html[OpenShiftのドキュメント]の指示に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In essence, we need to create a ConfigMap in the namespace `openshift-monitoring`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>突きつめると、名前空間 `openshift-monitoring` に ConfigMap を作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`cluster-monitoring-config.yaml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`cluster-monitoring-config.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And apply it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、それを以下のように適用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Openshift will automatically create the `openshift-user-workload-monitoring` namespace and deploy the required resources for Prometheus to it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Openshiftは自動的に `openshift-user-workload-monitoring` 名前空間を作成し、そこにPrometheusに必要なリソースをデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After the required infrastructure in OpenShift is ready, then let's continue with the Quarkus application. We'll implement a REST API and enable micrometer with prometheus which requires the addition of two Quarkus extensions to our `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenShiftで必要なインフラの準備ができたら、次にQuarkusアプリケーションを進めていきましょう。REST APIを実装し、prometheusでmicrometerを有効にします。そのためには、 `pom.xml` ファイルに2つのQuarkusエクステンションを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we'll add the Greeting resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、Greetingリソースを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we can see, we use the micrometer registry facade to create a counter with a tag by name that will be incremented every time it's invoked.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご覧のように、micrometer レジストリファサードを使用して、タグ名を持つカウンタを作成し、起動するたびにインクリメントしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try this application by running it:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションを実行して試してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we should be able to call our service:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、私たちのサービスを呼び出すことができるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And it should return `Hello!`. So good so far, we can also see the metrics in `http://localhost:8080/q/metrics` where should see our `greeting_counter` counter:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、 `Hello!` を返すはずです。ここまではいいとして、 `http://localhost:8080/q/metrics` でメトリクスを見ることもできます。ここでは、 `greeting_counter` のカウンターを確認できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, we need to deploy our Quarkus application into OpenShift. For ease this step, Quarkus provides a super useful extension called `quarkus-openshift`, let's add it into our `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、QuarkusアプリケーションをOpenShiftにデプロイする必要があります。このステップを簡単にするために、Quarkusは `quarkus-openshift` という非常に便利なエクステンションを提供していますので、これを `pom.xml` ファイルに追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's deploy our application into a newly created project `my-project` in OpenShift:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、OpenShiftで新たに作成したプロジェクト `my-project` にアプリケーションをデプロイしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The label `app-with-metrics` will be used in a later step to select the applications to monitor by OpenShift.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ラベル `app-with-metrics` は、後のステップで OpenShift が監視するアプリケーションを選択するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before moving forward, let's explain first how Prometheus works. Prometheus uses a pull model to get metrics from applications. This means that Prometheus will scrape or watch endpoints to pull metrics from.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先に進む前に、まずPrometheusの仕組みを説明しましょう。Prometheus は、アプリケーションからメトリクスを取得するためにプル・モデルを使用します。つまり、Prometheus はメトリクスを取得するためにエンドポイントをスクレイピングしたり、ウォッチしたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the previous step, our service is now running in OpenShift, but we didn't configure anything in Prometheus to scrape our service yet. This is done by the Service Monitor resource:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のステップから、サービスは OpenShift で実行されていますが、Prometheus でサービスをスクレイプするための設定はまだ何もしていません。これは Service Monitor リソースで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`service-monitor.yaml`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`service-monitor.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we have just done is to create a Service Monitor named `prometheus-app-monitor` that will select apps with the label `app-with-metrics: quarkus-app` that was added in the previous step. Then, OpenShift will call the endpoint `/q/metrics` for all the services labeled with `app-with-metrics: quarkus-app` every 30 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今行ったのは、前のステップで追加した `app-with-metrics: quarkus-app` というラベルのついたアプリを選択する `prometheus-app-monitor` という名前の Service Monitor を作成することです。すると、OpenShiftは30秒ごとに、 `app-with-metrics: quarkus-app` というラベルのついたサービスすべてについて、エンドポイント `/q/metrics` を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's start using it!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いよいよ、使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to call our greetings service: `http://quarkus-micrometer-my-project.ocp.host/hello/quarkus`. This will increment the `greeting_counter_total` counter. But where can we see the metrics? Let's browse to OpenShift Console in the `Developer &gt; Monitoring` view, select `Metrics`, then `Custom Query` and type `greeting_counter_total{name = "quarkus"}`, we should see now:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、グリーティングサービスを呼び出す必要があります: `http://quarkus-micrometer-my-project.ocp.host/hello/quarkus` 。これで `greeting_counter_total` カウンターが増加します。しかし、このメトリクスはどこで見ることができるでしょうか？OpenShift Console の `Developer &gt; Monitoring` view, select `Metrics` を開き、 `Metrics` を選択し、次に `Custom Query` を選択し、 `greeting_counter_total{name = "quarkus"}` と入力してみましょう。これで次のように表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Great! We are now exposing our Quarkus Application metrics in OpenShift!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>素晴らしい!OpenShiftにQuarkus Applicationのメトリクスを公開出来ています!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.5.Final released - Bugfixes'
date: 2020-12-16
tags: release
synopsis: 1.10.5.Final fixes several important issues in Quarkus 1.10.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: Quarkus 1.10.5.Finalリリース - バグフィックス
date: 2020-12-16
tags: release
synopsis: 1.10.5.Finalでは、Quarkus 1.10のいくつかの重要な問題が修正されました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.5.Final is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.10.5.Final はメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It fixes some important issues in Quarkus, most notably in the Hibernate ORM extension which got Hibernate ORM upgraded to 5.4.26.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの幾つかの重要な課題を修正します。特に注目すべき点として、Hibernate ORMエクステンションにおいて、Hibernate ORMが5.4.26.Finalにアップグレードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[the full changelog of 1.10.4.Final] and the https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[full changelog for 1.10.5.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[1.10.4.Finalの完全な変更履歴]と https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[1.10.5.Finalの完全な変更履歴] をGitHubで取得出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have been hard at work during Summer to bake Quarkus 1.8.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>夏の間、Quarkus1.8を作り上げるために頑張ってきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It comes with some shiny new features, among them:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それはいくつかのピカピカの新機能が付属していますが、中でも以下のような機能があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A new Micrometer extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいMicrometerエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.8[our migration guide for 1.8].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のアプリケーションの移行をお考えですか? link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.8[1.8の移行ガイドは] こちらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, with standard Quarkus configuration, the Hibernate ORM extension only supported a single persistence unit.  You could work around this limitation by using a `persistence.xml` but it was unpractical at best.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまで、Quarkusの標準的な設定では、Hibernate ORMエクステンションは単一の永続化ユニットしかサポートしていませんでした。 `persistence.xml` を使用することでこの制限を回避できましたが、せいぜい実用的ではありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.8 introduces support for multiple persistence units in the Hibernate ORM extension.  The feature is still experimental, not because it's unstable, but because we might tweak how you configure it depending on your feedback.  So if you use this feature, please provide your feedback on Zulip or on our `quarkus-dev` mailing list.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.8 では、Hibernate ORM エクステンションに複数の永続化ユニットのサポートが導入されています。この機能はまだ実験的なもので、不安定だからというわけではありません。ですから、もしこの機能を使っているのであれば、Zulip や `quarkus-dev` メーリングリストでフィードバックをお願いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about this new feature and how to use it in your applications, please refer to link:/guides/hibernate-orm[the Hibernate ORM extension guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この新機能の詳細とアプリケーションでの使用方法については、 link:/guides/hibernate-orm[Hibernate ORM エクステンションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While standard Hibernate ORM entities can belong to several persistence units, Panache entities can only belong to one persistence unit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>標準のHibernate ORMエンティティは複数の永続化ユニットに所属できますが、Panacheエンティティは1つの永続化ユニットにしか所属できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer is a widely used library to collect metrics from your application.  One big advantage over our existing MicroProfile Metrics implementation is that a lot of dashboards are available out there for your usual monitoring tools.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Microrometer はアプリケーションからメトリクスを収集するために広く使われているライブラリです。既存の MicroProfile Metrics の実装と比較した場合の大きな利点は、通常のモニターリングツールに多くのダッシュボードが用意されていることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.8 introduces a new extension for Micrometer called `quarkus-micrometer`.  Please refer to link:/guides/micrometer[its guide] to learn more about it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.8では、 `quarkus-micrometer` と呼ばれるMicrometerのための新しいエクステンションが導入されました。詳細については、 link:/guides/micrometer[このガイドを] 参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scripting with jbang</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>jbangを使ったスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.8 provides integration with https://jbang.dev[jbang]] which allows you to write Java scripts/applications requiring no Maven nor Gradle to get running.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.8は link:https://jbang.dev[jbang] との統合を提供します。これにより、MavenやGradleを実行する必要のないJavaのスクリプトやアプリケーションを書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing quick scripts using the Quarkus stack becomes easy.  Learn more about it in link:/guides/scripting[the Scripting with jbang guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusスタックを使用したクイックスクリプトの作成が簡単になりました。詳細については、 link:/guides/scripting[jbangを使ったスクリプト作成ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM 20.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you build native executables from your Quarkus applications, it is time to update to GraalVM 20.2, which is the recommended version from now on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのアプリケーションからネイティブの実行ファイルをビルドしている場合は、今から推奨バージョンであるGraalVM 20.2にアップデートする時期になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye OpenAPI users often request the ability to save the generated API document.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye OpenAPIのユーザーは、生成されたAPIドキュメントを保存する機能をしばしば要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `quarkus.smallrye-openapi.store-schema-directory` property allows you to do exactly that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい `quarkus.smallrye-openapi.store-schema-directory` プロパティーを使用すると、まさにそれが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quartz</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is now possible to configure the Quartz by setting the `quarkus.quartz.instance-name` configuration property.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.quartz.instance-name` 設定プロパティーを設定することで、Quartzの設定が可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with 1.8, you can use CDI injection in Quartz jobs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.8からは、QuartzジョブでCDIインジェクションを使用できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension points (trigger listeners, job listeners, plugins) configuration have changed, so if you are using this feature, please refer to link:/guides/quartz#quartz-configuration-reference[the updated documentation] to migrate your configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>拡張ポイント(トリガーリスナー、ジョブリスナー、プラグイン)の設定が変更されていますので、この機能をご利用の方は、 link:/guides/quartz#quartz-configuration-reference[更新されたドキュメントを] 参照して設定を移行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of our extensions requires some additions to properly support Kotlin.  This is the case of the MongoDB with Panache extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのエクステンションの中には、Kotlin を適切にサポートするためにいくつかの追加を必要とするものがあります。これは MongoDB with Panache エクステンションがそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using MongoDB with Panache and Kotlin, please add the `quarkus-mongodb-panache-kotlin` extension to your project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>MongoDBをPanacheとKotlinで使用している場合は、 `quarkus-mongodb-panache-kotlin` のエクステンションをプロジェクトに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.8.0.CR1[1.8.0.CR1] and https://github.com/quarkusio/quarkus/releases/tag/1.8.0.Final[1.8.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.0.CR1[1.8.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.8.0.Final[1.8.0.Final] の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[356 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusコミュニティは成長を続けており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[356人の貢献者] がいます。一人ひとりの貢献者に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post gives some feedback on a particular challenge I have been facing in a professional context with respect to deploying applications on Kubernetes, and how we were able to provide a solution that met our goals using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この記事では、Kubernetes上でのアプリケーションのデプロイに関して、私が仕事上で直面している特定の課題について、Quarkusを使ってどのように目標を達成するソリューションを提供できたかについてフィードバックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The challenge</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>チャレンジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a few years now I have been involved in a Kubernetes project, aiming at:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>数年前から、私はKubernetesのプロジェクトに参加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Onboarding more easily and more quickly new technologies (either applicative frameworks, or middleware products).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい技術（アプリケーション・フレームワークやミドルウェア製品）をより簡単に、より早く導入する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lowering the administrative burden of deploying distributed inter-related services by creating a logical deployment abstraction on top of these services; something like the https://helm.sh/docs/howto/charts_tips_and_tricks/#complex-charts-with-many-dependencies[umbrella chart] pattern.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://helm.sh/docs/howto/charts_tips_and_tricks/#complex-charts-with-many-dependencies[アンブレラチャートパターン]のように、サービスの上に論理的な展開の抽象化を行うことで、相互に関連する分散型サービスを展開する際の管理負担を軽減する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limiting the work needed by an application team to deploy a component, and hyper-standardize Kubernetes deployment objects.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションチームがコンポーネントをデプロイするために必要な作業を限定し、Kubernetesのデプロイメントオブジェクトを超標準化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transitioning to an hybrid cloud deployment model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ハイブリッドクラウドのデプロイモデルへの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to those goals, there was a constraint related to the fact that applications may be deployed by tenant (i.e. they are not multi-tenant, for different reasons, some being regulatory related). Depending on the application, there may be a few dozens tenants, which would translate into deploying the application once per tenant (so if we had 10 tenants for an application, there would be 10 processes running in production). However, if processes needed to be physically separated, often some portions of configuration could be shared between some tenants, and/or IT environments, and/or geographical zones according to different business rules. Highly simplified and factorized bits of configuration would be a true source of simplicity for the development team, and a true source of complexity for the deployment process.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの目標に加えて、アプリケーションがテナントごとにデプロイされるという事実に関連した制約がありました（つまり、規制に関連した理由もありますが、マルチテナントではありません）。アプリケーションによっては、数十のテナントが存在する可能性があり、その場合、テナントごとにアプリケーションを1回デプロイすることになります（つまり、あるアプリケーションに10のテナントがあった場合、本番では10のプロセスが実行されることになります）。しかし、物理的にプロセスを分離する必要がある場合は、異なるビジネスルールに基づいて、一部のテナント、IT環境、地理的ゾーンの間で、設定の一部を共有することができます。高度に単純化、因数分解された構成部分は、開発チームにとっては真の意味での単純さの源となり、デプロイメントプロセスにとっては真の意味での複雑さの源となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some projections indicated that at project end, the different clusters in production would contain 10'000 pods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト終了時には、さまざまなクラスターで10,000個のポッドが含まれているという予測もありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First attempts</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初の試み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given that complexity we created our own tool for configuration and deployment. The initial version was based on Ansible and ran into Tower workflows. For different reasons we decided to rewrite it in Java a year ago, mainly to:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その複雑さを考慮して、私たちは設定とデプロイのための独自のツールを作成しました。最初のバージョンはAnsibleをベースにしたもので、Towerのワークフローに対応していました。さまざまな理由から、1年前にJavaで書き直すことにしました。主な理由は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get better performances.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>パフォーマンスの向上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a high level language that could cope with algorithm complexity.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アルゴリズムの複雑さに対応できる高レベルの言語の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get better support for unit and integration testing.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ユニットテストや統合テストの充実したサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Improve productivity with quality development tools (e.g. IDE).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高品質な開発ツール（IDEなど）による生産性の向上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing we were concerned about though, was memory consumption, CPU usage and startup times since for a given application, each tenant is deployed in isolation in its own deployment process. For that reason we decided to not depend on any application framework when we started the Java rewrite, because if they do offer productivity and standardization, the abstraction they provide comes with a resource cost. So the program was written in plain Java, and it was small enough in size and use cases that we were able get away with it, provided we relied on a few patterns (e.g. constructor based injection by hand) for clean code. This program is called _ocpdeploy_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、一つ気になったのは、メモリ消費量、CPU使用率、起動時間でした。というのも、あるアプリケーションでは、各テナントがそれぞれのデプロイメントプロセスで独立してデプロイされるからです。というのも、アプリケーションフレームワークは生産性や標準化の面では優れていますが、抽象化の面ではリソースコストがかかるからです。そのため、プログラムはプレーンなJavaで書かれており、サイズもユースケースも十分に小さかったので、クリーンなコードのためにいくつかのパターン（例：コンストラクタベースのインジェクションを手作業で行う）に頼ることを条件に、それで済ませることができました。このプログラムは _ocpdeploy_ といいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we were moving away from Tower, we decided to leverage our Kubernetes infrastructure by running _ocpdeploy_ as tasks in Tekton pipelines. This gave us repeatability, a way to deploy different applications, or even different tenants for the same application with different _ocpdeploy_ versions. The use of java (any other high level language would have been a good fit) provided us with a high level of productivity, and maintainable code, while being able to implement complex algorithms for configuration processing, and raised the level of quality of _ocpdeploy_ releases thanks to our extensive regression testing suite.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Tower からの移行に伴い、Tekton パイプラインのタスクとして _ocpdeploy_を実行することで、Kubernetes インフラストラクチャを活用することにしました。これにより、再現性が得られ、異なるアプリケーションや、同じアプリケーションの異なるテナントを異なる _ocpdeploy_バージョンでデプロイすることができました。java (他のハイレベル言語でも可) を使用することで、設定処理のための複雑なアルゴリズムを実装することができる一方で、高いレベルの生産性と保守可能なコードを提供し、広範なリグレッション・テスト・スイートのおかげで _ocpdeploy_のリリースの品質レベルが向上しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All was well... until we started deploying multiple tenants at the same time, and/or different applications. We had sized the _ocpdeploy_ container to `200 millicores` and `280 Mb` of RAM. For some applications there were around 30 tenants, that would be all deployed in parallel. This meant 30 pods, which accounted for `6 cores` and `8 Gb` of RAM. This seems livable, but deployments tend to be done after business hours, between 7 and 8pm for many. And we started being afraid of the impact _ocpdeploy_ itself would have if we were running multiple deployments in parallel, on top of our SpringBoot or WildFly applications, which take their toll on the cluster at startup.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>全てが順調だったのは、複数のテナントを同時にデプロイしたり、異なるアプリケーションをデプロイするようになるまでです。 _ocpdeploy_コンテナのサイズは `200 millicores` 、RAMは `280 Mb` でした。いくつかのアプリケーションでは、約30のテナントがあり、それらはすべて並行してデプロイされます。これは30ポッドを意味し、 `6 cores` と `8 Gb` のRAMを占めていました。しかし、デプロイは多くの場合、営業時間後の午後7時から8時の間に行われることが多いのです。また、起動時にクラスタに負担をかけるSpringBootやWildFlyのアプリケーションに加えて、複数のデプロイを並行して実行する場合、 _ocpdeploy_自体が受ける影響を心配し始めました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So less than a year ago we decided to launch a Quarkus POC on _ocpdeploy_, the goal being to deploy it as a GraalVM executable.  The main challenges we ran into were related to the lack of support for GraalVM in some of the libraries we were using: FreeMarker, https://github.com/hierynomus/smbj[SMBJ] (a java client library that implements the Server Message Block SMB2 and SMB3 protocols), the Fabric8 OpenShift client (when instantiating OpenShift specific CRDs), and a home made java agent that ships logs to a proprietary centralized logging system.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1年前、私たちは _Ocpdeploy_でQuarkusのPOCを開始することにしました。その目的は、QuarkusをGraalVMの実行ファイルとしてデプロイすることでした。遭遇した主な課題は、使用していたいくつかのライブラリでGraalVMがサポートされていないことに関連していました。FreeMarker、 link:https://github.com/hierynomus/smbj[SMBJ]（Server Message Block SMB2およびSMB3プロトコルを実装したJavaクライアントライブラリ）、Fabric8 OpenShiftクライアント（OpenShift固有のCRDをインスタンス化する際）、そして独自の集中型ログシステムにログを送信する自作のJavaエージェントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately, other bits were already there in Quarkus, such as support for command mode applications, a rest client, the Vault extension, and support for the Fabric8 Kubernetes Client, which provided a nice base for a new OpenShift Client extension that was added to the core. The Kubernetes Client extension alone was a huge push for the project because when we started we did not have Argo available, so we had to implement _apply_ and _prune_ ourselves.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>幸いなことに、コマンドモードアプリケーションのサポート、restクライアント、Vaultエクステンション、Fabric8 Kubernetes Clientのサポートなど、他の部分はすでにQuarkusに存在しており、コアに追加された新しいOpenShift Clientエクステンションのベースとなりました。Kubernetes Clientエクステンションだけでも、プロジェクトにとって大きな後押しとなりました。というのも、スタート時にはArgoが利用できなかったので、 _apply_と _prune_ を自分たちで実装しなければならなかったからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For FreeMarker we pushed a new extension to the Quarkiverse, with code largely inspired from work by https://github.com/ppalaga[ppalaga] and https://github.com/carlosthe19916[carlosthe19916].  For SMBJ we created an extension in our internal Quarkiverse. And for our logging client, I was able to draw some inspiration from the `quarkus-logging-gelf` extension, and created an additional internal extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>FreeMarkerについては、 link:https://github.com/ppalaga[ppalaga]と link:https://github.com/carlosthe19916[carlosthe19916]の作業に大きく影響されたコードで、Quarkiverseに新しいエクステンションを導入しました。SMBJについては、社内のQuarkiverseでエクステンションを作成しました。また、ロギングクライアントについては、 `quarkus-logging-gelf` のエクステンションからヒントを得て、追加の社内エクステンションを作成しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting a library to run in native was facilitated by the very good documentation that comes from the Quarkus project and support in the framework (e.g. _processors_ and _recorders_): https://quarkus.io/guides/writing-native-applications-tips#native-in-extension[Supporting native in a Quarkus extension].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライブラリをネイティブで動作させるには、Quarkusプロジェクトから提供される非常に優れたドキュメントと、フレームワークでのサポート（ _プロセッサ_や _レコーダー_など）が役立ちました。 link:https://quarkus.io/guides/writing-native-applications-tips#native-in-extension[Quarkusのエクステンションでネイティブをサポートする]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When things got a little hairy (SMBJ was trickier than we thought), we got some help from the https://medium.com/GraalVM/introducingthe-tracing-agent-simplifying-GraalVM-native-image-configuration-c3b56c486271[GraalVM tracing agent].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ちょっとした問題が発生したとき（SMBJは思ったよりも厄介だった）、 link:https://medium.com/GraalVM/introducingthe-tracing-agent-simplifying-GraalVM-native-image-configuration-c3b56c486271[GraalVMのトレースエージェント]から助けを得ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is the list of extensions that we happened to use: `cdi, config-yaml, freemarker, hibernate-validator, kubernetes-client, openshift-client, rest-client, restclient-jackson, vault` (plus internal extensions for SMBJ and our internal centralized logging system).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時々使用していたエクステンションのリストは以下の通りです。 `cdi, config-yaml, freemarker, hibernate-validator, kubernetes-client, openshift-client, rest-client, restclient-jackson, vault` (加えて、SMBJと私たちの内部集中型ログシステムのための内部エクステンション)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eventually we got all the required libraries to work in native mode, and we could switch efforts toward migrating the application to look like a _real_ Quarkus application:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最終的には、必要なライブラリがすべてネイティブモードで動作するようになったので、アプリケーションを _本物の_Quarkusアプリケーションのように移行する作業に切り替えることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection, with qualifiers and producers when necessary.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要に応じて qualifiers や producers を用いたインジェクションを使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rewriting tests to use the different mocking approaches, including the new (at the time) https://quarkus.io/blog/quarkus-test-profiles/[QuarkusTest profiles].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>（当時における）新しい link:https://quarkus.io/blog/quarkus-test-profiles/[QuarkusTestのプロファイル]を含む、さまざまなモッキングアプローチを使用するためのテストの書き換え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allowed us to provide extensive testing through Kubernetes yaml generation, _snapshotting_ and _replay_ in a variety of situations transforming all the configuration to be _MP config_ compliant.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、Kubernetesのyaml生成、 _snapshot_、様々な状況での _replay_を通じた広範なテストが可能となり、すべての設定を _MP config_に準拠したものに変換することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Benchmarks</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベンチマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we ran some benchmarks to assess resource consumption compared to the old version. We were not really worried about startup time. We knew it would be very good. And as long as it stayed in the few seconds window (which we were experiencing on the plain Java version), we were OK. But memory and CPU consumption was another story. The whole exercise was motivated by hopes for some real gains.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、いくつかのベンチマークを実行し、旧バージョンと比較してリソース消費量を評価しました。起動時間についてはあまり気にしていませんでした。非常に優れていることはわかっていましたから。起動時間が数秒以内に収まっていれば（プレーンなJavaバージョンで経験していたことですが）、問題ありませんでした。しかし、メモリとCPUの消費は別の話でした。この試みは、実際に何らかの利益が得られることを期待して行われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the plain Java version we were able to squeeze the container down to `180 Mb` (below that it would either go _OOM_, or the _GC_ would kill the performances). And for the native version, we were able to go as low as `50 Mb`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プレーンなJavaバージョンでは、 `180 Mb` までコンテナを絞り込むことができました（それ以下では、 _OOM_になるか、 _GC_がパフォーマンスを殺してしまいます）。また、ネイティブ版では、 `50 Mb` まで下げることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then we executed several runs with different configurations (`plain Java 180 Mb`, `Quarkus native 180 Mb`, `Quarkus jvm 180 Mb`, `Quarkus native 50 Mb` , starting from `50 millicores request=limit`, moving up to `100`, `150`, …</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、さまざまな構成（ `plain Java 180 Mb` 、 `Quarkus native 180 Mb` 、 `Quarkus jvm 180 Mb` 、 `Quarkus native 50 Mb` 、 `50 millicores request=limit` から始めて、 `100` 、 `150` 、 ...）で数回の実行を行いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At `50 millicores`, `Quarkus native 180 Mb` would run in 20 seconds, `Quarkus native 50 Mb` in 60 seconds, and the others 2 in 300 seconds. This meant that if we allowed `180 Mb` to _ocpdeploy_, we could go from 300 to 20 seconds. A _x15_ times improvement.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`50 millicores` では、 `Quarkus native 180 Mb` が 20 秒、 `Quarkus native 50 Mb` が 60 秒、その他の 2 つが 300 秒で実行されます。つまり、 `180 Mb` を _ocpdeploy_ に許可すれば、300秒から20秒になるということです。 _15_倍の改善です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At `250 millicores` we had `Quarkus native 180 Mb` under 5 seconds, `Quarkus native 50 Mb` at 10 seconds, and the 2 others around 40 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`250 millicores` では、 `Quarkus native 180 Mb` が5秒以下、 `Quarkus native 50 Mb` が10秒、その他の2つが40秒前後でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We searched also how much CPU was needed to get a deployment under 60 seconds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、デプロイメントを60秒以下にするために、どれだけのCPUが必要かを調べました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For `Quarkus native 50 Mb` it was `50 millicores`, for `plain Java 180 Mb` and `Quarkus jvm 180 Mb` it was `240 millicores` (`Quarkus native 180 Mb` was out of scope since its "worst" result was 20 seconds as discussed in the first test). This meant that if time was our constraint, we could go from `240 millicores` to `50 millicores`, while going from `180 Mb` to `50 Mb` by moving to Quarkus native.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Quarkus native 50 Mb` では `50 millicores` 、 `plain Java 180 Mb` と `Quarkus jvm 180 Mb` では `240 millicores` でした（ `Quarkus native 180 Mb` は、最初のテストで説明したように「最悪」の結果が 20 秒だったため、対象外となりました）。つまり、時間に制約がある場合は、 `240 millicores` から `50 millicores` へ、また、 `180 Mb` から `50 Mb` へは、Quarkus native へ移行することで対応できるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comparison between `Quarkus native 180 Mb` and `50 Mb` was interesting as well, because it showed that by pushing up and down the memory and CPU knobs we could work on the use case execution duration. It was then up to us to decide where was the sweet spot between execution time and resource consumption.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Quarkus native 180 Mb` と `50 Mb` の比較も興味深いものでした。というのも、メモリと CPU のノブを上げ下げすることで、ユースケースの実行時間を調整できることがわかったからです。実行時間とリソース消費の間のスイートスポットをどこに設定するかは、私たち次第です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last interesting observation we made was that the results for `plain Java 180 Mb` were nearly identical to `Quarkus jvm 180 Mb`. This meant that the cost of the applicative framework, which provides maintainability and productivity, was 0 in our case. It's like having your cake and eating it as well. In our case we did not mind slow executions, as long as we could save a lot on memory and CPU, which we were able to achieve.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に興味深い観察結果として、 `plain Java 180 Mb` の結果が `Quarkus jvm 180 Mb` とほぼ同じだったことが挙げられます。これは、保守性と生産性を提供するアプリケーションフレームワークのコストが、私たちのケースでは0だったということです。ケーキを食べているようなものですね。私たちの場合、メモリとCPUを大幅に節約できるのであれば、実行速度が遅くても構わないと考えていましたが、それが実現できました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Program execution in seconds for different limits (in millicores)  [cols="h,,,,",options="header",width="20%]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>異なる制限値（単位：millicores）におけるプログラム実行時間（秒） [cols="h,,,,",options="header",width="20%].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>||plain Java (180Mb)|Quarkus Native (180Mb)|Quarkus JVM (180Mb)|Quarkus Native (50Mb)  |50m|283|18|306|61 |100m|95|9|120|32 |250m|38|4|43|11 |500m|17|3|21|8 |1000m|11|3|11|5 |1500m|9|3|8|5 |2000m|7|3|7|5 |No Limit|8|3|6|5</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>||plain Java (180Mb)|Quarkus Native (180Mb)|Quarkus JVM (180Mb)|Quarkus Native (50Mb)  |50m|283|18|306|61 |100m|95|9|120|32 |250m|38|4|43|11 |500m|17|3|21|8 |1000m|11|3|11|5 |1500m|9|3|8|5 |2000m|7|3|7|5 |No Limit|8|3|6|5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few issues</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの問題点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beside the challenges of running ad hoc libraries in GraalVM, there were a few unexpected behaviors or minor pain points we ran into, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVMでアドホック・ライブラリを動作させる上での課題以外にも、予期せぬ動作やちょっとした問題点がいくつかありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Missing warning on unknown application configuration property https://github.com/quarkusio/quarkus/issues/14889[#14889]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>不明なアプリケーション構成プロパティに対する警告の欠落 link:https://github.com/quarkusio/quarkus/issues/14889[#14889]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default on config pojo should behave the same if set in `src/main/resources/application.yaml` https://github.com/quarkusio/quarkus/issues/13423[#13423]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`src/main/resources/application.yaml` で設定した場合、pojoの設定上のデフォルトは同じ動作をするべき。 link:https://github.com/quarkusio/quarkus/issues/13423[#13423]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Warn or fail if an application.yaml is provided without the `quarkus-config-yaml` dependency https://github.com/quarkusio/quarkus/issues/13227[#13227]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-config-yaml` の依存関係なしで application.yaml が提供された場合、警告または失敗する link:https://github.com/quarkusio/quarkus/issues/13227[#13227]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Upgrade to _MP Rest Client_ 2.0 https://github.com/quarkusio/quarkus/issues/10520[#10520], which we have been waiting for, to get "follow redirects"</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_MP Rest Client_2.0 link:https://github.com/quarkusio/quarkus/issues/10520[#10520]へのアップグレード。待望のものであり、"リダイレクトへの追従 "が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I wished there was a way to define mock alternatives per test through annotation, but this was answered in https://groups.google.com/g/quarkus-dev/c/IBojyD1BplY/m/NWFmsX3NBwAJ[this thread]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アノテーションでテストごとにモックを定義する方法があればと思いましたが、これは link:https://groups.google.com/g/quarkus-dev/c/IBojyD1BplY/m/NWFmsX3NBwAJ[このスレッド]で回答されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inability to provide certificates at run time instead of build time (GraalVM limitation) https://github.com/oracle/graal/pull/3091[#3091]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>証明書をビルド時ではなく実行時に提供できない（GraalVMの制限) link:https://github.com/oracle/graal/pull/3091[#3091]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visibility of `src/main/resources/application.properties` in test as discussed in https://groups.google.com/g/Quarkus-dev/c/xCU6Yvw__ks/m/cogHVvNsAwAJ[this thread]; A lot of work has been done since then such as "Use AbstractLocationConfigSourceLoader to load application.properties and application.yaml" https://github.com/quarkusio/quarkus/pull/15282[#15282], so I need to recheck</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://groups.google.com/g/Quarkus-dev/c/xCU6Yvw__ks/m/cogHVvNsAwAJ[このスレッド] で議論されているように、テストにおける `src/main/resources/application.properties` の可視性; 以来、"Use AbstractLocationConfigSourceLoader to load application.properties and application.yaml" https://github.com/quarkusio/quarkus/pull/15282[#15282] など、多くの作業が行われてきました、そのため、再チェックが必要です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional config property overriden with empty value as discussed in https://groups.google.com/g/Quarkus-dev/c/_g-6qfUFA3A/m/2s9XjTVxAwAJ[this thread]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://groups.google.com/g/Quarkus-dev/c/_g-6qfUFA3A/m/2s9XjTVxAwAJ[このスレッド]で議論されているように、オプションの設定プロパティが空の値で上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This seems quite a bit, but actually none of those bullet points were major issues, or something we could not work around. Several issues were related to configuration, in part because the program was run as a Tekton task, and there is limited flexibility on how you define optional parameters in Tekton. I have listed only those points that we had to work around. Many issues or questions were actually resolved as we were making progress through answers in the google group, or actual fixes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これはかなりの量に見えますが、実際にはこれらの箇条書きはどれも大きな問題ではなく、回避できないものでもありませんでした。いくつかの問題は設定に関するものでしたが、これはプログラムがTektonタスクとして実行されていたためで、Tektonではオプションのパラメータを定義する際の柔軟性が限られています。ここに挙げたのは、回避しなければならなかった点のみです。多くの問題や質問は、Google Groupでの回答や実際の修正により、進行中に解決されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CI for native builds</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブビルドのためのCI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another challenge was related to native build time, memory and CPU usage during those builds. The approach we took was to only generate a native executable on master, and run tests in jvm mode on the feature branches. We would still have an option to test against native in a particular feature branch if we needed to. But unless we were integrating a new library, getting the jvm tests to pass gave us sufficient confidence that we would have an identical behavior in native.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つの課題は、ネイティブビルドの時間と、その間のメモリとCPUの使用量に関するものでした。そこで私たちがとった方法は、マスターでのみネイティブの実行ファイルを生成し、フィーチャーブランチではjvmモードでテストを実行するというものでした。必要であれば、特定のフィーチャーブランチでネイティブテストを行うという選択肢もあります。しかし、新しいライブラリを統合するのでなければ、jvmテストを通過させることで、ネイティブでも同様の動作をするという十分な自信を持つことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other trick we applied was to cancel the current build on _master_ if a new one got triggered; that way we would not have multiple native builds running at the same time. In theory it could be frustrating to get a build killed because another commit was done. In practice this was not an issue because the rate of PRs getting merged on _master_ stayed low.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう一つの工夫は、新しいビルドが開始されたときに、 _マスター_の現在のビルドをキャンセルすることでした。理論的には、別のコミットが行われたためにビルドがキャンセルされるのはフラストレーションがたまるかもしれません。実際には、PRが _master_にマージされる割合は低いままだったので、この問題はありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But there are definitely some questions around sizing a build infrastructure if we had wanted to increase the number of Quarkus applications developed internally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、社内で開発するQuarkusアプリケーションの数を増やしたいと考えた場合、ビルドインフラのサイズには疑問が残ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only drawback compared to the original solution was that our regression test suite was slower to run, essentially because our tests generated resources in the context of a specific configuration. And since we were using _MP config_, we needed to boot a new Quarkus context every time we wanted to test a different configuration. Fortunately booting a new context is extremely fast in Quarkus, but still a lot slower than with our original plain Java solution.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>オリジナルのソリューションと比較した場合の唯一の欠点は、リグレッションテストスイートの実行が遅くなったことです。 _MPconfig_を使用していたので、異なるコンフィグをテストするたびに、新しいQuarkusコンテキストを起動する必要がありました。幸いなことに、新しいコンテキストの起動はQuarkusでは非常に高速ですが、それでも元々のプレーンなJavaソリューションに比べればかなり遅いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is all about the community</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>すべてはコミュニティのために</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beside work on the Vault, FreeMarker and OpenShift Client extensions, we started contributing a few PRs in and outside Quarkus, hoping to speed up the process of getting improvements, such as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vault、FreeMarker、OpenShift Clientのエクステンションの作業の他に、Quarkus内外でいくつかのPRに貢献し始めました。これは、以下のような改善を得るためのプロセスをスピードアップすることを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `appendResourceVersionInObject` for CRD objects https://github.com/fabric8io/kubernetes-client/pull/2365[#2365] (merged)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CRDオブジェクトに `appendResourceVersionInObject` を追加 link:https://github.com/fabric8io/kubernetes-client/pull/2365[#2365](merged)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add cert-manager extension support https://github.com/fabric8io/kubernetes-client/pull/2930[#2930] (merged)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>cert-manager エクステンションサポートの追加 link:https://github.com/fabric8io/kubernetes-client/pull/2930[#2930](merged)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build distroless image using cekit in ci https://github.com/quarkusio/quarkus-images/pull/118[#118] (merged)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ci で cekit を使って distroless イメージをビルド link:https://github.com/quarkusio/quarkus-images/pull/118[#118](merged)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Allow root certificates to be configured at run time of native image https://github.com/oracle/graal/pull/3091[#3091] (_teshull_ assigned by Christian Wimmer at Oracle to work on this for the GraalVM 21.3 release)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ネイティブイメージの実行時にルート証明書を設定できるようにしました link:https://github.com/oracle/graal/pull/3091[#3091] (_teshull_はオラクルの Christian Wimmer から GraalVM 21.3 リリースのための作業を任されました)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is worth noting that the Quarkus community has been a huge factor for success, by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特筆すべきは、Quarkusのコミュニティが成功の大きな要因になっていることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answering questions on the google group, zulip or other means such as stackoverflow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>googleグループやzulipなど、stackoverflowなどで質問に答えること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Investigating issues in a timely fashion, and depending on the situation either providing fixes, guidance on applying the right approach, or workarounds.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>問題をタイムリーに調査し、状況に応じて、修正、正しいアプローチの適用に関するガイダンス、または回避策を提供すること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being open to improvements (e.g. on configuration).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>設定などの改善に前向きであること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reviewing PRs quickly, and facilitating contributions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>PRを迅速にレビューし、貢献を促進すること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Releasing with high frequency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>高い頻度でリリースすること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Takeovers</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>引継ぎ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It took us only a few months to do the migration, and we started deploying our first OpenShift application with our Quarkus powered _ocpdeploy_ end of last year. Since then, it was used to run hundreds of deployments. We were able to follow the pace of new releases with limited effort. We incurred very few bugs, usually fixed in time for the next release. The applicative framework provided by Quarkus allowed us to better structure our code, making it more maintainable, and easy to tests with mock features and test profiles. It is interesting to note as well that _ocpdeploy_ development was done by team members that were not Quarkus developers, or even strong Java specialists. This is a sign that the framework is light enough that once the overall structure (e.g. components, tests, configuration, ci) is in place, we can forget about it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>移行に要した期間はわずか数ヶ月で、昨年末にはQuarkusを搭載した _ocpdeploy_で最初のOpenShiftアプリケーションのデプロイを開始しました。それ以来、何百ものデプロイメントを実行するために使用されました。限られた労力で新しいリリースのペースを追うことができました。バグはほとんど発生せず、通常は次のリリースに間に合うように修正されました。Quarkusが提供するアプリケーションフレームワークにより、コードの構造化が進み、保守性が向上し、モック機能やテストプロファイルを使ったテストが容易になりました。 _ocpdeploy_の開発は、Quarkusの開発者ではなく、Javaの専門家でもないチームメンバーによって行われたことも興味深い点です。これは、フレームワークが、全体的な構造（例：コンポーネント、テスト、構成、ci）が整ってしまえば、それを忘れることができるほど軽量であることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our program was not business critical in the sense that if it did not work, business would not stop. But it is the only mean to deploy all of our OpenShift microservices. And given the pace of internal developments, it is considered a critical piece in the value chain. _ocpdeploy_ is not evidently ultra sophisticated, and we only scratched the surface of what could be done with Quarkus, but yet it worked for us, showing that it can tackle many different use cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのプログラムは、それが動作しなければビジネスが止まらないという意味で、ビジネスクリティカルではありませんでした。しかし、OpenShiftのマイクロサービスをすべてデプロイするには、このプログラムしかありません。 _ocpdeploy_は明らかに超高度なものではなく、Quarkusでできることの表面をなぞっただけでしたが、それでも私たちのために動いてくれたので、さまざまなユースケースに取り組めることがわかりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In conclusion, I think the strong selling points for Quarkus are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>結論として、Quarkusの強力なセールスポイントは以下の通りだと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A vivid community, which listens actively for feedback, and welcome contributions</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>積極的にフィードバックに耳を傾け、貢献を歓迎する生き生きとしたコミュニティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A project developed with high velocity</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ハイスピードで開発されたプロジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The right positioning (cloud native, developer joy, …) with versatility</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>汎用性のある適切なポジショニング（クラウドネイティブ、デベロッパー満足度、...）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An architecture with a compact core and extensions, allowing for rapid expansion, which will nurture innovation</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンパクトなコアとエクステンションを持ち、迅速な拡張を可能にすることで、イノベーションを育むアーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for native by default, but also some improvements in jvm mode also</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトではネイティブをサポートしていますが、jvmモードでもいくつかの改良が加えられていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fast growing eco-system through the core extensions, the universe extensions (e.g. camel) and the Quarkiverse</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コアのエクステンション、ユニバースエクステンション（例：camel）、Quarkiverseによる急成長のエコシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode (local and remote)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モード（ローカルおよびリモート）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A framework for developing extensions that facilitate implementing patterns such as the build time initialization</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ビルド時の初期化などのパターンを実現するためのエクステンションを開発するためのフレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main challenge I see going forward, similarly to app stores 10 or 15 years ago, is to make sure that the extension eco-system grows in quantity without sacrifice for quality. Or at least provide a way to rate extensions, so that people building business critical applications get assurances that their investment in the technology is sound. In other words going deep in addition to going wide.  The other challenge I see is progressively filling the gaps of enterprise readiness; for instance finishing up solutions sometimes partially developed today, and making sure there is a clear and mature solution for the most common use cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>10年前、15年前のアプリストアと同じように、私が考える今後の主な課題は、エクステンションのエコシステムが、品質を犠牲にすることなく量的に成長するようにすることです。あるいは、少なくともエクステンションを評価する方法を提供して、ビジネスクリティカルなアプリケーションを構築する人々が、テクノロジーへの投資が適切であることを保証できるようにすることです。言い換えれば、"広く広く "に加えて "深く "ということです。私が考えるもう一つの課題は、企業の準備状況のギャップを徐々に埋めていくことです。例えば、今日、部分的に開発されているソリューションを完成させ、最も一般的なユースケースに対して明確で成熟したソリューションを提供できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is how Quarkus will win over enterprises. And I can see this being in motion.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それが、Quarkusがエンタープライズに勝つ方法です。そして、これが動き出しているのがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I am very hopeful for the project. Can't wait to expand the use cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロジェクトにはとても期待しています。早くユースケースを広げたいですね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each Quarkus release, it's the same story: it comes with a ton of exciting new features and enhancements... But believe it or not, it's true.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのリリースのたびに、同じことが起きています:沢山の刺激的な新機能や機能強化が行われています、、信じられないかもしれませんが、本当です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive,</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Dev UI.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it also comes with many other enhancements be it for Micrometer, for jbang or for our Spring compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、Micrometer、jbang、スプリング互換性レイヤーなどに対しても、他にも多くの機能強化が施されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And this release wouldn't be so great without all the people who tested our Betas and CR so a big thanks to everyone who participated in testing this release!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そして、このリリースはBetaとCRをテストしてくれた全ての人がいなければ、ここまで素晴らしいものにはならなかったでしょう。このリリースのテストに参加したすべての人に感謝します!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[our migration guide for 1.11].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のアプリケーションの移行をお考えですか? link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11の移行ガイド]はこちらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3 in its Java 11 flavor is the newly recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11のフレーバーのGraalVM 20.3は、新たに推奨されているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you probably guessed from the name, this work is a *new JAX-RS implementation* written from the ground up to work on our common *Vert.x* layer and is thus fully *reactive*, while also being very *tightly integrated with Quarkus* and consequently moving a lot of framework specific work (like annotation scanning and metamodel generation) to *build time*.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>名前からお察しの通り、この作品は共通の *Vert.x* レイヤー上で動作するように一から書かれた *新しいJAX-RSの実装* であり、完全に *リアクティブ* であると同時に、 *Quarkusと緊密に統合されて* いるため、フレームワーク固有の作業(アノテーションスキャンやメタモデル生成など)の多くを *ビルド時に* 移行させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive allows you to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive は、広く使用されている非常に強力な JAX-RS API を活用してアプリケーションの REST レイヤーを公開し、アプリケーションが達成できる最大スループットを大幅に向上させることができます。また、アプリケーションの起動がわずかに速くなり、メモリーの消費量が少し減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It got presented in great details by Georgios in https://quarkus.io/blog/resteasy-reactive/[the RESTEasy Reactive announcement].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それは link:https://quarkus.io/blog/resteasy-reactive/[RESTEasy Reactiveの発表] の中で、Georgios氏によって非常に詳細に紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A detailed documentation is available in the link:/guides/resteasy-reactive[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細なドキュメントは、 link:/guides/resteasy-reactive[RESTEasy Reactiveガイド] にございます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the beginning of a great story: Quarkus 1.11 offers a UI dedicated to development to make it easier than ever.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは素晴らしい物語の始まりです。Quarkus 1.11では、開発をこれまで以上に簡単にする為に、特化したUIが提供されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each extension can expose features in this Dev UI, be it to list the CDI beans, list your endpoints, replay your Flyway migrations, deploy to OpenShift... Sky is the limit.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>各エクステンションは、CDI Beanのリスト、エンドポイントのリスト、Flywayマイグレーションのリプレイ、OpenShiftへのデプロイなど、このDev UIで機能を公開することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.11 introduces the infrastructure of this Dev UI and some features already.  If you are an extension developer or wants to do some frontend work, additions and improvements are very welcome.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.11では、このDev UIのインフラと、すでにいくつかの機能が提供されています。もしあなたがエクステンションの開発者であったり、フロントエンドの仕事をしたいと思っているなら、追加や改善は大歓迎です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Dev UI is available in dev mode only (e.g. `mvn quarkus:dev`) and accessible at the `/q/dev` endpoint by default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev UI は開発モードでのみ利用可能で(例: `mvn quarkus:dev` )、デフォルトでは `/q/dev` エンドポイントからアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to add a feature to the Dev UI? Just have a look at link:/guides/dev-ui[our Dev UI guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Dev UI に機能を追加したいですか? link:/guides/dev-ui[Dev UI ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Micrometer support is continuously improving:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>当社のMicrometer対応は常に改善しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Streams metrics are now exposed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka Streams のメトリクスが公開されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registries were moved to extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジストリーはエクステンションに移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for registries, the one for **Prometheus** is part of our Core extensions: `io.quarkus:quarkus-micrometer-registry-prometheus`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>レジストリーに関しては、 **Prometheus** 用のものはCoreエクステンション: `io.quarkus:quarkus-micrometer-registry-prometheus` の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the registries are hosted in the Quarkiverse (our home for additional extensions):</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>残りのレジストリーはQuarkiverseでホストされています(追加のエクステンションのためのホーム):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Monitor</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Azure Monitor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datadog</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Datadog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SignalFX</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SignalFX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stackdriver</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Stackdriver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StatsD</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>StatsD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you feel like contributing to these registries or creating new ones, the https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registry project] is the place you are looking for.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのレジストリーに貢献したい、または新しいレジストリーを作成したいとお考えの方は、 link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registryプロジェクト] をご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Spring Data REST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using our Spring Data compatibility layer, you can now benefit from the Spring Data REST extension to simplify writing a CRUD REST layer.  It is very similar to our REST with Panache extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>弊社のSpring Data互換レイヤーを使用している場合、Spring Data RESTエクステンションの恩恵を受けて、CRUD RESTレイヤーの記述を簡単にすることができます。これはREST with Panacheエクステンションと非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in link:/guides/spring-data-rest[the dedicated guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>詳細については、 link:/guides/spring-data-rest[専用のガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non application endpoints moved to `/q/`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーション以外のエンドポイントは `/q/` に移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes some technical endpoints that are not part of your application (for example, the Health endpoints).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、アプリケーションの一部ではない技術的なエンドポイント(Healthエンドポイントなど)をいくつか公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid conflicts with your application endpoints, they have all been moved to the `/q/` namespace.  Redirects have been added to redirect the old URLs to the new ones.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションのエンドポイントとの衝突を避けるために、これらはすべて `/q/` 名前空間に移動されました。古い URL を新しい URL にリダイレクトするためのリダイレクトが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This root path can be customized with `quarkus.http.non-application-root-path`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このルートパスは、 `quarkus.http.non-application-root-path`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, it was only possible to inject the JPA `EntityManagerFactory` and `EntityManager` in your applications.  Starting with 1.11, you can inject the Hibernate ORM-specific `SessionFactory` and `Session` if you need to access their specific methods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、JPA `EntityManagerFactory` と `EntityManager` をアプリケーションに注入することしかできませんでした。1.11 からは、Hibernate ORM 固有の `SessionFactory` と `Session` の特定のメソッドにアクセスする必要がある場合は、注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`FAIL_ON_UNKNOWN_PROPERTIES` is now disabled by default for the default CDI-enabled `ObjectMapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトで CDI で有効になっている `ObjectMapper` で `FAIL_ON_UNKNOWN_PROPERTIES` が無効になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See https://quarkus.io/guides/rest-json#jackson for more details about how to go back to the previous behavior.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前の動作に戻す方法については、 https://quarkus.io/guides/rest-json#jackson を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The integration with https://jbang.dev[jbang] now supports enabling development mode and can use Quarkus platforms (BOM) for version management.  For this you need to use jbang v0.62+.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://jbang.dev[jbang]との統合は、開発モードの有効化をサポートするようになり、バージョン管理にQuarkusプラットフォーム(BOM)を使用できるようになりました。このためには、jbang v0.62+を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run it, just pass in `-Dquarkus.dev`, i.e.:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>実行するには、 `-Dquarkus.dev` を渡すだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of `@pom` in the first line; that instructs jbang to load the pom for the platform and use it for version management and the other dependency versions can be left out.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初の行で `@pom` を使用していることに注意してください。これは jbang にプラットフォーム用の pom をロードしてバージョン管理に使用するように指示しており、他のバージョン指定をしないで済むようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then with dev mode you can edit that file and save it again and Quarkus live reload feature will take care of applying the changes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、開発モードでファイルを編集して再度保存すると、Quarkusのライブリロード機能が変更の適用の世話をしてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other dev mode features like `https://localhost:8080/q/dev` and `https://localhost:8080/q/swagger-ui` are also available.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他にも `https://localhost:8080/q/dev` や `https://localhost:8080/q/swagger-ui` のような開発モードの機能が用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now this only works for single file jbang scripts, future releases will enable it to work for multiple files too.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今のところ、これは単一ファイルのjbangスクリプトに対してのみ動作しますが、将来のリリースでは複数のファイルに対しても動作するようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>GraalVM 20.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.11 is GraalVM 20.3.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.11に対するGraalVMの推奨バージョンはGraalVM 20.3です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final]の全変更履歴は GitHub で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[417 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[417人の貢献者] がいます。一人ひとりに多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The just released Quarkus 1.10.2.Final comes with a lot of improvements and new features:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リリースされたばかりのQuarkus 1.10.2.Finalには、多くの改善と新機能が搭載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default media type is now JSON</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのメディアタイプがJSONになりました</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts is now the default project generation tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CodeStarts はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Qute error pages</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい Qute のエラーページ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Part of the Hibernate ORM configuration is now overridable at runtime</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>HibernateのORM設定の一部が実行時にオーバーライド可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients support multiple datasources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブ SQL クライアントが複数のデータソースをサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Amazon IAM extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいAmazon IAMのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[our migration guide for 1.10].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のアプリケーションの移行をお考えですか?ここに  https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10への移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is still the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Java 11 対応の GraalVM 20.2 は、まだ推奨の GraalVM のバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where is my 1.10.0.Final (and my 1.10.1.Final)?!?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.10.0.Final(と1.10.1.Final)はどこにあるの!?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We spotted a regression in the Caffeine extension and decided to skip the announcement of 1.10.0.Final altogether.  And then we spotted an issue with the Platform BOM and had to release a 1.10.2.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Caffeine エクステンションのリグレッションを発見しました。そのため 1.10.0.Final の発表をスキップしました。そして、Platform BOM の問題を発見しました。なので 1.10.2.Final をリリースしなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All in all, we managed to fix a few more issues in the meantime so that makes 1.10.2.Final a greater release.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その間にいくつかの問題を修正することができたので、1.10.2.Final はより大きなリリースとなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON as the Default Content Type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのコンテンツタイプとしての JSON</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In an effort to make your REST resources less verbose and considering nowadays JSON is the most widely used content type for REST services, it is now the default in Quarkus for your REST resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST リソースを冗長にならないようにするための努力と、最近では JSON が REST サービスで最も広く使用されているコンテンツタイプであることを考慮して、Quarkus では REST リソースのデフォルトとして JSON が使用されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It means that, if you are using JSON, you don't need to add `@Produces` and `@Consumes` annotations anymore.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>つまり、JSON を使用している場合は、`@Produces` と `@Consumes` のアノテーションを追加する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also means that if you were relying on content type negotiation, you will have to add these annotations with the content types you support.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、コンテンツタイプネゴシエーションに頼っていた場合、サポートしているコンテンツタイプでこれらのアノテーションを追加しなければいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts as Default Project Generation Tool</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのプロジェクト生成ツールとしてのCodeStarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CodeStarts project has been a long and steady effort.  Good news: it is now the default project generation tool.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CodeStarts プロジェクトは、長い間地道な努力を続けてきました。朗報:今はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From an end user perspective, it brings a better UI, more flexibility and code examples.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドユーザーの視点から見ると、より良い UI、より柔軟性のあるコード例をもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two new registries were added:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新たに2つのレジストリーが追加されました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also added more metrics.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらにメトリクスを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of work has been done to make the Swagger/GraphQL/Health/OpenAPI UIs consistent and Quarkus-themed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Swagger/GraphQL/Health/OpenAPI UI を一貫して Quarkus をテーマにしたものにするために、多くの作業が行われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also now disable them at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、実行時にそれらを無効にすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More specifically on the Swagger UI front, all the Swagger UI configuration knobs have been exposed as Quarkus configuration properties.  You can learn more about it in link:/blog/stylish-api/[the just published Stylish API blog post].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>より具体的には、Swagger UI の前面では、すべての Swagger UI 設定のつまみが Quarkus の設定プロパティーとして公開されています。それについては、  https://quarkus.io/blog/stylish-api/[先日公開されたばかりの Stylish API のブログ記事]で紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Qute, our template engine, you will be pleased to see our shiny new error pages, which points you to the error and makes you even more productive:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テンプレートエンジンのQuteをお使いの方は、ピカピカのエラーページをご覧になって喜んでいただけると思います。これがエラーを指摘し、さらに生産性を高めてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before 1.10, all of the Hibernate ORM configuration properties were fixed at build time.  Mostly for optimization purposes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.10 以前では、すべての Hibernate ORM 構成プロパティーがビルド時に修正されていました。主に最適化のためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With 1.10, we started to relax this rule for some carefully chosen properties and you can now override the following properties at runtime:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.10 では、慎重に選択したいくつかのプロパティーについてこのルールを緩和しました。以下のプロパティーを実行時にオーバーライドできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.5.0 which includes several improvements and Mutiny to 0.11.0.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>SmallRye Reactive Messaging  が 2.5.0 にアップグレードされました。これにより、いくつかの改善と Mutiny が 0.11.0 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive SQL Clients now support multiple datasources: you can connect to several databases, exactly in the same way as for JDBC datasources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive SQL クライアントは複数のデータソースをサポートするようになりました。これによって複数のデータベースに接続できるようになりました。JDBC データソースの場合と全く同じ方法で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Amazon Services extensions got a new friend: a brand new Amazon IAM extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Amazon サービスのエクステンションに新しい友人ができました。真新しい Amazon IAM エクステンションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More on this one in link:/guides/amazon-iam[the Amazon IAM guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これについては、 https://quarkus.io/guides/amazon-iam[Amazon IAM ガイド]で詳しく紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of Google Cloud-related work is taking place in the https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Google Cloud 関連の仕事の多くは https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse] で行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And if you wonder how you will deploy your Quarkus application to Google Cloud, we have a link:/guides/deploying-to-google-cloud[new guide] for you.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Quarkus アプリケーションをどのように Google Cloud にデプロイするのか疑問に思っている方のために、 https://quarkus.io/guides/deploying-to-google-cloud[新しいガイド]をご用意しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.24.Final</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate ORM が 5.4.24.Final にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1], https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final], https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final] and https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] の完全な変更ログはGitHubで入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[395 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusには現在 https://github.com/quarkusio/quarkus/graphs/contributors[395人の貢献者]がいます。皆様、本当にありがとうございました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It gives the Quarkus and RESTEasy teams great pleasure to announce that RESTEasy Reactive integration in Quarkus has landed in the main Quarkus repo footnote:disclaimer[Currently the main RESTEasy Reactive component resides at https://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactive in the main Quarkus repository; the plan is however that once things settle, this code will move to https://github.com/resteasy/resteasy-reactive. This move should not affect users of the quarkus-resteasy-reactive extensions in any way, just a heads up if anyone reads this blog post in the future and can’t find it.] and will be part of the next Quarkus release 1.11.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusとRESTEasyチームは、QuarkusにおけるRESTEasy Reactiveの統合がメインのQuarkusレポジトリに到着したことを発表することに大きな喜びを感じています。 footnote:disclaimer[現在、メインのRESTEasy Reactiveコンポーネントは、メインのQuarkusリポジトリのhttps://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactiveにあります。この移動は、quarkus-resteasy-reactive エクステンションのユーザーには何ら影響を与えないはずです。このブログポストを将来読んだ人が見つけられなかった場合に備えての追記。] 次のQuarkusリリース 1.11 に含まれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are looking forward to everyone testing it and providing us as much feedback as possible.  In typical Quarkus fashion, the project is consumable as a new set of extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>皆さまにテストしていただき、できるだけ多くのフィードバックを提供していただけると幸いです。 典型的なQuarkusのやり方で、このプロジェクトは新しいエクステンションのセットとして利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is it?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why should I care?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜ重要なのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest answer is that you can continue to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最も単純な答えは、アプリケーションの REST レイヤを公開する為に広く使われている非常に強力な JAX-RS API を活用し続けながら、アプリケーションが達成できる最大スループットを大幅に向上できるということです。また、アプリケーションは起動が少し速くなり、メモリーの消費量が少し減るはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our benchmarks reveal that the measurable performance with this new extension is almost identical to what we would achieve using Quarkus' Reactive Routes API (which is a very interesting API in its own right, but is generally more low level - not to mention the fact that it's a new API developers would need to learn).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ベンチマークでは、この新しいエクステンションを使った測定可能なパフォーマンスは、QuarkusのReactive Routes API(それ自体は非常に興味深いAPIですが、一般的には低レベルなものです)とほぼ同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when comparing our results to other competing enterprise Java frameworks that provide annotation based REST layers, Quarkus provided as much as double the throughput depending on the benchmark.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、アノテーションベースのRESTレイヤーを提供する他の競合するエンタープライズJavaフレームワークと結果を比較すると、ベンチマークによっては、Quarkusは2倍ものスループットを提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What other benefits are there?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他にはどんなメリットがあるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As if the familiar API and the much improved runtime characteristics of the new extension weren't enough, we have added some really exciting and convenient new features (which are not part of the JAX-RS spec) that have either been requested by the community, or are things we feel improve the developer experience and soften some of the spec’s rough edge.  These new features are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>おなじみのAPIと、新しいエクステンションの大幅に改善されたランタイム特性だけでは十分ではないかのように、コミュニティからの要望に基づき、あるいは開発者の経験を向上させ、仕様の粗いエッジを和らげてくれると我々が考える、本当にエキサイティングで便利な新機能(JAX-RS仕様の一部ではありません)をいくつか追加しました。これらの新機能は以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-blocking by default</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトでノンブロッキング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All endpoints are now running on the IO thread by default. You can use `@Blocking` to change that.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトではすべてのエンドポイントが IO スレッド上で実行されます。 `@Blocking` を使えばこれを変更出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scoring system</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スコアリングシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On dev-mode startup, the application will show you a list of your endpoints, along with a performance score telling you why your endpoint is slower than an optimal version. This helps a lot in figuring out how to improve REST performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>devモードで起動すると、アプリケーションはエンドポイントのリストを表示し、エンドポイントが最適なバージョンよりも遅い理由を示すパフォーマンススコアを表示します。これは、REST のパフォーマンスを向上させる方法を見つけるのに非常に役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New request/response filter design</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リクエスト/レスポンスフィルターの新しい設計</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JAX-RS filters require implementing an interface and injecting context objects as fields, which is costly and inflexible. Based on our success in the Quarkus build system, filters are now simply annotated methods and any parameter is automatically injected:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSのフィルターは、インターフェースを実装し、コンテキストオブジェクトをフィールドとして注入する必要がありますが、これはコストがかかり、柔軟性に欠けます。Quarkus ビルドシステムでの成功に基づき、フィルタは単にアノテーション付きのメソッドになり、全てのパラメーターは自動的に注入されるようになりました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, if filters need to perform blocking operations, then they can return `Uni&lt;Void&gt;` and RESTEasy Reactive will not block the event-loop thread while executing the filter.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、フィルタがブロッキング操作を行う必要がある場合は `Uni&lt;Void&gt;` を返すことができ、RESTEasy Reactive はフィルタを実行している間はイベントループスレッドをブロックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, although we haven’t done it yet, this approach could easily be extended to other types of JAX-RS Providers thus completely forgoing the need to use `@Context` in their code.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後に、まだ実施していませんが、このアプローチは他のタイプのJAX-RSプロバイダにも簡単に拡張でき、コード中で `@Context` を使用する必要が完全になくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New `*Param` annotations</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい `*Param` アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These annotations are meant to be used instead of the JAX-RS `@PathParam`, `@QueryParam` etc. annotations, without having the need to specify a name.  The reason we chose not to reuse the same annotation names is to avoid conflicting with either JAX-RS or other EE specs:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのアノテーションは、JAX-RSの `@PathParam`, `@QueryParam` などのアノテーションの代わりに、名前を指定することなく使用することを意図しています。  同じアノテーション名を再利用しないことにしたのは、JAX-RSや他のEE仕様との衝突を避けるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simpler parameter and context injection</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>よりシンプルなパラメーターとコンテキストインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With RESTEasy Reactive you don’t even need to use `@PathParam` or `@RestPath` if your parameter has the same name as a path parameter, and similarly you can skip `@Context` for all the known context types, which makes it even simpler:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive では、パラメーターがパスパラメーターと同じ名前であれば `@PathParam` や `@RestPath` を使用する必要はありませんし、同様に、既知のすべてのコンテキストタイプに対して `@Context` を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New optimal message body reader / writer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい最適なメッセージボディのリーダー/ライター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no filters and interceptors are invoked when an endpoint is serviced, you can use more efficient message body writers that directly write to vert.x and don’t require reflection and annotations:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントがサービスされるときにフィルタやインターセプタが呼び出されない場合、 リフレクションやアノテーションを必要としない、vert.x に直接書き込む、更に効率的なメッセージボディライターを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default content types</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのコンテンツタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Endpoints that return a String default to producing text/plain. We plan to do the same for JSON and other types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>String を返すエンドポイントは、デフォルトで text/plain を生成します。JSON やその他の型についても同様のことを行う予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All injections via JAX-RS’s @Context are delegated to Arc. This provides users with the benefits of build time injection that Arc brings to all other parts of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RSの@Contextを介したインジェクションはすべてArcに委譲されます。これにより、ユーザーは、ArcがQuarkusの他のすべての部分にもたらすビルドタイムインジェクションのメリットを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Per-class Exception Mapper</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスごとの例外マッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JAX-RS specification there’s no way to handle exceptions differently for a specific JAX-RS Resource Class - all exception mapping is done in a global manner.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>JAX-RS仕様では、特定のJAX-RSリソースクラスに対して異なる例外を処理する方法はありません - すべての例外のマッピングはグローバルな方法で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In RESTEasy Reactive however you can simply do something like:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、RESTEasy Reactive では、次のようなことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to customize the exception handling of certain Resource Classes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>特定のリソースクラスの例外処理をカスタマイズする為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that `@ServerExceptionMapper` can be used to handle exceptions in a global manner, just as JAX-RS does with `ExceptionMapper`.  To do that, simply annotate a method that does not belong to a Resource class with `@ServerExceptionMapper`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、`@ServerExceptionMapper`は、JAX-RSが`ExceptionMapper`を使うのと同じように、グローバルな方法で例外を扱うことができることにも注意する必要があります。  そのためには、Resourceクラスに属さないメソッドに `@ServerExceptionMapper` をアノテーションするだけで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do other extensions work with it?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他のエクステンションでも動作しますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>勿論!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extensions that integrate with the existing quarkus-resteasy extension also integrate with quarkus-resteasy-reactive extensions. So you can continue to use _CDI_, _Security_, _Metrics_, _JSON_, _Qute_, _Bean Validation_, _OpenAPI_ and enjoy a great out of the box and complete development experience.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のquarkus-resteasyエクステンションと統合するエクステンションは、quarkus-resteasy-reactiveエクステンションとも統合されます。そのため、_CDI_、_Security_、_Metrics_、_JSON_、_Qute_、_Bean Validation_、_OpenAPI_を使い続けることができ、素晴らしいアウトオブボックスと完全な開発体験を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I try it out?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どうやって試してみたらいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project has landed in the Quarkus master branch, so if you’re eager to try it out, you'll have to build Quarkus from source by following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this] and use the proper BOM and version following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このプロジェクトはQuarkus masterブランチにありますので、試してみたい方は、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this]のようにソースからQuarkusをビルドし、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this]のように適切なBOMとバージョンを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, you can also use Maven Snapshots (as Quarkus snapshot builds are uploaded to Sonatype once a day), by specifying version `999-SNAPSHOT` as the Quarkus version and using `quarkus-bom` instead of `quarkus-universe-bom` as the BOM.  There are various ways to enable snapshot versions in Maven. https://stackoverflow.com/a/7717234/2504224[This] StackOverflow answer shows configuration that can be used either on a per project basis or globally.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、バージョン `999-SNAPSHOT` をQuarkusのバージョンとして指定し、BOMとして `quarkus-universe-bom` の代わりに `quarkus-bom` を使用することで、Mavenのスナップショットを使用することもできます(Quarkusのスナップショットビルドは1日1回Sonatypeにアップロードされるため)。  Mavenでスナップショットバージョンを有効にするには、さまざまな方法があります。 https://stackoverflow.com/a/7717234/2504224[This] StackOverflowの回答では、プロジェクト単位でもグローバルでも使える設定が示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The available RESTEasy Reactive extensions are:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>利用可能な RESTEasy Reactive エクステンションは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These extensions are the equivalent to the existing _quarkus-resteasy_* extensions, so simply switching from _quarkus-resteasy-jackson_ to _quarkus-resteasy-reactive-jackson_ in your application should allow you to try RESTEasy Reactive with Jackson integration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのエクステンションは、既存の _quarkus-resteasy_* エクステンションと同等ですので、アプリケーション内で _quarkus-resteasy-jackson_ から _quarkus-resteasy-reactive-jackson_ に切り替えるだけで、Jackson 統合による RESTEasy Reactive を試すことができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the _quarkus-jaxrs-client_ extension can be used if you need to use the JAX-RS client (this is not the declarative MicroProfile REST Client, but the programmatic client specified by the JAX-RS spec).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、JAX-RSクライアントを使用する必要がある場合は、_quarkus-jaxrs-client_ エクステンションを使用することができます (これは宣言型MicroProfile RESTクライアントではなく、JAX-RS仕様で定義されたプログラマティッククライアントです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What should I be careful of?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どんなことに気をつければいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for the time being this set of extensions is currently considered experimental. Although the project passes almost the entirety of the JAX-RS TCK, it’s just the first release, so keep in mind that it might have more bugs than a typical battle hardened library, while some of the new APIs and SPIs might break.  Despite this being a first release, we do envision this work becoming the default REST layer for Quarkus in the near future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最初に注意しなければならないのは、当面の間、この一連のエクステンションは実験的なものと考えられているということです。このプロジェクトはJAX-RS TCKのほぼ全体を通過していますが、まだ最初のリリースに過ぎませんので、典型的な実績のあるライブラリよりも多くのバグがあるかもしれないことを覚えておいてください。 これは最初のリリースですが、近い将来、このライブラリがQuarkusのデフォルトのRESTレイヤーになることを見通しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the new features section, requests are served on the event-loop threads by default. This ensures maximum throughput, but also means that no blocking work should be performed on these threads. If you use Blocking IO (for example by accessing a database with Hibernate Panache), be sure to use the `@Blocking` annotation on either the method or the class.  This will ensure that the request will be served on a worker thread. It goes without saying that we are also very interested in hearing your feedback about this default.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新機能のセクションで述べたように、デフォルトではリクエストはイベントループスレッド上で処理されます。これは最大のスループットを保証しますが、これらのスレッドでブロッキング作業を行うべきではないことも意味します。ブロッキング IO を使用する場合 (例えば、Hibernate Panache でデータベースにアクセスするなど)、メソッドまたはクラスのいずれかで `@Blocking` アノテーションを必ず使用してください。  これにより、リクエストがワーカースレッドで処理されるようになります。言うまでもなく、このデフォルトについてのフィードバックも非常に興味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no docs yet. Docs will be added before the formal 1.11 release and will be progressively enhanced.  This email should contain all the information you need to get started, but should you run into any trouble, we are available to help on any of the usual channels (Zulip chat, mailing list, GitHub Issues, StackOverflow).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ドキュメントはまだありません。ドキュメントは正式な1.11リリースの前に追加され、徐々に強化されていく予定です。  このメールには開始に必要な情報がすべて含まれているはずですが、何か問題が発生した場合は、通常のチャネル(Zulip チャット、メーリングリスト、GitHub Issues、StackOverflow)のいずれかで支援を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What JAX-RS features are missing?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どのJAX-RSの機能が欠けていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We decided to focus on what most users need from a modern REST layer instead of implementing every single feature required by the JAX-RS TCK.  So in that vein, there is no XML support in RESTEasy Reactive, while various arcane features of the spec are also not supported (like _javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちは、JAX-RS TCK が必要とする機能をすべて実装するのではなく、ほとんどのユーザーが最新の REST レイヤから必要とするものに焦点を当てることにしました。  そのため、RESTEasy Reactive には XML サポートがなく、仕様の様々な難解な機能もサポートされていません(_javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_ のようなもの)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, worth noting is that the first release will not contain an implementation of the MicroProfile REST Client based on the new JAX-RS Client (for which there is a dedicated extension). This will most likely change in the near future.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、最初のリリースには、 (専用のエクステンションが存在する) 新しい JAX-RS Clientをベースにした MicroProfile REST Client の実装が含まれていないことも注目に値する。これは近い将来に変更される可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new extensions will be available with the regular _1.11_ release, we are considering doing a `1.11.0.Alpha1` release to make it as easy as possible for you to try out the new extensions and provide early feedback.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しいエクステンションは通常の _1.11_ リリースで利用可能になりますが、新しいエクステンションを出来る限り簡単に試せるように、そしてフィードバックを簡単に出来るように、私たちは `1.11.0.Alpha1` リリースを行うことを検討しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very much looking forward to hearing your thoughts about and experience using RESTEasy Reactive in Quarkus and plan to put it to good use to further improve the project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクトのさらなる改善の為に、RESTEasy ReactiveをQuarkusで使用した感想や経験を是非お聞かせ下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, 1.13.5.Final introduced a regression in the Hibernate Validator extension due to a Jandex issue (Jandex is our library indexing the classes and annotations).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>残念ながら、1.13.5.Finalでは、Jandexの問題により、Hibernate Validatorエクステンションにリグレッションが発生しました（Jandexは、クラスやアノテーションのインデックスを作成するライブラリです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, we released 1.13.6.Final today to mitigate the issue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そこで、この問題を軽減するために、本日1.13.6.Finalをリリースしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.6.Final is a safe upgrade for everyone using Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.6.Finalは、Quarkus 1.13を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also check out https://quarkus.io/blog/quarkus-1-13-5-final-released/[the 1.13.5 announcement]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、 link:https://quarkus.io/blog/quarkus-1-13-5-final-released/[1.13.5のアナウンス]もご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.6.Final[the full changelog of 1.13.6.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.6.Final[GitHub上で1.13.6.Finalの完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>abraxas.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>abraxas.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two things are certain in the life of a developer: Java and Taxes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発者の人生には確かなことが2つあります。Javaと税金です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the past 25 years, Java has been the dominant framework for developers creating enterprise applications. During that same time, developers continue to support their respective communities and countries each pay period through taxes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>過去25年間にわたって、Javaはエンタープライズアプリケーションを作成する開発者にとって圧倒的なフレームワークとなっています。その間、開発者は税金を払って、それぞれのコミュニティや国を支え続けてきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What do Java and taxes have in common? Java, specifically Quarkus, is the backbone of a new and innovative tax solution developed by https://www.abraxas.ch/de[Abraxas Informatik AG] that is targeted to Swiss government tax agencies. Quarkus made developing the Java-based tax application exciting and innovative for the development team.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javaと税金の共通点とは？Java、特にQuarkusは、 link:https://www.abraxas.ch/de[Abraxas Informatik AG]が開発したスイス政府の税務機関を対象とした新しく革新的な税務ソリューションのバックボーンとなっています。Quarkusによって、Javaベースの税務アプリケーションの開発は、開発チームにとってエキサイティングで革新的なものになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let’s learn a little more about how Quarkus turned the creation of a tax application into an exciting and rewarding project for it’s developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusがどのようにして税務アプリケーションの作成を、開発者にとってエキサイティングでやりがいのあるプロジェクトに変えたのか、もう少し詳しく見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Challenge</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>チャレンジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abraxas is the largest provider of integrated IT solutions for the public sector in Switzerland. They made a strategic decision to create a new modular, cloud-native tax solution that could be used throughout Switzerland’s cantons and municipalities to implement tax laws. Each canton and municipality has different rules and requirements for taxing its citizens which posed a unique challenge for the team.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Abraxas社は、スイスの公共部門向けに統合ITソリューションを提供する最大手の企業です。Abraxas社は、スイスの州や市町村が税法を施行する際に使用できる、モジュール式のクラウド・ネイティブな税務ソリューションを新たに開発するという戦略的な決断を下しました。各州や市町村は、市民への課税に関する規則や要件が異なるため、チームには独自の課題がありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abraxas formed a specialized group of experts (Team Polaris) to architect, develop, and deploy the tax solution. While the Polaris team is a part of a larger organization, it acts very much like a startup. This provided the team with the ability to identify and implement the best technology for the job in order to meet the needs of their customers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Abraxas は、税務ソリューションを設計、開発、展開するために、専門家のグループ（チームポラリス）を結成しました。ポラリスチームは、大規模な組織の一部ではありますが、スタートアップに近い形で活動しています。このチームは、お客様のニーズを満たすために、最適なテクノロジーを見極め、導入することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abraxas is developing its products with a "cloud first" strategy where the tax application needs to be deployed in a clustered, scalable, secure environment that is browser-based. Abraxas was able to leverage its own cloud platform “Abraxas Government Cloud” which offers a Kubernetes-based cloud solution to its customers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Abraxasは「クラウドファースト」戦略で製品を開発しており、税務アプリケーションはブラウザベースのクラスター化されたスケーラブルでセキュアな環境に展開される必要があります。Abraxasは、Kubernetesベースのクラウドソリューションを顧客に提供している自社のクラウドプラットフォーム「Abraxas Government Cloud」を活用することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Solution</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The tax application is cloud-native and flexible so that it can be used by different cantons and municipalities across the country. Quarkus was analyzed against other Java frameworks and platforms and selected to be the backbone for this application because of its performance, efficiency, and developer productivity in a Kubernetes environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この税務アプリケーションは、国内のさまざまな州や市町村で使用できるように、クラウドネイティブで柔軟性に富んでいます。Quarkusは、他のJavaフレームワークやプラットフォームと比較して分析され、パフォーマンス、効率性、Kubernetes環境での開発者の生産性が評価され、このアプリケーションのバックボーンとして選ばれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each customer, whether it be cantons or municipalities, has its own unique requirements and needs. Therefore, each customer has its own clustered Kubernetes environment that is configurable for their specific needs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>州や市町村などのお客様は、それぞれ独自の要件やニーズをお持ちです。そのため、お客様ごとにクラスター化されたKubernetes環境を用意し、それぞれのニーズに合わせて設定できるようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The tax application is based on a containerized microservices architecture with each service split up based on the business need. One advantage is that this allows the development team to easily replace a service with different business logic if needed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>税務アプリケーションは、コンテナ化されたマイクロサービスアーキテクチャをベースに、ビジネスニーズに応じて各サービスが分割されています。これにより、必要に応じて開発チームがサービスを異なるビジネスロジックに簡単に置き換えることができるという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Team Polaris provides a flexible distribution environment for each customer including the ability to deploy on private cloud (on-premise) or hosted cloud environments. The Abraxas platform team provisions the cloud infrastructure dependent upon the client requirements. The development teams have the ability to configure their customized environments and deploy their applications. The tax solution is currently in the development stage and is running in both a dev and staging environment with production rollout planned for 2022 with updates and enhancements coming soon after.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>チームポラリスは、プライベートクラウド（オンプレミス）やホステッドクラウド環境での展開を含め、各顧客に柔軟な配信環境を提供しています。Abraxasのプラットフォームチームは、お客様の要件に応じてクラウドインフラストラクチャを準備します。開発チームは、カスタマイズされた環境を構成して、アプリケーションを展開することができます。税務ソリューションは現在、開発段階にあり、開発環境とステージング環境の両方で稼働しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A variety of Quarkus extensions are being utilized in the application including:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリケーションでは、以下のような様々なQuarkusのエクステンションが利用されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate/ORM</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Hibernate/ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy (Jackson)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy (Jackson)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Client (Jackson)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>REST Client (Jackson)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka (Reactive Messaging)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kafka (Reactive Messaging)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics (Micrometer)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Metrics (Micrometer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenAPI/Swagger</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenAPI/Swagger</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenTracing</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>フォールトトレランス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, the team also utilizes a number of Quarkus extensions for testing, including:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、チームはテスト用に以下のような多数のQuarkusエクステンションも活用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Junit5 + Mockito</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Junit5 + Mockito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test H2</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Test H2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-Memory Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インメモリ・リアクティブ・メッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jacoco</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jacoco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why Quarkus?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜQuarkusなのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was chosen over alternatives such as Spring Boot, Micronaut and Helidon. While Spring is the predominant Java framework within Abraxas, the Polaris team chose Quarkus for a number of reasons including its superior performance in a Kubernetes environment.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、Spring Boot、Micronaut、Helidonなどの候補の中から選ばれました。AbraxasではSpringが主流のJavaフレームワークですが、Polarisチームは、Kubernetes環境での優れたパフォーマンスなど、多くの理由からQuarkusを選択しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The team specifically highlighted Quarkus’ performance, vast extension ecosystem, native compilation, and developer productivity tools (live reloading, Dev UI) as contributing factors in the decision to utilize Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>チームは、Quarkusのパフォーマンス、広大なエクステンションエコシステム、ネイティブコンパイル、開発者の生産性向上のためのツール（ライブリロード、Dev UI）をQuarkusの採用を決定する要因として特に強調しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Polaris team was also impressed by the Quarkus community especially when compared to alternative communities because of its vibrant activity, release cadence, native compilation capability, and more.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、Polarisチームは、Quarkusコミュニティの活発な活動、リリースケイデンス、ネイティブコンパイル機能など、他のコミュニティと比較して特にQuarkusコミュニティに感銘を受けました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learning Curve</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>学習曲線</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What learning curve?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どんな学習曲線？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus developers have continually commented how easy it is to understand the framework and create meaningful applications. Developers at Abraxas had the same experience but wanted to take things a step further. They created a custom “Hello, world!” application training project to make it easy for new developers on their team to learn how to implement Quarkus. The project includes PostgreSQL, Kafka and REST endpoints. New developers are typically up and running with the technology within 1-2 weeks which makes it easy to onboard new developers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの開発者は、フレームワークを理解して有意義なアプリケーションを作成するのがいかに簡単かということを常にコメントしています。Abraxasの開発者も同じ経験をしましたが、さらに一歩先に進みたいと考えていました。彼らは、チームの新しい開発者がQuarkusの導入方法を簡単に学べるように、カスタムの「Hello, world!このプロジェクトには、PostgreSQL、Kafka、RESTエンドポイントが含まれています。新しい開発者は通常1～2週間でこの技術を使いこなせるようになり、新しい開発者の受け入れが容易になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What’s Next?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the first release of the application is slated for 2022, the application will continue far beyond that. Team Polaris is already looking for ways to improve performance, reliability, security, and scalability. This includes things like implementing a reactive architecture for microservices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>アプリケーションの最初のリリースは2022年を予定していますが、アプリケーションはそれよりもずっと先まで続きます。チームポラリスはすでに、パフォーマンス、信頼性、セキュリティ、スケーラビリティを向上させる方法を模索しています。これには、マイクロサービスのリアクティブアーキテクチャの実装などが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From an organizational perspective, the Polaris team is hard at work transferring their Quarkus knowledge and experiences to other groups within the organization through things like internal TechTalks. One of their biggest challenges is overcoming the hesitancy to change to other Java frameworks which often requires a steep learning curve.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>組織的な観点から見ると、Polarisチームは社内のTechTalksなどを通じて、Quarkusの知識や経験を組織内の他のグループに伝えることに懸命に取り組んでいます。彼らの最大の課題の1つは、急な学習曲線を必要とすることが多い他のJavaフレームワークへの変更をためらう気持ちを克服することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bernhard Lutzmann, architect and backend software engineer on the Polaris project team, said it best: _“The learning curve for Quarkus was extremely short. Quarkus has a number of great resources including guides, blogs and a supportive community on Zulip.”_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Polarisプロジェクトチームのアーキテクト兼バックエンドソフトウェアエンジニアであるBernhard Lutzmann氏は、このように述べています。 _"Quarkusの学習曲線は極めて短いものでした。Quarkusには、ガイド、ブログ、Zulipのサポートコミュニティなど、数多くの素晴らしいリソースがあります。"_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Words of Wisdom</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>金言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Polaris team has learned a lot so far on their application journey with Quarkus. They have some helpful advice to others who are considering using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Polarisチームは、Quarkusを使ったアプリケーションの旅でこれまでに多くのことを学びました。彼らは、Quarkusの使用を検討している他の人々に有益なアドバイスをしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_“Developers new to Quarkus often wonder why there are so few questions on Stack Overflow. This is because the main discussion between users and the Quarkus team happens on https://quarkusio.zulipchat.com/[Zulip]. Go there and you will quickly get answers to your questions, often by the Quarkus team directly.” - Bernhard Lutzmann_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_"Quarkusを初めて使う開発者は、Stack Overflowに質問が少ないことを不思議に思うことがよくあります。これは、ユーザーとQuarkusチームの間の主な議論が https://quarkusio.zulipchat.com/[Zulip] で行われているからです。そこに行けば、質問に対する回答がすぐに得られ、多くはQuarkusチームが直接回答しています。"- Bernhard Lutzmann_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_“When considering Quarkus’ native capability, make sure the libraries that you use are native compatible. The best approach is to stay with the core Quarkus extensions for as long as possible.” - Bernhard Lutzmann, Polaris project architect and backend software engineer_</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>_"Quarkusのネイティブ機能を検討する際には、使用するライブラリがネイティブに対応しているかどうかを確認してください。最良のアプローチは、できるだけ長くコアのQuarkusエクステンションを使い続けることです。"- Polarisプロジェクトアーキテクト兼バックエンドソフトウェアエンジニア、Bernhard Lutzmann氏_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Good news for Java developers in Switzerland and beyond. Abraxas is hiring and looking to bring on new team members who are open-minded and not afraid to actively participate. Abraxas encourages its developers to spend time looking at other technologies. If you live in Switzerland or are considering moving there, have a look at their https://www.abraxas.ch/de/karriere/offenen-stellen[job offerings].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スイスやその他の国のJava開発者に朗報です。Abraxasでは、オープンマインドで積極的に参加することを恐れない新しいチームメンバーを採用したいと考えています。Abraxasは、開発者が他の技術に目を向けることに時間を費やすことを奨励しています。スイスにお住まいの方、またはスイスへの移住を検討されている方は、同社の link:https://www.abraxas.ch/de/karriere/offenen-stellen[求人情報]をご覧になってみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abraxas Informatik AG is the largest provider of integrated IT solutions for the public sector in Switzerland. Abraxas connects Swiss administrations, authorities, companies and the population with efficient, secure and integrated solutions and services in the field of information and communication technology.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Abraxas Informatik AGは、スイスの公共部門に統合ITソリューションを提供する最大の企業です。Abraxasは、情報通信技術の分野で、効率的で安全な統合されたソリューションとサービスで、スイスの行政、当局、企業、国民を結びつけています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.4.0 release of Quarkus Tools for IntelliJ.  This release enhances codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus Tools for IntelliJの1.4.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードのcodestartsのサポートが強化されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard now highlights codestarts enabled extension with a specific icon (right to the extension name), similar to code.quarkus.io, allowing users to better identify codestarts enabled extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusプロジェクトウィザードでは、code.quarkus.ioと同様に、codestartsを有効にしたエクステンションを特定のアイコン（エクステンション名の右側）で強調表示するようになり、ユーザーはcodestartsを有効にしたエクステンションをよりよく識別できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We just released 1.13.3.Final, a new maintenance release for the 1.13 release train.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13リリーストレインの新しいメンテナンスリリースである1.13.3.Finalをリリースしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.13.3.Final is a safe upgrade for everyone using Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>1.13.3.Finalは、Quarkus 1.13を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.13.3.Final[the full changelog of 1.13.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.3.Final[1.13.3.Finalの完全な変更履歴は、GitHub] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven Reactive Programming library.  Like other reactive programming libraries, it uses streams as the primary construct.  These streams convey events, and your code processes these events.  Most of the time, your code is only interested in item and failure events.  But there are other kinds of events such as cancellation, request, completion, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。他のリアクティブ・プログラミング・ライブラリと同様に、主要な構成要素としてストリームを使用します。これらのストリームはイベントを伝え、あなたのコードはこれらのイベントを処理します。ほとんどの場合、あなたのコードはアイテムイベントと失敗イベントにしか興味がありません。しかし、キャンセル、リクエスト、完了などの他の種類のイベントもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not rare that you need to look at these various events to understand better what's going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何が起こっているのかをよりよく理解したり、特定の副作用を実装したりするために、これらの様々なイベントを見る必要があることは稀ではありません。例えば、完了イベントの後にリソースを閉じたり、失敗やキャンセル時にメッセージをログに記録したりする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each kind of event, there is an associated _group_ providing the methods to handle that specific event: `onItem()`, `onFailure()`, `onCompletion()` and so on.  These groups provide two methods to peek at the various events without impacting its distribution: `invoke` and `call`.  It does not transform the received event; it notifies you that something happened and let you react.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>イベントの種類ごとに、その特定のイベントを処理するための方法を提供する関連 _グループ_ があります: `onItem()`, `onFailure()`, `onCompletion()` など。これらのグループは、配信に影響を与えずに様々なイベントを覗くための 2 つの方法を提供しています: `invoke` と `call` 。これらのグループは、受信したイベントを変換するのではなく、何かが起こったことを通知して反応させてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The invoke method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>invoke メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method is synchronous and does not return anything.  Mutiny invokes the configured callback when the observed stream dispatches the event:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`invoke` メソッドは同期で、何も戻りません。Mutinyは、観測されたストリームがイベントをディスパッチするときに、設定されたコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, `invoke` is synchronous.  Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上で述べたように、 `invoke` は同期です。Mutinyはコールバックを呼び出し、コールバックが戻ってきたらイベントを下流に伝播させます。ディスパッチをブロックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, we highly recommend you not to block.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もちろん、ブロックしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippets show how you can log the different types of events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次のスニペットは、さまざまな種類のイベントをログに記録する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のコードスニペットの矢印は、イベントが上流(ソース)から来るのか、下流(コンシューマ)から来るのかを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method does not change the event, except in one case.  If the `invoke` callback throws an exception, the downstream does not get the actual event but get a failure event instead.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`invoke` メソッドは、1 つのケースを除いて、イベントを変更しません。 `invoke` コールバックが例外をスローした場合、ダウンストリームは実際のイベントを取得せず、代わりに失敗イベントを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When observing the failure event, if the callback throws an exception, Mutiny propagates a `CompositeException` aggregating the original failure and the callback failure.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>失敗イベントを観測しているときに、コールバックが例外を投げると、Mutinyは元の失敗とコールバックの失敗を集約した `CompositeException` を伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The call method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>呼び出し方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike `invoke`, `call` is asynchronous, and the callback returns a `Uni&lt;?&gt;` object.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`invoke` とは異なり、 `call` は非同期で、コールバックは `Uni&lt;?&gt;` オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call` is often used when you need to implement asynchronous side-effects, such as closing resources.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`call` リソースを閉じるなど、非同期の副作用を実装する必要がある場合によく使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyは、コールバックによって返されたUniがアイテムを放出するまで、元のイベントを下流にディスパッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As shown in the previous snippet, you can use this approach to delay items. 
But the primary use case is about completing asynchronous actions:
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前のスニペットが示すように、このアプローチを使用してアイテムを遅らせることもできます。
ただし、主なユースケースは非同期アクションの完了に関するものです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Under the hood, Mutiny gets the `Uni` (by invoking the callback) and subscribes to it. 
It observes the item or failure event from that `Uni`. 
It discards the item value as only the emission matters in this case.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>内部的には、Mutinyは `Uni` を(コールバックを呼び出すことによって)取得し、サブスクライブします。 
`Uni`からアイテムまたは障害イベントを監視します。
この場合、排出のみが重要であるため、アイテムの値は破棄されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the callback throws an exception or the produced `Uni` produces a failure, Mutiny propagates that failure (or a `CompositeException`) downstream, replacing the original event. 
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コールバックが例外をスローするか、生成された `Uni` が失敗を生成した場合、Mutinyはその失敗(または `CompositeException` )をダウンストリームに伝播し、元のイベントを置き換えます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` and `call` methods are handy when you need to observe a stream without changing the transiting events.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`invoke` と `call` メソッドはストリームをイベントを変更せずに観察するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `invoke` for implementing synchronous side-effects or logging events.  The asynchronous nature of `call` makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`invoke`を同期の副作用操作やイベントのロギングの実装の為に使用してください。 `call`の非同期性は、非同期副作用操作、例えばリソースのクローズ、データのフラッシュ、アイテムの遅延などを実装するのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table highlights the key differences:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のテーブルが主な違いを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`invoke`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`invoke`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`call`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nature</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return type</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>戻り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`void`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`void`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Main Use cases</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>主なユースケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are available for every kind of event in the associated group.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらのメソッドは、関連するグループ内のあらゆる種類のイベントに対して利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we announce the availability of Quarkus 1.13.0.Final.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本日、Quarkus 1.13.0.Finalがリリースされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release brings several new features:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のリリースでは、いくつかの新機能が追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DevServices simplifies testing with containers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>DevServicesはコンテナでテストを簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenTelemetry is now supported via two new extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>OpenTelemetryは、2つの新しいエクステンションを通じてサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes Service Binding simplifies the deployment on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Kubernetes Service Bindingは、Kubernetes上へのデプロイを簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We introduced a new MicroProfile REST Client based on RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactiveをベースにした新しいMicroProfile REST Clientを導入しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jacoco` can generate your test coverage reports.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jacoco` では、テストカバレッジレポートを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And as usual its fair share of bugfixes and small improvements all over the place.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、いつものようにバグフィックスや小さな改良が随所に施されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.13[our migration guide for 1.13].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>既存のアプリケーションを移行したいとお考えですか？ここでは、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.13[1.13の移行ガイド]をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, our main goal is to make developer lives easier and bring back developer joy.  In 1.13, we added a new element to the (not so secret) Quarkus recipe: DevServices.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusでは、開発者の生活を楽にし、開発者の満足感を取り戻すことを主な目標としています。1.13では、Quarkusのレシピに新しい要素を追加しました（秘密ではありません）。それがDevServicesです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When starting dev mode (live reload), we are now able to automatically start containers for your tests and you don't even need to configure anything: the container is automatically wired to the Quarkus dev mode configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードの起動（ライブリロード）時に、テスト用のコンテナを自動的に起動できるようになりました。何も設定する必要はありません。コンテナは自動的にQuarkusの開発モード設定と紐づけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, if you're developing a PostgreSQL-based application, as soon as you have the PostgreSQL JDBC extension in your pom, a container will be started for testing using Testcontainers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、PostgreSQLベースのアプリケーションを開発している場合、PostgreSQL JDBC extensionをpomに入れれば、Testcontainersを使ってテスト用のコンテナが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You only need to define your configuration for production with the `%prod.` prefix.  The dev mode one is taken care of.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>本番用の設定を、 `%prod.` のプレフィックスで定義するだけでOKです。devモード用のものは準備されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will find all the details about this new feature in the link:/guides/datasource#devservices-configuration-free-databases[Datasource guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この新機能の詳細は、 link:/guides/datasource#devservices-configuration-free-databases[データソースガイド]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://opentelemetry.io/[OpenTelemetry] project from the https://www.cncf.io[Cloud Native Computing Foundation] is an initiative to merge the OpenTracing and OpenCensus projects to provide a common project for all telemetry. Tracing is the first piece of OpenTelemetry which GA'd in the last month, metrics and logging are still under development.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://www.cncf.io[Cloud Native Computing Foundation]の link:https://opentelemetry.io/[OpenTelemetry]プロジェクトは、OpenTracing と OpenCensus プロジェクトを統合し、すべてのテレメトリのための共通プロジェクトを提供する取り組みです。Tracing は先月 GA が行われた OpenTelemetry の最初の部分で、metrics と logging はまだ開発中です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.13 introduces a new extension for OpenTelemetry called `quarkus-opentelemetry` which offers the ability to trace requests. For exporting traces to a Jaeger collector, use the `quarkus-opentelemetry-exporter-jaeger` extension which depends on `quarkus-opentelemetry`.  With this initial version, traces are available in JAX-RS Resource methods, REST Client, and Reactive Messaging with Kafka. Further integrations with other extensions will come in future releases, as well as a guide and quickstart.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.13では、OpenTelemetryの新しいエクステンション（ `quarkus-opentelemetry` ）が導入され、リクエストをトレースする機能が提供されています。トレースをJaegerコレクターにエクスポートするには、 `quarkus-opentelemetry` に依存する `quarkus-openeltemetry-exporter-jaeger` を使用してください。この初期バージョンでは、JAX-RS Resourceメソッド、REST Client、およびReactive Messaging with Kafkaでトレースが利用できます。他のエクステンションとの統合は、ガイドやクイックスタートと同様に、今後のリリースで行われる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports binding services to applications via the https://github.com/k8s-service-bindings/spec[Service Binding Specification for Kubernetes].  Specifically Quarkus implements the https://github.com/k8s-service-bindings/spec#application-projection[Application Projection] part of the specification, thus allowing applications running in appropriately configured Kubernetes clusters to consume services (such as a Database or a Broker) without the need for user configuration.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、 link:https://github.com/k8s-service-bindings/spec[Service Binding Specification for Kubernetes]を介したサービスのアプリケーションへのバインディングをサポートしています。具体的には、Quarkusは仕様の link:https://github.com/k8s-service-bindings/spec#application-projection[Application Projection]部分を実装しており、適切に構成されたKubernetesクラスタで実行されるアプリケーションが、ユーザーによる設定を必要とせずにサービス（DatabaseやBrokerなど）を利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-mariadb`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jdbc-mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-mssql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jdbc-mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-mysql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jdbc-mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-jdbc-postgresql`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-jdbc-postgresql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-kafka-client`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-kafka-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-reactive-messaging-kafka`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`quarkus-smallrye-reactive-messaging-kafka`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything you need to know about it is detailed in the link:/guides/deploying-to-kubernetes#service-binding[Kubernetes guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのために必要なことはすべて、 link:/guides/deploying-to-kubernetes#service-binding[Kubernetesガイド]に詳しく書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are continuing to enrich the RESTEasy Reactive experience and, this time, it's on the REST Client front.  A new RESTEasy Reactive-based REST Client extension `quarkus-rest-client-reactive` is present in Quarkus 1.13.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちはRESTEasy Reactiveの体験をより豊かなものにするために、今回はRESTクライアントの面での取り組みを続けています。新しいRESTEasy ReactiveベースのRESTクライアントエクステンション `quarkus-rest-client-reactive` がQuarkus 1.13に搭載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that RESTEasy Reactive can be used for reactive but also for traditional blocking workloads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なお、RESTEasy Reactiveは、リアクティブなワークロードだけでなく、従来のブロッキングなワークロードにも使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, if you wanted websockets support in your applications, you had to switch to Undertow.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これまでは、アプリケーションでWebsocketをサポートしたい場合は、Undertowに乗り換える必要がありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.13 introduces a pure-Vert.x-based Websockets extension called `quarkus-websockets`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.13では、 `quarkus-websockets` という純粋なVert.xベースのWebsocketsエクステンションが導入されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test Coverage Reports</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>テストカバレッジレポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Given the way Quarkus is architected, it was not as easy as it should be to generate test coverage reports with Jacoco.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのアーキテクチャを考えると、Jacocoでテストカバレッジレポートを作成するのはそれほど簡単ではありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.13 comes with `quarkus-jacoco` which will automatically generate your test coverage reports. And it does not require any Maven setup anymore. More about this in link:/guides/tests-with-coverage[our updated guide].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkus 1.13には、テストカバレッジレポートを自動的に生成する `quarkus-jacoco` が存在します。また、Mavenのセットアップも必要ありません。詳しくは、 link:/guides/tests-with-coverage[改訂されたガイド]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.13.0.CR1[1.13.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.13.0.Final[1.13.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.13.0.CR1[1.13.0.CR1]および link:https://github.com/quarkusio/quarkus/releases/tag/1.13.0.Final[1.13.0.Final]の完全な変更履歴はGitHubでご覧いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[461 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusコミュニティは成長を続けており、現在の link:https://github.com/quarkusio/quarkus/graphs/contributors[コントリビューターは461名]となっています。それぞれの方に深く感謝いたします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: Adding Eyecandy to your Quarkus App with React and Patternfly 
date: 2021-04-15
tags: web gui react patternfly
synopsis: Find out how to easily integrate the React and Patternfly GUI frameworks into your projects for development as well as production      
author: dbrintzi
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: post
title: ReactとPatternflyでQuarkusアプリの外観を改善する
date: 2021-04-15
tags: web gui react patternfly
synopsis: ReactとPatternflyのGUIフレームワークを、開発や生産のためにプロジェクトに簡単に統合する方法をご紹介します。
author: dbrintzi
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A common pattern for containerized and distributed Quarkus applications is to serve as an efficient and scalable backend for a separate frontend application.  In the Kubernetes world a frontend application could be a pure web layer pod such as React, Angular or Vue.js, delegating all REST calls to these Quarkus service layer pods.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>コンテナ化された分散型のQuarkusアプリケーションで一般的なパターンとして、別のフロントエンドアプリケーションのための効率的でスケーラブルなバックエンドとして機能することがあります。Kubernetesの世界では、フロントエンドアプリケーションはReact、Angular、Vue.jsなどの純粋なウェブレイヤーPodであり、すべてのRESTコールをQuarkusのサービスレイヤーPodに委ねることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While this approach has the benefit of independent container scaling as well as an independent lifecycle it may sometimes be over engineered for small applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプローチには、独立したコンテナのスケーリングと独立したライフサイクルという利点がありますが、小規模なアプリケーションには過剰なエンジニアリングとなる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perhaps you just want to create a small self-contained CRUD application without compromising in modern web GUI technologies? We have seen how to achieve this with https://quarkus.io/blog/quarkus-and-web-ui-development-mode/[Angular] but what about React which at least according to GitHub stars has surpassed Angular in terms of popularity? It is all about choice and I will show you how you can not only integrate React but also use a web component framework called https://www.patternfly.org/[Patternfly].  Patternfly is a collection of patterns, components and styles for creating rich, consistent and interactive GUIs.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新のWeb GUI技術に妥協することなく、自己完結型の小さなCRUDアプリケーションを作りたいと思っているのではないでしょうか？ link:https://quarkus.io/blog/quarkus-and-web-ui-development-mode/[Angular]でこれを実現する方法を見てきましたが、少なくともGitHubの星の数において、人気の点でAngularを上回っているReactはどうでしょうか？今回は、Reactを統合するだけでなく、 link:https://www.patternfly.org/[Patternfly]と呼ばれるWebコンポーネントフレームワークを使用する方法を紹介します。Patternflyは、リッチで一貫性のあるインタラクティブなGUIを作成するためのパターン、コンポーネント、スタイルを集めたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create a Quarkus App with a REST endpoint that serves atomic particle objects to be displayed in a React/Patternfly table.  The sourcecode for the final application can be found https://github.com/nexus-Six/quarkus-gui-react-patternfly[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>React/Patternflyのテーブルに表示される原子パーティクルオブジェクトを提供するRESTエンドポイントを持つQuarkus Appを作成してみましょう。最終的なアプリケーションのソースコードは link:https://github.com/nexus-Six/quarkus-gui-react-patternfly[こちら]にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Generate the Quarkus Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ1 - Quarkusプロジェクトの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate a starter project go to https://code.quarkus.io. Enter 'io.quarkus' as Maven Group and 'quarkus-react' as Artifact.  In the list of extensions choose *RESTEasy JAX-RS* and *RESTEasy JSON-B*. Then generate and download the project, unzip it on your local machine and open the project folder in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>スタータープロジェクトを生成するには、 https://code.quarkus.io  にアクセスします。Maven Groupとして "io.quarkus" 、Artifactとして "quarkus-react" を入力します。エクステンションのリストで、 *RESTEasy JAX-RS* と *RESTEasy JSON-B* を選択します。その後、プロジェクトを生成してダウンロードし、ローカル・マシンで解凍して、お気に入りのIDEでプロジェクト・フォルダを開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 2 - Add the Quarkus REST Endpoint</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ2 - Quarkus RESTエンドポイントの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Java package folder /src/main/java/io/quarkus where the sample *GreetingResource.java* resides, create a new bean class called *Particle.java* with the following content:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>サンプルの *GreetingResource.java* が存在するJavaパッケージフォルダ/src/main/java/io/quarkusに、 *Particle.java* という名前の新しいBeanクラスを以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a new REST resource class called *ParticleResource.java* where we return some test particles (neglecting any atomic physics implications here).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ここで、 *ParticleResource.java* という新しいRESTリソースクラスを作成し、いくつかのテストパーティクルを返します（ここでは原子物理学的な意味合いは無視します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test if everything works by starting up Quarkus in dev mode:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>開発モードでQuarkusを起動して、すべてが動作するかどうかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a new terminal call the endpoint to see your particle response:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい端末で、エンドポイントを呼び出して、パーティクルの応答を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Quarkus data layer is now ready, so let's create the React GUI next.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのデータレイヤーの準備ができたので、次はReactのGUIを作りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 3 - Generate the React Project</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ3 - Reactプロジェクトの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have installed *Node.js* and *npm* on your system.  Refer to the https://nodejs.org/en/download/[official documentation] for more information if required.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>お使いのシステムに *Node.js* と *npm* がインストールされていることを確認してください。必要に応じて、 link:https://nodejs.org/en/download/[公式ドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new folder in your project /src/main/*webapp* which will be the base folder for your React project. Now open another terminal in this folder, run the React project initializer and then add the Patternfly node module:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロジェクト内に新しいフォルダ/src/main/ *webapp* を作成し、これをReactプロジェクトのベースフォルダとします。このフォルダで別のターミナルを開き、Reactプロジェクトイニシャライザを実行して、Patternfly Nodeモジュールを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When starting the React app it will run on port 3000 by default. When we then try to access our Quarkus endpoint on port 8080 the browser will prevent this due to https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[CORS security policies].  In production this will not matter as the compiled static React app will be served from Quarkus over port 8080 as well but during development this is an issue.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactアプリを起動すると、デフォルトではポート3000で実行されます。その後、ポート8080でQuarkusのエンドポイントにアクセスしようとすると、 link:https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[CORSセキュリティポリシー]のためにブラウザがこれを阻止します。本番環境では、コンパイルされた静的なReactアプリがポート8080でQuarkusから提供されるため、これは問題になりませんが、開発中はこれが問題になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately React has a neat little feature called *proxy* which forwards all requests for unknown endpoints to another URL. In the */webapp* folder open the file *package.json* and add the proxy line forwarding everything to our Quarkus port on 8080:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>幸いなことに、Reactには未知のエンドポイントへのすべてのリクエストを別のURLに転送する *proxy* というちょっとした機能があります。 *webapp* フォルダで *package.json* ファイルを開き、proxyの行を追加して、すべてのリクエストをQuarkusのポート8080に転送します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Create a Patternfly Table Component to Populate with our Data</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ4 - Patternflyのテーブルコンポーネントを作成して、データで埋める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the Patternfly CSS in the React project in */webapp/src/index.js*</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactプロジェクトの */webapp/index.js* にPatternflyのCSSをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In /webapp/src create a new folder called *components*, inside create a file called *particles.js* and generate a Patternfly table by looping over a list of particle objects:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>webapp/srcに *components* という新しいフォルダを作り、その中に *particles.js* というファイルを作り、パーティクルオブジェクトのリストをループさせてPatternflyのテーブルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next adjust */webapp/src/App.js* to call our Quarkus service endpoint and render our particle component with the response data:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次に、 */webapp/src/App.js* を調整して、Quarkusサービスのエンドポイントを呼び出し、レスポンスデータを使ってパーティクルコンポーネントをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are now ready to test our GUI in React development mode.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これで、Reactの開発モードでGUIをテストする準備が整いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure Quarkus is still running in another terminal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>別のターミナルでQuarkusがまだ起動していることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the */webapp* folder execute :</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*/webapp* フォルダ内で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A browser will open to http://localhost:3000.  If not navigate to that URL.  You should see our table dynamically populated from your Quarkus particle backend.  In the developer tools of your browser you will see that the data is actually retrieved from http://localhost:3000/particles</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザで http://localhost:3000 を開きます。開かない場合は、そのURLに移動してください。Quarkusのパーティクルバックエンドからテーブルが動的に入力されているのがわかると思います。ブラウザの開発者ツールでは、データが実際に http://localhost:3000/particles から取得されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are running in a double developer mode now. Any changes made to either your Java or Javascript code will be applied immediately.  Isn't that developer bliss?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在、ダブルデベロッパーモードで運用しています。JavaとJavascriptのどちらかのコードに加えられた変更は、すぐに適用されます。これは開発者にとって至福の時ではないでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But what about containerized deployment you ask? Well, once your shiny new GUI app is ready for primetime there are some last adjustments that we need to build runnable jars and images.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、コンテナを使ったデプロイについてはどうでしょうか？新しいGUIアプリが完成したら、実行可能なjarやイメージを作成するために、いくつかの調整が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 5 - Prepare our Project for Production Build</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ステップ5 - プロジェクトの本番ビルドへの準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In */webapp/package.json* add a prod build phase:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*webapp/package.json* にprodのビルドフェーズを追加:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will do a production build of the static React assets and copy them over into the default Quarkus directory for static files.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、静的なReactアセットのプロダクションビルドが行われ、Quarkusのデフォルトの静的ファイル用ディレクトリにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rsync command is specific for Linux.  For other operating systems please substitute with an equivalent command.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>rsyncコマンドは、Linux専用です。他のOSの場合は、同等のコマンドで代用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the last step we will add the excellent https://github.com/eirslett/frontend-maven-plugin[frontend-maven-plugin] to our pom.xml that will trigger these React build phases from a normal maven build. Adjust the npm and node versions to match your locally installed ones. The maven install phase would actually install these two packages which can be handy for a CI/CD build or when starting with this project.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最後のステップでは、優れた link:https://github.com/eirslett/frontend-maven-plugin[frontend-maven-plugin]を pom.xml に追加して、通常の maven ビルドから React のビルドフェーズを起動します。npmとnodeのバージョンを、ローカルにインストールされているものに合わせて調整します。mavenのインストールフェーズでは、実際にこれらの2つのパッケージがインストールされますが、これはCI/CDビルドやこのプロジェクトの起動時に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's build our runnable jar:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>それでは、実行可能なjarをビルドしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop all other running environments to free up the ports and run:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>他の稼働中の環境をすべて停止してポートを空け、実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open your browser to http://localhost:8080 to see you table again, now running from a single optimized Quarkus jar.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウザで http://localhost:8080 を開くと、最適化された単一のQuarkus jarから実行されているテーブルが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take Away</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There you go. With just a few easy steps you can use the power of React and Patternfly to add slick looking interactive GUIs to your Quarkus apps.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いくつかの簡単なステップで、ReactとPatternflyの力を使って、Quarkusアプリに洗練された見た目のインタラクティブなGUIを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How about compiling this app to https://quarkus.io/guides/building-native-image[native] next to deploy an extremely lightweight webapp? Or you may want to look at some of other https://www.patternfly.org/v4/get-started/develop/[Patternfly components] to create a more sophisticated web interface. Either way there no boundaries except for your creativity to make you Quarkus apps shine.       
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このアプリを次は link:https://quarkus.io/guides/building-native-image[ネイティブ]にコンパイルして、極めて軽量なWebアプリを展開するのはどうでしょうか。あるいは、他の link:https://www.patternfly.org/v4/get-started/develop/[Patternflyコンポーネント]を使用して、より洗練されたウェブインターフェイスを作成することもできます。いずれにしても、Quarkusアプリを輝かせるためには、あなたの創造性以外に制限はありません。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From time to time, I see tweets or articles claiming they don't see the point of Quarkus because "who needs fast startup?", "I have plenty of memory" or "what is the point of live reload?".</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>時折、「誰が高速起動を必要としているのか」、「メモリは十分にある」、「ライブリロードの意味は何か」といった理由で、Quarkusの必要性が理解できないと主張するツイートや記事を目にすることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I could write an article debunking these arguments and explain how the latter makes your development workflow much more efficient and how the former makes the latter possible, even if fast boots are not your thing.  But for the sake of this blog post, let's admit these persons are absolutely right and these are not good reasons to use Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえ高速起動が必要なくとも、後者がいかに開発ワークフローをより効率的にするか、また前者がいかに後者を可能にするかを説明し、これらの議論を否定する記事を書くこともできます。しかし、このブログ記事のために、これらの人たちが全く正しく、これらはQuarkusを使用する良い理由ではないとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So now what? Back to `&lt;insert your favorite framework here&gt;`? Not so fast...</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さて、どうしましょう？ `&lt;ココに好きなフレームワークを入れてください&gt;` に戻る？そうはいきません...。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus didn't achieve fast startup and low memory footprint by using dark magic or lazy loading tricks but by entirely rethinking the way Java applications are bootstrapped.  The whole point of Quarkus is to move as much work as possible to the build time and this journey made us create a framework to push work at build time that can be leveraged in Quarkus extensions.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは、黒魔術や遅延ローディングのトリックを使って高速起動と低メモリフットプリントを実現したのではなく、Javaアプリケーションのブートストラップ方法を全面的に再考しました。Quarkusの全体的なポイントは、できるだけ多くの作業をビルド時に移動させることです。この移動のために、我々はビルド時に作業を進めるためのフレームワークを作成し、Quarkusのエクステンションで活用できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkus extension? That sounds like a lot of work?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのエクステンション？それは大変そうですね？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No, really, it is not.  You can develop your own extensions very easily and they can solve some out of the ordinary problems in a very simple way.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>いいえ、そんなことはありません。独自のエクステンションを簡単に開発することができ、通常では考えられないような問題を非常にシンプルな方法で解決することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last week, one of of our users (hey, Juan!) asked this question on Zulip:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>先週、私たちのユーザーの一人（ヘイ、Juan！）が、Zulipでこんな質問をしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hi! I'm trying to understand how to find classes with some criteria and add them to the dependency injection context, for example: I want to find all classes whose name ends with "MessageTransformer" and add them to the context, I want to find those classes in an external library, so I can't add annotations to them.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>こんにちは！いくつかの基準でクラスを見つけ、それらを依存性注入コンテキストに追加する方法を理解しようとしています。名前が "MessageTransformer "で終わるすべてのクラスを見つけて、コンテキストに追加したいのですが、それらのクラスは外部のライブラリで見つけたいので、アノテーションを追加することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see how we can solve this issue by developing a custom extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この問題を解決するために、カスタムエクステンションを開発する方法を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the extension is as simple as:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの作成は以下のようにとても簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will ask for a `groupId` - let's keep the default `org.acme` - and an extension id - I went for `message-transformers-as-beans`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`groupId` - デフォルトの `org.acme` - とエクステンションID - `message-transformers-as-beans` を要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can import your new extension into your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その後、お好きなIDEに新しいエクステンションをインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Structure of the extension</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションの構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a lot to say about extensions but, in the context of this blog post, we will keep it short.  The extension is composed of three Maven modules:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションについては、いろいろと言いたいことがありますが、このブログ記事の文脈では、短くまとめます。エクステンションは、3つのMavenモジュールで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parent module - nothing to see here</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>親モジュール - 特に注意すべきことはありません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The deployment module - this is the one of interest for our blog post</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デプロイメントモジュール - 今回のブログ記事ではこのモジュールを紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime module - in this blog post, we won't modify it</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ランタイムモジュール - このブログ記事では変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's keep it simple: the deployment module is what will be used at build time, the runtime module is what will be used at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>簡単に説明しますと、デプロイメントモジュールはビルド時に使用されるもので、ランタイムモジュールは実行時に使用されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our case, we want to declare new beans and this is something we do at build time, so deployment module, here we come!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のケースでは、新しいBeanを宣言したいのですが、これはビルド時に行うものなので、デプロイメント・モジュールが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Processors and build steps</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プロセッサーとビルドステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a look at your `deployment` module, you will see a `MessageTransformersAsBeansProcessor` and you can see a method annotated with the `@BuildStep` annotation in it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`deployment` モジュールを見ると、 `MessageTransformersAsBeansProcessor` 、その中に `@BuildStep` のアノテーションが付いたメソッドがあるのがわかると思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus build is populated by these build steps and they are following a consumer/producer model with dependency injection.  The items being consumed and produced are called ``BuildItem``s.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusのビルドには、これらのビルドステップが含まれており、依存性注入によるコンシューマー／プロデューサーモデルに従っています。消費されるアイテムと生産されるアイテムは、 `BuildItem` と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The build step that is automatically generated is easy to understand.  It produces a `FeatureBuildItem` which will be consumed by Quarkus startup and you will see the extension name in the list displayed by Quarkus at startup:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>自動的に生成されるビルドステップはわかりやすいです。これは、Quarkusの起動時に消費される `FeatureBuildItem` を生成し、起動時にQuarkusが表示するリストにエクステンションの名前が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we are done with the scaffolding, let's think a bit about what we want to achieve: we need to find all the classes in a given package whose name ends with `MessageTransformer`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これでスキャフォールド（足場）ができたので、何を実現したいかを少し考えてみましょう。あるパッケージの中で、名前が `MessageTransformer` で終わるクラスをすべて見つける必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An important assumption of Quarkus is that the application lives in a closed world.  You cannot dynamically add a jar at runtime to your Quarkus application and expect it to work.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの重要な前提は、アプリケーションが閉じた世界に存在するということです。実行時に動的にjarをQuarkusアプリケーションに追加して、それが動作することを期待することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it can be seen as a limitation, it opens all sorts of possibilities, one of which is the ability to index the classes and their annotations to easily look them up.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは制限とも言えますが、様々な可能性を秘めています。その1つが、クラスとそのアノテーションにインデックスを付けて、簡単に調べられるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index, based on https://github.com/wildfly/jandex[Jandex], is a very important part of the Quarkus bootstrap.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://github.com/wildfly/jandex[Jandex]をベースにしたこの指標は、Quarkusのブートストラップにおいて非常に重要な役割を果たしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Jandex index doesn't contain all the classes around but is, by default, limited to the application classes and the dependencies containing either a pre-built index or an empty `META-INF/beans.xml`.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Jandexのインデックスは、すべてのクラスを含んでいるわけではなく、デフォルトでは、アプリケーションクラスと、事前に構築されたインデックスまたは空の `META-INF/beans.xml` を含む依存関係に限定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our case, we want to list the classes of an external dependency so we will need to add them to the index.  We can do that very easily by adding a build step to `MessageTransformersAsBeansProcessor`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今回のケースでは、外部依存関係にあるクラスをリストアップしたいので、インデックスに追加する必要があります。これは、 `MessageTransformersAsBeansProcessor` にビルドステップを追加することで簡単に行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the content of the `my.group.id:my-artifact-id` jar to the index.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、 `my.group.id:my-artifact-id` jarの内容がインデックスに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declaring additional beans</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加 Bean の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we have our classes indexed, we want to make them CDI beans.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスのインデックスができたので、CDI Beanにしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be achieved by adding another build step:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これは、別のビルドステップを追加することで実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the additional beans producer</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>追加のBeanプロデューサーを投入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get all known classes from the index</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>インデックスからすべての既知のクラスを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Filter out abstract classes</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>抽象クラスの除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the FQCN of the class</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>クラスのFQCNを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only keep classes from the root package we target</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>対象のルートパッケージのクラスのみを保持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only keep ``MessageTransformer``s</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`MessageTransformer` のみを保持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Produce an `AdditionalBeanBuildItem`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AdditionalBeanBuildItem` を生産</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make the beans unremovable to prevent ArC from removing the beans if they are only programatically consumed</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>プログラムでしか消費されない場合に、ArCがBeanを取り除かないようにするために、Beanを取り除けないようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the default scope to `@ApplicationScoped` - can be any CDI scope of your preference</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>デフォルトのスコープを `@ApplicationScoped` に設定 - 任意のCDIスコープにすることも可能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this build step, any non-abstract class from our root package `my.package` whose name ends with `MessageTransformer` will be made an `@ApplicationScoped` CDI bean.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このビルドステップでは、ルートパッケージ `my.package` から、名前が `MessageTransformer` で終わる非抽象クラスは、 `@ApplicationScoped` CDI Bean になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cherry on top, all this work is done at build time and you don't need to scan your entire classpath at runtime.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>さらに、これらの作業はすべてビルド時に行われるので、ランタイムにクラスパス全体をスキャンする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually, we look up classes in the index with an interface, a superclass or an annotation.  It is less brittle and faster than crawling the whole index and filter by name.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>通常、インターフェイス、スーパークラス、アノテーションでインデックス内のクラスを検索します。これは、インデックス全体をクロールして名前でフィルタリングするよりも、脆くなく、速い方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the point here was to do with the constraints of the user and it wasn't an option to adapt the external dependency.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、ここでのポイントはユーザーの制約であり、外部依存を調整するという選択肢はありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all, folks!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以上です！皆さん、よろしくお願いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, this is a very simple example and you can do much more complex things with a Quarkus extension.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もちろん、これは非常に単純な例であり、Quarkusのエクステンションを使えば、もっと複雑なことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the whole point of this blog post was to demonstrate that you can easily leverage our extension framework to solve real-life issues.  And **in ~10 minutes of coding, our problem is gone**.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、このブログ記事の目的は、現実の問題を解決するために、私たちのエクステンションフレームワークを簡単に利用できることを示すことでした。そして、 **10分ほどのコーディングで、私たちの問題は解決しました** 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next one?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>次は？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I had the question multiple times: how do I use Eclipse Vert.x in Quarkus? Indeed, you can use Vert.x in Quarkus.  You can deploy _verticles_, communicate with the event bus, or use anything from the Vert.x ecosystem.  But, you can also use the Mutiny variant of Vert.x in Quarkus, and get a seamless experience with the other reactive APIs offered by Quarkus.  Several posts have already mentioned this, but it deserves a specific blog post.  So, here we are.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>よく次の質問をされます:「QuarkusでEclipse Vert.xを使うにはどうすればいいですか?」確かに、QuarkusではVert.xを使用することができます。 _Verticles_ をデプロイしたり、イベントバスと通信したり、Vert.xエコシステムのものなら何でも使えます。しかし、QuarkusでVert.xのMutinyバリアントを使用して、Quarkusが提供する他のReactive APIとシームレスな体験を得ることもできます。これについてはすでにいくつかの記事で触れていますが、具体的なブログ記事に値する内容です。というわけで、ここで紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse Vert.x</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Eclipse Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit to build reactive applications.  The Vert.x ecosystem is enormous.  From HTTP and data access abilities to messaging clients via microservice and security facilities, the Vert.x ecosystem is remarkably diverse and versatile.  To understand that variety, just check the https://vertx.io/docs/[Vert.x documentation].  That makes Vert.x popular in many areas such as web applications, IoT gateways, banking applications and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://vertx.io[Vert.x] はリアクティブなアプリケーションを構築するためのツールキットです。Vert.x のエコシステムは膨大です。HTTP やデータアクセス機能からマイクロサービスやセキュリティー機能を介したメッセージングクライアントまで、Vert.x のエコシステムは非常に多様で汎用性に富んでいます。その多様性を理解するには、Vert https://vertx.io/docs/[Vert.xのドキュメント]をチェックしてください。そのため、Vert.xはWebアプリケーション、IoTゲートウェイ、銀行アプリケーションなど、多くの分野で人気があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you may know, Quarkus is based on Vert.x.  Under the hood, there is a managed Vert.x instance that powers the rest of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ご存知のように、QuarkusはVert.xをベースにしています。裏側では、マネージドのVert.xのインスタンスが存在し、Quarkusに力を与えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus serves a HTTP endpoint, under the hood, there is a Vert.x HTTP server handling the request and response.  That's also true for messaging, gRPC and almost any I/O.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusがHTTPエンドポイントを提供する場合、フードの下には、リクエストとレスポンスを処理するVert.x HTTPサーバーがあります。これは、メッセージング、gRPC、およびほぼすべてのI/Oにも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vert.x "bare" API and friends</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.xの「素の」APIとその仲間たち</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x provides multiple APIs.  Let's focus on the "bare" one for now.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.xは複数のAPIを提供しています。ここでは「素」のものに注目してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the reactive nature of Vert.x, the API contains mostly asynchronous methods.  These methods are following a syntax convention:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x のリアクティブな性質にしたがって、API のほとんどを非同期メソッドが占めています。これらのメソッドは構文規則に従っています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part is the last parameter.  It's a function, a callback to be more precise, that gets called when the operation completes or fails.  Indeed, the asynchronous nature of Vert.x does not allow using `try/catch` blocks.  So you need to pass a continuation callback, invoked with the outcome.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>興味深いのは最後のパラメーターです。これは関数、より正確にはコールバックで、操作が完了したときや失敗したときに呼び出されます。実際、Vert.xの非同期の性質上、 `try/catch`  ブロックを使用することはできません。そのため、結果に応じて呼び出される継続コールバックを渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AsyncResult` is a structure capturing this outcome.  It contains the result (of type `&lt;T&gt;`) produced by the operation, or the failure if it failed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`AsyncResult`  は、この結果をキャプチャする構造体です。これは、操作によって生成された結果 ( `&lt;T&gt;`  型)、または失敗した場合の失敗を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例を挙げてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code reads a file, and as it's an asynchronous operation, invokes the callback when the file is read.  The `readFile` method reads the complete content of the file and accumulates it in a _buffer_.  The callback receives the asynchronous result containing either the file's content (`ar.result()`) or a failure.  Vert.x invokes this callback when the operation has either completed or failed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このコードはファイルを読み込み、非同期操作であるため、ファイルが読み込まれたときにコールバックを呼び出します。 `readFile`  メソッドは、ファイルの完全な内容を読み込み、 _バッファ_ に蓄積します。コールバックは、ファイルの内容 ( `ar.result()` ) または失敗を含む非同期の結果を受け取ります。Vert.x は、操作が完了または失敗したときにこのコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x also supports streams thanks to the `ReadStream` and `WriteStream` classes.  A `ReadStream` represents a stream of data you can read.  So you can attach a callback invoked on every item traversing the stream.  A `WriteStream` is a data source.  You can push items to a `WriteStream.` These items will be consumed by a `ReadStream`:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x は `ReadStream`  と `WriteStream`  クラスのおかげでストリームもサポートしています。 `ReadStream`  は読み込み可能なデータのストリームを表します。そのため、ストリームを通過するすべての項目で呼び出されるコールバックをアタッチすることができます。 `WriteStream`  はデータソースです。アイテムを `WriteStream.`  にプッシュすることができます。 これらのアイテムは `ReadStream`  によって消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x streams do not implement Reactive Streams.  Vert.x provides a different back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x ストリームは、Reactive Streams を実装していません。Vert.x は別のバックプレッシャープロトコルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why are these API shaping rules important? Vert.x does not provide a single API.  The "bare" API presented above is just one of the proposed API.  It also provides API in Kotlin, API for RX Java, and so on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜこれらの API シェーピングルールが重要なのか?Vert.xは単一のAPIを提供していません。上で紹介した「素の」APIは、提案されているAPIの1つに過ぎません。他にもKotlinでのAPIやRX JavaでのAPIなども提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These APIs are **generated**.  Vert.x provides a code generator that _ translates_ the Vert.x "bare" API into the other APIs.  Because all methods are well-formed, the generator understands how they should be adapted.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これらの API は *生成され* ます。Vert.x は、Vert.x の "むき出しの" API を他の API に変換するコード ジェネレーターを提供します。すべてのメソッドは整形されているので、ジェネレータはどのように適応されるべきかを理解しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated code exposes a different API; each method delegating to the "bare" API.  Asynchronous methods and streams can follow different transformations, so the resulting API uses the right idioms.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>生成されたコードは、異なる API を公開しており、各メソッドは「素」の API にデリゲートします。非同期メソッドとストリームは異なる変換を行うことができるので、生成されたAPIは適切なイディオムを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven reactive programming library.  It's not related to Vert.x.  However, we have written a code generator that generates the Mutiny variant for the Vert.x API:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。Vert.xとは関係ありませんが、Vert.x API用のMutiny版を生成するコードジェネレータを書いています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/mutiny.png[]</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>&lt;span class="image"&gt;&lt;img src="/assets/images/posts/mutiny-vertx/mutiny.png" alt="mutiny"&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transformations are straightforward:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>変換は簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx` package =&gt; `io.vertx.mutiny` package</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`io.vertx`  パッケージ ⇒ `io.vertx.mutiny`  パッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous methods =&gt; method returning a `Uni&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>非同期メソッド⇒メソッドが返す `Uni&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReadStreams&lt;T&gt;` =&gt; can be consumed as `Multi&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`ReadStreams&lt;T&gt;`  ⇒消費することができます。 `Multi&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WriteStreams&lt;T&gt;` =&gt; can be consumed as Reactive Streams `Subscriber&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`WriteStreams&lt;T&gt;` ⇒ リアクティブストリームとして消費することができます。 `Subscriber&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also adapts the Vert.x back pressure protocol to Reactive Streams, as Mutiny implements Reactive Streams.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>また、MutinyがReactive Streamsを実装しているため、Vert.xのバックプレッシャープロトコルをReactive Streamsに適応させています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the first example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、上から1番目の例では、次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One difference between the two APIs is related to laziness. The Vert.x "bare" API triggers the operation as soon as the method is called.  The Mutiny variant expects a subscription to trigger the operation.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>2つのAPIの違いの1つは、怠惰性に関連しています。Vert.x の "素の" API は、メソッドが呼び出されるとすぐに操作をトリガーします。Mutiny 版では、操作をトリガーするためにサブスクリプションを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The stream example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>上からのストリームの例は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit more than this</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もう少し補足</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny variant does not only apply the rules exposed in the previous section.  For asynchronous methods, it also provides:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutiny版は、前のセクションで公開されたルールを適用するだけではありません。非同期メソッドに対しても提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndAwait()` methods - blocks the caller thread until the outcome is received. In the case of a failure, throws a `RuntimeException`</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`xAndAwait()`  メソッド - 結果を受け取るまで呼び出し元のスレッドをブロックします。失敗した場合は `RuntimeException` を発生させます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndForget()` methods - triggers the operation, discard the outcome</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>`xAndForget()`  methods - 操作をトリガし、結果を破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can we find this API?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このAPIはどこにありますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment of writing, we only provide Vert.x core and Vert.x clients (MongoDB, Redis, Web client, Mqtt, and so on).  We are extending the support to cover the full Vert.x stack.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>執筆時点では、Vert.xコアとVert.xクライアント(MongoDB、Redis、Webクライアント、Mqttなど)のみを提供しています。私たちはVert.x スタック全体をカバーするようにサポートを拡張しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the Mutiny clients, you need to add the right dependency to your project.  Browse https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[the list of dependency] to pick the one you need.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Mutinyクライアントを使用するには、適切な依存関係をプロジェクトに追加する必要があります。 https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[依存関係のリスト]を見て、必要なものを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to you use the Mutiny variant of the Vert.x Web client, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>例えば、Vert.x Web クライアントの Mutiny 版を使用するには、以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have the dependency, just create the web client instance:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>依存関係ができたら、あとはWebクライアントのインスタンスを作成するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Something missing? Open an issue on https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>何か足りないものがあった場合は、 https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils] に課題を提起してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Javadoc is available http://smallrye.io/smallrye-reactive-utils/apidocs/[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javadocは http://smallrye.io/smallrye-reactive-utils/apidocs/[こちら] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The road ahead: Vert.x 4!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>今後の道:Vert.x 4!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x 4 is coming soon! We are already working in Quarkus and the different satellite projects to migrate.  With Vert.x 4, a new generator has been implemented (following the same code generation approach), paving the road to a smooth upgrade.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Vert.x 4が間もなく登場します!既にQuarkusと異なるサテライトプロジェクトで移行作業を行っています。Vert.x 4では、新しいジェネレータが実装されており(同じコード生成アプローチを踏襲しています)、スムーズなアップグレードへの道が開かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of this blog post is to clear up some confusion about RESTEasy Reactive and answer some commonly asked questions around it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このブログ記事の目的は、RESTEasy Reactive についての混乱を解消し、よくある質問に答えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>謝辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our quest to understand why RESTEasy Reactive is important and how it differs from RESTEasy Classic, it helps to paraphrase a very important message that was first introduced https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[here].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive が重要な理由と、RESTEasy Classic と異なる点を理解するために、link:https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[ここ] で最初に紹介した非常に重要なメッセージを再び考察してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Java web applications use imperative programming combined with blocking IO operations. This is incredibly popular because it is easier to reason about the code.  Things get executed sequentially. When the application receives a request, the framework associates this request to a worker thread.  When the request processing needs to interact with a database or another remote service, it relies on blocking IO.  The thread is blocked waiting for the answer, making the communication synchronous. With this model one request is not affected by another as they are run on different threads.  Even when one thread is waiting, other requests running on different threads are not slowed down significantly.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>一般的に、Java のWeb アプリケーションでは、ブロッキング IO 操作と組み合わせた命令型プログラミングを使用します。これは、コードを推論するのが簡単なので、非常に人気があります。物事は順次実行されます。アプリケーションがリクエストを受け取ると、フレームワークはこのリクエストをワーカースレッドに関連付けます。リクエスト処理がデータベースや他のリモートサービスと対話する必要があるときは、ブロッキング IO に依存します。スレッドは応答を待ってブロックされ、通信を同期化します。このモデルでは、1 つのリクエストは別のスレッドで実行されるので、別のリクエストの影響を受けません。1 つのスレッドが待機している場合でも、異なるスレッド上で実行されている他のリクエストが大幅に遅くなることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This model enables the usage of a single IO thread to handle multiple requests. There are three significant benefits.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このモデルでは、単一の IO スレッドを使用して複数のリクエストを処理することができます。3 つの大きなメリットがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the response time is smaller because it does not have to jump to another thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>まず、別のスレッドにジャンプする必要がないので、レスポンス時間が短くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, it reduces memory consumption as it decreases the usage of threads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第 2 に、スレッドの使用量が減るため、メモリーの消費量を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Third, your concurrency is no longer limited by the number of threads.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>第 3 に、並行処理はスレッド数に制限されなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive model uses the hardware resources more efficiently, but... a significant pitfall lurks. If the processing of a request starts to block, things can go south really quickly as no other request can be handled. To avoid this, you need to learn how to write asynchronous and non-blocking code, how to schedule operations, how to write continuations, how to chain actions.  Basically, we need a way to structure asynchronous processing, and use non-blocking IO. No doubt, that consists of a paradigm shift.  In Quarkus, we want to make the shift as easy as possible, so RESTEasy Reactive allows you to choose whether an endpoint is blocking or non-blocking (an application is free to mix and match blocking and non-blocking methods at will).  So don’t be intimidated by the reactive word, the infrastructure is reactive, but your code can be either reactive or imperative. That’s what we mean by unification of reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブモデルはハードウェアリソースをより効率的に使用しますが、重大な落とし穴が潜んでいます。もしリクエストの処理がブロックされ始めると、他のリクエストが処理できなくなるため、本当にすぐに事態が悪化してしまいます。これを避けるためには、非同期でノンブロッキングなコードの書き方、操作のスケジュールの立て方、連続処理の書き方、アクションの連鎖の仕方などを学ぶ必要があります。基本的には、非同期処理を構造化し、ノンブロッキングIOを使う方法が必要です。これは間違いなく、パラダイムシフトであることは間違いありません。Quarkusでは、このシフトをできるだけ簡単にしたいと考えているので、RESTEasy Reactiveでは、エンドポイントがブロッキングかノンブロッキングかを選択することができます (アプリケーションはブロッキングとノンブロッキングのメソッドを自由に組み合わせて使用することができます)。インフラストラクチャはリアクティブですが、あなたのコードはリアクティブ型にも命令型にもなり得ます。これが、リアクティブ型と命令型の統一の意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive by default handles each HTTP request on an IO thread (otherwise known as an event-loop thread)footnote:[More information about the execution model of RESTEasy Reactive can be found https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[here]].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive は、デフォルトでは IO スレッド(イベントループスレッドとして知られている)上の各 HTTP リクエストを処理します footnote:[RESTEasy Reactiveの実行モデルについて詳細は https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[ここ] にあります]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following image shows what that looks at a high level:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>以下のイメージでは、ハイレベルの様子を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-non-blocking.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RR-non-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ensures that maximum throughput can be achieved, but it also means that the implementation of an endpoint method should complete in a timely fashion otherwise the thread will be used for too longfootnote:["Too long" depends on your target concurrency. You may consider 1ms as too long for some endpoint heavily used, but 100ms might be acceptable for less used endpoints] and other requests will be queued up and lead to degraded throughput.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これにより、最大のスループットを達成することがきます。ただし、エンドポイントメソッドの実装がタイムリーに完了しなければならないことも意味しています。そうでなければ、スレッドの使用が長くなり過ぎてしまい footnote:["長過ぎる" は目標とする並列度次第です。頻繁に使用されるエンドポイントでは 1ms も長過ぎると考える場合もありますし、あまり使われないエンドポイントでは 100ms でも許容可能かもしれません。]、他のリクエストがキューイングされ、スループットの低下につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to understand that a method body that uses imperative code only becomes a problem when it takes a long time to execute - which is almost always the case for blocking IO operations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>命令型コードを使用するメソッド本体が問題になるのは、実行に長い時間がかかるときだけ - ブロッキング IO 処理がほぼ全てのケース - であることを理解することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For that reason, when the body of the method performs some kind of blocking IO operation (or even some CPU bound operation that requires time to complete), the request needs to be offloaded to a worker thread.  In RESTEasy Reactive that is done declaratively using the `@Blocking` annotation - no reactive programming or complex Java concurrency related code is needed.  Quarkus also warns you when you attempt to use blocking IO on an IO thread.  If however the method body performs non-blocking IO (or some CPU bound operation that completes very quickly) then RESTEasy Reactive can continue to serve the entire request on the IO thread.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、メソッドの本体が何らかのブロッキング IO 操作 (あるいは完了までに時間を要する CPU バインド操作) を実行する場合、リクエストはワーカースレッドにオフロードされる必要があります。RESTEasy Reactiveでは、`@Blocking` アノテーションを使用して宣言的に行われます。Quarkus は、IO スレッドでブロッキング IO を使用しようとした場合にも警告します。しかし、メソッド本体がノンブロッキング IO (または非常に速く完了するCPUバインド操作) を実行する場合、RESTEasy Reactive は、IO スレッド上でリクエスト全体を提供し続けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely not!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もちろん違います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although RESTEasy Reactive was built from the ground up to do non-blocking IO and serve requests from the event loop threads (thus avoiding the needless usage of worker pool threads)  it can effortlessly work with blocking IO and any piece of code that provides a blocking API (such as Hibernate) without blocking the event loop.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive は、ノンブロッキング IO とイベントループスレッドからのリクエストを処理するために一から構築されていますが(そのため、ワーカープールスレッドの不要な使用を避けることができます)、ブロッキング IO と、(Hibernate のような) ブロッキング APIを提供するあらゆるコードをイベントループをブロッキングせずに簡単に動作させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only thing you have to do is add `@Blocking` on your endpoint method or class.  That’s it! If you use `@Blocking` you are back to the regular dispatching mechanism: a worker thread is used to execute your method.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントのメソッドやクラスに `@Blocking` を追加するだけです。これだけです。`@Blocking` を使用すると、通常のディスパッチの仕組み:ワーカースレッドがメソッドの実行に使用される方式に戻れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At a high level it this looks like this:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ハイレベルでは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-blocking.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RR-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can probably guess from the answer to the previous question, the answer is no.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>前の質問の答えからわかる通り、答えは「ノー」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate, the `@Blocking` annotation should be placed on the endpoint methods that interact with Hibernate.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive が Hibernate と一緒に使用されるシナリオでは、 `@Blocking` アノテーションを Hibernate と相互作用するエンドポイントメソッドに配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate Reactive, no `@Blocking` annotation is necessary on the endpoint methods that interact with Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive が Hibernate Reactive とともに使用されるシナリオでは、Hibernate Reactive と相互作用するエンドポイントメソッドに `@Blocking` アノテーションは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the performance implication of using @Blocking?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>@Blocking を使用することによるパフォーマンスへの影響について</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the absolute highest throughput is achieved when an endpoint method is non-blocking (that is the HTTP request is served completely from the event loop thread), great performance can nonetheless be achieved even when `@Blocking` is used.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エンドポイントメソッドがノンブロッキング (つまり、HTTP リクエストがイベントループスレッドから完全に提供される) の場合には、絶対的に最高のスループットが達成されますが、 `@Blocking` を使用していても優れたパフォーマンスを達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our benchmarks we see the use of `@Blocking` reduce maximum throughput by around 30%footnote:[This is basically the cost we have to pay for dispatching the request to a worker thread. The percentage of the slowdown decreases the longer the target method takes to execute].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>私たちのベンチマークでは、`@Blocking` を使用することで最大スループットが約 30%footnote 低下することがわかります footnote:[これは基本的にワーカースレッドにリクエストを振り分けるためにかかるコストです]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, an endpoint method using `@Blocking` in RESTEasy Reactive still achieves around 50% higher throughput than the same method using RESTEasy Classic.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、RESTEasy Reactive で `@Blocking` を使用したエンドポイントメソッドでは、RESTEasy Classic を使用した同じメソッドよりも約 50% 高いスループットを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does RESTEasy Reactive using @Blocking perform better than RESTEasy Classic?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>なぜ @Blocking を使用した RESTEasy Reactive は RESTEasy Classic よりもパフォーマンスが良いのですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is able to gain its performance advantage over RESTEasy Classic by:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive は、RESTEasy Classic と比較して、以下のような特徴を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating very tightly with Eclipse Vert.x for everything IO related. Vert.x has been extremely well optimized for IO operations and so tight integration with it allows RESTEasy Reactive to benefit from all that work.  You might recall that RESTEasy Classic on Quarkus uses Vert.x under the hood as well, but in that case the integration is not as deep and is therefore unable to fully utilize the power of Vert.x.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>IO に関連するすべてを Eclipse Vert.x と緊密に統合します。Vert.x は IO 操作のために非常によく最適化されています。そのため、RESTEasy Reactive はそれとの緊密な統合により、その恩恵を受けることができます。RESTEasy Classic on Quarkus も同様に Vert.x を使用しています。ただし、その場合、統合はそれほど深くないため、Vert.x のパワーを十分に活用することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving a lot of work to build time. As RESTEasy Reactive was built from the ground up to serve the needs of Quarkus, it benefits from the tightest possible integration with Quarkus and is probably the extension that does the most build time work.  This in turn results in creating an optimal data pipeline for serving each request, helping the JIT compiler by generating bytecode to inline runtime operations, eliminating reflection at runtime (both for invoking methods and for determining types) and reducing memory allocations.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>多くの作業をビルド時に移行しています。RESTEasy Reactive は、Quarkus のニーズに応えるためにゼロから構築されています。そのため、Quarkus との統合が可能な限り緊密に行われており、おそらく最も多くをビルド時に作業を行うエクステンションとなっています。これにより、各リクエストを処理するための最適なデータパイプラインを作成し、実行時の操作をインラインで行うバイトコードを生成することで JIT コンパイラを支援し、実行時の (メソッドの呼び出しと型の決定のための) リフレクションを排除し、メモリーの割り当てを削減します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Avoiding the use of ThreadLocals and instead by utilizing a context object that contains all the necessary information.  ThreadLocals are a convenient way to make data available to different parts of a framework, but their frequent use comes at a cost and are thus fully avoided in RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ThreadLocals の使用を避け、代わりに必要な情報をすべて含むコンテキストオブジェクトを利用します。ThreadLocals はフレームワークのさまざまな部分でデータを利用できるようにする便利な方法です。ただし、その頻繁な使用にはコストがかかるため、RESTEasyReactive では完全に回避されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Utilizing Arc in an optimal manner for all necessary injections. RESTEasy Classic provides an abstraction layer that performs the various injection operations, which for the needs of Quarkus is entirely unnecessary since Arc provides the same functionality with better performance.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>必要なすべてのインジェクションに最適な方法でArcを活用します。RESTEasy Classic は、さまざまなインジェクション操作を実行する抽象化レイヤーを提供しますが、Arcは同じ機能をより優れたパフォーマンスで提供するため、Quarkus のニーズには全く不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might recall that Quarkus allows you to use Mutiny return types (Uni and Multi) when using RESTEasy Classic via the `quarkus-resteasy-mutiny` extension and thus might be wondering how that compares to using RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Classic を使用しているときに Quarkus では、`quarkus-resteasy-mutiny` エクステンションを介して Mutiny 戻り値の型 (UniとMulti) を使用することができることや、これが RESTasy Reactive の使用と、どのように異なるかと思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main thing to understand about RESTEasy Classic is that it *always* handles requests on a worker thread as it does not use the event-loop concept at all.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Classic について最も理解しておくべきこととして、RESTEasy Classic はイベントループの概念を一切使用しないため、*常に*ワーカースレッド上でリクエストを処理することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is best shown by the following image:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>これを最もよく表しているのは、以下の画像です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CR.png</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>CR.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when using RESTEasy Classic even when you return a reactive type like `Uni` or `Multi` the initial request is still being handled on a worker thread and while the call to the library may result in non-blocking IO, nevertheless there is no way for RESTEasy Classic to reuse the worker thread once it is blocked waiting on IO.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>そのため、RESTEasy Classic を使用する場合、`Uni` や `Multi` のようなリアクティブ型を返しても、最初のリクエストはワーカースレッドで処理され、ライブラリーの呼び出しはノンブロッキング IO になることがあります。それでも IO の待機中にブロックされると、RESTEasyClassic がワーカースレッドを再利用する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the gain of using reactive return types in RESTEasy Classic is a syntactic gain, not a runtime gain - the underlying hardware isn’t used more efficiently despite the use of reactive types.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>このように、RESTEasy Classic でリアクティブな戻り値型を使用することで得られる利益は、ランタイムの利益ではなく、構文的な利益です。リアクティブ型を使用していても、基礎となるハードウェアが、より効率的に使用されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning Mutiny types using RESTEasy Reactive, everything happens on the IO Thread (except if the endpoint is annotated with `@Blocking`). By the way, no need for an external extension to use Mutiny with RESTEasy Reactive, it’s built-in!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive を使用して Mutiny 型を返す場合、すべての処理は IO スレッド上で行われます (エンドポイントが `@Blocking` でアノテーションされている場合を除く)。RESTEasy Reactive で Mutiny を使用するための外部エクステンションは不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do I have to use the new RESTEasy Reactive APIs to achieve maximum performance?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最大のパフォーマンスを実現するためには、新しい RESTEasy Reactive API を使用する必要がありますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading through the RESTEasy Reactive documentation you soon come across the new APIs for writing request filters (https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[@ServerRequestFilter]), response filters (`@ServerResponseFilter`) and exception mappers (https://quarkus.io/guides/resteasy-reactive#exception-mapping[@ServerExceptionMapper]).  You might wonder if their usage affects performance in any way compared to the standard JAX-RS APIs (`ContainerRequestFilter`, `ContainerResponseFilter` and `ExceptionMapper`).</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive のドキュメントを読むと、すぐにリクエストフィルター link:https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[(@ServerRequestFilter])、レスポンスフィルター (`@ServerResponseFilter`)、例外マッパー link:https://quarkus.io/guides/resteasy-reactive#exception-mapping[(@ServerExceptionMapper]) を記述するための新しい API に出くわします。これらの使用法が標準の JAX-RS API (`ContainerRequestFilter`, `ContainerResponseFilter`, `ExceptionMapper`) と比べてパフォーマンスに影響を与えるかどうかを疑問に思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new APIs will give a tiny performance advantage over using the old APIs if the use of `@Context` is involved in the latter case, the advantage is negligible and should not worry you unless you are trying to squeeze out every inch of performance you can find.  One thing to keep in mind when writing filters with either API, is that using `org.jboss.resteasy.reactive.server.SimpleResourceInfo` instead of `javax.ws.rs.container.ResourceInfo` is advised as the latter results in reflection being performed.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>後者のケースで `@Context` を使用する場合、新しい API は古い API を使用するよりもわずかなパフォーマンスの優位性を与えます。ただし、その優位性は取るに足らない程度で、可能な限りのパフォーマンスを限界まで引き出すのでない限り、心配する必要はありません。どちらの API を使ってフィルターを書く場合でも注意すべきことは、`javax.ws.rs.container.ResourceInfo` の代わりに `org.jboss.resteasy.reactive.server.SimpleResourceInfo` を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A special (albeit rather advanced) case where the new APIs do result in noticeably better performance is the case of `MessageBodyReader` and `MessageBodyWriter` classes.  When reading the HTTP request and writing the HTTP response, the use of https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader] and `ServerMessageBodyWriter` allows RESTEasy Reactive to optimize the data-path for serving the request.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>新しい API によってパフォーマンスが顕著に向上する特別なケースとして、`MessageBodyReader` と `MessageBodyWriter` クラスがあります。HTTP リクエストの読み込みと HTTP レスポンスの書き込みの際に、 link:https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader]と `ServerMessageBodyWriter` を使用することで、RESTEasy Reactive はリクエストを提供するためのデータパスを最適化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about Reactive Routes?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>リアクティブルートは?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was already providing a way to handle HTTP requests from the IO thread. Reactive Routes provides a declarative model to implement HTTP API. Each route can be called on the IO thread (default) or on a worker thread (using the `@Blocking` annotation).  Reactive Routes provide very good throughput and performance as highlighted in https://quarkus.io/blog/io-thread-benchmark/[this] article. How does reactive routes compare to RESTEasy Reactive?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusはすでに IO スレッドから HTTP リクエストを処理する方法を提供していました。Reactive Routes (リアクティブルート) は、HTTP API を実装するための宣言モデルを提供します。各ルートは、IO スレッド (デフォルト) またはワーカースレッド (`@Blocking` アノテーションを使用) で呼び出すことができます。link:https://quarkus.io/blog/io-thread-benchmark/[この]記事で強調されているように、Reactive Routes は非常に優れたスループットとパフォーマンスを提供します。リアクティブルートは RESTEasy Reactive と比較してどうでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main complaints we got about Reactive Routes was about the development model: it’s very different from the one used with RESTEasy. However, Reactive Routes allowed us to verify the performance and efficiency benefits of using an end-to-end reactive model on top of Quarkus.  RESTEasy Reactive can be seen as the “next generation”: you get the runtime benefits while also using a familiar development model.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Reactive Routes についての主な不満の 1 つは、開発モデルに関するものでした。RESTEasy で使用したものとは大きく異なります。しかし、Reactive Routes を使用することで、Quarkus 上にエンドツーエンドのリアクティブモデルを使用することで得られるパフォーマンスと効率性のメリットを検証することができました。RESTEasy Reactive は「次世代」と考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is the next generation of HTTP framework. It unifies reactive (non-blocking IO, asynchronous APIs) and imperative (thanks to the `@Blocking` annotation). It improves raw performances without constraining the user experience.  Its reactive/imperative duality makes it fit any use cases, from highly concurrent HTTP APIs, to more traditional transactional CRUD applications.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive は次世代の HTTP フレームワークです。リアクティブ型 (ノンブロッキング IO、非同期 API) と命令型 (`@Blocking` アノテーションを使用) を統合しています。ユーザーエクスペリエンスを制限することなく、生のパフォーマンスを向上させます。その命令型/リアクティブ型の二面性により、高度に並列化された HTTP API から、より伝統的なトランザクション型の CRUD アプリケーションまで、あらゆるユースケースに適合するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see RESTEasy Reactive as becoming the default HTTP layer in Quarkus in the near future and are completely committed to making it perform at the best possible level while also introducing new features that spark developer joy!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>RESTEasy Reactive は、近い将来 Quarkus のデフォルト HTTP レイヤーになると思われます。また、開発者にうれしい新機能を導入しながら、可能な限り最高のパフォーマンスを実現することに完全にコミットしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In that vein, we hope that this short blog post will provide you with some insight on what makes RESTEasy Reactive special and clear up any misconceptions you may have had about it.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>この短いブログ記事が、RESTEasy Reactive が特別である理由と、RESTEasy Reactive について抱いていた誤解を解き明かすためのヒントになればと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The evolution of Java</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javaの進化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java is a language that never ceases to impress me. From its conception, to the first Java Virtual Machines with the premise of “write once run anywhere”, to Tomcat or to the Enterprise Edition standards (whether J2EE, or Java EE) it’s an ever evolving language.  With the advent of containerization and the possibility of effectively managing microservices, running components that could be loaded in a "reactive" manner and the need for boot speed and efficiency, Quarkus is revealing itself as the choice for Cloud Native Java programmers.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Javaという言語には、いつも驚かされます。その構想から、「write once run anywhere」を前提とした最初のJava仮想マシン、Tomcat、あるいはEnterprise Editionの規格（J2EEでもJava EEでも）に至るまで、常に進化し続ける言語です。コンテナ化が進み、マイクロサービスを効果的に管理できるようになり、「リアクティブ」な方法でロードできるコンポーネントを実行し、起動速度と効率性が求められるようになったことで、QuarkusはクラウドネイティブJavaプログラマーの選択肢として登場しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with brownfield applications</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ブラウンフィールドでの活用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, after so many years and lines of code written, how can we move those Java workloads to this set of new paradigms? The Red Hat Modernization and Migration Solutions team is here to help by providing the http://red.ht/mta[Migration Toolkit for Applications] (MTA), a tool that simplifies, and reduces the effort required to take this step. As a matter of fact, just like Java, MTA is not a new tool but one that has been evolving over time.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>しかし、何年もかけて何行ものコードを書いた後、これらのJavaワークロードをこの一連の新しいパラダイムに移行するにはどうすればよいのでしょうか？Red HatのModernization and Migration Solutionsチームは、 link:http://red.ht/mta[Migration Toolkit for]Applications (MTA)というツールを提供することで、このステップに必要な労力を簡略化し、削減することを支援します。実は、Javaと同様にMTAも新しいツールではなく、時間をかけて進化してきたものなのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It all started by helping developers update their code to run in a new https://developers.redhat.com/products/eap/[JBoss EAP] version, a "piece of cake". That’s why the tool started by being called "JBoss Cake" back in 2012. It kept evolving to be able to be used to modernize Java code and move it from WebLogic or WebSphere to JBoss EAP or https://developers.redhat.com/products/webserver/[JBoss Web Server] (the Red Hat Supported build of Tomcat), when it became the Red Hat Application Migration Toolkit. It kept being improved by developers and consultants, bringing their experience by working in the first line with production code, who wrote more and better rules, increasing the number of covered cases.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>その始まりは、開発者がコードを更新して link:https://developers.redhat.com/products/eap/[JBoss EAP]の新バージョンで実行できるようにすることを簡単にするためでした。そのため、このツールは2012年に「JBoss Cake」と呼ばれることから始まりました。その後、JavaコードをモダナイズしてWebLogicやWebSphereからJBoss EAPや link:https://developers.redhat.com/products/webserver/[JBoss Web Server]（TomcatのRed Hatがサポートするビルド）に移行する際に使用できるように進化を続け、Red Hat Application Migration Toolkitとなりました。このツールは、開発者やコンサルタントによって改良され続けています。開発者やコンサルタントは、本番コードの第一線で働いた経験を生かして、より良いルールを書き、対象となるケースを増やしていきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the latest evolution, the tool started being called by its current name, Migration Toolkit for Applications, or MTA. With the release 5.0.0, it started seeding the first rules to help migrate applications from the Spring Boot framework to Quarkus. That happened, among other things due to the feedback that developer teams working with modern Java patterns, and deploying on Kubernetes, were interested in. It happened that these teams were using Spring Boot but quickly became interested in Quarkus as a way to improve speed, required resources, and productivity. With version 5.1.1, MTA broke the 120 rules barrier to ease this transformation path. Now, closing the circle, MTA in the coming release 5.1.3 of MTA (expected by mid March 2021) will include rules to upgrade code written for Quarkus 1.11, so it can efficiently be moved to 1.12. A piece of cake!</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>最新の進化の中で、このツールは現在の名前であるMigration Toolkit for Applications（MTA）と呼ばれるようになりました。5.0.0のリリースでは、Spring BootフレームワークからQuarkusへのアプリケーションの移行を支援する最初のルールの提供が開始されました。これは、最新のJavaパターンを使用し、Kubernetesにデプロイする開発者チームが興味を持っているというフィードバックを受けたことなどによります。これらのチームは、Spring Bootを使用していましたが、スピード、必要なリソース、生産性を向上させる方法として、すぐにQuarkusに興味を持つようになりました。MTAはバージョン5.1.1で120ルールの壁を突破し、このトランスフォーメーションの道を容易にしました。そして、今後MTAのリリース5.1.3（2021年3月中旬までに予定）では、Quarkus 1.11向けに書かれたコードをアップグレードするためのルールが含まれており、1.12への移行を効率的に行うことができます。簡単ですね!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Related resources</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>関連リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do you want to know more? Here you are, some MTA related resources:</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>もっと知りたいですか？ここでは、MTA関連のリソースをご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://red.ht/mta[MTA web page] (with downloads and demo videos)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:http://red.ht/mta[MTAのWebページ]（ダウンロード、デモビデオあり）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://developers.redhat.com/blog/2020/12/08/spring-boot-to-quarkus-migrations-and-more-in-red-hats-migration-toolkit-for-applications-5-1-0/[Spring Boot to Quarkus migrations with MTA] (in developers.redhat.com)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://developers.redhat.com/blog/2020/12/08/spring-boot-to-quarkus-migrations-and-more-in-red-hats-migration-toolkit-for-applications-5-1-0/[MTAによるSpring BootからQuarkusへ]の移行(developers.redhat.com 内)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://youtu.be/coeVxLaXy5M[Migrating Spring Boot "Pet-Clinic" (REST version) to Quarkus] (http://konveyor.io[konveyor.io] meetup recording)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:https://youtu.be/coeVxLaXy5M[Spring Boot「Pet-Clinic」（REST版）のQuarkusへの移行] （link:http://konveyor.io[konveyor.io] のミートアップレコーディング）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>ライセンスは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusは https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0] でライセンスされているオープンソースプロジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>どこから入手できますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>QuarkusはMaven Centralで公開されています。必要な link:/extensions[which extensions] を確認し、`pom.xml` にインポートするだけでQuarkusを入手できます。link:/get-started[Getting Started guides] からQuarkusの体験を始めることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>はい、Quarkusは安定していると考えています。Quarkusのアプリが使用する機能の95%は、Hibernate ORM、Eclipse Vert.x、Netty、RESTEasyなどのエコシステムによって提供されていることを忘れないでください。これらのライブラリは極めて盤石です:)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://code.quarkus.io/[code.quarkus.io]にアクセスして、特定のエクステンションが_安定_(デフォルト)か_プレビュー_かを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusの主な目標の1つは、拡張性の容易さと活気のあるエコシステムの構築です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusエクステンションはプロジェクトの依存関係だと考えてください。エクステンションは、フレームワークまたはテクノロジーをQuarkusアプリケーションに構成、起動、および統合します。また、アプリケーションをネイティブにコンパイルするために、GraalVMに適切な情報を提供するという面倒な作業もすべて行います。これにより、サードパーティのプロジェクトは、GraalVMをターゲットにしやすくするために我々が行った作業を簡単に利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションステータスとは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションは、Quarkusエコシステムに入る際に、さまざまな成熟度を持ちます。ステータスは、信頼度の期待値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*安定*:下位互換性とエコシステムでの存在感が非常に重要視されています。アプリケーションはこれらのエクステンションに安全に依存できます。プレビューまたは実験的(大部分)としてマークされていないエクステンションは安定しています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*プレビュー*:下位互換性とエコシステム内での存在感は保証されません。特定の改善には、構成またはAPIの変更が必要になる場合があり、_安定_になる計画が進行中です。このようなエクステンションは、成熟プロセスの途中です。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>*実験的*:アイデアを成熟させるために、早期のフィードバックが必要です。ソリューションが成熟するまで、プラットフォーム内での安定性や長期的な存在は保証されません。このようなエクステンションは、成熟プロセスの初期段階にあります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションステータスは、https://code.quarkus.io[code.quarkus.io] またはエクステンション link:/guides/[guides] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>エクステンションを作成できますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>勿論です! Quarkusの「初期」チームの外部でかなりの数のエクステンションが作成されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>Quarkusはオープンエコシステムであり、人々がアプリを作成するために必要なすべてのエクステンションが存在することを期待しています。エクステンションを個別のリポジトリと個別のGAVで公開し、Quarkusコアとは独立してMavenリポジトリで公開できるようにするために取り組んでいます。これにより、公開プロセスが大幅に簡素化されます。近いうちのニュースを期待してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/master/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>現在の制限の1つは、エクステンションはOpenJDKとGraalVMの両方のネイティブ実行可能ファイルで機能する必要があるということです。これは、Quarkusユーザーに提供する保証です(アプリのクロスコンパイル)。エクステンションを改善して完全に「Quarked」し、Quarkusの恩恵を受けるための成熟度モデルがあり、すべて段階的に実行されます。 https://quarkus.io/community/#discussions[メーリングリスト] にアクセスして、アイデアについて話し合い、サポートを受けてください。また、https://quarkus.io/guides/writing-extensions[エクステンションガイドの作成] を読み始めることも、 https://github.com/quarkusio/quarkus/tree/master/extensions[既存のエクステンション] からインスピレーションを得ることもできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>https://www.graalvm.org[GraalVM] は、さまざまな異なる言語で記述されたアプリケーションを実行するためのユニバーサル仮想マシンであり、JVMバイトコードをネイティブ実行可能ファイルにコンパイルする機能を提供します(このネイティブ実行可能ファイルは、SubstrateVMと呼ばれる特別な仮想マシンを実行します)。これらのネイティブ実行可能ファイルは、従来のJVMよりもはるかに高速に起動し、使用するメモリーを大幅に削減できますが、すべてのJVM機能がサポートされているわけではなく、一部は通常よりも制限されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>たとえば、デフォルトでは、クラス/メンバーがリフレクション用に明示的に登録されていない限り、GraalVMでのリフレクションは機能しません。これは通常、すべてのクラス、メソッド、フィールド、コンストラクターをJSONファイルにリストし、これをパラメーターとしてネイティブイメージビルドに渡すことで実現されます。これは、最も些細なプロジェクトを除いて、明らかに非常に面倒になります。 Quarkusは、これらの注釈を簡単に回避し、何を登録するかをプログラムで決定できるフレームワークを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 命令型プログラミングとリアクティブプログラミングをどのように統合しますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/continuum[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/continuum[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/container-first[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/container-first[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 標準についてどう考えていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/standards[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/standards[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>## 開発者の満足度を向上させるために何に取り組んでいますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/developer-joy[Learn more].</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>link:/vision/developer-joy[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
      <tuv xml:lang="zh_CN">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
    </tu>
  </body>
</tmx>
