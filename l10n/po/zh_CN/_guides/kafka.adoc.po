# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-07-11 01:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, no-wrap
msgid "Quarkus - Using Apache Kafka with Reactive Messaging"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:11
msgid "This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:12
#, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:15
msgid "To complete this guide, you need:"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:17
msgid "less than 15 minutes"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:18
msgid "an IDE"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:19
msgid "JDK 11+ installed with `JAVA_HOME` configured appropriately"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:20
msgid "Apache Maven {maven-version}"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:21
msgid "A running Kafka cluster, or Docker Compose to start a development cluster"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:22
msgid "GraalVM installed if you want to run in native mode."
msgstr ""

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:23 upstream/_guides/kafka.adoc:31
#, no-wrap
msgid "Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:30
msgid "In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events."
msgstr ""

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:31
#, no-wrap
msgid "kafka-guide-architecture.png"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:33
#, no-wrap
msgid "Solution"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:37
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:39
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:41
msgid "The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory]."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:42
#, no-wrap
msgid "Creating the Maven Project"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:45
msgid "First, we need a new project. Create a new project with the following command:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:55
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-quickstart \\\n"
"    -DclassName=\"org.acme.kafka.PriceResource\" \\\n"
"    -Dpath=\"/prices\" \\\n"
"    -Dextensions=\"resteasy,smallrye-reactive-messaging-kafka\"\n"
"cd kafka-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:58
msgid "This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:61
msgid "If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:65
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:68
msgid "This will add the following to your `pom.xml`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:75
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:78
#, no-wrap
msgid "Dev Services"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:82
msgid "No need to start a Kafka broker when using the dev mode or for tests. Quarkus starts a broker for you automatically.  See xref:kafka-dev-services.adoc[Dev Services for Kafka] for details."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:84
#, no-wrap
msgid "The price generator"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:87
msgid "Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:91 upstream/_guides/kafka.adoc:132
#: upstream/_guides/kafka.adoc:175
#, no-wrap
msgid "package org.acme.kafka;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:94
#, no-wrap
msgid ""
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:96 upstream/_guides/kafka.adoc:139
#: upstream/_guides/kafka.adoc:489
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:99
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:106
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:108
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:115
#, no-wrap
msgid ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:117 upstream/_guides/kafka.adoc:158
#: upstream/_guides/kafka.adoc:508 upstream/_guides/kafka.adoc:752
#: upstream/_guides/kafka.adoc:849
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:119
msgid "Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:120
msgid "The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:123
msgid "The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:124
#, no-wrap
msgid "The price converter"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:128
msgid "The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:137
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:146
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming data from the \"prices\" Kafka topic and applying some conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:148 upstream/_guides/kafka.adoc:498
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:156
#, no-wrap
msgid ""
"    @Incoming(\"prices\")                                     // <1>\n"
"    @Outgoing(\"my-data-stream\")                             // <2>\n"
"    @Broadcast                                              // <3>\n"
"    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // <4>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:160
msgid "Indicates that the method consumes the items from the `prices` topic"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:161
msgid "Indicates that the objects returned by the method are sent to the `my-data-stream` stream"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:162
msgid "Indicates that the item are dispatched to all _subscribers_"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:163
msgid "Make sure to acknowledge the incoming message"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:166
msgid "The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:167
#, no-wrap
msgid "The price resource"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:171
msgid "Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:178 upstream/_guides/kafka.adoc:628
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:185 upstream/_guides/kafka.adoc:635
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:191
#, no-wrap
msgid ""
"/**\n"
" * A simple resource retrieving the in-memory \"my-data-stream\" and sending the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:195
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"my-data-stream\")\n"
"    Publisher<Double> prices; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:204
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS) // <2>\n"
"    @SseElementType(\"text/plain\") // <3>\n"
"    public Publisher<Double> stream() { // <4>\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:206
msgid "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:207
msgid "Indicates that the content is sent using `Server Sent Events`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:208
msgid "Indicates that the data contained within the server sent events is of type `text/plain`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:209
msgid "Returns the stream (_Reactive Stream_)"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:210
#, no-wrap
msgid "Configuring the Kafka connector"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:214
msgid "We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:216
msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:218
msgid "The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:220
msgid "`generated-price` -> sink in which we write the prices"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:221
msgid "`prices` -> source in which we read the prices"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:228
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
"mp.messaging.outgoing.generated-price.topic=prices\n"
"mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:233
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka\n"
"mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer\n"
"mp.messaging.incoming.prices.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:236
msgid "More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:238
msgid "What about `my-data-stream`? This is an in-memory stream, not connected to a message broker."
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:240
#, no-wrap
msgid "What is \"mp.messaging.incoming.prices.health-readiness-enabled=false\"?"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:247
msgid "The `health-readiness-enabled` disables the readiness health check.  By default, it verifies that there is an active connection with the broker.  In our case, the connection only happens when we get the first consumer.  This is because the stream is consumed as an SSE, waiting lazily for the first connection to trigger the whole stream.  So, if you are running in an environment only routing traffic to containers that are _ready_ (such as Kubernetes), it would not send traffic to your application, which, as a consequence, will never connect to Kafka and pass the readiness check."
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:249
msgid "More details about health reporting is given in <<kafka-health-check>>."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:254
msgid "The previous configuration does not set the Kafka _bootstrap.servers_.  Quarkus starts a Kafka broker automatically and configures the application.  See xref:kafka-dev-services.adoc[Dev Services for Kafka] for more details."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:255
#, no-wrap
msgid "The HTML page"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:258
msgid "Final touch, the HTML page reading the converted prices using SSE."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:260
msgid "Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:268
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:276
#, no-wrap
msgid ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:291
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:294
msgid "Nothing spectacular here. On each received price, it updates the page."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:295
#, no-wrap
msgid "Get it running"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:298
msgid "You just need to run the application using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:302
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:305
msgid "Open `http://localhost:8080/prices.html` in your browser."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:306
#, no-wrap
msgid "Running in JVM or Native mode"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:310
msgid "When not running in dev or test mode, you will need to start your Kafka broker.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:314
#, no-wrap
msgid "version: '2'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:316
#, no-wrap
msgid "services:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:327
#, no-wrap
msgid ""
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:343
#, no-wrap
msgid ""
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:346
msgid "Once created, run `docker-compose up`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:348
msgid "This is a development cluster, do not use in production."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:350
msgid "You can build and run the application in JVM mode with:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:355
#, no-wrap
msgid ""
"./mvnw package\n"
"java -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:359
msgid "By default, the application tries to connect to a Kafka broker listening at `localhost:9092`.  You can configure the bootstrap server using: `java -Dkafka.bootstrap.servers=... -jar target/quarkus-app/quarkus-run.jar`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:361
msgid "You can build and run the native executable with:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:366
#, no-wrap
msgid ""
"./mvnw package -Pnative\n"
"./target/kafka-quickstart-1.0.0-SNAPSHOT-runner -Dkafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:368
#, no-wrap
msgid "Imperative usage"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:371
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:374
msgid "For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Outgoing` because your method has parameters."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:376
msgid "For this, you can use an `Emitter`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:381
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:387
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:390
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:392
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:399
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:403
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy."
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:405
#, no-wrap
msgid "Deprecation"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:408
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:410
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:411
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:412
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:414
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:417
#, no-wrap
msgid "Kafka Health Checks"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:421
msgid "Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:427
msgid "When using the `quarkus-kafka` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  That check requires an _admin connection_ with the Kafka broker.  This check is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:432
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides a _liveness_ and _readiness_ check.  The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka.  The _readiness_ check verifies that communication with Kafka is established.  For each channel, you can disable the checks using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:436
#, no-wrap
msgid "# Disable both liveness and readiness checks with `health-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:441
#, no-wrap
msgid ""
"# Incoming channel (receiving records form Kafka)\n"
"mp.messaging.incoming.your-channel.health-enabled=false\n"
"# Outgoing channel (writing records to Kafka)\n"
"mp.messaging.outgoing.your-channel.health-enabled=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:443
#, no-wrap
msgid "# Disable only the readiness check with `health-readiness-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:446
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.health-readiness-enabled=false\n"
"mp.messaging.outgoing.your-channel.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:449
msgid "You can configure the `bootstrap.servers` for each channel. Defaults is `kafka.bootstrap.servers`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:453
msgid "Reactive Messaging readiness check offers two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in metrics."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:456
msgid "Using the `health-readiness-topic-verification=true` attribute, you can also check the topics used by the application exist in the broker.  Note that, to achieve this, an _admin connection_ is required."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:457
#, no-wrap
msgid "JSON serialization"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:460
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:462
msgid "Imagine we have a `Fruit` pojo as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:466
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:469
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:472
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:478
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:481
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:487
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:496
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" stream.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:506
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:511
msgid "To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:513
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:515
#, no-wrap
msgid "Serializing via Jackson"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:518
msgid "First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:525
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:529
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson.  You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:532
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:536
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:538
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:545
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:548
msgid "Finally, configure your streams to use the Jackson serializer and deserializer."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:555
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:560
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:563
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo."
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:565
#, no-wrap
msgid "Serializing via JSON-B"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:568
msgid "First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:575
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:579
msgid "There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B.  You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:582
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:586
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:588
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:595
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:599
msgid "If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:601
msgid "Finally, configure your streams to use the JSON-B serializer and deserializer."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:608
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:613
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:616
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo."
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:617
#, no-wrap
msgid "Sending JSON Server-Sent Events (SSE)"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:621
msgid "If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:623
msgid "The following example shows how to use SSE from a Kafka topic source."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:638
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:641
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"fruit-out\") Publisher<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:650
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(MediaType.APPLICATION_JSON)\n"
"    public Publisher<Fruit> stream() {\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:652
#, no-wrap
msgid "Avro serialization"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:655
msgid "This is described in a dedicated guide: link:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro]."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:657
#, no-wrap
msgid "Serializer/deserializer autodetection"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:661
msgid "When using SmallRye Reactive Messaging with Kafka, Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:663
msgid "For example, if you declare"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:670
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Integer> generate() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:673
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:675
msgid "Similarly, if you declare"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:682
#, no-wrap
msgid ""
"@Incoming(\"my-kafka-records\")\n"
"public void consume(KafkaRecord<Long, byte[]> record) {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:685
msgid "and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:687
msgid "Finally, if you declare"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:693
#, no-wrap
msgid ""
"@Inject\n"
"@Channel(\"price-create\")\n"
"Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:696
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:698
msgid "The full set of types supported by the serializer/deserializer autodetection is:"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:700
msgid "`short` and `java.lang.Short`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:701
msgid "`int` and `java.lang.Integer`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:702
msgid "`long` and `java.lang.Long`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:703
msgid "`float` and `java.lang.Float`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:704
msgid "`double` and `java.lang.Double`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:705
msgid "`byte[]`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:706
msgid "`java.lang.String`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:707
msgid "`java.util.UUID`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:708
msgid "`java.nio.ByteBuffer`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:709
msgid "`org.apache.kafka.common.utils.Bytes`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:710
msgid "`io.vertx.core.buffer.Buffer`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:711
msgid "`io.vertx.core.json.JsonObject`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:712
msgid "`io.vertx.core.json.JsonArray`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:713
msgid "classes generated from Avro schemas, if Confluent or Apicurio _serde_ is present"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:714
msgid "see link:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio libraries"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:715
msgid "classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in <<jackson-serialization>>"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:716
msgid "it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:717
msgid "classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in <<jsonb-serialization>>"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:718
msgid "it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:721
msgid "In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:722
#, no-wrap
msgid "Blocking processing"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:726
msgid "You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:728
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:732
#, no-wrap
msgid "package org.acme.panache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:735
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:738
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:741
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:750
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Blocking\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:755
msgid "The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:759
msgid "There are 2 `@Blocking` annotations:"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:761
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:762
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:767
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:769
#, no-wrap
msgid "Testing a Kafka application"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:771
#, no-wrap
msgid "Testing without a broker"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:775
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:777
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:779
msgid "First, add the following dependency to your application:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:787
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:790
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:794
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:804
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");  // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"queue\");   // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:810
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:812
msgid "Switch the incoming channel \"orders\" (expecting messages from Kafka) to in-memory."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:813
msgid "Switch the outgoing channel \"queue\" (writing messages to Kafka) to in-memory."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:814
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:815
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:817
msgid "Create a Quarkus Test using the test resource created above:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:823
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:826
#, no-wrap
msgid ""
"    @Inject @Any\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:831
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> orders = connector.source(\"orders\"); // <2>\n"
"        InMemorySink<Beverage> queue = connector.sink(\"queue\");    // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:836
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:838
#, no-wrap
msgid "        orders.send(order);  // <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:840
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(queue::received, t -> t.size() == 1); // <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:847
#, no-wrap
msgid ""
"        Beverage queuedBeverage = queue.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:851
msgid "Inject the in-memory connector in your test class."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:852
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:853
msgid "Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:854
msgid "Use the `send` method to send a message to the `orders` channel. So, the application will process this message."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:855
msgid "Use the `received` method to check the messages produced by the application."
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:856
#, no-wrap
msgid "Starting Kafka in a test resource"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:860
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:864
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:866
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:872
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:878
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:880
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:881
#, no-wrap
msgid "Authenticating with OAuth"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:885
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:892
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:896
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:906
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:909
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:911
msgid "OAuth authentication works for both JVM and native modes."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:912
#, no-wrap
msgid "Using Snappy"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:915
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:919
#, no-wrap
msgid "mp.messaging.outgoing.fruit-out.compression.type=snappy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:923
msgid "In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:925
msgid "Uses GraalVM 21.+"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:926
msgid "Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:928
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:929
#, no-wrap
msgid "Configuration"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:933
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.8/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation].  The most important attributes are listed in the tables below:"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:934
#, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:937 upstream/_guides/kafka.adoc:1091
msgid "The following attributes are configured using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:941
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:944 upstream/_guides/kafka.adoc:1099
msgid "Some properties have aliases which can be configured globally:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:948 upstream/_guides/kafka.adoc:1103
#, no-wrap
msgid "kafka.bootstrap.servers=...\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:950
#, no-wrap
msgid "Incoming Attributes of the 'smallrye-kafka' connector"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:953 upstream/_guides/kafka.adoc:1108
#, no-wrap
msgid "Attribute (_alias_)"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:953 upstream/_guides/kafka.adoc:1108
#, no-wrap
msgid "Description"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:953 upstream/_guides/kafka.adoc:1108
#, no-wrap
msgid "Mandatory"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:955 upstream/_guides/kafka.adoc:1110
#, no-wrap
msgid "Default"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:957 upstream/_guides/kafka.adoc:1116
#, no-wrap
msgid ""
"*bootstrap.servers*\n"
"\n"
"_(kafka.bootstrap.servers)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:959 upstream/_guides/kafka.adoc:1118
#, no-wrap
msgid ""
"A comma-separated list of host:port to use for establishing the initial connection to the Kafka cluster.\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:959 upstream/_guides/kafka.adoc:963
#: upstream/_guides/kafka.adoc:967 upstream/_guides/kafka.adoc:971
#: upstream/_guides/kafka.adoc:975 upstream/_guides/kafka.adoc:979
#: upstream/_guides/kafka.adoc:983 upstream/_guides/kafka.adoc:987
#: upstream/_guides/kafka.adoc:991 upstream/_guides/kafka.adoc:995
#: upstream/_guides/kafka.adoc:999 upstream/_guides/kafka.adoc:1007
#: upstream/_guides/kafka.adoc:1016 upstream/_guides/kafka.adoc:1020
#: upstream/_guides/kafka.adoc:1024 upstream/_guides/kafka.adoc:1028
#: upstream/_guides/kafka.adoc:1032 upstream/_guides/kafka.adoc:1036
#: upstream/_guides/kafka.adoc:1040 upstream/_guides/kafka.adoc:1044
#: upstream/_guides/kafka.adoc:1048 upstream/_guides/kafka.adoc:1052
#: upstream/_guides/kafka.adoc:1056 upstream/_guides/kafka.adoc:1060
#: upstream/_guides/kafka.adoc:1064 upstream/_guides/kafka.adoc:1068
#: upstream/_guides/kafka.adoc:1072 upstream/_guides/kafka.adoc:1076
#: upstream/_guides/kafka.adoc:1080 upstream/_guides/kafka.adoc:1084
#: upstream/_guides/kafka.adoc:1112 upstream/_guides/kafka.adoc:1118
#: upstream/_guides/kafka.adoc:1122 upstream/_guides/kafka.adoc:1126
#: upstream/_guides/kafka.adoc:1130 upstream/_guides/kafka.adoc:1136
#: upstream/_guides/kafka.adoc:1142 upstream/_guides/kafka.adoc:1148
#: upstream/_guides/kafka.adoc:1152 upstream/_guides/kafka.adoc:1158
#: upstream/_guides/kafka.adoc:1164 upstream/_guides/kafka.adoc:1170
#: upstream/_guides/kafka.adoc:1174 upstream/_guides/kafka.adoc:1178
#: upstream/_guides/kafka.adoc:1182 upstream/_guides/kafka.adoc:1186
#: upstream/_guides/kafka.adoc:1190 upstream/_guides/kafka.adoc:1194
#: upstream/_guides/kafka.adoc:1198 upstream/_guides/kafka.adoc:1202
#: upstream/_guides/kafka.adoc:1206 upstream/_guides/kafka.adoc:1210
#: upstream/_guides/kafka.adoc:1214 upstream/_guides/kafka.adoc:1218
#: upstream/_guides/kafka.adoc:1226
#, no-wrap
msgid "false"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:961 upstream/_guides/kafka.adoc:1120
#, no-wrap
msgid "`localhost:9092`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:961 upstream/_guides/kafka.adoc:1212
#, no-wrap
msgid "*topic*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:963 upstream/_guides/kafka.adoc:1214
#, no-wrap
msgid ""
"The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:965 upstream/_guides/kafka.adoc:1172
#, no-wrap
msgid "*health-enabled*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:967 upstream/_guides/kafka.adoc:1174
#, no-wrap
msgid ""
"Whether health reporting is enabled (default) or disabled\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:969 upstream/_guides/kafka.adoc:973
#: upstream/_guides/kafka.adoc:985 upstream/_guides/kafka.adoc:989
#: upstream/_guides/kafka.adoc:1026 upstream/_guides/kafka.adoc:1086
#: upstream/_guides/kafka.adoc:1132 upstream/_guides/kafka.adoc:1150
#: upstream/_guides/kafka.adoc:1176 upstream/_guides/kafka.adoc:1180
#: upstream/_guides/kafka.adoc:1220 upstream/_guides/kafka.adoc:1228
#, no-wrap
msgid "`true`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:969 upstream/_guides/kafka.adoc:1176
#, no-wrap
msgid "*health-readiness-enabled*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:971 upstream/_guides/kafka.adoc:1178
#, no-wrap
msgid ""
"Whether readiness health reporting is enabled (default) or disabled\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:973 upstream/_guides/kafka.adoc:1184
#, no-wrap
msgid "*health-readiness-topic-verification*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:975 upstream/_guides/kafka.adoc:1186
#, no-wrap
msgid ""
"Whether the readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin connection.\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:977 upstream/_guides/kafka.adoc:997
#: upstream/_guides/kafka.adoc:1022 upstream/_guides/kafka.adoc:1038
#: upstream/_guides/kafka.adoc:1188 upstream/_guides/kafka.adoc:1204
#, no-wrap
msgid "`false`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:977 upstream/_guides/kafka.adoc:1180
#, no-wrap
msgid "*health-readiness-timeout*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:979 upstream/_guides/kafka.adoc:1182
#, no-wrap
msgid ""
"During the readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready.\n"
"\n"
"Type: _long_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:981 upstream/_guides/kafka.adoc:1184
#, no-wrap
msgid "`2000`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:981 upstream/_guides/kafka.adoc:1216
#, no-wrap
msgid "*tracing-enabled*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:983 upstream/_guides/kafka.adoc:1218
#, no-wrap
msgid ""
"Whether tracing is enabled (default) or disabled\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:985 upstream/_guides/kafka.adoc:1128
#, no-wrap
msgid "*cloud-events*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:987 upstream/_guides/kafka.adoc:1130
#, no-wrap
msgid ""
"Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:989
#, no-wrap
msgid "*topics*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:991
#, no-wrap
msgid ""
"A comma-separating list of topics to be consumed. Cannot be used with the `topic` or `pattern` properties\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:993
#, no-wrap
msgid "*pattern*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:995
#, no-wrap
msgid ""
"Indicate that the `topic` property is a regular expression. Must be used with the `topic` property. Cannot be used with the `topics` property\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:997
#, no-wrap
msgid "*key.deserializer*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:999
#, no-wrap
msgid ""
"The deserializer classname used to deserialize the record's key\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1001
#, no-wrap
msgid "`org.apache.kafka.common.serialization.StringDeserializer`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1001
#, no-wrap
msgid "*value.deserializer*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1003
#, no-wrap
msgid ""
"The deserializer classname used to deserialize the record's value\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1003 upstream/_guides/kafka.adoc:1222
#, no-wrap
msgid "true"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1005
#, no-wrap
msgid "*fetch.min.bytes*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1007
#, no-wrap
msgid ""
"The minimum amount of data the server should return for a fetch request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive.\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1009 upstream/_guides/kafka.adoc:1070
#: upstream/_guides/kafka.adoc:1114
#, no-wrap
msgid "`1`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1009
#, no-wrap
msgid "*group.id*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1016
#, no-wrap
msgid ""
"A unique string that identifies the consumer group the application belongs to.\n"
"\n"
"If not set, defaults to the application name as set by the `quarkus.application.name` configuration property.\n"
"\n"
"If that is not set either, a unique, generated id is used.\n"
"It is recommended to always define a `group.id`, the automatic generation is only a convenient feature for development.\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1018
#, no-wrap
msgid "*enable.auto.commit*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1020
#, no-wrap
msgid ""
"If enabled, consumer's offset will be periodically committed in the background by the underlying Kafka client, ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting and let Reactive Messaging handles the commit.\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1022
#, no-wrap
msgid "*retry*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1024
#, no-wrap
msgid ""
"Whether or not the connection to the broker is re-attempted in case of failure\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1026
#, no-wrap
msgid "*retry-attempts*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1028
#, no-wrap
msgid ""
"The maximum number of reconnection before failing. -1 means infinite retry\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1030 upstream/_guides/kafka.adoc:1208
#, no-wrap
msgid "`-1`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1030
#, no-wrap
msgid "*retry-max-wait*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1032
#, no-wrap
msgid ""
"The max delay (in seconds) between 2 reconnects\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1034
#, no-wrap
msgid "`30`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1034
#, no-wrap
msgid "*broadcast*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1036
#, no-wrap
msgid ""
"Whether the Kafka records should be dispatched to multiple consumer\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1038
#, no-wrap
msgid "*auto.offset.reset*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1040
#, no-wrap
msgid ""
"What to do when there is no initial offset in Kafka.Accepted values are earliest, latest and none\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1042
#, no-wrap
msgid "`latest`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1042
#, no-wrap
msgid "*failure-strategy*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1044
#, no-wrap
msgid ""
"Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `fail` (default), `ignore`, or `dead-letter-queue`\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1046
#, no-wrap
msgid "`fail`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1046
#, no-wrap
msgid "*commit-strategy*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1048
#, no-wrap
msgid ""
"Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `latest`, `ignore` or `throttled`. If `enable.auto.commit` is true then the default is `ignore` otherwise it is `throttled`\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1050
#, no-wrap
msgid "*throttled.unprocessed-record-max-age.ms*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1052
#, no-wrap
msgid ""
"While using the `throttled` commit-strategy, specify the max age in milliseconds that an unprocessed message can be before the connector is marked as unhealthy.\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1054
#, no-wrap
msgid "`60000`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1054
#, no-wrap
msgid "*dead-letter-queue.topic*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1056
#, no-wrap
msgid ""
"When the `failure-strategy` is set to `dead-letter-queue` indicates on which topic the record is sent. Defaults is `dead-letter-topic-$channel`\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1058
#, no-wrap
msgid "*dead-letter-queue.key.serializer*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1060
#, no-wrap
msgid ""
"When the `failure-strategy` is set to `dead-letter-queue` indicates the key serializer to use. If not set the serializer associated to the key deserializer is used\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1062
#, no-wrap
msgid "*dead-letter-queue.value.serializer*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1064
#, no-wrap
msgid ""
"When the `failure-strategy` is set to `dead-letter-queue` indicates the value serializer to use. If not set the serializer associated to the value deserializer is used\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1066
#, no-wrap
msgid "*partitions*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1068
#, no-wrap
msgid ""
"The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers. It should match the number of partition of the targeted topic\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1070
#, no-wrap
msgid "*consumer-rebalance-listener.name*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1072
#, no-wrap
msgid ""
"The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener`. If set, this rebalance listener is applied to the consumer.\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1074
#, no-wrap
msgid "*key-deserialization-failure-handler*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1076
#, no-wrap
msgid ""
"The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing keys are delegated to this handler which may provide a fallback value.\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1078
#, no-wrap
msgid "*value-deserialization-failure-handler*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1080
#, no-wrap
msgid ""
"The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing values are delegated to this handler which may provide a fallback value.\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1082
#, no-wrap
msgid "*graceful-shutdown*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1084
#, no-wrap
msgid ""
"Whether or not a graceful shutdown should be attempted when the application terminates.\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:1088
#, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1096
#, no-wrap
msgid "mp.messaging.outgoing.your-channel-name.attribute=value\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:1105
#, no-wrap
msgid "Outgoing Attributes of the 'smallrye-kafka' connector"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1110
#, no-wrap
msgid "*acks*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1112
#, no-wrap
msgid ""
"The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. Accepted values are: 0, 1, all\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1120
#, no-wrap
msgid "*buffer.memory*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1122
#, no-wrap
msgid ""
"The total bytes of memory the producer can use to buffer records waiting to be sent to the server.\n"
"\n"
"Type: _long_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1124
#, no-wrap
msgid "`33554432`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1124
#, no-wrap
msgid "*close-timeout*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1126
#, no-wrap
msgid ""
"The amount of milliseconds waiting for a graceful shutdown of the Kafka producer\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1128
#, no-wrap
msgid "`10000`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1134
#, no-wrap
msgid ""
"*cloud-events-data-content-type*\n"
"\n"
"_(cloud-events-default-data-content-type)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1136
#, no-wrap
msgid ""
"Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1140
#, no-wrap
msgid ""
"*cloud-events-data-schema*\n"
"\n"
"_(cloud-events-default-data-schema)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1142
#, no-wrap
msgid ""
"Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1146
#, no-wrap
msgid ""
"*cloud-events-insert-timestamp*\n"
"\n"
"_(cloud-events-default-timestamp)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1148
#, no-wrap
msgid ""
"Whether or not the connector should insert automatically the `time` attribute` into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1150
#, no-wrap
msgid "*cloud-events-mode*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1152
#, no-wrap
msgid ""
"The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1154
#, no-wrap
msgid "`binary`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1156
#, no-wrap
msgid ""
"*cloud-events-source*\n"
"\n"
"_(cloud-events-default-source)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1158
#, no-wrap
msgid ""
"Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1162
#, no-wrap
msgid ""
"*cloud-events-subject*\n"
"\n"
"_(cloud-events-default-subject)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1164
#, no-wrap
msgid ""
"Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1168
#, no-wrap
msgid ""
"*cloud-events-type*\n"
"\n"
"_(cloud-events-default-type)_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1170
#, no-wrap
msgid ""
"Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1188
#, no-wrap
msgid "*key*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1190
#, no-wrap
msgid ""
"A key to used when writing the record\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1192
#, no-wrap
msgid "*key.serializer*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1194
#, no-wrap
msgid ""
"The serializer classname used to serialize the record's key\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1196
#, no-wrap
msgid "`org.apache.kafka.common.serialization.StringSerializer`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1196
#, no-wrap
msgid "*max-inflight-messages*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1198
#, no-wrap
msgid ""
"The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit\n"
"\n"
"Type: _long_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1200
#, no-wrap
msgid "`1024`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1200
#, no-wrap
msgid "*merge*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1202
#, no-wrap
msgid ""
"Whether the connector should allow multiple upstreams\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1204
#, no-wrap
msgid "*partition*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1206
#, no-wrap
msgid ""
"The target partition id. -1 to let the client determine the partition\n"
"\n"
"Type: _int_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1208
#, no-wrap
msgid "*retries*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1210
#, no-wrap
msgid ""
"Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error.\n"
"\n"
"Type: _long_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1212
#, no-wrap
msgid "`2147483647`"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1220
#, no-wrap
msgid "*value.serializer*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1222
#, no-wrap
msgid ""
"The serializer classname used to serialize the payload\n"
"\n"
"Type: _string_"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1224
#, no-wrap
msgid "*waitForWriteCompletion*"
msgstr ""

#. type: Table
#: upstream/_guides/kafka.adoc:1226
#, no-wrap
msgid ""
"Whether the client waits for Kafka to acknowledge the written record before acknowledging the message\n"
"\n"
"Type: _boolean_"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:1230
#, no-wrap
msgid "Going further"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1234
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1235
msgid "If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr ""
