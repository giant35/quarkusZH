# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-02-24 01:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/native-reference.adoc:6
#, no-wrap
msgid "Native Reference Guide"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:16
msgid "This guide is a companion to the xref:building-native-image.adoc[Building a Native Executable], xref:native-and-ssl.adoc[Using SSL With Native Images], and xref:writing-native-applications-tips.adoc[Writing Native Applications], guides.  It provides further details to debugging issues in Quarkus native executables that might arise during development or production."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:18
msgid "This reference guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide]."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:19
#, no-wrap
msgid "Requirements and Assumptions"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:25
msgid "Debugging Quarkus native executables experience is best done within a Linux environment.  Root access is not needed except to install packages required to run some debug steps, or to enable `perf` to gather events at the kernel.  Debugging in macOS and Windows environments also works in a container environment (see <<macwindows,FAQ entry>>)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:27
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:34
#, no-wrap
msgid ""
"# dnf (rpm-based)\n"
"sudo dnf install binutils gdb perf perl-open\n"
"# Debian-based distributions:\n"
"sudo apt install binutils gdb perf\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:37
msgid "Aside from system level packages, you'll need:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:39
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:40
msgid "Apache Maven {maven-version}"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:41
msgid "A working container runtime (Docker, podman)"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:42
msgid "The code of the application developed in the xref:getting-started.adoc[Getting Started Guide]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:45
msgid "Finally, this guide assumes the use of the link:https://github.com/graalvm/mandrel[Mandrel distribution] of GraalVM for building native executables, and these are built within a container so there is no need for installing Mandrel on the host."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:46
#, no-wrap
msgid "First Debugging Steps"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:49
msgid "As a first step, build the native executable for the application:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:54
#: upstream/_versions/main/guides/native-reference.adoc:409
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:57
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:61
#: upstream/_versions/main/guides/native-reference.adoc:416
#, no-wrap
msgid "./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:64
msgid "In another:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:68
#, no-wrap
msgid "curl http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:71
msgid "We can obtain basic extra information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:77
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:80
msgid "Executing that will produce additional output lines like this:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:87
#, no-wrap
msgid ""
"...\n"
"# Printing compilation-target information to: /project/reports/target_info_20211115_094828.txt\n"
"…\n"
"# Printing native-library information to: /project/reports/native_library_info_20211115_094841.txt\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:92
msgid "The target info file contains information such as the target platform, the toolchain used to compile the executable, and the C library in use:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:104
#, no-wrap
msgid ""
"$ cat target/*/reports/target_info_*.txt\n"
"Building image for target platform: org.graalvm.nativeimage.Platform$LINUX_AMD64\n"
"Using native toolchain:\n"
"   Name: GNU project C and C++ compiler (gcc)\n"
"   Vendor: redhat\n"
"   Version: 8.5.0\n"
"   Target architecture: x86_64\n"
"   Path: /usr/bin/gcc\n"
"Using CLibrary: com.oracle.svm.core.posix.linux.libc.GLib\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:107
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:122
#, no-wrap
msgid ""
"$ cat target/*/reports/native_library_info_*.txt\n"
"Static libraries:\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/liblibchelper.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libextnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnio.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libjava.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libfdlibm.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libsunec.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libzip.a\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/libjvm.a\n"
"Other libraries: stdc++,pthread,dl,z,rt\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:127
msgid "Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.  This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production, or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:133
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=--verbose\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:136
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:139
msgid "The first is a very short Java process that does some basic validation and builds the arguments for the second process (in a stock GraalVM distribution, this is executed as native code)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:142
msgid "The second Java process is where the main part of the native executable production happens.  The `--verbose` option shows the actual Java process executed.  You could take the output and run it yourself."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:144
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:150
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info,--verbose\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:156
msgid "Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol, it needs to be escaped to be processed correcly, e.g. `\\\\,`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:159
msgid "Given a native executable, various Linux tools can be used to inspect it."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:161
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:165
#, no-wrap
msgid "ldd ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:168
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:172
#, no-wrap
msgid "strings ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep Hello\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:175
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:179
#, no-wrap
msgid "strings ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep core.VM\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:183
msgid "Finally, using `readelf` we can inspect different sections of the binary.  For example, we can see how the heap and text sections take most of binary:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:187
#, no-wrap
msgid "readelf -SW ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:189
#, no-wrap
msgid "Native Reports"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:192
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:198
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.enable-reports\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:202
msgid "The reports will be created under `target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.  These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:203
#, no-wrap
msgid "Call Tree Reports"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:208
msgid "`call_tree` text file report is one of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.  This is useful for getting an approximation on why a method/class is included in the binary.  However, the text format makes it very difficult to read and can take up a lot of space."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:213
msgid "Since Mandrel 21.3.0.0-Final, the call tree is also reported as a group of CSV files.  These can in turn be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  Let’s see this in action."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:215
msgid "First, start a Neo4j instance:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:226
#, no-wrap
msgid ""
"export NEO_PASS=...\n"
"docker run \\\n"
"  --detach \\\n"
"  --rm \\\n"
"  --name testneo4j \\\n"
"  -p7474:7474 -p7687:7687 \\\n"
"  --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"  neo4j:latest\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:231
msgid "Once the container is running, you can access the Neo4j browser via http://localhost:7474.  Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:234
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:239
#, no-wrap
msgid ""
"CREATE CONSTRAINT unique_vm_id ON (v:VM) ASSERT v.vmId IS UNIQUE;\n"
"CREATE CONSTRAINT unique_method_id ON (m:Method) ASSERT m.methodId IS UNIQUE;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:243
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_vm.csv' AS row\n"
"MERGE (v:VM {vmId: row.Id, name: row.Name})\n"
"RETURN count(v);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:247
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:251
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_virtual_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:257
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_entry_points.csv' AS row\n"
"MATCH (m:Method {methodId: row.Id})\n"
"MATCH (v:VM {vmId: '0'})\n"
"MERGE (v)-[:ENTRY]->(m)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:263
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_direct_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:DIRECT {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:269
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_override_by_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:OVERRIDEN_BY]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:275
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_virtual_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:VIRTUAL {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:278
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:280
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:286
#, no-wrap
msgid ""
"docker cp \\\n"
"    target/*-native-image-source-jar/reports \\\n"
"    testneo4j:/var/lib/neo4j/import\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:288
#, no-wrap
msgid "docker cp import.cypher testneo4j:/var/lib/neo4j\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:291
msgid "After copying all the files, invoke the import script:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:295
#, no-wrap
msgid "docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:299
msgid "Once the import completes (shouldn't take more than a couple of minutes), go to the link:http://localhost:7474[Neo4j browser], and you'll be able to observe a small summary of the data in the graph:"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:300
#, no-wrap
msgid "Neo4j database information after import"
msgstr ""

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:300
#, no-wrap
msgid "native-reference-neo4j-db-info.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:305
msgid "The data above shows that there are ~60000 methods, and just over ~200000 edges between them.  The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.  Typically, you’d start by looking for a given method:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:309
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:312
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:316
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:323
msgid "Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is: why does this method get included in the call tree? To do that, start from the method and look for incoming connections at a given depth, starting from the end method.  For example, methods that directly call a method can be located via:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:327
#, no-wrap
msgid "match (m:Method) <- [*1..1] - (o) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:331
msgid "Then you can look for direct calls at depth of 2, so you’d search for methods that call methods that call into the target method:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:335
#, no-wrap
msgid "match (m:Method) <- [*1..2] - (o) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:341
msgid "You can continue going up layers, but unfortunately if you reach a depth with too many nodes, the Neo4j browser will be unable to visualize them all.  When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:346
#, no-wrap
msgid ""
"docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"  \"match (m:Method) <- [*1..10] - (o) where m.name = 'hello' return *\"\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:348
#, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:352
msgid "`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application, e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:353
#, no-wrap
msgid "Further Reports"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:357
msgid "Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.  These are called expert options and you can learn more about them by running:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:361
#, no-wrap
msgid "docker run quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} --expert-options-all\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:364
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:365
#, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:372
msgid "Quarkus instructs Mandrel to initialize as much as possible at build time, so that runtime startup can be as fast as possible.  This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.  Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization, thus making Quarkus more reliable."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:376
msgid "The most common examples of build-time initialized code are static variables and blocks.  Although Mandrel executes those at run-time by default, Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:380
msgid "This means that any static variables initialized inline, or initialized in a static block, will keep the same value even if the application is restarted.  This is a different behaviour compared to what would happen if executed as Java."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:383
msgid "To see this in action with a very basic example, modify the `GreetingResource` in the application to look like this:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:388
#: upstream/_versions/main/guides/native-reference.adoc:487
#: upstream/_versions/main/guides/native-reference.adoc:585
#: upstream/_versions/main/guides/native-reference.adoc:755
#: upstream/_versions/main/guides/native-reference.adoc:886
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:390
#, no-wrap
msgid "    static long firstAccess;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:394
#, no-wrap
msgid ""
"    static {\n"
"        firstAccess = System.currentTimeMillis();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:401
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello RESTEasy, first accessed: \" + firstAccess;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:404
msgid "Rebuild the binary using:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:412
msgid "Run the application in one terminal:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:419
msgid "Send a `GET` request multiple times from another terminal:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:423
#, no-wrap
msgid "curl http://localhost:8080/hello # run this multiple times\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:428
msgid "to see how the current time has been baked into the binary.  This time was calculated when the binary was being built, hence application restarts have no effect."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:432
msgid "In some situations, built time initializations can lead to errors when building native executables.  One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.  To see this in action, add this example to the same package as the REST resource:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:436
#: upstream/_versions/main/guides/native-reference.adoc:740
#: upstream/_versions/main/guides/native-reference.adoc:875
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:443
#, no-wrap
msgid ""
"import javax.crypto.Cipher;\n"
"import javax.crypto.NoSuchPaddingException;\n"
"import java.nio.charset.StandardCharsets;\n"
"import java.security.KeyPair;\n"
"import java.security.KeyPairGenerator;\n"
"import java.security.NoSuchAlgorithmException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:447
#, no-wrap
msgid ""
"class AsymmetricEncryption {\n"
"    static final KeyPairGenerator KEY_PAIR_GEN;\n"
"    static final Cipher CIPHER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:452
#, no-wrap
msgid ""
"    static {\n"
"        try {\n"
"            KEY_PAIR_GEN = KeyPairGenerator.getInstance(\"RSA\");\n"
"            KEY_PAIR_GEN.initialize(1024);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:458
#, no-wrap
msgid ""
"            CIPHER = Cipher.getInstance(\"RSA\");\n"
"        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:462
#, no-wrap
msgid ""
"    static String encryptDecrypt(String msg) {\n"
"        try {\n"
"            KeyPair keyPair = KEY_PAIR_GEN.generateKeyPair();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:464
#, no-wrap
msgid "            byte[] text = msg.getBytes(StandardCharsets.UTF_8);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:468
#, no-wrap
msgid ""
"            // Encrypt with private key\n"
"            CIPHER.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());\n"
"            byte[] encrypted = CIPHER.doFinal(text);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:472
#, no-wrap
msgid ""
"            // Decrypt with public key\n"
"            CIPHER.init(Cipher.DECRYPT_MODE, keyPair.getPublic());\n"
"            byte[] unencrypted = CIPHER.doFinal(encrypted);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:479
#, no-wrap
msgid ""
"            return new String(unencrypted, StandardCharsets.UTF_8);\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:482
msgid "Then, replace the `GreetingResource` code for the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:494
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return AsymmetricEncryption.encryptDecrypt(\"Hello RESTEasy\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:497
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:521
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"    reading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"   \t constant java.security.KeyPairGenerator$Delegate@491aefd7 reached by\n"
"    scanning method org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"Call path from entry point to org.acme.AsymmetricEncryption.encryptDecrypt(String):\n"
"    at org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"    at org.acme.GreetingResource.hello(GreetingResource.java:14)\n"
"    at com.oracle.svm.reflect.GreetingResource_hello_116f4f3295793f67a71f7bce0a46ea6d6055545a_85.invoke(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.reflect.Method.invoke(Method.java:566)\n"
"    at org.jboss.resteasy.core.ContextParameterInjector$GenericDelegatingProxy.invoke(ContextParameterInjector.java:166)\n"
"    at com.sun.proxy.$Proxy193.toString(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.String.valueOf(String.java:2951)\n"
"    at java.base@11.0.12/java.lang.StringBuilder.append(StringBuilder.java:168)\n"
"    at java.base@11.0.12/java.net.Proxy.<init>(Proxy.java:95)\n"
"    at com.oracle.svm.jni.JNIJavaCallWrappers.jniInvoke_VARARGS:Ljava_net_Proxy_2_0002e_0003cinit_0003e_00028Ljava_net_Proxy_00024Type_2Ljava_net_SocketAddress_2_00029V(generated:0)\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:527
msgid "So, what the message above is telling us is that our application references a `KeyPairGenerator$Delegate` instance which contains a `SecureRandom` instance.  This is not desirable because something that's supposed to be random is no longer so, because the seed is baked in the image.  As a next step, we'd like to know what is causing such instances to be left in the heap image."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:529
msgid "We could try again adding option to track object instantiation:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:559
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=\"--trace-object-instantiation=java.security.SecureRandom\"\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
"\t at java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"    at sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"    at sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"    at com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"    reading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"   \t constant java.security.KeyPairGenerator$Delegate@7725180c reached by\n"
"    scanning method org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"Call path from entry point to org.acme.AsymmetricEncryption.encryptDecrypt(String):\n"
"    at org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"    at org.acme.GreetingResource.hello(GreetingResource.java:14)\n"
"    at com.oracle.svm.reflect.GreetingResource_hello_116f4f3295793f67a71f7bce0a46ea6d6055545a_54.invoke(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.reflect.Method.invoke(Method.java:566)\n"
"    at org.jboss.resteasy.core.ContextParameterInjector$GenericDelegatingProxy.invoke(ContextParameterInjector.java:166)\n"
"    at com.sun.proxy.$Proxy193.toString(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.String.valueOf(String.java:2951)\n"
"    at java.base@11.0.12/java.lang.StringBuilder.append(StringBuilder.java:168)\n"
"    at java.base@11.0.12/java.net.Proxy.<init>(Proxy.java:95)\n"
"    at com.oracle.svm.jni.JNIJavaCallWrappers.jniInvoke_VARARGS:Ljava_net_Proxy_2_0002e_0003cinit_0003e_00028Ljava_net_Proxy_00024Type_2Ljava_net_SocketAddress_2_00029V(generated:0)\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:566
msgid "What does `DnsClient` have to do with our example? The key is in what happens inside `KeyPairGenerator.initialize()` method call.  It uses `JCAUtil.getSecureRandom()` which is why this is problematic, but sometimes the tracing options can show some stack traces that do not represent what happens in reality.  The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:568
msgid "Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:570
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:571
#, no-wrap
msgid "Profile Runtime Behaviour"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:573
#, no-wrap
msgid "Single Thread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:577
msgid "In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.  Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:580
msgid "Replace the GreetingResource implementation with the following code (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:591
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        sb.append(new char[1_000_000]);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:596
#, no-wrap
msgid ""
"        do {\n"
"            sb.append(12345);\n"
"            sb.delete(0, 5);\n"
"        } while (Thread.currentThread().isAlive());\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:600
#, no-wrap
msgid ""
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:603
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:612
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
"...\n"
"$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/hello # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:617
msgid "However, the question we’re trying to answer here is: what would be the bottleneck of such code? Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:621
msgid "Since we're dealing with a linux native executable, we can use tools like `perf` directly.  To use `perf`, you either have to be an administrator, or you have to set:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:625
#, no-wrap
msgid "echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:628
msgid "Then, we execute:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:632
#: upstream/_versions/main/guides/native-reference.adoc:1435
#, no-wrap
msgid "perf record -F 1009 -g -a ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:635
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:639
#, no-wrap
msgid "curl http://localhost:8080/hello # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:648
msgid "After a few seconds, halt the `perf record` process.  This will generate a `perf.data` file.  We could use `perf report` to inspect the perf data, but you can often get a better picture showing that data as a flame graph.  To generate flame graphs, checkout the https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository] locally and export its location via the `FG_HOME` environment variable, e.g."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:653
#, no-wrap
msgid ""
"export FG_HOME=/tmp/FlameGraph\n"
"git clone https://github.com/brendangregg/FlameGraph ${FG_HOME}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:656
msgid "Then, generate a flame graph using the data captured via `perf record`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:661
#, no-wrap
msgid ""
"$ perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl > out.perf-folded\n"
"$ ${FG_HOME}/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:665
msgid "The flame graph is an svg file that a web browser, such as Firefox, can easily display.  After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:666
#, no-wrap
msgid "Perf flamegraph without symbols"
msgstr ""

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:666
#, no-wrap
msgid "native-reference-perf-flamegraph-no-symbols.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:674
msgid "We see a big majority of time spent in what is supposed to be our main, but we see no trace of the `GreetingResource` class, nor the `StringBuilder` class we're calling.  We should look at the symbol table of the binary: can we find symbols for our class and `StringBuilder`? We need those in order to get meaningful data:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:679
#, no-wrap
msgid ""
"objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep GreetingResource\n"
"[no output]\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:682
#, no-wrap
msgid ""
"objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"[no output]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:688
msgid "None of those really show anything.  This is why we don't see any call graphs in the flame graphs.  This is a deliberate decision that native-image makes.  By default, it removes symbols from the binary."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:691
msgid "To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.  On top of that, enable DWARF debug info so that the stack traces can be populated with that information:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:698
#: upstream/_versions/main/guides/native-reference.adoc:812
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:702
msgid "Inspect the native executable with `objdump`, and see how the symbols are now present:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:706
#, no-wrap
msgid "objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:710
msgid "Then, run the executable through perf, *indicating that the call graph is dwarf*:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:715
#: upstream/_versions/main/guides/native-reference.adoc:820
#, no-wrap
msgid ""
"perf record -F 1009 --call-graph dwarf -a \\\n"
"  ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:718
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:723
#: upstream/_versions/main/guides/native-reference.adoc:828
#, no-wrap
msgid ""
"perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl > out.perf-folded\n"
"${FG_HOME}/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:728
msgid "The flamegraph now shows where the bottleneck is.  It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.  The issue is that 1 million characters need to be shifted in very small increments:"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:729
#, no-wrap
msgid "Perf flamegraph with symbols"
msgstr ""

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:729
#, no-wrap
msgid "native-reference-perf-flamegraph-symbols.png"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:731
#, no-wrap
msgid "Multi-Thread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:736
msgid "Multi-threaded programs might require special attention when trying to understand their runtime behaviour.  To demonstrate this, replace the `GreetingResource` code for the following (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:752
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.net.InetSocketAddress;\n"
"import java.nio.ByteBuffer;\n"
"import java.nio.channels.DatagramChannel;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ThreadFactory;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:762
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() throws Exception {\n"
"        sendMulticasts();\n"
"        return \"Complete\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:767
#, no-wrap
msgid ""
"    static void sendMulticasts() throws Exception {\n"
"        DatagramChannel ch = DatagramChannel.open();\n"
"        ch.bind(new InetSocketAddress(5555));\n"
"        ch.configureBlocking(false);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:776
#, no-wrap
msgid ""
"        ExecutorService pool =\n"
"        Executors.newCachedThreadPool(new ShortNameThreadFactory());\n"
"        for (int i = 0; i < 10; i++)\n"
"        {\n"
"            pool.submit(() -> {\n"
"                final ByteBuffer buf = ByteBuffer.allocateDirect(1000);\n"
"                final InetSocketAddress remoteAddr =\n"
"                        new InetSocketAddress(\"127.0.0.1\", 5556);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:784
#, no-wrap
msgid ""
"                while (true)\n"
"                {\n"
"                    buf.clear();\n"
"                    ch.send(buf, remoteAddr);\n"
"                }\n"
"            });\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:787
#, no-wrap
msgid ""
"        System.out.println(\"Warming up...\");\n"
"        Thread.sleep(3000);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:791
#, no-wrap
msgid ""
"        System.out.println(\"Benchmarking...\");\n"
"        Thread.sleep(5000);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:793
#, no-wrap
msgid "    private static final class ShortNameThreadFactory implements ThreadFactory {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:796
#, no-wrap
msgid ""
"        private final AtomicInteger threadNumber = new AtomicInteger(1);\n"
"        private final String namePrefix = \"thread-\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:802
#, no-wrap
msgid ""
"        public Thread newThread(Runnable r) {\n"
"            return new Thread(r, namePrefix + threadNumber.getAndIncrement());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:805
msgid "Build the native executable with debug info:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:815
msgid "Run it through `perf`:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:823
msgid "Make and open a flamegraph:"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:830
#, no-wrap
msgid "Muti-thread perf flamegraph with separate threads"
msgstr ""

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:830
#, no-wrap
msgid "native-reference-multi-flamegraph-separate-threads.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:834
msgid "The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.  This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:837
msgid "This is happening because from a `perf` perspective, each thread is a different command.  We can see that if we inspect `perf report`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:847
#, no-wrap
msgid ""
"perf report --stdio\n"
"# Children      Self  Command          Shared Object       Symbol\n"
"...\n"
"    11.07%     0.02%  thread-9         code-with-quarkus-1.0.0-SNAPSHOT-runner  [.]\n"
"...\n"
"     7.44%     0.00%  thread-6         code-with-quarkus-1.0.0-SNAPSHOT-runner  [.]\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:851
msgid "This can be worked around by applying some modifications to the perf output, in order to make all threads have the same name. E.g."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:857
#, no-wrap
msgid ""
"perf script | sed -E \"s/thread-[0-9]*/thread/\" \\\n"
"    | ${FG_HOME}/stackcollapse-perf.pl > out.perf-folded\n"
"${FG_HOME}/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:859
#, no-wrap
msgid "Muti-thread perf flamegraph with joined threads"
msgstr ""

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:859
#, no-wrap
msgid "native-reference-multi-flamegraph-joined-threads.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:863
msgid "When you open the flamegraph, you will see all threads' work collapsed into a single area.  Then, you can clearly see that there's some locking that could affect performance."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:864
#, no-wrap
msgid "Debugging Native Crashes"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:871
msgid "One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers, instead we need to debug them using `gdb`, the GNU Project debugger.  To demonstrate how to do this, we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/hello.  To achieve this, replace the `GreetingResource` code with the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:877
#, no-wrap
msgid "import sun.misc.Unsafe;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:883
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.lang.reflect.Field;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:902
#, no-wrap
msgid ""
"\t@GET\n"
"\t@Produces(MediaType.TEXT_PLAIN)\n"
"\tpublic String hello() {\n"
"    \tField theUnsafe = null;\n"
"    \ttry {\n"
"        \ttheUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n"
"        \ttheUnsafe.setAccessible(true);\n"
"        \tUnsafe unsafe = (Unsafe) theUnsafe.get(null);\n"
"        \tunsafe.copyMemory(0, 128, 256);\n"
"    \t} catch (NoSuchFieldException | IllegalAccessException e) {\n"
"        \te.printStackTrace();\n"
"    \t}\n"
"    \treturn \"Never happens\";\n"
"\t}\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:906
msgid "This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.  To verify this compile and run the example application:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:915
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
"...\n"
"./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"curl http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:918
msgid "This will result in the following output:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:929
#, no-wrap
msgid ""
"$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2021-06-24 18:14:22,102 INFO  [io.quarkus] (main) code-with-quarkus 1.0.0-SNAPSHOT native (powered by Quarkus 2.2.3.Final) started in 0.026s. Listening on: http://0.0.0.0:8080\n"
"2021-06-24 18:14:22,102 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2021-06-24 18:14:22,102 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:931
#, no-wrap
msgid "[ [ SubstrateSegfaultHandler caught a segfault. ] ]\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:933
#, no-wrap
msgid "...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:938
msgid "Now let’s try to debug the segmentation fault using `gdb`.  We will start our application in `gdb` and execute `run`, then we will try to access http://localhost:8080/hello."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:949
#, no-wrap
msgid ""
"gdb ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"Reading symbols from ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner...\n"
"(No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"(gdb) run\n"
"Starting program: /home/zakkak/tmp/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"curl http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:952
#: upstream/_versions/main/guides/native-reference.adoc:999
msgid "This will result in the following message in `gdb`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:959
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-1\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to LWP 693675]\n"
"0x0000000000407380 in ?? ()\n"
"Missing separate debuginfos, use: dnf debuginfo-install glibc-2.33-15.fc34.x86_64 sssd-client-2.5.0-2.fc34.x86_64 zlib-1.2.11-26.fc34.x86_64\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:962
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:973
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  0x0000000000418b5e in ?? ()\n"
"#1  0x00007ffff6f2d328 in ?? ()\n"
"#2  0x0000000000418a04 in ?? ()\n"
"#3  0x00007ffff44062a0 in ?? ()\n"
"#4  0x00000000010c3dd3 in ?? ()\n"
"#5  0x0000000000000100 in ?? ()\n"
"#6  0x0000000000000000 in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:978
msgid "This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`, so `gdb` cannot find debugging symbols for our native executable, as indicated by the \"_No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:981
msgid "Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.  On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:996
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-OmitInlinedMethodDebugLineInfo\n"
"...\n"
"$ gdb ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"Reading symbols from ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner...\n"
"Reading symbols from /home/zakkak/tmp/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner.debug...\n"
"(gdb) run\n"
"Starting program: /home/zakkak/tmp/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/hello\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1007
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fffeffff640 (LWP 362984)]\n"
"com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) ()\n"
"\tat com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"169    com/oracle/svm/core/UnmanagedMemoryUtil.java: No such file or directory.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1011
msgid "We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.  We can also get a backtrace of the call graph that led us to this state:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1024
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"#1  0x00000000011aff54 in com.oracle.svm.core.UnmanagedMemoryUtil::copyBackward () at com/oracle/svm/core/UnmanagedMemoryUtil.java:110\n"
"#2  com.oracle.svm.core.UnmanagedMemoryUtil::copy () at com/oracle/svm/core/UnmanagedMemoryUtil.java:67\n"
"#3  com.oracle.svm.core.JavaMemoryUtil::unsafeCopyMemory () at com/oracle/svm/core/JavaMemoryUtil.java:276\n"
"#4  jdk.internal.misc.Unsafe::copyMemory0 () at com/oracle/svm/core/jdk/SunMiscSubstitutions.java:125\n"
"#5  jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:788\n"
"#6  jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:799\n"
"#7  sun.misc.Unsafe::copyMemory () at sun/misc/Unsafe.java:585\n"
"#8  org.acme.GreetingResource::hello(void) () at org/acme/GreetingResource.java:22\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1027
msgid "Similarly, we can get a backtrace of the call graph of other threads."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1029
msgid "First, we can list the available threads with:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1075
#, no-wrap
msgid ""
"(gdb) info threads\n"
"  Id   Target Id                                             Frame \n"
"  1    Thread 0x7ffff7a58d00 (LWP 1028851) \"getting-started\" __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc)\n"
"    at futex-internal.c:57\n"
"  2    Thread 0x7ffff62ff640 (LWP 1028852) \"gnal Dispatcher\" __futex_abstimed_wait_common64 (private=<optimized out>, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2c8d3a0)\n"
"    at futex-internal.c:57\n"
"* 4    Thread 0x7fffeffff640 (LWP 1028854) \"ecutor-thread-0\" com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"  5    Thread 0x7fffef7fe640 (LWP 1028855) \"-thread-checker\" __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x7fffef7fdba0, op=137, expected=0, futex_word=0x7fffe4000e68)\n"
"    at futex-internal.c:57\n"
"  6    Thread 0x7fffeebff640 (LWP 1028856) \"ntloop-thread-0\" 0x00007ffff7c64c2e in epoll_wait (epfd=11, events=0x2ca6890, maxevents=1024, timeout=1800000)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  7    Thread 0x7fffee1ff640 (LWP 1028857) \"ntloop-thread-1\" 0x00007ffff7c64c2e in epoll_wait (epfd=14, events=0x2ca98a0, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  8    Thread 0x7fffed9fe640 (LWP 1028858) \"ntloop-thread-2\" 0x00007ffff7c64c2e in epoll_wait (epfd=17, events=0x2cac8b0, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  9    Thread 0x7fffecfff640 (LWP 1028859) \"ntloop-thread-3\" 0x00007ffff7c64c2e in epoll_wait (epfd=20, events=0x2caf8c0, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  10   Thread 0x7fffd3fff640 (LWP 1028860) \"ntloop-thread-4\" 0x00007ffff7c64c2e in epoll_wait (epfd=23, events=0x2cb28d0, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  11   Thread 0x7fffcbfff640 (LWP 1028861) \"ntloop-thread-5\" 0x00007ffff7c64c2e in epoll_wait (epfd=26, events=0x2cb58e0, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  12   Thread 0x7fffd37fe640 (LWP 1028862) \"ntloop-thread-6\" 0x00007ffff7c64c2e in epoll_wait (epfd=29, events=0x2cb88f0, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  13   Thread 0x7fffd2ffd640 (LWP 1028863) \"ntloop-thread-7\" 0x00007ffff7c64c2e in epoll_wait (epfd=32, events=0x2cbb900, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  14   Thread 0x7fffd25ff640 (LWP 1028864) \"ceptor-thread-0\" 0x00007ffff7c64c2e in epoll_wait (epfd=56, events=0x2cd3980, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  15   Thread 0x7fffd1bff640 (LWP 1028865) \"ntloop-thread-8\" 0x00007ffff7c64c2e in epoll_wait (epfd=35, events=0x2cbe910, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  16   Thread 0x7fffd11ff640 (LWP 1028866) \"ntloop-thread-9\" 0x00007ffff7c64c2e in epoll_wait (epfd=38, events=0x2cc1920, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  17   Thread 0x7fffcb7fe640 (LWP 1028867) \"tloop-thread-10\" 0x00007ffff7c64c2e in epoll_wait (epfd=41, events=0x2cc4930, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  18   Thread 0x7fffcaffd640 (LWP 1028868) \"tloop-thread-11\" 0x00007ffff7c64c2e in epoll_wait (epfd=44, events=0x2cc7940, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  19   Thread 0x7fffca7fc640 (LWP 1028869) \"tloop-thread-12\" 0x00007ffff7c64c2e in epoll_wait (epfd=47, events=0x2cca950, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  20   Thread 0x7fffc9ffb640 (LWP 1028870) \"tloop-thread-13\" 0x00007ffff7c64c2e in epoll_wait (epfd=50, events=0x2ccd960, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  21   Thread 0x7fffc97fa640 (LWP 1028871) \"tloop-thread-14\" 0x00007ffff7c64c2e in epoll_wait (epfd=53, events=0x2cd0970, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"  22   Thread 0x7fffc8dff640 (LWP 1028872) \"tloop-thread-15\" 0x00007ffff7c64c2e in epoll_wait (epfd=8, events=0x2ca3880, maxevents=1024, timeout=-1)\n"
"    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1078
msgid "select the thread we want to inspect, e.g. thread 1:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1085
#, no-wrap
msgid ""
"(gdb) thread 1\n"
"[Switching to thread 1 (Thread 0x7ffff7a58d00 (LWP 1028851))]\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"57\t    return INTERNAL_SYSCALL_CANCEL (futex_time64, futex_word, op, expected,\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1088
msgid "and, finally, print the stack trace:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1116
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"#1  __futex_abstimed_wait_common (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=0, \n"
"    cancel=cancel@entry=true) at futex-internal.c:87\n"
"#2  0x00007ffff7bdd79f in __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0, \n"
"    private=private@entry=0) at futex-internal.c:139\n"
"#3  0x00007ffff7bdfeb0 in __pthread_cond_wait_common (abstime=0x0, clockid=0, mutex=0x2ca07b0, cond=0x2cd7ab0) at pthread_cond_wait.c:504\n"
"#4  ___pthread_cond_wait (cond=0x2cd7ab0, mutex=0x2ca07b0) at pthread_cond_wait.c:619\n"
"#5  0x00000000004e2014 in com.oracle.svm.core.posix.headers.Pthread::pthread_cond_wait () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#6  com.oracle.svm.core.posix.thread.PosixParkEvent::condWait(void) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#7  0x0000000000547070 in com.oracle.svm.core.thread.JavaThreads::park(void) () at com/oracle/svm/core/thread/JavaThreads.java:764\n"
"#8  0x0000000000fc5f44 in jdk.internal.misc.Unsafe::park(boolean, long) () at com/oracle/svm/core/thread/Target_jdk_internal_misc_Unsafe_JavaThreads.java:49\n"
"#9  0x0000000000eac1ad in java.util.concurrent.locks.LockSupport::park(java.lang.Object *) () at java/util/concurrent/locks/LockSupport.java:194\n"
"#10 0x0000000000ea5d68 in java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject::awaitUninterruptibly(void) ()\n"
"    at java/util/concurrent/locks/AbstractQueuedSynchronizer.java:2018\n"
"#11 0x00000000008b6b30 in io.quarkus.runtime.ApplicationLifecycleManager::run(io.quarkus.runtime.Application *, java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) ()\n"
"    at io/quarkus/runtime/ApplicationLifecycleManager.java:144\n"
"#12 0x00000000008bc055 in io.quarkus.runtime.Quarkus::run(java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) () at io/quarkus/runtime/Quarkus.java:67\n"
"#13 0x000000000045c88b in io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:41\n"
"#14 io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:120\n"
"#15 0x000000000045c88b in io.quarkus.runner.GeneratedMain::main ()\n"
"#16 com.oracle.svm.core.JavaMainWrapper::runCore () at com/oracle/svm/core/JavaMainWrapper.java:150\n"
"#17 com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *) () at com/oracle/svm/core/JavaMainWrapper.java:186\n"
"#18 0x000000000048084d in com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *)\n"
"    () at com/oracle/svm/core/JavaMainWrapper.java:280\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1119
msgid "Alternatively, we can list the backtraces of all threads with a single command:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1123
#, no-wrap
msgid "(gdb) thread apply all backtrace\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1143
#, no-wrap
msgid ""
"Thread 22 (Thread 0x7fffc8dff640 (LWP 1028872) \"tloop-thread-15\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=8, events=0x2ca3880, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1163
#, no-wrap
msgid ""
"Thread 21 (Thread 0x7fffc97fa640 (LWP 1028871) \"tloop-thread-14\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=53, events=0x2cd0970, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1166
#, no-wrap
msgid ""
"Thread 20 (Thread 0x7fffc9ffb640 (LWP 1028870) \"tloop-thread-13\"):\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1169
msgid "Note, however, that despite being able to get a backtrace we can still not list the source code at point with the `list` command."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1174
#, no-wrap
msgid ""
"(gdb) list\n"
"164    in com/oracle/svm/core/UnmanagedMemoryUtil.java\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1180
msgid "This is because `gdb` is not aware of the location of the source files.  We are running the executable outside of the target directory.  To fix this we can either rerun `gdb` from the target directory or, run `directory target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1196
#, no-wrap
msgid ""
"(gdb) directory target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/sources\n"
"Source directories searched: /home/zakkak/tmp/code-with-quarkus/target/sources:$cdir:$cwd\n"
"(gdb) list\n"
"164        \tUnsignedWord offset = size;\n"
"165        \twhile (offset.aboveOrEqual(32)) {\n"
"166            \toffset = offset.subtract(32);\n"
"167            \tPointer src = from.add(offset);\n"
"168            \tPointer dst = to.add(offset);\n"
"169            \tlong l24 = src.readLong(24);\n"
"170            \tlong l16 = src.readLong(16);\n"
"171            \tlong l8 = src.readLong(8);\n"
"172            \tlong l0 = src.readLong(0);\n"
"173            \tdst.writeLong(24, l24);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1203
msgid "We can now examine line `169` and get a first hint of what might be wrong (in this case we see that it fails at the first read from src which contains the address `0x0000`), or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.  To learn more about using gdb to debug native executables see https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DebugInfo.md[here]."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:1204
#, no-wrap
msgid "Frequently Asked Questions"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1206
#, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1210
msgid "Native executable generation is a multi-step process.  The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1216
msgid "In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.  As new classes are discovered, some of them will be initialized during this process depending on the configuration.  In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.  The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.  The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1218
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1225
msgid "The time spent in analysis and compilation phases depends on how big the application is.  The bigger the application, the longer it takes to compile it.  However, there are certain features that can have an exponential effect.  For example, when registering types and methods for reflection access, the analysis can’t easily see what’s behind those types or methods, so it has to do more work to complete the analysis step."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1226
#, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1231
msgid "As with most things in life there are some trade offs involved when choosing native compilation over JVM mode.  So depending on the application the runtime performance of a native application might be slower compared to JVM mode, though that’s not always the case."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1237
msgid "JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.  That includes the opportunities to inline a lot more of the code, locate hot code on direct paths (i.e. ensure better instruction cache locality)  and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).  Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1240
msgid "By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.  Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1242
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1244
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1245
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1246
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1248
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1250
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1251
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1254
msgid "An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.  Although the compiled code is not as well optimized it is available straight away."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1257
msgid "The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.  In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1266
msgid "There are several reasons for 3). The JVM does not have a closed world assumption.  So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.  For example, if an interface has only one implementation it can make a call jump directly to that code.  However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.  Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable, including recording the full class and interface hierarchy, details of which methods override other methods, all method bytecode etc.  In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1271
msgid "The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.  At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.  That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.  It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1272
#, no-wrap
msgid "Why are native executables “big”?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1275
msgid "This can be attributed to a number of different reasons:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1281
msgid "Native executables include not only the application code but also, library code, and JDK code.  As a result a more fair comparison would be to compare the native executable’s size with the size of the application, plus the size of the libraries it uses, plus the size of the JDK.  Especially the JDK part is not negligible even in simple applications like HelloWorld.  To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1287
msgid "Some features are always included in a native executable even though they might never be actually used at run time.  An example of such a feature is garbage collection.  At compile time we can’t be sure whether an application will need to run garbage collection at run time, so garbage collection is always included in native executables increasing their size even if not necessary.  Native executable generation relies on static code analysis to identify which code paths are reachable, and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1290
msgid "There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue] with some interesting discussions about that topic."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1291
#, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1294
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1299
#, no-wrap
msgid ""
"$ strings target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep GraalVM\n"
"com.oracle.svm.core.VM=GraalVM 21.3.0.0-Final Java 11 Mandrel Distribution\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1301
#, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1305
msgid "Executing the native executable with `-XX:PrintFlags=` prints a list of flags that can be passed to native executables.  For various levels of GC logging one may use:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1318
#, no-wrap
msgid ""
"$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -XX:PrintFlags=\n"
"...\n"
"  -XX:±PrintGC                                 Print summary GC information after each collection. Default: - (disabled).\n"
"  -XX:±PrintGCSummary                          Print summary GC information after application main method returns. Default: - (disabled).\n"
"  -XX:±PrintGCTimeStamps                       Print a time stamp at each collection, if +PrintGC or +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintGCTimes                            Print the time for each of the phases of each collection, if +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintHeapShape                          Print the shape of the heap before and after each collection, if +VerboseGC. Default: - (disabled).\n"
"...\n"
"  -XX:±TraceHeapChunks                         Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Default: - (disabled).\n"
"  -XX:±VerboseGC                               Print more information about the heap before and after each collection. Default: - (disabled).\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1320
#, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1327
msgid "Unfortunately generating heap dumps in hprof format, which can be opened by tools such as VisualVM or Eclipse MAT, can only be achieved with https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition].  Mandrel, which is based on the GraalVM Community Edition, does not have this capability."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1331
msgid "Although Mandrel can generate debug symbols and these contain a fair amount of information about object layouts, including what is a pointer field vs a primitive field, this information cannot be used as is to detect memory leaks or find dominator objects.  This is because it has no idea what constitutes a root pointer nor how to recursively trace pointers from those roots."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1333
#, no-wrap
msgid "Can I follow these examples if I’m running macOS or Windows?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1339
msgid "The ideal environment for trying out these debugging examples is Linux.  All examples, except for profiling and debugging native crashes, can also be executed natively in either macOS or Windows.  If you are in either of these two platforms, you can run all the steps (including native crash debugging and profiling) within a Linux container.  The following `Dockerfile` shows what a Linux container requires in order to follow the examples:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1343
#, no-wrap
msgid "FROM fedora:35\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1350
#, no-wrap
msgid ""
"RUN dnf install -y \\\n"
"binutils \\\n"
"gdb \\\n"
"git \\\n"
"perf \\\n"
"perl-open\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1353
#, no-wrap
msgid ""
"RUN cd /opt \\\n"
"&& git clone https://github.com/brendangregg/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1355
#, no-wrap
msgid "ENV FG_HOME /opt/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1357
#, no-wrap
msgid "WORKDIR /data\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1360
msgid "Using `docker` in the non-Linux environment, you can create an image using this `Dockerfile` via:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1364
#, no-wrap
msgid "docker build -t fedora-tools:v1 .\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1367
msgid "Then, run the Docker container as:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1373
#, no-wrap
msgid ""
"$ docker run --privileged \\\n"
"-t -i -v $(PWD)/$(project):/data --rm -p 8080:8080 fedora-tools:v1 /bin/bash\n"
"...\n"
"_\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:1381
msgid "Note that in order to use `perf` to profile the native executables in the guide, the container needs to run as privileged, or with `--cap-add sys_admin`.  Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1384
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1389
#, no-wrap
msgid ""
"echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
"echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1393
msgid "Once you’re inside the container, you can execute `strings`, `perf`, `objdump`…, etc commands on the generated binary.  Since the binary was created inside a Linux container, the container tools should have no issues with them, e.g."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1397
#, no-wrap
msgid "objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep “GreetingResource”\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1400
msgid "Flame graphs should also be generated inside the container:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1405
#, no-wrap
msgid ""
"perf script | /opt/FlameGraph/stackcollapse-perf.pl > out.perf-folded\n"
"/opt/FlameGraph/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1408
msgid "The resulting svg files can then be opened outside the container for visualization."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1409
#, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1413
msgid "There are multiple ways in which a native executable produced by Mandrel can be profiled.  All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1417
msgid "The method shown in this reference guide generates a binary with DWARF debug information, runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.  However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1422
msgid "An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.  It instructs the binary to use an extra register for the frame pointer.  This enables `perf` to do stack walking to profile the runtime behaviour.  To generate the native executable using these flags, do the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1428
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=-H:+PreserveFramePointer,-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1431
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1439
msgid "The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.  This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1445
msgid "DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand, for profiling or debugging purposes.  Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well, hence it does not bloat the native executable itself.  To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1455
#, no-wrap
msgid ""
"perf report --stdio -F+srcline\n"
"...\n"
"83.69%     0.00%  GreetingResource.java:20 ...\n"
"...\n"
"83.69%     0.00%  AbstractStringBuilder.java:1025 ...\n"
"...\n"
"83.69%     0.00%  ArraycopySnippets.java:95 ...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1461
msgid "The performance penalty of preserving the frame pointer is due to using the extra register for stack walking, particularly in `x86_64` compared to `aarch64` where there are less registers available.  Using this extra register reduces the number of registers that are available for other work, which can lead to performance penalties."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1462
#, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1466
msgid "Although it is possible to remote debug processes within containers, it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1471
msgid "Native executable generation is the result of two Java processes that are executed sequentially.  The first process is very short and its main job is to set things up for the second process.  The second process is the one that takes care of most of the work.  The steps to debug one process or the other vary slightly."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1476
msgid "Let’s discuss first how to debug the second process, which is the one you most likely to want to debug.  The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.  To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1481
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative \\\n"
"    -Dquarkus.native.additional-build-args=--debug-attach=*:8000\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1487
msgid "The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.  In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.  However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process, so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1492
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Pnative \\\n"
"    -Dquarkus.native.additional-build-args=--vm.agentlib:jdwp=transport=dt_socket\\\\,server=y\\\\,suspend=y\\\\,address=*:8000\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1494
#, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1502
msgid "https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] can be used to profile native binaries since GraalVM CE 21.2.0.  However, JFR in GraalVM is currently significantly limited in capabilities compared to HotSpot.  The custom event API is fully supported, but many VM level features are unavailable.  They will be added in future releases. Current limitations are:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1504
msgid "Minimal VM level events"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1505
msgid "No old object sampling"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1506
msgid "No stacktrace tracing"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1507
msgid "No Streaming API for JDK 17"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1510
msgid "To use JFR add the application property: `-Dquarkus.native.enable-vm-inspection=true`.  E.g."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1516
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.enable-vm-inspection=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1519
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1525
#, no-wrap
msgid ""
"./target/code-with-quarkus-1.0.0-SNAPSHOT-runner \\\n"
"    -XX:+FlightRecorder \\\n"
"    -XX:StartFlightRecording=\"filename=recording.jfr\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1527
msgid "For more details on using JFR, see https://www.graalvm.org/reference-manual/native-image/JFR[here]."
msgstr ""
